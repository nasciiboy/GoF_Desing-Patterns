<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" />
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es" >
<head>
  <title>Patrones de Diseño</title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="subtitle" content="Elementos de software orientado a objetos reutilizable" />
  <meta name="author" content="Erich Gamma" />
  <meta name="author" content="Richard Helm" />
  <meta name="author" content="Ralph Johnson" />
  <meta name="author" content="John Vlissides" />
  <meta name="translator" content="Cesar Fernandez Acebal" />
  <link rel="stylesheet" type="text/css" href="worg-data/worg.css" />
</head>

<body>
<div id="toc">
  <p>index</p>
  <div id="toc-contents">
  <ul>
  <li><a class="h2" href="#elogios-a-patrones-de-diseño" >Elogios a Patrones de Diseño</a></li>
  <li><a class="h2" href="#prefacio" >Prefacio</a></li>
  <li><a class="h2" href="#prologo" >Prologo</a></li>
  <li><a class="h2" href="#prologo-a-la-edicion-española" >Prologo a la edicion española</a></li>
  <li><a class="h2" href="#guia-para-los-lectores" >Guia para los lectores</a></li>
  <li><a class="h2" href="#capitulo-1" >Introduccion</a></li>
    <ul>
    <li><a class="h3" href="#1.1" >¿Que es un patron de diseño?</a></li>
    <li><a class="h3" href="#1.2" >Patrones de diseño en el MVC de Smalltalk</a></li>
    <li><a class="h3" href="#1.3" >Descripcion de los patrones de diseño</a></li>
    <li><a class="h3" href="#1.4" >El catalogo de patrones de diseño</a></li>
    <li><a class="h3" href="#1.5" >Orgarnizacion del catalogo</a></li>
    <li><a class="h3" href="#1.6" >Como resuelven los patrones los problemas de diseño</a></li>
      <ul>
      <li><a class="h4" href="#encontrar-los-objetos-apropiados" >Encontrar los objetos apropiados</a></li>
      <li><a class="h4" href="#determinar-la-granularidad-de-los-objetos" >Determinar la granularidad de los objetos</a></li>
      <li><a class="h4" href="#especificar-las-interfaces-de-los-objetos" >Especificar las interfaces de los objetos</a></li>
      <li><a class="h4" href="#especificar-las-implementaciones-de-los-objetos" >Especificar las implementaciones de los objetos</a></li>
        <ul>
        <li><a class="h5" href="#herencia-de-clases-frente-a-herencia-de-interfaces" >Herencia de clases frente a herencia de interfaces</a></li>
        <li><a class="h5" href="#programar-para-interfaces,-no-para-una-implementacion" >Programar para interfaces, no para una implementacion</a></li>
        </ul>
      <li><a class="h4" href="#poner-a-funcionar-los-mecanismos-de-reutilizacion" >Poner a Funcionar los mecanismos de Reutilizacion</a></li>
        <ul>
        <li><a class="h5" href="#herencia-frente-a-composicion" >Herencia frente a Composicion</a></li>
        <li><a class="h5" href="#delegacion" >Delegacion</a></li>
        <li><a class="h5" href="#herencia-frente-a-tipos-parametrizados" >Herencia frente a Tipos Parametrizados</a></li>
        </ul>
      <li><a class="h4" href="#estructuras-que-relacionan-tiempo-de-ejecucion-y-tiempo-de-compilacion" >Estructuras que relacionan tiempo de ejecucion y tiempo de compilacion</a></li>
      <li><a class="h4" href="#diseñar-para-el-cambio" >Diseñar para el cambio</a></li>
        <ul>
        <li><a class="h5" href="#programas-de-aplicacion" >Programas de aplicacion</a></li>
        <li><a class="h5" href="#toolkits5" >Toolkits<span class="note" ><sup><a href="#5" >5</a></sup></span></a></li>
        <li><a class="h5" href="#frameworks6" >Frameworks<span class="note" ><sup><a href="#6" >6</a></sup></span></a></li>
        </ul>
      </ul>
    <li><a class="h3" href="#1.7" >Como seleccionar un patron de diseño</a></li>
    <li><a class="h3" href="#1.8" >Como usar un patron de diseño</a></li>
    </ul>
  <li><a class="h2" href="#capitulo-2" >Un Caso de estudio: diseñando un editor de documentos</a></li>
    <ul>
    <li><a class="h3" href="#2.1" >Problemas de diseño</a></li>
    <li><a class="h3" href="#2.2" >Estructura del documento</a></li>
      <ul>
      <li><a class="h4" href="#composicion-recursiva" >Composicion Recursiva</a></li>
      <li><a class="h4" href="#glifos11" >GLIFOS<span class="note" ><sup><a href="#11" >11</a></sup></span></a></li>
      <li><a class="h4" href="#patron-composite" >Patron Composite</a></li>
      </ul>
    <li><a class="h3" href="#2.3" >Formateando</a></li>
      <ul>
      <li><a class="h4" href="#encapsulacion-del-algoritmo-de-formateado" >Encapsulacion del algoritmo de formateado</a></li>
      <li><a class="h4" href="#componedor-y-composicion" >Componedor y composicion</a></li>
      <li><a class="h4" href="#patron-strategy-(estrategia)" >Patron Strategy (Estrategia)</a></li>
      </ul>
    <li><a class="h3" href="#2.4" >Adornar la interfaz de usuario</a></li>
      <ul>
      <li><a class="h4" href="#recinto-transparente17" >Recinto Transparente<span class="note" ><sup><a href="#17" >17</a></sup></span></a></li>
      <li><a class="h4" href="#monoglifo" >Monoglifo</a></li>
      <li><a class="h4" href="#patron-decorator-(decorador)" >Patron Decorator (Decorador)</a></li>
      </ul>
    <li><a class="h3" href="#2.5" >Permitir multiples estandares de interfaz de usuario</a></li>
      <ul>
      <li><a class="h4" href="#abstrayendo-la-creacion-de-objetos" >Abstrayendo la creacion de objetos</a></li>
      <li><a class="h4" href="#clases-fabrica-y-producto" >Clases Fabrica y Producto</a></li>
      <li><a class="h4" href="#patron-abstract-factory-(fabrica-abstracta)" >Patron Abstract Factory (Fabrica Abstracta)</a></li>
      </ul>
    <li><a class="h3" href="#2.6" >Permitir multiples sistemas de ventanas</a></li>
      <ul>
      <li><a class="h4" href="#podemos-usar-una-fabrica-abstracta?" >Podemos usar una Fabrica Abstracta?</a></li>
      <li><a class="h4" href="#encapsular-dependencias-de-implementacion" >Encapsular dependencias de implementacion</a></li>
      <li><a class="h4" href="#ventana-y-ventanaimp" ><code>Ventana</code> y <code>VentanaImp</code></a></li>
        <ul>
        <li><a class="h5" href="#subclases-de-ventanaimp" >Subclases de <code>VentanaImp</code></a></li>
        <li><a class="h5" href="#configurar-ventanas-con-ventanaimps" >Configurar <code>Ventanas</code> con <code>VentanaImp</code>s</a></li>
        </ul>
      <li><a class="h4" href="#patron-bridge-(puente)" >Patron Bridge (Puente)</a></li>
      </ul>
    <li><a class="h3" href="#2.7" >Operaciones de usuario</a></li>
      <ul>
      <li><a class="h4" href="#encapsular-una-peticion" >Encapsular una peticion</a></li>
      <li><a class="h4" href="#clase-orden-y-sus-subclases" >Clase <code>Orden</code> y sus Subclases</a></li>
      <li><a class="h4" href="#capacidad-de-deshacer23" >Capacidad de Deshacer<span class="note" ><sup><a href="#23" >23</a></sup></span></a></li>
      <li><a class="h4" href="#historial-de-ordenes" >Historial de Ordenes</a></li>
      <li><a class="h4" href="#patron-command-(orden)" >Patron Command (Orden)</a></li>
      </ul>
    <li><a class="h3" href="#2.8" >Revision ortografica e insercion de guiones<span class="note" ><sup><a href="#24" >24</a></sup></span></a></li>
      <ul>
      <li><a class="h4" href="#acceder-a-informacion-dispersa" >Acceder a informacion dispersa</a></li>
      <li><a class="h4" href="#encapsular-el-acceso-y-el-recorrido" >Encapsular el acceso y el recorrido</a></li>
      <li><a class="h4" href="#clase-iterador-y-sus-subclases" >Clase <code>Iterador</code> y sus subclases</a></li>
      <li><a class="h4" href="#patron-iterator-(iterador)" >Patron Iterator (Iterador)</a></li>
      <li><a class="h4" href="#recorrido-y-acciones-del-recorrido" >Recorrido y acciones del recorrido</a></li>
      <li><a class="h4" href="#encapsular-el-analisis" >Encapsular el analisis</a></li>
      <li><a class="h4" href="#clase-visitante-y-sus-subclases" >Clase <code>Visitante</code> y sus subclases</a></li>
      <li><a class="h4" href="#patron-visitor-(visitante)" >Patron Visitor (Visitante)</a></li>
      </ul>
    <li><a class="h3" href="#2.9" >Resumen</a></li>
    </ul>
  <li><a class="h2" href="#catalogo-de-patrones-de-diseño" >Catalogo de Patrones de Diseño</a></li>
  <li><a class="h2" href="#capitulo-3" >Patrones de Creacion</a></li>
    <ul>
    <li><a class="h3" href="#abstract-factory" >Abstract Factory</a></li>
      <ul>
      <li><a class="h4" href="#abstract-factory-proposito" >Proposito</a></li>
      <li><a class="h4" href="#abstract-factory-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#abstract-factory-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#abstract-factory-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#abstract-factory-estructura" >Estructura</a></li>
      <li><a class="h4" href="#abstract-factory-participantes" >Participantes</a></li>
      <li><a class="h4" href="#abstract-factory-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#abstract-factory-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#abstract-factory-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#abstract-factory-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#abstract-factory-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#abstract-factory-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#builder" >Builder</a></li>
      <ul>
      <li><a class="h4" href="#builder-proposito" >Proposito</a></li>
      <li><a class="h4" href="#builder-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#builder-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#builder-estructura" >Estructura</a></li>
      <li><a class="h4" href="#builder-participantes" >Participantes</a></li>
      <li><a class="h4" href="#builder-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#builder-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#builder-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#builder-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#builder-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#builder-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#factory-method" >Factory Method</a></li>
      <ul>
      <li><a class="h4" href="#factory-method-proposito" >Proposito</a></li>
      <li><a class="h4" href="#factory-method-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#factory-method-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#factory-method-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#factory-method-estructura" >Estructura</a></li>
      <li><a class="h4" href="#factory-method-participantes" >Participantes</a></li>
      <li><a class="h4" href="#factory-method-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#factory-method-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#factory-method-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#factory-method-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#factory-method-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#factory-method-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#prototype" >Prototype</a></li>
      <ul>
      <li><a class="h4" href="#prototype-proposito" >Proposito</a></li>
      <li><a class="h4" href="#prototype-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#prototype-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#prototype-estructura" >Estructura</a></li>
      <li><a class="h4" href="#prototype-participantes" >Participantes</a></li>
      <li><a class="h4" href="#prototype-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#prototype-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#prototype-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#prototype-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#prototype-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#prototype-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#singleton" >Singleton</a></li>
      <ul>
      <li><a class="h4" href="#singleton-proposito" >Proposito</a></li>
      <li><a class="h4" href="#singleton-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#singleton-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#singleton-estructura" >Estructura</a></li>
      <li><a class="h4" href="#singleton-participantes" >Participantes</a></li>
      <li><a class="h4" href="#singleton-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#singleton-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#singleton-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#singleton-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#singleton-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#singleton-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#discusion-sobre-los-patrones-de-creacion" >Discusion sobre los patrones de creacion</a></li>
    </ul>
  <li><a class="h2" href="#capitulo-4" >Patrones Estructurales</a></li>
    <ul>
    <li><a class="h3" href="#adapter" >Adapter</a></li>
      <ul>
      <li><a class="h4" href="#adapter-proposito" >Proposito</a></li>
      <li><a class="h4" href="#adapter-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#adapter-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#adapter-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#adapter-estructura" >Estructura</a></li>
      <li><a class="h4" href="#adapter-participantes" >Participantes</a></li>
      <li><a class="h4" href="#adapter-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#adapter-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#adapter-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#adapter-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#adapter-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#adapter-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#bridge" >Bridge</a></li>
      <ul>
      <li><a class="h4" href="#bridge-proposito" >Proposito</a></li>
      <li><a class="h4" href="#bridge-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#bridge-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#bridge-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#bridge-estructura" >Estructura</a></li>
      <li><a class="h4" href="#bridge-participantes" >Participantes</a></li>
      <li><a class="h4" href="#bridge-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#bridge-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#bridge-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#bridge-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#bridge-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#bridge-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#composite" >Composite</a></li>
      <ul>
      <li><a class="h4" href="#composite-proposito" >Proposito</a></li>
      <li><a class="h4" href="#composite-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#composite-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#composite-estructura" >Estructura</a></li>
      <li><a class="h4" href="#composite-participantes" >Participantes</a></li>
      <li><a class="h4" href="#composite-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#composite-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#composite-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#composite-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#composite-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#composite-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#decorator" >Decorator</a></li>
      <ul>
      <li><a class="h4" href="#decorator-proposito" >Proposito</a></li>
      <li><a class="h4" href="#decorator-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#decorator-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#decorator-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#decorator-estructura" >Estructura</a></li>
      <li><a class="h4" href="#decorator-participantes" >Participantes</a></li>
      <li><a class="h4" href="#decorator-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#decorator-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#decorator-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#decorator-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#decorator-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#decorator-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#facade" >Facade</a></li>
      <ul>
      <li><a class="h4" href="#facade-proposito" >Proposito</a></li>
      <li><a class="h4" href="#facade-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#facade-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#facade-estructura" >Estructura</a></li>
      <li><a class="h4" href="#facade-participantes" >Participantes</a></li>
      <li><a class="h4" href="#facade-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#facade-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#facade-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#facade-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#facade-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#facade-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#flyweight" >Flyweight</a></li>
      <ul>
      <li><a class="h4" href="#flyweight-proposito" >Proposito</a></li>
      <li><a class="h4" href="#flyweight-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#flyweight-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#flyweight-estructura" >Estructura</a></li>
      <li><a class="h4" href="#flyweight-participantes" >Participantes</a></li>
      <li><a class="h4" href="#flyweight-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#flyweight-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#flyweight-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#flyweight-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#flyweight-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#flyweight-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#proxy" >Proxy</a></li>
      <ul>
      <li><a class="h4" href="#proxy-proposito" >Proposito</a></li>
      <li><a class="h4" href="#proxy-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#proxy-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#proxy-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#proxy-estructura" >Estructura</a></li>
      <li><a class="h4" href="#proxy-participantes" >Participantes</a></li>
      <li><a class="h4" href="#proxy-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#proxy-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#proxy-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#proxy-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#proxy-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#proxy-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#discusion-sobre-los-patrones-estructurales" >Discusion sobre los patrones estructurales</a></li>
      <ul>
      <li><a class="h4" href="#adapter-frente-a-bridge" >Adapter frente a Bridge</a></li>
      <li><a class="h4" href="#composite-frente-a-decorator-y-a-proxy" >Composite frente a Decorator y a Proxy</a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#capitulo-5" >Patrones de Comportamiento</a></li>
    <ul>
    <li><a class="h3" href="#chain-of-responsibility" >Chain of Responsibility</a></li>
      <ul>
      <li><a class="h4" href="#chain-of-responsibility-proposito" >Proposito</a></li>
      <li><a class="h4" href="#chain-of-responsibility-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#chain-of-responsibility-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#chain-of-responsibility-estructura" >Estructura</a></li>
      <li><a class="h4" href="#chain-of-responsibility-participantes" >Participantes</a></li>
      <li><a class="h4" href="#chain-of-responsibility-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#chain-of-responsibility-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#chain-of-responsibility-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#chain-of-responsibility-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#chain-of-responsibility-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#chain-of-responsibility-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#command" >Command</a></li>
      <ul>
      <li><a class="h4" href="#command-proposito" >Proposito</a></li>
      <li><a class="h4" href="#command-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#command-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#command-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#command-estructura" >Estructura</a></li>
      <li><a class="h4" href="#command-participantes" >Participantes</a></li>
      <li><a class="h4" href="#command-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#command-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#command-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#command-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#command-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#command-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#interpreter" >Interpreter</a></li>
      <ul>
      <li><a class="h4" href="#interpreter-proposito" >Proposito</a></li>
      <li><a class="h4" href="#interpreter-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#interpreter-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#interpreter-estructura" >Estructura</a></li>
      <li><a class="h4" href="#interpreter-participantes" >Participantes</a></li>
      <li><a class="h4" href="#interpreter-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#interpreter-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#interpreter-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#interpreter-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#interpreter-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#interpreter-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#iterator" >Iterator</a></li>
      <ul>
      <li><a class="h4" href="#iterator-proposito" >Proposito</a></li>
      <li><a class="h4" href="#iterator-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#iterator-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#iterator-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#iterator-estructura" >Estructura</a></li>
      <li><a class="h4" href="#iterator-participantes" >Participantes</a></li>
      <li><a class="h4" href="#iterator-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#iterator-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#iterator-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#iterator-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#iterator-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#iterator-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#mediator" >Mediator</a></li>
      <ul>
      <li><a class="h4" href="#mediator-proposito" >Proposito</a></li>
      <li><a class="h4" href="#mediator-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#mediator-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#mediator-estructura" >Estructura</a></li>
      <li><a class="h4" href="#mediator-participantes" >Participantes</a></li>
      <li><a class="h4" href="#mediator-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#mediator-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#mediator-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#mediator-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#mediator-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#mediator-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#memento" >Memento</a></li>
      <ul>
      <li><a class="h4" href="#memento-proposito" >Proposito</a></li>
      <li><a class="h4" href="#memento-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#memento-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#memento-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#memento-estructura" >Estructura</a></li>
      <li><a class="h4" href="#memento-participantes" >Participantes</a></li>
      <li><a class="h4" href="#memento-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#memento-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#memento-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#memento-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#memento-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#memento-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#observer" >Observer</a></li>
      <ul>
      <li><a class="h4" href="#observer-proposito" >Proposito</a></li>
      <li><a class="h4" href="#observer-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#observer-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#observer-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#observer-estructura" >Estructura</a></li>
      <li><a class="h4" href="#observer-participantes" >Participantes</a></li>
      <li><a class="h4" href="#observer-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#observer-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#observer-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#observer-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#observer-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#observer-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#state" >State</a></li>
      <ul>
      <li><a class="h4" href="#state-proposito" >Proposito</a></li>
      <li><a class="h4" href="#state-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#state-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#state-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#state-estructura" >Estructura</a></li>
      <li><a class="h4" href="#state-participantes" >Participantes</a></li>
      <li><a class="h4" href="#state-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#state-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#state-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#state-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#state-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#state-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#strategy" >Strategy</a></li>
      <ul>
      <li><a class="h4" href="#strategy-proposito" >Proposito</a></li>
      <li><a class="h4" href="#strategy-tambien-conocido-como" >Tambien Conocido Como</a></li>
      <li><a class="h4" href="#strategy-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#strategy-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#strategy-estructura" >Estructura</a></li>
      <li><a class="h4" href="#strategy-participantes" >Participantes</a></li>
      <li><a class="h4" href="#strategy-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#strategy-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#strategy-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#strategy-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#strategy-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#strategy-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#template-method" >Template Method</a></li>
      <ul>
      <li><a class="h4" href="#template-method-proposito" >Proposito</a></li>
      <li><a class="h4" href="#template-method-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#template-method-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#template-method-estructura" >Estructura</a></li>
      <li><a class="h4" href="#template-method-participantes" >Participantes</a></li>
      <li><a class="h4" href="#template-method-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#template-method-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#template-method-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#template-method-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#template-method-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#template-method-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#visitor" >Visitor</a></li>
      <ul>
      <li><a class="h4" href="#visitor-proposito" >Proposito</a></li>
      <li><a class="h4" href="#visitor-motivacion" >Motivacion</a></li>
      <li><a class="h4" href="#visitor-aplicabilidad" >Aplicabilidad</a></li>
      <li><a class="h4" href="#visitor-estructura" >Estructura</a></li>
      <li><a class="h4" href="#visitor-participantes" >Participantes</a></li>
      <li><a class="h4" href="#visitor-colaboraciones" >Colaboraciones</a></li>
      <li><a class="h4" href="#visitor-consecuencias" >Consecuencias</a></li>
      <li><a class="h4" href="#visitor-implementacion" >Implementacion</a></li>
      <li><a class="h4" href="#visitor-codigo-de-ejemplo" >Codigo de Ejemplo</a></li>
      <li><a class="h4" href="#visitor-usos-conocidos" >Usos Conocidos</a></li>
      <li><a class="h4" href="#visitor-patrones-relacionados" >Patrones Relacionados</a></li>
      </ul>
    <li><a class="h3" href="#discusion-sobre-los-patrones-de-comportamiento" >Discusion sobre los patrones de comportamiento</a></li>
      <ul>
      <li><a class="h4" href="#encapsular-lo-que-varia" >Encapsular lo que varia</a></li>
      <li><a class="h4" href="#objetos-como-argumentos" >Objetos como argumentos</a></li>
      <li><a class="h4" href="#la-comunicacion,-¿deberia-estar-encapsulada-o-distribuida?" >La comunicacion, ¿Deberia estar encapsulada o distribuida?</a></li>
      <li><a class="h4" href="#desacoplar-emisores-y-receptores" >Desacoplar emisores y receptores</a></li>
      <li><a class="h4" href="#resumen" >Resumen</a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#capitulo-6" >Conclusion</a></li>
    <ul>
    <li><a class="h3" href="#6.1" >Que esperar de los patrones de diseño</a></li>
      <ul>
      <li><a class="h4" href="#un-vocabulario-de-diseño-comun" >Un vocabulario de diseño comun</a></li>
      <li><a class="h4" href="#una-ayuda-para-la-documentacion-y-el-aprendizaje" >Una ayuda para la documentacion y el aprendizaje</a></li>
      <li><a class="h4" href="#un-complemento-de-los-metodos-existentes" >Un complemento de los metodos existentes</a></li>
      <li><a class="h4" href="#un-objetivo-para-la-refactorizacion" >Un objetivo para la refactorizacion</a></li>
      </ul>
    <li><a class="h3" href="#6.2" >Una breve historia</a></li>
    <li><a class="h3" href="#6.3" >La comunidad de patrones</a></li>
      <ul>
      <li><a class="h4" href="#los-lenguajes-de-patrones-de-alexander" >Los lenguajes de patrones de Alexander</a></li>
      <li><a class="h4" href="#patrones-de-software" >Patrones De Software</a></li>
      </ul>
    <li><a class="h3" href="#6.4" >Una invitacion</a></li>
    <li><a class="h3" href="#6.5" >Una reflexion a modo de despedida</a></li>
    </ul>
  <li><a class="h2" href="#apendice-a" >Glosario</a></li>
  <li><a class="h2" href="#apendice-b" >Guia de la notacion</a></li>
    <ul>
    <li><a class="h3" href="#b.1" >Diagrama de clases</a></li>
    <li><a class="h3" href="#b.2" >Diagrama de objetos</a></li>
    <li><a class="h3" href="#b.3" >Diagrama de iteracion</a></li>
    </ul>
  <li><a class="h2" href="#apendice-c" >Clases fundamentales</a></li>
    <ul>
    <li><a class="h3" href="#c.1" >Lista</a></li>
      <ul>
      <li><a class="h4" href="#costruccion,-destruccion,-inicializacion-y-asignacion" >Costruccion, Destruccion, Inicializacion y Asignacion</a></li>
      <li><a class="h4" href="#acceso" >Acceso</a></li>
      <li><a class="h4" href="#adicion" >Adicion</a></li>
      <li><a class="h4" href="#borrado" >Borrado</a></li>
      <li><a class="h4" href="#interfaz-de-la-pila" >Interfaz de la pila</a></li>
      </ul>
    <li><a class="h3" href="#c.2" >Iterador</a></li>
    <li><a class="h3" href="#c.3" >IteradorLista</a></li>
    <li><a class="h3" href="#c.4" >Punto</a></li>
    <li><a class="h3" href="#c.5" >Rect</a></li>
    </ul>
  <li><a class="h2" href="#bibliografia" >Bibliografia</a></li>
  <li><a class="h2" href="#notas" >Notas</a></li>
  </ul>
  </div>
</div>

<h1>Patrones de Diseño</h1>
<div class="hBody-1" >
<div class="center" >
<p>A Karin (E.G.)</p>
<p>A Sylvie (R.H.)</p>
<p>A Faith (R.J.)</p>
<p>A Drug Ann y Matthew (Josue 24,15b) (J.V.)</p>
</div>
</div>
<h2 id="elogios-a-patrones-de-diseño" >Elogios a Patrones de Diseño</h2>
<div class="hBody-2" >
<blockquote>
<p><q>Este es uno de los libros mejor escritos y mas maravillosamente perspicaces que he leido en mucho tiempo... Este libro establece la legitimidad de los patrones del mejor modo: no mediante razonamientos sino mediante ejemplos.</q></p>
<div class="quote-author" >
<p>Stan Lippman, C++ Report</p>
</div>
</blockquote>
<blockquote>
<p><q>...este nuevo libro de Gamma, Helm, Johnson y Vlissides promete tener un impacto importante y definitivo en la disciplina del diseño de software. Debido a que <em>Patrones de Diseño</em> se enuncia a si mismo como relacionado solo con software orientado a objetos, temo que los desarrolladores de software no pertenecientes a la comunidad de objetos puedan pasarlo por alto. Seria una pena. Este libro tiene algo para todos aquellos que diseñan software. Todos los diseñadores de software usan patrones; entender mejor las abastracciones reutilizables de nuestro trabajo solo puede hacernos mejores en el.</q></p>
<div class="quote-author" >
<p>Tom DeMarco, IEEE Software</p>
</div>
</blockquote>
<blockquote>
<p><q>Creo que este libro representa una contribucion extremadamente valiosa y unica en este campo porque capta una riqueza de experiencia de diseño orientado a objetos en una forma compacta y reutilzable. Este Libro es seguramente uno al que acudire a menudo en busqueda de poderosas ideas de diseño orientado a objetos; despues de todo, de eso es de lo que trata la reutilizacion, ¿no es cierto?</q></p>
<div class="quote-author" >
<p>Sanjiv Gossain, Journal of Object-Oriented Programming</p>
</div>
</blockquote>
<blockquote>
<p><q>Este libro largamente esperado esta a la altura de todo el año en que ha estado en boga anticipadamente. La metafora es la de un libro de patrones de un arquitecto lleno de diseños probados y utilizables. Los autores han elegido 23 patrones procedentes de decadas de experiencia en orientacion a objetos. La brillantez de este libro reside en la disciplina representada por ese numero. Dele una copia de <em>Patrones de Diseño</em> a todo buen programador que conozca que quiera ser mejor.</q></p>
<div class="quote-author" >
<p>Larry O&#39;Brien, Software Development</p>
</div>
</blockquote>
<blockquote>
<p><q>El Hecho es que los patrones tienen el potencial de cambiar para siempre el campo de la ingenieria de software, catapultandola al reino de un diseño realmente elegante. De los libros sobre este tema hasta la fecha, <em>Patrones de Diseño</em> es como mucho el mejor. Es un libro para ser leido, estudiado interiorizado y querido. Cambiara para siempre el modo en que ve el software.</q></p>
<div class="quote-author" >
<p>Steve Billow, Journal of Object Oriented Programming</p>
</div>
</blockquote>
<blockquote>
<p><q><em>Patrones de Diseño</em> es un libro poderoso. Despues de invertir un poco de tiempo en el, la mayoria de los programadores de C++ seran capaces de comenzar a aplicar sus <q>patrones</q> para producir mejor software. Este libro suministra un capital intelectual: herramientas concretas que nos ayudan a pensar y expresarnos de forma mas efectiva. Puede cambiar drasticamente nuestra forma de pensar en la programacion.</q></p>
<div class="quote-author" >
<p>Tom Cargill, C++ Report</p>
</div>
</blockquote>
</div>
<h2 id="prefacio" >Prefacio</h2>
<div class="hBody-2" >
<p>Este libro no es una introduccion a la tecnologia o el diseño orientado a objetos. Ya hay muchos libros que sirven bien a ese proposito. Este libro presupone que el lector domina razonablemnete al menos un lenguaje de programacion orientado a objetos, y seria igualmente deseable que tuviese algo de experiencia en el diseño orientado a objetos. En definitiva, que no se abalanzara sobre el diccionario mas cercano cuando hablemos de <q>tipos</q> y <q>polimorfirmo</q>, o de la herencia de <q>interfaces</q> frente a la de <q>implementacion</q>.</p>
<p>Por otro lado, tampoco es este un avanzado tratado tecnico. Es un libro de <b>Patrones de diseño</b> que describe soluciones simples y elegantes a problemas especificos de diseño de software orientado a objetos. Los patrones de diseño representan soluciones que han sido desarrolladas y han ido evolucionando a lo largo del tiempo. Por tanto, no se trata de los diseños que la gente tiende a generar inicialmente, sino que reflejan todo el rediseño y la recodificacion que los desarrolladores han ido haciendo a medida que luchaban por conseguir mayor reutilizacion y felxibilidad en su software. Los patrones de diseño expresan estas soluciones de una manera sucinta y facilmente aplicable.</p>
<p>Los patrones de diseño no requieren caracteristicas sofisticadas del lenguaje ni sorprendentes trucos de programacion con los que dejar atonitos a jefes y amigos. Todo se puede implementar en lenguajes orientados a objetos estandar, Si bien puede costar algo mas de trabajo que las soluciones <em>ad hoc</em>. Pero este esfuerzo extra siempre se ve recompensado por un aumento de la flexibilidad y la reutilizacion.</p>
<p>Una vez que haya entendido los patrones de diseño y experimentado con ellos, nunca mas pensara en el diseño orientado a objetos de la misma manera que antes. Tendra una perspectiva que puede hacer que sus propios diseños sean mas felxibles, modulares, reutilizables y comprensibles, lo cual, al fin y al cabo, es la principal razon por la que esta interesado en la tecnologia orientada a objetos, ¿verdad?</p>
<p>Una advertencia y unas palabras de animo: no se preocupe si no entiende del todo este libro en la primer lectura. ¡Tampoco nosotros lo entendimos todo la primera vez que lo escribimos! Recuerde que no es un libro para leer una vez y ponerlo despues en una estanteria. Esperamos que acuda a el una y otra vez en busca de pistas de diseño y de ispiracion. Este libro ha tenido un largo periodo de gestacion. Ha visto cuatro paises, los matrimonios de tres de sus autores y el nacimiento de dos hijos. Mucha gente ha participado en su desarrollo. Estamos especialmente agradecidos a Bruce Anderson, Kent Beck, y André Weinand por su inspiracion y consejos. Tambien a aquellos que revisaron los borradores del original: Roguer Bielefeld, Grady Booch, Tom Cargill, Marshall Cline, Ralph Hyre, Brian Kernighan, Thomas Laliberty, Mark Lorenz, Arthur Riel, Doug Schmidt, Clovis Tondo, Steve Vinoski y Rebecca Wirfs-Brock. Tambien queremos agradecer al equipo de Addison-Wesley su ayuda y paciencia: Kate Habib, Tiffany Moore. Lisa Raffaele, Padeepa Siva y Jhon Wait. Muchas gracias a Carl Kessler, Donny Sabbah, y Mark Wegman, de IBM Research, por su apoyo constante a este trabajo.</p>
<p>Por ultimo, pero no menos importante, nos dieron palabras de aliento y nos dijeron que lo que estabamos haciendo valia la pena. Estas personas son, entre otros, Jon Avotins, Steve Berozuk, Julian Berdych, Matthias Bohlen, John Brant, Allan Clarke, Paul Chisholm, Jens Coldewey, Dave Collinns, Jim Coplien, Don Dwiggins, Gabriele Elia, Doug Felt, Brian Foote, Denis Fortin, Ward Harold, Hermann Hueni, Nayeem Islam, Bikramjit Kalra, Paul Keefer, Thomas Kofler, Doug Lea, Dan LaLiberte, James Long, Ann Louise Luu, Pundi Madhavan, Brian Marick, Robert Martin, Dave McComb, Carl McConnell, Christine Mingins, Hanspeter Mössenböck, Eric Newton, Marianne Ozkan, Roxsan Payette, Larry Podmolik, George Radin, Sita Ramakrishnan, Russ Ramirez, Alexander Ran, Dirk Riehle, Brian Rosenburg, Aamod Sane, Duri Schmidt, Rober Seidl, Xin Shu y Bill Walker.</p>
<p>No consideramos a esta coleccion de patrones de diseño como algo completo y estatitco; se trata mas bien de una recopilacion de nuestras ideas actuales sobre diseño. Los comentarios al respecto seran bienvenidos, ya sean criticas de nuestros ejemplos, referencias y usos conocidos que hayamos pasado por alto u otros patrones que deberiamos haber incluido. Puede escribirnos a Addison-Wesley, o enviar un correo electonico a <a href="mailto:design-patterns-source@cs.uiuc.edu" >mailto:design-patterns-source@cs.uiuc.edu</a>. Tambien puede obtener una copia del codigo de las secciones de ejemplo enviandonos el mensaje <q>send design pattern source</q> a <a href="mailto:design-patterns-source@cs.uiuc.edu" >mailto:design-patterns-source@cs.uiuc.edu</a>. Y existe una pagina Web en <a href="http://st-www.cs.uiuc.edu/users/patterns/DPBook/DPBook.html" >http://st-www.cs.uiuc.edu/users/patterns/DPBook/DPBook.html</a> donde podra encontrar informacion de ultima hora y actualizaciones.</p>
<div class="pret" >
Mountain View, California  E.G.
Montreal, Quebec           R.H.
Urbana, Illinois           R.J.
Hawthorne, New York        J.V.

Agosto de 1994
</div>
</div>
<h2 id="prologo" >Prologo</h2>
<div class="hBody-2" >
<p>Todas las arquitecturas orientadas a objetos que estan bien estructuradas estan repletas de patrones. De hecho, uno de los metodos que utilizo para medir la calidad de un sistema orientado a objetos es examinar si los desarrolladores le han prestado la debida atencion a las colaboraciones entre sus objetos. Centrarse en tales mecanismos durante el desarrollo de un sistema puede dar lugar a una arquitectura mas pequeña, simple y mucho mas comprensible que si se hubieran obviado los patrones.</p>
<p>La importancia de los patrones en la construccion de sistemas complejos ha sido reconocida desde hace tiempo en otras disciplinas. En concreto, Christopher Alexander y sus colegas fueron quiza los primeros en proponer la idea de emplear un lenguaje de patrones para diseñar la arquitectura de edificios y ciudades. Sus ideas y las contribuciones de otros estan ahora arraigadas en la comunidad del software orientado a objetos. Resumiento, el concepto de patron de diseño en el software proporciona una clave para ayudar a los desarrolladores a aprovechar la experiencia de otros arquitectos expertos.</p>
<p>En este libro, Erich Gmama, Richard Helm, Ralph Johnson y John Vlissides introducen los principios de los patrones de diseño y ofrecen un catalogo de dichos patrones. Asi, este libro realiza dos importantes contribuciones. En primer lugar, muestra el papel que los patrones pueden desempeñar diseñando la arquitectura de sistemas complejos. En segundo lugar, proporciona una referencia practica de un cojunto de excelentes patrones que el desarrollador puede aplicar para construir sus propias aplicaciones.</p>
<p>Es un honor para mi haber tenido la oportunidad de trabajar directamente con algunos de los autores de este libro en tareas de diseño arquitectonico. He aprendido mucho de ellos y sospecho que, leyendo este libro, usted tambien lo hara.</p>
<div class="right" >
<p>Grady Booch</p>
<p>Cientifico Jefe, Rational Software Corporation</p>
</div>
</div>
<h2 id="prologo-a-la-edicion-española" >Prologo a la edicion española</h2>
<div class="hBody-2" >
<p>A veces ––en informatica al menos–– se da el caso de libros que, por la especial contribucion que realizan en un campo determinado, se convierten en clasicos apenas han sido publicados. Este libro constituye uno de esos casos excepcionales. En efecto, a pesar de los pocos años transcurridos desde la publicacion del original en ingles, <em>Design Patterns, Elements of Reusable Object-Oriented Software</em>, tambien conocido como GoF (de <em>gang of four</em>, o <q>banda de los cuatro</q>, en alusion a sus autores), ha revolucionado el campo de la arquitectura del software, llevando la tecnologia de la orientacion a objetos a un estadio mas avanzado de su evolucion. Hoy dia, pocos son los arquitectos de software que no han oido hablar de patrones de diseño, y su uso generalmente diferencia a un buen diseño de otro que, en el mejor de los casos, resuelve un problema concreto pero que se adapta muy mal ––o no lo hace en absoluto–– a nuevos requisitos o cambios en los ya existentes.</p>
<p>No obstante, tambien es cierto que los patrones de diseño aun no son todo lo conocidos que debieran, especialmente por parte de los alumnos universitarios y de los recien titulados. A la rigidez de los planes de estudio, es muy posible que se una la ausencia casi total de pubilcaciones en español acerca de este tema. En este sentido, creemos que esta traduccion al castellano puede contribuir a catapultar definitivamente este libro al lugar que merece dentro de la comunidad hispana de la ingenieria del software. Ademas de servir de ayuda a los profesionales que no hayan leido el original en ingles, sin duda pasara a ser un libro de texto recomendado de la asignatura de ingenieria del software de muchas universidades, enriqueciendo asi el curriculum de futuras promociones de ingenieros en informatica.</p>
<p>Por otro lado, nunca resulta sencillo traducir un libro tecnico en informatica. Numerosos barbarismos se han instalado ya en el idioma, de tal forma que resulta dificil a veces optar entre lo que seria el termino correcto en español o el equivalente comunmente aceptado por la comunidad de la ingenieria del software. Uno de los ejemplos mas evidentes lo constituye la palabra <q>instancia</q>, para designar cada uno de los objetos creados de una clase dada, y que en español tal vez debiera haberse traducido como <q>ejemplar</q>. No obstante, pocas palabras hay mas conocidas que esta en la jerga de la orientacion a objetos, por lo que pretender cambiarla a estas alturas habria sido un acto de vanidad por nuestra parte que solo habria contribuido a incrementar la confusion y dificultar la comprension del libro. En otras ocaciones, nos encontramos con palabras como <em>framework</em> o <em>toolkit</em> que hemos dejado sin traducir por el mismo motivo: el lector esta acostumbrado a ellas, por lo que de haberlas traducido probablemente no supiese a que se esta haciendo referencia, desvirtuando asi el sentido del original.</p>
<p>Alla donde ha habido dudas, hemos optado por incluir ambos terminos, dando preferencia al español e incluyendo el original a continuacion, entre parentesis, o bien mediente una nota. Esta ha sido la decision adoptada para el nombre de los patrones. El nombre es parte fundamental de un patron, ya que, una vez comprendido este, pasa a formar parte, como los propios autores indican, de nuestro vocabulario de diseño. Por tanto, los nombres de los patrones de diseño han de ser considerados, en este sentido como las palabras reservadas de un lenguaje de programacion: no admiten traduccion, so pena de engañar al lector. Sin embargo, dado que el nombre designa con una o dos palabras el proposito del patron, parecia oportuno que el lector desconocedor de la lengua inglesa pudiese conocer su significado. Por ese motivo, hemos optado por ofrecer una traduccion, entre parentesis, al comienzo de la descripcion de cada patron, aunque posteriormente, en el texto, nos refiramos siempre a ellos con su nombre original en ingles.</p>
<p>Sera dificil que las decisiones adoptadas sean siempre del gusto de todos, como inevitable sera, a pesar de todos los esfuerzos, que se haya escapado algun error en la version final del libro. En cuarquier caso, sepa el lector que se han puesto los mayores esfuerzos en aunar el rigor tecnico con el cuidado del idioma, y apelamos a su indulgencia por los errores cometidos, de modo consciente o inconsciente.</p>
<p>No quisieramos terminar este prologo sin dar las gracias a Raul Izquierdo Castanedo, Aquilino Adolfo Juan Fuente, Francisco Ortin Soler, Jose Emilio Labra Gayo y el resto de miembros del <em>Laboratorio de Tecnologias Orientadas a Objetos de la universidad de Oviedo</em> (<a href="http://www.ootlab.uniovi.es" >http://www.ootlab.uniovi.es</a>, por el trabajo del grupo de investigacion sobre patrones de diseño y por sus valiosos comentarios y aportaciones.</p>
<p>Por ultimo, esperamos que con esta traduccion al español sean muchos mas los que se acerquen a las patrones de diseño, algo que sin duda contribuira a seguir mejorando y dignificando asi nuestra profesion, al hacernos mejores arquitectos de software. Igualmente, confiamos en que sirva, como ya hemos dicho, para ayudar a la formacion de futuras promociones de ingenieros en informatica. Haber contribuido a ello, con el minusculo esfuerzo de una traduccion, en comparacion con la labor original de Eric Gammna, Rechard Helm, Ralph Johnson y John Vlissides, seria algo que nos llenaria de satisfaccion y orgullo.</p>
<div class="right" >
<p>Cesar Fernandez Acebal</p>
<p>Juan Manuel Cueva Lovelle</p>
<p>Oviedo, 20 de junio de 2002</p>
</div>
</div>
<h2 id="guia-para-los-lectores" >Guia para los lectores</h2>
<div class="hBody-2" >
<p>Este libro tiene dos partes principales. La primera parte (Capitulos 1 y 2) describe que son los patrones de diseño y como pueden ayudarle a diseñar software orientado a objetos. Incluye un caso de estudio que demuestra como se aplican en la practica. La segunda parte del libro (Capitulos 3, 4 y 5) es un catalogo de los patrones de diseño propiamente dichos.</p>
<p>El catalogo constituye la mayor parte del libro. Sus capitulos dividen los patrones de diseño en tres tipos: de creacion, estructurales y de comportamiento. El catalogo se puede usar de varias formas: puede leerse de principio a fin o se puede simplemente ir de un patron a otro. Otra posibilidad es estudiar uno de los capitulos. Esto le ayudara a ver como se distinguen entre si patrones estrechamente relacionados.</p>
<p>Puede usar las referencias entre los patrones como una ruta logica a traves del catalogo. Este enfoque le hara comprender como se relacionan los patrones entre si, como se pueden combinar con otros y que patrones funcionan bien juntos. La <a href="#figura-1.1" >Figura 1.1</a> muestra estas referencias graficamente.</p>
<p>Otra forma mas de leer el catalogo es usar un enfoque mas orientado al problema. Vaya directamente a la <a href="#1.6" >Seccion 1.6</a> para leer algunos problemas comunes a la hora de diseñar software orientado a objetos reutilizable; despues, lea los patrones que resuelven estos problemas. Algunas personas leen primero el catalogo completo y <em>luego</em> usan un enfoque orientado al problema para aplicar los patrones en sus proyectos.</p>
<p>Si no es un diseñador orientado a objetos experimentado, le recomendamos que empiece con los patrones sencillos y mas comunes:</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<ul>
<li>
<p><a href="#abstract-factory" >Abstract Factory</a></p>
</li>
<li>
<p><a href="#adapter" >Adapter</a></p>
</li>
<li>
<p><a href="#composite" >Composite</a></p>
</li>
<li>
<p><a href="#decorator" >Decorator</a></p>
</li>
</ul>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<ul>
<li>
<p><a href="#factory-method" >Factory Method</a></p>
</li>
<li>
<p><a href="#observer" >Observer</a></p>
</li>
<li>
<p><a href="#strategy" >Strategy</a></p>
</li>
<li>
<p><a href="#template-method" >Template Method</a></p>
</li>
</ul>
</div>
</div>
<p>Es dificil encontrar un sistema orientado a objetos que no use al menos un par de estos patrones,  los grandes sistemas los usan casi todos. Este subconjunto le ayudara a entender los patrones de diseño en particular y el buen diseño orientado a objetos en general.</p>
</div>
<h2 id="capitulo-1" >Introduccion</h2>
<div class="hBody-2" >
<p>Diseñar software orientado a objetos es dificil, y aun lo es mas diseñar software orientado a objetos reutilizable. Hay que encontrar los objetos pertinentes, factorizarlos en clases con la granularidad adecuada, definir interfaces de clases y jerarquias de herencia y establecer las principales relaciones entre esas clases y objetos. Nuestro diseño debe ser especifico del problema que estamos manejando, pero tambien lo suficientemente general para adecuarse a futuros requisitios y problemas. Tambien queremos evitar el rediseño, o al menos minimizarlo. Los diseñadores experimentados de software orientado a objetos nos diran que es dificil, sino imposible, lograr un diseño flexible y reutilizable a la primera y que, antes de terminar un diseño, es frecuente intentar reutilizarlo varias veces, modificandolo cada una de ellas.</p>
<p>Sin embargo, estos diseñådores experimentados realmente consiguen hacer buenos diseño, mientras que los diseñadores novatos se ven abrumados por las opciones disponibles y tienden a recurrir a las tecnicas no orientadas a objectos que ya usaron antes. A un principante le lleva bastante tiempo aprender en que consiste un buen diseño orientado a objetos. Es evidente que los diseñadores experimentados saben algo que los principiantes no. ¿Que es?</p>
<p>Algo que los expertos saben que <em>no</em> hay que hacer es resolver cada problema partiendo de cero. Por el contrario, reutilizan soluciones que ya les han sido utiles en el pasado. Cuando ecuentran una solucion buena, la usan una y otra vez. Esta experiencia es parte de lo que les convierte en expertos. Por tanto, nos encontraremos con patrones recuerrentes de clases y comunicaciones entre objetos en muchos sistemas orientados a objetos. Estos patrones resuelven problemas concretos de diseño y hacen que los diseños orientados a objetos sean mas flexibles, elegantes y reutilizables. Los patrones ayudan a los diseñadores a reutilizar buenos diseños al basar los nuevos diseños en la experiencia previa. Un diseñador familiarizado con dichos patrones puede aplicarlos inmediatamente en los problemas de diseño sin tener que redescubrirlos.</p>
<p>Ilustremos este punto con una analogia. Los novelistas y escritores rara vez diseñan las tramas de sus obras desde cero, si no que siguen patrones como el del <em>heroe tragico</em> (Macbeth, Hamlet, etc.) o <em>la novela romantica</em> (innumerables novelas de amor). Del mismo modo, los diseñadores orientados a objetos siguen patrones como <q>representar estados con objetos</q> o <q>decorar objetos de manera que se puedan añadir y borrar funcionalidades facilmente</q>. Una vez que conocemos el patron, hay muchas decisiones de diseño que se derivan de manera natural.</p>
<p>Todos sabemos el valor de la experiencia en el diseño. ¿Cuantas veces hemos tenido un <em>déjà-vu</em> de diseño ––esa sensacion de que ya hemos resuelto ese problema antes, pero no sabemos exactamente donde ni como––? Si pudieramos recordar los detalles del problema anterior y de como lo resolvimos podriamos valernos de esa experiencia sin tener que reinvertar la solucion. Sin embargo, no solemos dedicarnos a dejar constancia de nuestra experiencia en el diseño de software para que la usen otros.</p>
<p>El proposito de este libro es documentar la experiencia en el diseño de software orientado a objetos en forma de <b>patrones de diseño</b>. Cada patron nomina, explica y evalua un diseño importante y recurrente en los sistemas orientados a objetos. Nuestro objetivo es representar esa experincia de diseño de forma que pueda ser reutilizada de manera efectiva por otras personas. Para lograrlo, hemos documentado algunos de los patrones de diseño mas importantes y los presentamos como un catalogo.</p>
<p>Los patrones de diseño hacen que sea mas facil reutilizar buenos diseños y arquitecturas. Al expresar como patrones de diseño tecnicas que ya han sido probadas, las estamos haciendo mas accesibles para los desarrolladores de nuevos sistemas. Los patrones de diseño nos ayudan a elegir las alternativas de diseño que hacen que un sistema sea reutilizable, y a evitar aquellas que dificultan dicha reutilizacion. Pueden incluso mejorar la documentacion y el mantenimiento de los sistemas existentes al proporcionar una expecificacion explicita de las iteracciones entre clases y objetos y de cual es su intencion. En definitiva, los patrones de diseño ayudan a un diseñador a lograr un buen diseño mas rapidamente.</p>
<p>Ninguno de los patrones de diseño de este libro describe diseños nuevos o que no hayan sido probados. Se han incluido solo aquellos que se han aplicado mas de una vez en diferentes sistemas. La mayoria de ellos estaba sin documentar, y existian bien como parte del repertorio de la comunidad de la orientacion a objetos, bien como elementos de algunos buenos sistemas orientados a objetos ––y de ninguna de ambas formas resultaban faciles de aprender por los diseñadores novatos––. Asi que, aunque estos diseños no son nuevos, los hemos expresado de una forma nueva y accesible: como un catalogo de patrones de diseño que tienen un formato consistente.</p>
<p>A pesar del tamaño del libro, los patrones de diseño que hay en el representan solo una parte de lo que puede saber un experto. No contiene patrones que tengan que ver con concurrencia o programacion distribuida o en tiempo real. Tampoco hay patrones de dominios especificos. No se cuenta como construir interfaces de usuario, como escribir controladores de dispositivos o como usar una base de datos orientada a objetos. Cada una de estas areas tiene sus propios patrones, y seria bueno que alguien los catalogase tambien.</p>
</div>
<h3 id="1.1" >¿Que es un patron de diseño?</h3>
<div class="hBody-3" >
<p>Segun Christopher Alexander, <q>cada patron describe un problema que ocurre una y otra vez en nuestro entorno, asi como la solucion a ese problema, de tal modo que se pueda aplicar esta solucion un millon de veces, sin hacer lo mismo dos veces</q> [<a href="#ais+77" >AIS+77</a>]. Aunque Alexander se referia a patrones en ciudades y edificios, lo que dice tambien es valido para patrones de diseño orientados a objetos. Nuestras soluciones se expresan en terminos de objetos e interfaces, en vez de paredes y puertas, pero en la esencia de ambos tipos de patrones se encuentra una solucion a un problema dentro de un contexto.</p>
<p>En general, un patron tiene cuatro elementos esenciales:</p>
<ol class="num" >
<li>
<p>El <b>nombre del patron</b> permite describir, en una o dos palabras, un problema de diseño junto con sus soluciones y consecuencias. Al dar nombre a un patron inmediatamante estamos incrementando nuestro vocabulario de diseño, lo que nos permite diseñar con mayor abstraccion. Tener un vocabulario de patrones nos permite hablar de ellos con otros colegas, mencionarlos en nuestra documentacion y tenerlos nosotros mismos en cuenta. De esta manera, resulta mas facil pensar en nuestros diseños y transmitirlos a otros, junto con sus ventajas e inconvenientes. Encontrar buenos nombres ha sido una de las partes mas dificiles al desarrollar nuestro catalogo.</p>
</li>
<li>
<p>El <b>problema</b> describe cuando aplicar el patron. Explica el problema y su contexto. Puede describir problemas concretos de diseño (por ejemplo, como representar algoritmos como objetos), asi como las estructuras de clases u objetos que son sintomaticas de un diseño inflexible. A veces el problema incluye una serie de condiciones que deben darse para que tenga sentido aplicar el patron.</p>
</li>
<li>
<p>La <b>solucion</b> describe los elementos que constituyen el diseño, sus relaciones, responsabilidades y colaboraciones. La solucion no describe un diseño o una implementacion en concreto, sino que un patron es mas bien como una plantilla que puede aplicarse en muchas situaciones diferentes. El patron proporciona una descripcion abstracta de un problema de diseño y como lo resuelve una disposicion general de elementos (en nuestro caso, clases y objetos).</p>
</li>
<li>
<p>Las <b>consecuencias</b> son los resultados asi como las ventajas e inconvenientes de aplicar el patron. Aunque cuando se describen desiciones de diseño muchas veces no se reflejan sus consecuencias, estas son fundamentales para evaluar las alternativas de diseño y comprender los costes y beneficios de aplicar el patron. Las consecuencias en el software suelen referise al equlibrio entre espacio y tiempo. Tambien pueden tratar cuestiones de lenguaje e implementacion. Por otro lado, puesto que la reutilizacion suele ser uno de los factores de los diseños orientados a objetos, las consecuencias de un patron incluyen su impacto sobre la flexibilidad, extensibilidad y portabilidad de un sistema. Incluir estas consecuencias de un modo explicito nos ayudara a comprenderlas y evaluarlas.</p>
</li>
</ol>
<p>Que es y que no es un patron de diseño es una cuestion que depende del punto de vista de cada uno. Lo que para una persona es un patron puede ser un bloque primitivo de construccion para otra. En este libro nos hemos centrado en patrones situados en un cierto nivel de abstraccion. <em>Patrones de diseño</em> no se ocupa de diseños como listas enlazadas y tablas de dispersion (<em>hash</em>) que pueden codificarse en clases y reutilizarse como tales. Tampoco se trata de complicados diseños especificos de un dominio para una aplicacion o subsistema completo. Los patrones de diseño de este libro son <em>descripciones de clases y objetos relacionados que estan particularizados para resolver un problema de diseño general en un determinado contexto</em>.</p>
<p>Un patron de diseño nomina, abstrae e identifica los aspectos clave de una estructura de diseño comun, lo que los hace utiles para crear un diseño orientado a objetos reutilizable. El patron de diseño identifica las clases e instancias participantes, sus roles y colaboraciones, y la distribucion de responsabilidades. Cada patron de diseño se centra en un problema concreto, describiendo cuando aplicarlo y si tiene sentido hacerlo teniendo en cuenta otras restricciones de diseño, asi como las consecuencias y las ventajas e inconvenientes de su uso. Por otro lado, como normalmente tendremos que implementar nuestros diseños, un patron tambien proporciona codigo de ejemplo en C++, y a veces en Smalltalk, para ilustrar una implementacion.</p>
<p>Aunque los patrones describen diseños orientados a objetos, estan basados en soluciones practicas que han sido implementadas en los lenguajes de programacion orientados a objetos mas usuales, como Smalltalk y C++, en vez de mediante lenguajes procedimentales (Pascal, C, Ada) u otros lenguajes orientados a abjetos mas dinamicos (CLOS, Dylan, Self). Nosotros hemos elegido Smalltalk y C++ por una cuestion pragmatica: nuestra experiencia diaria ha sido con estos lenguajes, y estos cada vez son mas populares.</p>
<p>La eleccion del lenguaje de programacion es importante, ya que influye en el punto de vista. Nuestros patrones presuponen caracteristicas de los lenguajes Smalltalk y C++, y esa eleccion determina lo que puede implementarse o no facilmente. Si hubieramos supuesto lenguajes procedimentales, tal vez hubieramos incluido patrones llamados <q>Herencia</q>, <q>Encapsulacion</q> y <q>Polimorfismo</q>. De manera similar, algunos de nuestros patrones estan incluidos directamente en lenguajes orientados a objetos menos corrientes. CLOS, por ejemplo, tiene multi-metodos que reducen la necesidad de patrones como el <a href="#visitor" >Visitor</a>. De hecho, hay suficientes diferencias entre Smalltalk y C++ como para que algunos patrones puedan expresarse mas facilmente en un lenguaje que otro (por ejemplo, el <a href="#iterator" >Iterator</a>).</p>
</div>
<h3 id="1.2" >Patrones de diseño en el MVC de Smalltalk</h3>
<div class="hBody-3" >
<p>La triada de clases Modelo/Vista/Controlador (MVC) [<a href="#kp88" >KP88</a>] se usa para interfaces de usuario en Smalltalk-80. Observar los patrones de diseño que hay en MVC deberia ayudar a entender que queremos decir con el termino <q>patron</q>.</p>
<p>MVC consiste en tres tipos de objetos. El <b>Modelo</b> es el objeto de aplicacion, la <b>Vista</b> es su representacion en pantalla y el <b>Controlador</b> define el modo en que la interfaz reacciona a la entrada del usuario. Antes de MVC, los diseños de interfaces de usuario tendian a agrupar estos objetos en uno solo. MVC los separa para incrementar la flexibilidad y reutilizacion.</p>
<p>MVC desacopla las vistas de los modelos estableciendo entre ellos un protocolo de subscripcion/notificacion. Una vista debe asegurarse de que su apariencia refleja el estado del modelo. Cada vez que cambian los datos del modelo, este se encarga de avisar a las vistas que dependen de el. Como respuesta a dicha notificacion, cada vista tiene la oportunidad de actualizarse a si misma. Este enfoque permite asignar varias vistas a un modelo para ofrecer diferentes presentaciones. Tambien se pueden crear nuevas visitas de un modelo sin necesidad de volver a escribir este.</p>
<p>El siguiente diagrama muestra un modelo y tres vistas (hemos dejado fuera los controladores para simplificar). El modelo contiene algunos valores de datos y las vistas, consistentes en una hoja de calculo, un histograma y un grafico de tarta que muestran estos datos de varias formas. El modelo se comunica con sus vistas cuando cambian sus valores, y las vistas se comunican con el modelo para acceder a estos.</p>
<figure>
<img src="img/000.png" />
</figure>
<p>Si nos fiamos de el, este ejemplo refleja un diseño que desacopla las vistas de los modelos. Pero el diseño es aplicable a un problema mas general: desacoplar objetos de manera que los cambios en uno puedan afectar a otros sin necesidad de que el objeto que cambia conozca detalles de los otros. Dicho diseño mas general se describe en el patron <a href="#observer" >Observer</a>.</p>
<p>Otras caracteristicas de MVC es que las vistas se pueden anidar. Por ejemplo, un panel de control con botones se puede implementar como una vista compleja que contiene varias vistas de botones anidadas. La interfaz de usuario de un inspector de objetos puede consistir en vistas anidadas que pueden ser reutilizadas en un depurador. MVC permite vistas anidadads gracias a la clase <code>VistaCompuesta</code>, una subclase de <code>Vista</code>. Los objetos <code>VistaCompuesta</code> pueden actuar simplemente como objetos <code>Vista</code>, es decir, una vista compuesta puede usarse en cualquier lugar donde pudiera usarse una vista, pero tambien contiene y gestiona vistas anidadas.</p>
<p>De nuevo, podriamos pensar en el como un diseño que nos permite tratar a una vista compuesta exactamente igual que a uno de sus componentes. Pero el diseño es aplicable a un problema mas general, que ocurre cada vez que queremos agrupar objetos y tratar al grupo como a un objeto individual. El patron <a href="#composite" >Composite</a> describe este diseño mas general. Dicho patron permite crear una jerarquia en la que algunas subclases definen objetos primitivos (por ejemplo, <code>Boton</code>) y otras, objetos compuestos (<code>VistaCompuesta</code>), que ensamblan los objetos primitivos en otros mas complejos.</p>
<p>MVC tambien permite cambiar el modo en que una vista responde a la entrada de usuario sin cambiar su representacion visual. En este sentido, tal vez queramos cambiar como responde al teclado, por ejemplo, o hacer que use un menu contextual en vez de atajos de teclado. MVC encapsula el mecanismo de respuesta en un objeto <code>Controlador</code>. Hay una jerarquia de controladores y es facil crear un nuevo controlador como una variacion de uno existente.</p>
<p>Una vista usa una instancia de una subclase de <code>Controlador</code> para implementar una determinada estrategia de respuesta; para implementar una estrategia diferente, simplemente basta con sustituir la instancia por otra clase de controlador. Incluso es posible cambiar el controlador de una vista en tiempo de ejecucion, para hacer que la vista cambie el modo en que responde a la entrada de usuario. Por ejemplo, para desactivar una vista y que no acepte entradas basta con asignarle un controlador que haga caso omiso de los eventos de entrada.</p>
<p>La relacion entre <code>Vista</code> y <code>Controlador</code> es un ejemplo del patron <a href="#strategy" >Strategy</a>. Una Estrategia es un objeto que representa un algoritmo. Es util cuando queremos reemplazar el algoritmo, ya sea estatica o dinamicamente, cuando existen muchas variantes del mismo o cuando tiene estructuras de datos complejas que queremos encapsular.</p>
<p>MVC usa otros patrones de diseño, tales como el <a href="#factory-method" >Factory Method</a> para especificar la clase controlador predeterminada de una vista, el <a href="#decorator" >Decorator</a> para añadir capacidad de desplazamiento a una vista. Pero las principales relaciones en MVC se dan entre los patrones de diseño <a href="#observer" >Observer</a>, <a href="#composite" >Composite</a> y <a href="#strategy" >Strategy</a>.</p>
</div>
<h3 id="1.3" >Descripcion de los patrones de diseño</h3>
<div class="hBody-3" >
<p>¿Como describimos los patrones de diseño? Las notaciones graficas, aunque importantes, no son suficientes. Simplemente representan el producto final del proceso de diseño, como las relaciones entre clases y objetos. Para reutilizar el diseño, debemos hacer constar las decisiones, alternativas y ventajas e inconvenientes que dieron lugar a el. Tambien son importantes los ejemplos concretos, porque nos ayudan a ver el diseño en accion.</p>
<p>Describimos los patrones de diseño empleando un formato consistente. Cada patron se divide en secciones de acuerdo a la siguiente plantilla. Esta da una estructura uniforme a la informacion, haciendo que los patrones de diseño sean mas faciles de aprender, comparar y usar.</p>
<dl>
<dt>Nombre de patron y clasificacion</dt>
<dd>
<p>El nombre del patron transmite sucintamente su esencia. Un buen nombre es vital, porque pasara a formar parte de nuestro vocabulario de diseño. La clasificacion del patron refleja el esquema que se presenta en la <a href="#1.5" >Seccion 1.5</a></p>
</dd>
<dt>Proposito</dt>
<dd>
<p>Una frase breve que responde a las siguientes cuestiones:</p>
<ul>
<li>
<p>¿Que hace este patron de diseño?</p>
</li>
<li>
<p>¿En que se basa?</p>
</li>
<li>
<p>¿Cual es el problema concreto de diseño que resuelve?</p>
</li>
</ul>
</dd>
<dt>Tambien conocido como</dt>
<dd>
<p>Otros nombres, si existen, por los que se conoce el patron.</p>
</dd>
<dt>Motivacion</dt>
<dd>
<p>Un escenario que ilustra un problema de diseño y como las estructuras de clases y objetos del patron resuelven el problema. El escenario ayudara a entender la descripcion que sigue.</p>
</dd>
<dt>Aplicabilidad</dt>
<dd>
<ul>
<li>
<p>¿En que situaciones se puede aplicar el patron de diseño?</p>
</li>
<li>
<p>¿Que ejemplos hay de malos diseños que el patron puede resolver?</p>
</li>
<li>
<p>¿Como se puede reconocer dichas situaciones?</p>
</li>
</ul>
</dd>
<dt>Estructura</dt>
<dd>
<p>Una representacion grafica de las clase del patron usando una notacion basada en la Tecnica de Modelado de Objetos (OMT) [<a href="#rbp+91" >RBP+91</a>]. Tambien hacemos uso de diagramas de interaccion [<a href="#jcjo92" >JCJO92</a>, <a href="#boo94" >Boo94</a>] para mostrar secuencias de peticiones y colaboraciones entre objetos. El <a href="#apendice-b" >Apendice B</a> describe estas notaciones en detalle.</p>
</dd>
<dt>Participantes</dt>
<dd>
<p>Las clases y objetos participantes en el patron de diseño, junto con sus reponsabilidades.</p>
</dd>
<dt>Colaboraciones</dt>
<dd>
<p>Como colaboran los participantes para llevar a cabo sus responsabilidades.</p>
</dd>
<dt>Consecuencias</dt>
<dd>
<ul>
<li>
<p>¿Como consigue el patron sus objetivos?</p>
</li>
<li>
<p>¿Cuales son las ventajas e inconvenientes y los resultados de usar el patron?</p>
</li>
<li>
<p>¿Que aspectos de la estructura del sistema se pueden modificar de forma independiente?</p>
</li>
</ul>
</dd>
<dt>Implementacion</dt>
<dd>
<ul>
<li>
<p>¿Cuales son las dificultades, trucos o tecnicas que deberiamos tener en cuenta a la hora de aplicar el patron?</p>
</li>
<li>
<p>¿Hay cuestiones especificas del lenguaje?</p>
</li>
</ul>
</dd>
<dt>Codigo de ejemplo</dt>
<dd>
<p>Fragmentos de codigo que muestran como se puede implementar el patron en C++ o en Smalltalk.</p>
</dd>
<dt>Usos conocidos</dt>
<dd>
<p>Ejemplos del patron en sistemas reales. Incluidos al menos dos ejemplos de diferentes dominios.</p>
</dd>
<dt>Patrones relacionados</dt>
<dd>
<ul>
<li>
<p>¿Que patrones de diseño estan estrechamente relacionados con este?</p>
</li>
<li>
<p>¿Cuales son las principales diferencias?</p>
</li>
<li>
<p>¿Con que otros patrones deberia usarse?</p>
</li>
</ul>
</dd>
</dl>
<p>Los apendices proporcionan informacion adicional que le ayudara a entender los patrones y las discuciones que lo rodean. El <a href="#apendice-a" >Apendice A</a> es un glosario de la terminologia en el libro. En el <a href="#apendice-b" >Apendice B</a> que ya hemos mencionado se presentan las diferentes notaciones. Tambien describiremos aspectos de las notaciones a medida que las vayamos introduciendo en las discuciones venideras. Finalmente, el <a href="#apendice-c" >Apendice C</a> contiene el codigo fuente de las clases que usamos en los ejemplos.</p>
</div>
<h3 id="1.4" >El catalogo de patrones de diseño</h3>
<div class="hBody-3" >
<p>El catalogo contiene 23 patrones de diseño. A continuacion mostraremos el nombre y el proposito de cada uno de ellos para ofrecerle una perspectiva general.</p>
<dl>
<dt><a href="#abstract-factory" >Abstract Factory</a> (Fabrica Abstracta)</dt>
<dd>
<p>Proporciona una interfaz para crear familias de objetos relacionados o que dependen entre si, sin especificar sus clases concretas.</p>
</dd>
<dt><a href="#adapter" >Adapter</a> (Adaptador)</dt>
<dd>
<p>Convierte la interfaz de una claze en otra distinta que es la que esperan los clientes. Permite que cooperen clases que de otra manera no podrian por tener interfaces incompatibles.</p>
</dd>
<dt><a href="#bridge" >Bridge</a> (Puente)</dt>
<dd>
<p>Desacopla una abstraccion de su implementacion, de manera que ambas puedan variar de forma independiente.</p>
</dd>
<dt><a href="#builder" >Builder</a> (Constructor)</dt>
<dd>
<p>Separa la construccion de un objeto complejo de su representacion, de forma que el mismo proceso de construccion pueda crear diferentes representaciones.</p>
</dd>
<dt><a href="#chain-of-responsibility" >Chain of Responsibility</a> (Cadena de Responsabilidad)</dt>
<dd>
<p>Evita acoplar el emisor de una peticion a su receptor, al dar a mas de un objeto la posibilidad de responder a la peticion. Crea una cadena con los objetos receptores y pasa la peticion a traves de la cadena hasta que esta sea tratada por algun objeto.</p>
</dd>
<dt><a href="#command" >Command</a> (Orden)</dt>
<dd>
<p>Encapsula una peticion en un objeto, permitiendo asi paramentrizar a los clientes con distintas peticiones, encolar o llevar un registro de las peticiones y poder deshacer las operaciones.</p>
</dd>
<dt><a href="#composite" >Composite</a> (Compuesto)</dt>
<dd>
<p>Combina objetos en estructuras de arbol para representar jerarquias de parte-todo. Permite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos.</p>
</dd>
<dt><a href="#decorator" >Decorator</a> (Decorador)</dt>
<dd>
<p>Añade dinamicamente nuevas responsabilidades a un objeto, proporcionando una alternativa flexible a la herencia para extender la funcionalidad.</p>
</dd>
<dt><a href="#facade" >Facade</a> (Fachada)</dt>
<dd>
<p>Proporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema sea mas facil de usar.</p>
</dd>
<dt><a href="#factory-method" >Factory Method</a> (Metodo de Fabricacion)</dt>
<dd>
<p>Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan que clase instanciar. Permite que una clase delegue en sus subclases la creacion de objetos.</p>
</dd>
<dt><a href="#flyweight" >Flyweight</a> (Peso Ligero<span class="note" ><sup><a href="#1" >1</a></sup></span>)</dt>
<dd>
<p>Usa el comportamiento para permitir un gran numero de objetos de grano fino de forma eficiente.</p>
</dd>
<dt><a href="#interpreter" >Interpreter</a> (Interprete)</dt>
<dd>
<p>Dado un lenguaje, define una respresentacion de su gramatica junto con un interprete que usa dicha representacion para interpretar sentencias del lenguaje.</p>
</dd>
<dt><a href="#iterator" >Iterator</a> (Iterador)</dt>
<dd>
<p>Proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representacion interna.</p>
</dd>
<dt><a href="#mediator" >Mediator</a> (Mediador)</dt>
<dd>
<p>Define un objeto que encapsula como interactuan un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros explicitamente, y permite variar la interaccion entre ellos de forma independiente.</p>
</dd>
<dt><a href="#memento" >Memento</a> (Recuerdo)</dt>
<dd>
<p>Representa y externaliza el estado interno de un objeto sin violar la encapsulacion, de forma que este puede volver a dicho estado mas tarde.</p>
</dd>
<dt><a href="#observer" >Observer</a> (Observador)</dt>
<dd>
<p>Define una dependencia de uno-a-muchos entre objetos, de forma que cuando cambie de estado se notifica y se actualizan automaticamente todos los objetos que dependen de el.</p>
</dd>
<dt><a href="#prototype" >Prototype</a> (Prototipo)</dt>
<dd>
<p>Especifica los tipos de objetos a crear por medio de una instacia prototipica, y crea nuevos objetos copiando de este prototipo.</p>
</dd>
<dt><a href="#proxy" >Proxy</a> (Apoderado)</dt>
<dd>
<p>Proporciona un sustituto o representante de otro objeto para controlar el acceso a este.</p>
</dd>
<dt><a href="#singleton" >Singleton</a> (Unico)</dt>
<dd>
<p>Garantiza que una clase solo tenga una instancia, y proporciona un punto de acceso global a ella.</p>
</dd>
<dt><a href="#state" >State</a> (Stado)</dt>
<dd>
<p>Permite que un objeto modifique su comportamiento cada vez que cambie su estado interno. Parecera que cambia la clase de objeto.</p>
</dd>
<dt><a href="#strategy" >Strategy</a> (Estrategia)</dt>
<dd>
<p>Define una familia de algoritmos, encapsula cada uno de ellos y los hace intercambiables. Permite que un algoritmo varie independientemente de los clientes que lo usan.</p>
</dd>
<dt><a href="#template-method" >Template Method</a> (Metodo Plantilla)</dt>
<dd>
<p>Define en una operacion el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura.</p>
</dd>
<dt><a href="#visitor" >Visitor</a> (Visitante)</dt>
<dd>
<p>Representa una operacion sobre los elementos de una estructura de objetos. Permite definir una nueva operacion sin cambiar las clases de los elementos sobre los que opera.</p>
</dd>
</dl>
</div>
<h3 id="1.5" >Orgarnizacion del catalogo</h3>
<div class="hBody-3" >
<p>Los patrones de diseño varian en su granularidad y nivel de abstraccion. Dado que existen muchos patrones de diseño, es necesario un modo de organizarlos. Esta seccion clasifica los patrones de diseño de manera que podamos referirnos a familias de patrones relacionados. La clasificacion ayuda a aprender mas rapidamente los patrones del catalogo, y tambien puede encauzar los esfuerzos para descubrir nuevos patrones.</p>
<p>Nosotros clasificamos los patrones de diseño siguiendo dos criterios (Tabla 1.1). El primero de ellos, denominado <b>proposito</b>, refleja que hace un patron. Los patrones pueden tener un proposito de <b>creacion</b>, <b>estructural</b> o de <b>comportamiento</b>. Los patrones de creacion tienen que ver con el proceso de creacion de objetos. Los patrones estructurales tratan con la composicion de clases u objetos. Los de comportamiento caracterizan el modo en que las clases y objetos interactuan y se reparten la responsabilidad.</p>
<div class="figure" >
<h1 class="figure"><span id="tabla-1.1" >Tabla 1.1</span>: Patrones de diseño</h1>
<table border="1">
<thead>
<tr><th colspan="5"><p>Proposito</p>
</th></tr>
<tr><th colspan="2"></th><th><p>De Creacion</p>
</th><th><p>Estructurales</p>
</th><th><p>De Comportamiento</p>
</th></tr>
</thead>
<tbody>
<tr><td rowspan="11"><p>Ambito</p>
</td><td rowspan="2"><p>Clase</p>
</td><td><p><a href="#factory-method" >Factory Method</a></p>
</td><td><p><a href="#adapter" >Adapter</a> (de clases)</p>
</td><td><p><a href="#interpreter" >Interpreter</a></p>
</td></tr>
<tr><td></td><td></td><td><p><a href="#template-method" >Template Method</a></p>
</td></tr>
<tr><td rowspan="9"><p>Objeto</p>
</td><td><p><a href="#abstract-factory" >Abstract Factory</a></p>
</td><td><p><a href="#adapter" >Adapter</a> (de objetos)</p>
</td><td><p><a href="#chain-of-responsibility" >Chain of Responsibility</a></p>
</td></tr>
<tr><td><p><a href="#builder" >Builder</a></p>
</td><td><p><a href="#bridge" >Bridge</a></p>
</td><td><p><a href="#command" >Command</a></p>
</td></tr>
<tr><td><p><a href="#prototype" >Prototype</a></p>
</td><td><p><a href="#compositive" >Compositive</a></p>
</td><td><p><a href="#iterator" >Iterator</a></p>
</td></tr>
<tr><td><p><a href="#singleton" >Singleton</a></p>
</td><td><p><a href="#decorator" >Decorator</a></p>
</td><td><p><a href="#mediator" >Mediator</a></p>
</td></tr>
<tr><td></td><td><p><a href="#facade" >Facade</a></p>
</td><td><p><a href="#memento" >Memento</a></p>
</td></tr>
<tr><td></td><td><p><a href="#flyweight" >Flyweight</a></p>
</td><td><p><a href="#observer" >Observer</a></p>
</td></tr>
<tr><td></td><td><p><a href="#proxy" >Proxy</a></p>
</td><td><p><a href="#state" >State</a></p>
</td></tr>
<tr><td></td><td></td><td><p><a href="#strategy" >Strategy</a></p>
</td></tr>
<tr><td></td><td></td><td><p><a href="#visitor" >Visitor</a></p>
</td></tr>
</tbody>
</table>
</div>
<p>El segundo criterio, denominado ambito, especifica si el patron se aplica principalmente a clases o a objetos. Los patrones de clases se ocupan de las relaciones entre las clases y sus subclases. Estas relaciones se establecen a traves de la herencia, de modo que son relaciones estaticas ––fiajadas en tiempo de compilacion––. Los patrones de objetos tratan con las relaciones entre objetos, que pueden cambiarse en tiempo de ejecucion y son dinamicas. Casi todos los patrones usan la herencia de un modo u otro, asi que los unicos patrones etiquetados como <q>patrones de clases</q> son aquellos que se centran en las relaciones entre clases. Notese que la mayoria de los patrones tienen un ambito de objeto.</p>
<p>Los patrones de creacion de clases delegan alguna parte del proceso de creacion de objetos en las subclases, mientras que los patrones de creacion de objetos lo hacen en otro objeto. Los patrones estructurales de clases usan la herencia para componer clases, mientras que los objetos describen formas de ensamblar objetos. Los patrones de comportamiento de clases usan la herencia para describir algoritmos y flujos de control, mientras que los de objetos describen como cooperan un grupo de objetos para realizar una tarea que ningun objeto puede llevar a cabo por si solo.</p>
<p>Hay otras maneras de organizar los patrones. Algunos patrones suelen usarse juntos. Por ejemplo, el Composite suele usarse con el Iterator o el Visitor. Algunos patrones son alternativas: el Prototype es muchas veces una alternativa al Abstract Factory. Algunos patrones dan como resultado diseños parecidos, a pesar de que tengan diferentes propositos. Por ejemplo, los diagramas de estructura del Composite y el Decorator son similares.</p>
<p>Otro modo de organizar los patrones de diseño es en funcion de como se hagan referencia unos a otros en su seccion <q>Patrones Relacionados</q>. La Figura 1.1 representa estas relaciones graficamente.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-1.1" >Figura 1.1</span>: Relaciones entre los patrones de diseño</h1>
<figure>
<img src="img/001.png" />
</figure>
</div>
<p>Es evidente que hay muchas formas de organizar los patrone de diseño. Tener muchas formas de pensar en los patrones le hara comprender mejor que es lo que hacen, como compararlos y cuando aplicarlos</p>
</div>
<h3 id="1.6" >Como resuelven los patrones los problemas de diseño</h3>
<div class="hBody-3" >
<p>Los patrones de diseño resuelven muchos de los problemas diarios con los que se enfrentan los diseñadores orientados a objetos, y lo hacen de muchas formas diferentes. A Continuacion se muestran algunos de estos problemas y como los solucionan los patrones.</p>
</div>
<h4 id="encontrar-los-objetos-apropiados" >Encontrar los objetos apropiados</h4>
<div class="hBody-4" >
<p>Los programas orientados a objetos estan formados de objetos. Un objeto encapsula tanto datos como los procedimientos que operan sobre esos datos. Estos procedimientos es lo que se conoce normalmente como <b>metodos</b> u <b>operaciones</b>. Un objeto realiza una operacion cuando recibe una <b>peticion</b> (o <span class="math" >mensaje</span>) de un <b>cliente</b>.</p>
<p>Las peticiones son el <em>unico</em> modo de lograr que un objeto ejecute una operacion. Las operaciones son la <em>unica</em> forma de cambiar los datos internos de un objeto. Debido a estas restricciones, se dice que el estado interno de un objeto esta encapsulado; no puede accederse a el directamente, y su representacion no es visible desde el exterior del objeto.</p>
<p>Lo mas complicado del diseño orientado a objetos es descomponer un sistema en objetos. La tarea es dificil porque entran en juego muchos factores: encapsulacion, granularidad, dependencia, flexibilidad, rendimiento, evolucion, reutilizacion, etcetera, etcetera. Todos ellos influyen en la descomposicion, muchas veces de formas opuestas.</p>
<p>Las metodologias orientadas a objetos permiten muchos enfoques diferentes. Podemos escribir la descripcion de un problema, extraer los nombres y verbos, y crear las correspondientes clases y operaciones. O podemos centrarnos en las colaboraciones y responsabilidades de nuestro sistema. O modelar el mundo real y traducir al diseño los objetos encontrados durante el analisis. Siempre habra discrepancias sobre que enfoque es mejor.</p>
<p>Muchos objetos de un diseño proceden del modelo del analisis. Pero los diseños orientados a objetos suelen acabar teniendo clases que no tienen su equivalente en el mundo real. Algunas de ellas son clases de bajo nivel como los arrays. Otras son de mucho mas alto nivel. Por ejemplo, el patron <a href="#composite" >Composite</a> introduce una abstraccion para tratar de manera uniforme objetos que no tienen un equivalente fisico. El modelado estricto del mundo real conduce a un sistema que refleja las realidades presentes pero no necesariamente las futuras. Las abstracciones que surgen durante el diseño son fundamentales para lograr un diseño flexible.</p>
<p>Los patrones de diseño ayudan a identificar abstracciones menos obvias y los objetos que las expresan. Por ejemplo, los objetos que representan un proceso o algoritmo no tienen lugar en la naturaleza, y sin embargo son una parte crucial de los diseños flexibles. El patron <a href="#strategy" >Strategy</a> describe como implementar familias intercambiables de algoritmos. El patron <a href="#state" >State</a> representa cada estado de una entidad como un objeto. Estos objetos rara vez se encuentran durante el analisis o incluso en las primeras etapas del diseño; son descubiertos mas tarde, mientras se trata de hacer el diseño mas flexible y reutilizable.</p>
</div>
<h4 id="determinar-la-granularidad-de-los-objetos" >Determinar la granularidad de los objetos</h4>
<div class="hBody-4" >
<p>Los objetos pueden variar enormemente en tamaño y numero. Pueden representar cualquier cosa, desde el hardware hasta aplicaciones completas. ¿Como decidir entonces que deberia ser un objeto?</p>
<p>Los patrones de diseño tambien se encargan de esta cuestion. El patron <a href="#facade" >Facade</a> describe como representar subsistemas completos como objetos, y el patron <a href="#flyweight" >Flyweight</a> como permitir un gran numero de objetos de granularidad muy fina. Otros patrones de diseño describen formas concretas de descomponer un objeto en otros mas pequeños. Los patrones <a href="#abstract-factory" >Abstract Factory</a> y <a href="#builder" >Builder</a> producen objetos cuya unica responsabilidad es crear otros objetos. El patron <a href="#visitor" >Visitor</a> y el <a href="#command" >Command</a> dan lugar a objetos cuaya unica responsabilidad es implementar una peticon en otro objeto o grupo de objetos.</p>
</div>
<h4 id="especificar-las-interfaces-de-los-objetos" >Especificar las interfaces de los objetos</h4>
<div class="hBody-4" >
<p>Cada operacion declarada por un objeto especifica el nombre de la operacion, los objetos que toma como paramentros y el valor de retorno de la operacion. Esto es lo que se conoce como la <b>signatura</b> de la operacion. Al conjunto de todas las signaturas definidas por las operaciones de un objeto se le denomita la <b>interfaz</b> del objeto. Dicha interfaz caracteriza al conjunto completo de peticiones que se pueden enviar al objeto. Cualquier peticion que concuerde con una signatura de la interfaz puede ser enviada al objeto.</p>
<p>Un <b>tipo</b> es un nombre que se usa para denotar una determinada interfaz. Decimos que un objeto tiene el tipo <q>Ventana</q> si acepta todas las peticiones definidas en una interfaz llamada <q>Ventana</q>. Un objeto puede tener muchos tipos, y objetos muy diferentes pueden compartir un mismo tipo. Parte de la interfaz de un objeto puede ser caracterizada por un tipo, y otras partes por otros tipos. Dos objetos del mismo tipo solo necesitan compartir partes de sus interfaces. Las interfaces pueden contener, como subjconjuntos, otras interfaces. Se dice que un tipo es un <b>subtipo</b> de otro si su interfaz contiene a la interfaz de su <b>supertipo</b>. Suele decirse que un subtipo <em>hereda</em> la interfaz de su supertipo.</p>
<p>Las interfaces son fundamentales en los sistemas orientados a objetos. Los objetos solo se conocen a traves de su interfaz. No hay modo de saber nada de un objeto o pedirle que haga nada si no es atraves de su interfaz. La interfaz de un objeto no dice nada acerca de su implementacion ––distintos objetos son libres de implementar las peticiones de forma diferente––. Eso significa que dos objetos con implementaciones completamente diferentes pueden tener interfaces identicas.</p>
<p>Cuando se envia una peticion a un objeto, la operacion concreta que se ejecuta depende <em>tanto</em> de la peticion <em>como</em> del objeto que la recibe. Objetos diferentes que soportan peticiones identicas pueden tener distintas implementaciones de las operaciones que satisfacen esas peticiones. La asociacion en tiempo de ejecucion entre una peticion a un objeto y una de sus operaciones es lo que se conoce como <b>enlace dinamico</b>.</p>
<p>El enlace dinamico significa que enviar una peticion no nos liga a una implementacion particular hasta el tiempo de ejecucion. Por tanto, podemos escribir programas que esperen un objeto con una determinada interfaz, sabiendo que cualquier objeto que tenga la interfaz concreta aceptara la peticion.</p>
<p>Mas aun, el enlace dinamico nos permite sustituir objetos en tiempo de ejecucion por otros que tengan la misma interfaz. Esta capacidad de sustitucion es lo que se conoce como polimorfismo, y es el concepto clave en los sistemas orientados a objetos. Permite que un cliente haga pocas suposiciones sobre otros objetos aparte de que permitan una interfaz determinada. El polimorfirsmo simplifica las definiciones de los clientes, desacopla unos objetos de otros y permite que varien las relaciones entre ellos en tiempo de ejecucion.</p>
<p>Los patrones de diseño ayudan a definir interfaces identificando sus elementos clave y los tipos de datos que se envian a la interfaz. Un patron de diseño tambien puede decir que no debemos poner en la interfaz. El patron <a href="#memento" >Memento</a> (Recuerdo) es un buen ejemplo de esto. Dicho patron describe como encapsular y guardar el estado interno de un objeto para que este puedar volver a ese estado posteriormente. El patron estipula que los objetos <code>Recuerdo</code> deben definir dos interfaces: una restringida, que permita a los clientes albergar y copiar el estado a recordar, y otra protegida que solo pueda usar el objeto original para almacenar y recuperar dicho estado.</p>
<p>Los patrones de diseño tambien especifican relaciones entre interfaces. En concreto, muchas veces requieren que algunas clases tengan interfaces parecidas, o imponen restricciones a las interfaces de algunas clases. Por ejemplo, tanto el patron <a href="#decorator" >Decorator</a> como el <a href="#proxy" >Proxy</a> requieren que las interfaces de los objetos <code>Decorador</code> y <code>Proxy</code> sean identicos a los objetos <code>decorado</code> y <code>representado</code>, respectivamente. En el patron <a href="#visitor" >Visitor</a>, la interfaz <code>Visitante</code> debe reflejar todas las clases de objetos que pueden ser visitados.</p>
</div>
<h4 id="especificar-las-implementaciones-de-los-objetos" >Especificar las implementaciones de los objetos</h4>
<div class="hBody-4" >
<p>Hasta ahora hemos dicho poco sobre como definir realmente un objeto. La implementacion de un objeto queda definida por su clase. La clase especifica los datos, la representacion interna del objeto y define las operaciones que puede realizar.</p>
<p>Nuestra notacion basada en OMT (resumida en el <a href="#apendice-b" >Apendice B</a> muestra una clase como un rectangulo con el nombre en negrita. Las operaciones aparecen en un tipo de fuente normal bajo el nombre de la clase. Cualquier dato que defina la clase viene despues de las operaciones. Por ultimo, se utilizan lineas para separar el nombre de la clase de las operaciones y estas de los datos:</p>
<figure>
<img src="img/002.png" />
</figure>
<p>Los tipos de retorno y de las variables de instancia son opcionales, puesto que no suponemos un lenguaje de implementacion estaticamente <em>tipado</em>.</p>
<p>Los objetos se crean <b>instanciando</b> una clase. Se dice que el objeto es una <b>instancia</b> de la clase. El proceso de crear una instancia de una clase asigna espacio de almacenemaiento para los datos internos del objeto (representandos por <b>variables de instancia</b>) y asocia las operaciones con esos datos. Se pueden crear muchas instancias parecidas de un objeto instanciando una clase.</p>
<p>Una flecha de linea discontinua indica que una clase crea objetos de otra clase. La flecha apunta a la clase de los objetos creados.</p>
<figure>
<img src="img/003.png" />
</figure>
<p>Las nuevas clases se pueden definir en terminos de las existentes, usando la <b>herencia de clases</b>. Cuando una <b>subclase</b> hereda de una <b>clase padre</b>, incluye las definiciones de todos los datos y operaciones que define la clase patre. Los objetos que son instancias de las subclases contendran todos los datos definidos por la subclase y por sus clases padre, y seran capaces de realizar todas las operaciones definidas por sus subclases y sus padres. Indicamos la relacion de subclase con una linea vertical y un triangulo:</p>
<figure>
<img src="img/004.png" />
</figure>
<p>Una <b>clase abstracta</b> es aquella cuyo proposito principal es definir una interfaz comun para sus subclases. Una clase abstracta delegara parte o toda su implementacion en las operaciones definidas en sus subclases; de hay que no se pueda crear una instancia de una clase abstracta. Las operaciones que una clase abstracta define pero no implementa se denominan <b>operaciones abstractas</b>. Las clases que no son abstractas se denominan <b>clases concretas</b>.</p>
<p>Las subclases pueden definir el comportamiento de sus clases padres. Mas concretamente, una clase puede definir una operacion definida por su clase padre. La redefinicion permite que sean las subclases las que manejen una peticion en vez de sus clases padres. La herencia de clases permite definir clases simplemente extendiendo otras clases, haciendo que sea facil definir familias de objetos de funcionalidad parecida.</p>
<p>Los nombres de las clases abstractas aparecen en cursiva para distinguirlas de las clases concretas. Un diagrama puede incluir el pseudocodigo de la implementacion de una operacion; si es asi, el codigo aparecera en una caja con la esquina doblada unida por una linea discontinua a la operacion que implementa.</p>
<figure>
<img src="img/005.png" />
</figure>
<p>Una clase mezclable<span class="note" ><sup><a href="#2" >2</a></sup></span> es aquella pensada para proporcionar una interfaz o funcionalidad opcional a otras clases. Se parece a una clase abstracta en que no esta pensada para que se creen instancias de ella. Las clases mezclables requieren herencia multiple:</p>
<figure>
<img src="img/006.png" />
</figure>
</div>
<h5 id="herencia-de-clases-frente-a-herencia-de-interfaces" >Herencia de clases frente a herencia de interfaces</h5>
<div class="hBody-5" >
<p>Es importante entender la diferencia entre la <em>clase</em> de un objeto y su <em>tipo</em>.</p>
<p>La clase de un objeto define como se implementa un objeto. La clase define el estado interno del objeto y la implementacion de sus operaciones. Por el contrario, el tipo de un objeto solo se refiere a su interfaz ––el conjunto de peticiones a las cuales puede responder––. Un objeto puede tener muchos tipos, y objetos de clases diferentes pueden tener el mismo tipo.</p>
<p>Por supuesto, hay una estrecha relacion entre clase y tipo. Puesto que una clase define las operaciones que puede realizar un objeto tambien define el tipo del objeto. Cuando decimos que un objeto es una instancia de una clase, queremos decir que el objeto admite la interfaz definida por la clase.</p>
<p>Lenguajes como C++ y Eiffel usan clases para especificar tanto el tipo de un objeto como su implementacion. Los programadores de Smalltalk no declaran los tipos de las variables; por tanto, el compilador no comprueba que los tipos de los objetos asignados a una variable sean subtipos del tipo de la variable. Enviar un mensaje requiere comprobar que la clase del receptor implementa el mensaje, pero no que el receptor sea una instancia de una clase determinada.</p>
<p>Tambien es importante comprender la diferencia entre la herencia de clases y la de interfaces (o subtipado). La herencia de clases define la implementacion de un objeto en terminos de la implementacion de otro objeto. En resumen, es un mecanismo para compartir codigo y representacion. Por el contrario, la herencia de interfaces (o subtipado) describe cuando se puede usar un objeto en el lugar de otro.</p>
<p>Es facil confundir estos dos conceptos, porque muchos lenguajes no hacen esta distincion explicita. En lenguajes como C++ y Eiffel, herencia significa tanto herencia de interfaces como de implementacion. La manera normal de heredar de una interfaz en C++ es heredar publicamente de una clase que tiene funciones miembro virtuales (puras). La herencia de interfaces pura se puede simular en C++ heredando publicamente de clases abstractas puras. La herencia de implementacion o de clases pura puede simularse con herencia privada. En Smalltalk, la herencia significa simplemente herencia de implementacion. Se pueden asignar instancias de cualquier clase a una variable siempre que sus instancias permitan las operaciones realizadas sobre el valor de la variable.</p>
<p>Si bien la mayoria de los lenguajes de programacion no admiten la distincion entre herencia de interfaces y de implementacion, la gente hace esa distincion en la practica. Los programadores de Smalltalk normalmente tratan a las subclases como si fueran subtipos (aunque hay algunas conocidas excepciones [<a href="#coo92" >Coo92</a>]); los programadores de C++ manipulan objetos a traves de tipos definidos por clases abstractas.</p>
<p>Muchos de los patrones de diseño dependen de esta distincion. Por ejemplo, los objetos de una cadena en el patron <a href="#chain-of-responsibility" >Chain of Responsibility</a> deben tener un tipo comun, pero normalmente no comparten la misma implementacion. En el patron <a href="#composite" >Composite</a>, el <code>Componente</code> define una interfaz comun, mientras que el <code>Compuesto</code> suele definir una implementacion comun. Los patrones <a href="#command" >Command</a>, <a href="#observer" >Observer</a>, <a href="#state" >State</a>, y <a href="#strategy" >Strategy</a> suelen implementarse con clases abstractas que son interfaces puras.</p>
</div>
<h5 id="programar-para-interfaces,-no-para-una-implementacion" >Programar para interfaces, no para una implementacion</h5>
<div class="hBody-5" >
<p>La herencia de clases no es mas que un mecanismo para extender la funcionalidad de una aplicacion reutilizando la funcionalidad de las clases padres. Permite definir rapidamente un nuevo tipo de objeto basandose en otro, y obtener asi nuevas implentaciones casi sin esfuerzo, al heredar la mayoria de lo que se necesita de clases ya existentes.</p>
<p>En cualquier caso, reutilizar la implementacion es solo la mitad de la historia. Tambien es importante la capacidad de la herencia para definir familias de objetos con interfaces <em>identicas</em> (normalmente heredando de una clase abstracta), al ser justamente en lo que se basa el polimorfismo.</p>
<p>Cuando la herencia se usa con cuidado (algunos diran que cuando se usa <em>correctamente</em>), todas las clases que derivan de una clase abstracta compartiran su interfaz. Esto implica que una subclase simplemente añade o redefine operaciones y no oculta operaciones de la clase padre. <em>Todas</em> las subclases pueden entonces responder a las peticiones en la interfaz de su clase abstracta, convirtiendose asi todas ellas en subtipos de la clase abstracta.</p>
<p>Manipular los objetos solamente en terminos de la interfaz definida por las clases abstractas tiene dos ventajas:</p>
<ol class="num" >
<li>
<p>Los clientes no tiene que conocer los tipos especificos de los objetos que usan, basta con que estos se adhieran a la interfaz que esperan los clientes.</p>
</li>
<li>
<p>Los clientes desconocen las clases que implementan dichos objetos; solo conocen las clases abstractas que definen la interfaz.</p>
</li>
</ol>
<p>Esto reduce de tal manera las dependencias de implementacion entre subsistemas que lleva al siguiente principio del diseño orientado a objetos reutilizable:</p>
<blockquote>
<p>Programe para una interfaz, no para una implementacion.</p>
</blockquote>
<p>Es decir, no se deben declarar las variables como instancias de clases concretas. En ves de eso, se ajustaran simplemente a la interfaz definida por una clase abstracta. Esto sera algo recurrente en los patrones de diseño de este libro.</p>
<p>No obstante, es evidente que en algun lugar del sistema habra que crear instancias de clases concretas (esto es, especificar una determinada implementacion), y los patrones de creacion (<a href="#abstract-factory" >Abstract Factory</a>, <a href="#builder" >Builder</a>, <a href="#factory-method" >Factory Method</a>, <a href="#prototype" >Prototype</a> y <a href="#singleton" >Singleton</a>) se encargaran de eso. Al abstraer el proceso de creacion de objetos, estos patrones ofrecen diferentes modos de asociar una interfaz con su implementacion de manera transparente. Los patrones de creacion aseguran que el sistema se escriba en terminos de interfaces, no de implementaciones.</p>
</div>
<h4 id="poner-a-funcionar-los-mecanismos-de-reutilizacion" >Poner a Funcionar los mecanismos de Reutilizacion</h4>
<div class="hBody-4" >
<p>La mayoria de la gente comprente conceptos como objetos, interfaces, clases y herencia. La dificultad radica en aplicarlos para construir software flexible y reutilizable, y los patrones de diseño pueden mostrar como hacerlo.</p>
</div>
<h5 id="herencia-frente-a-composicion" >Herencia frente a Composicion</h5>
<div class="hBody-5" >
<p>Las dos tecnicas mas comunes para reutilizar funcionalidad en sistemas orientados a objetos son la herencia de clases y la composicion de objetos. Como ya hemos explicado, la herencia de clases permite definir una implementacion en terminos de otra. A esta forma de reutilizacion mediante herencia se le denomina frecuentemente <b>reutilizacion de caja blanca</b>. El termino <q>caja blanca</q> se refiere a la visibilidad: con la herencia, las interioridades de las clases padres suelen hacerse visibles a las subclases.</p>
<p>La composicion de objetos es una alternativa a la herencia de clases. Ahora, la nueva funcionalidad se obtiene ensamblando o <em>componiendo</em> objetos para obtener funcionalidad mas compleja. La composicion de objetos requiere que los objetos a componer tengan interfaces bien definidas. Este estilo de reutilizacion se denomina <b>reutilizacion de caja negra</b>, porque los detalles internos de los objetos no son visibles. Los objetos aparecen solo como <q>cajas negras</q>.</p>
<p>Tanto la herencia como la composicion tienen sus ventajas e inconvenientes. La herencia de clases se define estaticamente en tiempo de compilacion y es sencilla de usar, al estar permitida directamente por el lenguaje de programacion. La herencia de clases tambien hace que sea mas facil modificar la implementacion que esta siendo reutilizada. Cuando una subclase redefine alguna de las operaciones, puede afectar tambien a las operaciones de las que hereda, suponiendo que estas llamen a alguna de las operaciones redefinidas.</p>
<p>Pero la herencia de clases tambien tiene inconvenientes. En primer lugar, no se pueden cambiar las implementaciones heredadas de las clases padre en tiempo de ejecucion, porque la herencia se define en tiempo de compilacion. En segundo lugar, y lo que generalmente es peor, las clases padre suelen definir al menos parte de la representacion fisica de sus subclases. Como la herencia expone a una subclase los detalles de la imprementacion de su padre, suele decirse que <q>la herencia rompe la encapsulacion</q> [<a href="#sny86" >Sny86</a>]. La implementacion de una subclase se liga de tal forma a la implementacion de su clase padre que cualquier cambio en la implementacion del padre obligara a cambiar la subclase.</p>
<p>Las dependencias de implementacion pueden causar problemas al tratar de reutilizar una subclase. Cuando cualquier aspecto de la implementacion heredada no sea apropiado para nuevos dominios de problemas, la clase padre debera ser escrita de nuevo o reemplazada por otra mas adecuada. Esta dependencia limita la flexibilidad y la reutilizacion. Una solucion a esto es heredar solo de clases abstractas, ya que estas normalmente tiene poca o ninguna implementacion.</p>
<p>La composicion de objetos se define dinamicamente en tiempo de ejecucion a traves de objetos que tienen referencias a otros objetos. La composicion requiere que los objetos tengan en cuenta las interfaces de los otros, lo que a su vez requiere interfaces cuidadosamente diseñadas que no impidan que un objeto sea utilizado por otros. Pero hay una ventaja en esto: puesto que a los objetos se accede solo a traves de sus interfaces no se rompe su encapsulacion. Cualquier objeto puede ser reemplazado en tiempo de ejecucion por otro simpre que sean del mismo tipo. Ademas, como la implementacion de un objetos se escribira en terminos de interfaces de objetos, las dependencias de implementacion son notablemente menores.</p>
<p>La composicion de objetos produce otro efecto en el diseño del sistema. Optar por lo composicion de objetos frente a la herencia de clases ayuda a mantener cada clase encapsulada y centrada en una sola tarea. De esta manera, nuestras clases y jerarquias de clases permaneceran pequeñas y sera menos problable que se coviertan en monstruos inmanejables. Por otro lado, un diseño basado en la composicion de objetos tendra mas objetos (al tener menos clases), y el comportamiento del sistema dependera de sus relaciones en vez de estar definido en una clase.</p>
<p>Esto nos lleva a nuestro segundo principio del diseño orientado a objetos:</p>
<blockquote>
<p>Favorecer la composicion de objetos frente a la herencia de clases.</p>
</blockquote>
<p>Idealmente, solo creariamos nuevos componentes para lograr la reutilizacion. Deberiamos ser capaces de conseguir toda la funcionalidad que necesitasemos simplemente ensamblando componentes existentes a traves de la composicion de objetos. Sin embargo, rara vez es este el caso, puesto que el conjunto de componentes disponibles nunca es, en la practica, lo suficientemente rico. Reutilizar mediante la herencia hace mas facil construir nuevos componentes que puedan ser combinados con los antiguos. La herencia y la composicion trabajan por lo tanto juntas.</p>
<p>No obstante, nuestra experiencia es que los diseñadores abusan de la herencia como tecnica de reutilizacion, y que los diseños suelen ser mas reutilizabes (y mas simples) si dependen mas de la composicion de objetos. En los patrones de diseño se vera la composicion de objetos aplicada una y otra vez.</p>
</div>
<h5 id="delegacion" >Delegacion</h5>
<div class="hBody-5" >
<p>La <b>delegacion</b> es un modo de lograr que la composicion sea tan potente para la reutilizacion como lo es la herencia [<a href="#lie86" >Lie86</a>, <a href="#jz91" >JZ91</a>]. Con la delegacion, <em>dos</em> son los objetos encargados de tratar una peticion: un objeto receptor delega operaciones en su <b>delegado</b>. Esto es parecido a la forma en que las subclases envian peticiones a las clases padres. Pero, con la herencia, una operacion heredada siempre se puede referir al propio objeto a traves de las variables miembro <code>this</code> de C++ o <code>self</code> de Smalltalk. Para lograr el mismo efecto con la delegacion, el receptor se pasa a si mismo al delegado, para que la operacion delegada pueda referirse a el.</p>
<p>Por ejemplo, en vez de hacer que la clase <code>Ventana</code> sea una subclase de <code>Rectangulo</code> (porque resulta que las ventanas son rectangulares), la clase <code>Ventana</code> puede reutilizar el comportamiento de <code>Rectangulo</code> guardando una instancia de esta en una variable y delegando en ella el comportamiento especifico de los rectangulos. En otras palabras, en vez de hacer que una <code>Ventana</code> sea un <code>Rectangulo</code>, la <code>Ventana</code> contendra un <code>Rectangulo</code>. Ahora <code>Ventana</code> debe reenviar las peticiones a su instancia de <code>Rectangulo</code> explicitamente, mientras que antes habria heredado esas operaciones.</p>
<p>El siguiente diagrama muestra la clase <code>Ventana</code> delegando su operacion <code>Area</code> a una instancia de <code>Rectangulo</code>.</p>
<figure>
<img src="img/007.png" />
</figure>
<p>Una flecha lisa indica que una clase tiene una referencia a una instancia de otra clase. La referencia tiene un nombre opcional, en este caso <q>rectangulo</q>.</p>
<p>La principal ventaja de la delegacion es que hace que sea facil combinar comportamientos en tiempo de ejecucion y cambiar la manera en que estos se combinan. Nuestra ventana puede hacerse circular en tiempo de ejecucion simplemente cambiando su instancia <code>Rectangulo</code> por una instancia de <code>Circulo</code>, suponiendo que <code>Rectangulo</code> y <code>Circulo</code> tengan el mismo tipo.</p>
<p>La delegacion tiene un inconveniente comun a otras tecnicas que hacen al software mas flexible mediante la composicion de objetos: el software dinamico y altamente parametrizado es mas dificil de entender que el estatico. Hay tambien ineficiencias en tiempo de ejecucion, aunque las ineficiencias humanas son mas importantes a largo plazo. La delegacion es una buena eleccion en diseño solo cuando simplifica mas de lo que complica. No es facil dar reglas que digan exactamente cuando hay que usar delegacion, porque su efectividad dependera del contexto y de lo acostumbrados que estemos a ella. La delegacion funciona mejor cuando se usa de manera muy estilizada, es decir, en patrones estandar.</p>
<p>Varios patrones de diseño usan la delegacion. Los patrones <a href="#state" >State</a>, <a href="#strategy" >Strategy</a> y <a href="#visitor" >Visitor</a> se basan en ella. En el patron State, un objeto delega peticiones en un objeto <code>Estado</code> que representa su estado actual. En el patron Strategy, un objeto delega una peticion en un objeto que representa una estrategia para llevarla a cabo. Un objeto solo tendra un estado, pero puede tener muchas estrategias para diferentes peticiones. El proposito de ambos patrones es cambiar el comportamiento de un objeto cambiando los objetos en los que este delega. En el patron Visitor, la operacion que se realiza sobre cada elemento de una estructura de objetos simpre se delega en el objeto <code>Visitante</code>.</p>
<p>Otros patrones usan la delegacion de manera menos notoria. El patron <a href="#mediator" >Mediator</a> introduce un objeto que hace de mediador en la comunicacion entre objetos. A veces, el objeto <code>Mediador</code> implementa operaciones simplemente redirigiendolas a otros objetos; otras veces pasa una referencia a si mismo, usando asi verdadera delegacion. El patron <a href="#chain-of-responsibility" >Chain of Responsibility</a> procesa peticiones reenviandolas de un objeto a otro a traves de una cadena. A veces la peticion lleva consigo una referencia al objeto que recibio originalmente la peticion, en cuyo caso el patron esta usando delegacion. El patron <a href="#bridge" >Bridge</a> desacopla una abstraccion de su implementacion. En el caso de que la abstraccion y una implementacion concreta esten muy relacionadas, la abstraccion puede simplemente delegar operaciones en dicha implementacion.</p>
<p>La delegacion es un ejemplo extremo de composicion de objetos. Muestra como simpre se puede substituir la herencia por la composicion de objetos como mecanismo de reutilizacion de codigo.</p>
</div>
<h5 id="herencia-frente-a-tipos-parametrizados" >Herencia frente a Tipos Parametrizados</h5>
<div class="hBody-5" >
<p>Otra tecnica (no estrictamente orientada a objetos) para reutilizar funcionalidad es a traves de los <b>tipos parametrizados</b>, tambien conocidos como <b>genericos</b> (Ada, Eiffel) y <b>plantillas</b><span class="note" ><sup><a href="#3" >3</a></sup></span> (C++). Esta tecnica permite definir un tipo sin especificar todos los otros tipos que usa. Los tipos sin especificar se proporcionan como <em>parametros</em> cuando se va a usar el tipo paramentrizado). Por ejemplo, una clase <code>Lista</code> puede estar parametrizada por el tipo de los elementos que contiene. Para declarar una lista de enteros, proporcionamos el tipo <q>integer</q> como parametro del tipo parametrizado <code>Lista</code>.</p>
<p>Para declarar una lista de objetos <code>String</code>, proporcionamos el tipo <q>String</q> como parametro. El lenguaje de implementacion creara una version particularizada de la plantilla de la clase <code>Lista</code> para cada tipo de elemento.</p>
<p>Los tipos parametrizados nos dan una tercera forma (ademas de la herencia de clase y la composicion de objetos) de combinar comportamientos en sistemas orientados a objetos. Muchos diseños se pueden implementar usando alguna de estas tres tecnicas. Para paramentrizar una rutina de ordenacion segun el tipo de operacion que usa para comparar elementos, podriamos hacer que la comparacion fuese</p>
<ol class="num" >
<li>
<p>una operacion implementada por las subclases (una aplicacion del patron <a href="#template-method" >Template Method</a>).</p>
</li>
<li>
<p>responsabilidad de un objeto pasado a la rutina de ordenacion (<a href="#strategy" >Strategy</a>), o</p>
</li>
<li>
<p>un argumento de una plantilla C++ o de un generico de Ada que especifica el nombre de la funcion a llamar para comparar los elementos.</p>
</li>
</ol>
<p>Hay diferencias importantes entre estas tecnicas. La composicion de objetos nos permite cambiar el comportamiento en tiempo de ejecucion, pero tambien requiere indireccion y puede ser menos eficiente. La herencia nos deja proporcionar implementaciones de operaciones predeterminadas y que las subclases las redefinan. Los tipos parametrizados permiten cambiar los tipos que puede utilizar una clase. Que enfoque es mejor depende de nuestras restricciones de diseño e implementacion.</p>
<p>Ninguno de los patrones de este libro trata de tipos paramentrizados, auque los usamos en ocaciones para personalizar la implementacion C++ de algun patron. Los tipos parametrizados no son necesarios en lenguajes como Smalltalk, que no tienen comprobacion de tipos en tiempo de compilacion.</p>
</div>
<h4 id="estructuras-que-relacionan-tiempo-de-ejecucion-y-tiempo-de-compilacion" >Estructuras que relacionan tiempo de ejecucion y tiempo de compilacion</h4>
<div class="hBody-4" >
<p>La estructura en tiempo de ejecucion de un programa orientado a objetos suele guardar poco parecido con la estructura de su codigo. La estructura del codigo se fija en tiempo de compilacion, y consiste en clases con relaciones de herencia estaticas. La estructura de tiempo de ejecucion de un programa consiste en redes cambiantes de objetos que se comunican entre si. De hecho, ambas estructuras son en gran medida independientes. Tratar de entender una a partir de la otra es como tratar de entender el dinamismo de los ecosistemas vivos a partir de la taxonomia estatica de plantas y animales, y viceversa.</p>
<p>Consideremos la distincion entre <b>agregacion</b> y <b>asociacion</b><span class="note" ><sup><a href="#4" >4</a></sup></span> de objetos, y como se manifiestan esas diferencias en tiempo de ejecucion y en tiempo de compilacion. La agregacion implica que un objeto posee a otro o que es responsable de el. Normalmente decimos que un objeto <em>tiene</em> a otro o que un objeto <em>es parte</em> de otro. La agregacion implica que el objeto agregado y su propietario tienen la misma vida.</p>
<p>La asociacion implica que un objeto simplemente <em>conoce</em> a otro. A veces, a la asociacion tambien se le denomina relacion de <q>uso</q>. Los objetos asi relacionados pueden pedirse operaciones entre si, pero no son responsables unos de otros. Es una relacion mas debil que la agregacion y representa mucho menor acoplamiento entre objetos.</p>
<p>En nuestros diagramas, una flecha con la linea continua denota asociacion, mientras que una flecha con un rombo en su base denota agregacion:</p>
<figure>
<img src="img/008.png" />
</figure>
<p>Es facil confundir agregacion y asociacion, ya que muchas veces se implementan de la misma forma. En Smalltalk, todas las variables son referencias a otros objetos, no hay distincion en el lenguaje de programacion entre agregacion y asociacion. En C++, la agregacion se puede implementar definiendo variables miembro que sean verdaderas instancias, pero es mas frecuente definirlas como puntero o referencias a instancias. La asociacion se implementa tambien con punteros y referencias.</p>
<p>En ultima instancia, la asociacion y la agregacion quedan determinadas mas por su intencion que por mecanismos explicitos del lenguaje. La distincion puede ser dificil de ver en la estructura de tiempo de compilacion, pero es notable. Las relaciones de agregacion tienden a ser menos y mas permanentes que las de asociacion. Las asociaciones, por el contrario, se hacen y deshacen mucho mas frecuentemente, y algunas veces solo existen mientras dura una operacion. Tambien son mas dinamicas, haciendolas mas dificiles de distinguir en el codigo fuente.</p>
<p>Con esa disparidad entre las estructuras de tiempo de ejecucion y compilacion de un programa, es evidente que el codigo no lo revelara todo acerca de como funciona un sistema. La estructura de tiempo de ejecucion de un sistema debe ser impuesta mas por el diseñador que por el lenguaje. Las relaciones entre objetos y sus tipos deben ser diseñadas con mucho cuiadado, por que van a determinar la calidad de la estructura de tiempo de ejecucion.</p>
<p>Muchos patrones de diseño (en concreto aquellos que tienen ambito de objeto) representan explicitamente la distincion entre ambas estructuras. El patron <a href="#composite" >Composite</a> y el <a href="#decorator" >Decorator</a> son especialmente utiles para construir estructuras de tiempo de ejecucion complejas. El <a href="#observer" >Observer</a> involucra estructuras de tiempo de ejecucion que suelen ser dificiles de entender si no se conoce el patron. El patron <a href="#chain-of-responsibility" >Chain of Responsibility</a> tambien produce patrones de comunicacion que la herencia no pone de manifiesto. En general, las estructuras de tiempo de ejecucion no estan claras en el codigo hasta que se comprenden los patrones.</p>
</div>
<h4 id="diseñar-para-el-cambio" >Diseñar para el cambio</h4>
<div class="hBody-4" >
<p>La clave para maximizar la reutilizacion reside en anticipar nuevos requisitos y cambios en los requisitos existentes, y en rediseñar los sistemas de manera que puedan evolucionar en consecuencia.</p>
<p>Para diseñar un sistema que sea robusto a dichos cambios hay que tener en cuenta como puede necesitar cambiar el sistema a lo largo de su vida. Un diseño que no tenga en cuenta el cambio sufre el riesgo de tener que ser rediseñado por completo en el futuro. Dichos cambios pueden involucrar redeficiones y reimplementaciones de clases, modificar los clientes y voler a hacer pruebas. El rediseño afecta a muchas partes del sistema software, por lo que los cambios no previstos siempre resultan costosos.</p>
<p>Los patrones de diseño ayudan a evitar esto al asegurar que un sistema pueda cambiar de formas concretas. Cada patron de diseño deja que algun aspecto de la estructura del sistema varie independientemente de los otros, haciendo asi al sistema mas robusto frente a un tipo de cambio concreto.</p>
<p>A continuacion se presentan algunas de las causas comunes de rediseño junto con los patrones de diseño que lo resuelven:</p>
<ol class="num" >
<li>
<p><em>Crear un objeto especificando su clase explicitamente.</em> Especificar un nombre de clase al crear un objeto nos liga a una implementacion en vez de a una interfaz. Esto puede complicar los cambios futuros. Para evitarlo, debemos crear los objetos indirectamente.</p>
<p>Patrones de diseño; <a href="#abstract-factory" >Abstract Factory</a>, <a href="#factory-method" >Factory Method</a>, <a href="#prototype" >Prototype</a>.</p>
</li>
<li>
<p><em>Dependencia de operaciones concretas.</em> Cuando especificamos una determinada operacion, estamos ligandonos a una forma de satisfacer una peticion. Evitando ligar las peticiones al codigo, hacemos mas facil cambiar el modo de satisfacer una peticion, tanto en tiempo de compilacion como en tiempo de ejecucion.</p>
<p>Patrones de diseño: <a href="#chain-of-responsibility" >Chain of Responsibility</a>, <a href="#command" >Command</a>.</p>
</li>
<li>
<p><em>Dependencia de plataformas hardware o software.</em> Las interfaces externas de los sistemas operativos y las interfaces de programacion de aplicaciones (API) varian para las diferentes plataformas hardware y software. El software que depende de una plataforma concreta sera mas dificil de portar a otras plataformas. Incluso puede resultar dificil mantenerlo actualizado en su plataforma nativa. Pon tanto, es importante diseñar nuestros sistemas de manera que limiten sus dependencias de plataforma.</p>
<p>Patrones de diseño: <a href="#abstract-factory" >Abstract Factory</a>, <a href="#bridge" >Bridge</a>.</p>
</li>
<li>
<p><em>Dependencia de las implementaciones o implementaciones de objetos.</em> Los clientes de un objeto que saben como se representa, se almacena, se localiza o se implementa, quiza deban ser modificados cuando cambie dicho objeto. Ocultar esta informacion a los clientes previene los cambios en cascada.</p>
<p>Patrones de diseño: <a href="#abstract-factory" >Abstract Factory</a>, <a href="#bridge" >Bridge</a>, <a href="#memento" >Memento</a>, <a href="#proxy" >Proxy</a>.</p>
</li>
<li>
<p><em>Dependecias algoritmicas.</em> Muchas veces los algoritmos se amplian, optimizan o sustituyen por otros durante el desarrollo y posterior reutilizacion. Los objetos que dependen de un algoritmo tendran que cambiar cuando este cambie. Por tanto, aquellos algoritmos que es probable que cambien deberian estar aislados.</p>
<p>Patrones de diseño: <a href="#builder" >Builder</a>, <a href="#iterator" >Iterator</a>, <a href="#strategy" >Strategy</a>, <a href="#template-method" >Template Method</a>, <a href="#visitor" >Visitor</a>.</p>
</li>
<li>
<p><em>Fuerte acoplamiento.</em> Las clases que estan fuertemente acopladas son dificiles de reutilizar por separado, puesto que dependen unas de otras. El fuerte acoplamiento lleva a sistemas monoliticos, en los que no se puede cambiar o quitar una clase sin entender y cambiar muchas otras. El sistema se convierte asi en algo muy denso que resulta dificil de aprender, portar y mantener.</p>
<p>El bajo acoplamiento aumenta lo probabilidad de que una clase pueda ser reutilizada ella sola y que un sistema pueda aprenderse, portarse, modificarse y extenderse mas facilmente.</p>
<p>Los patrones de diseño hacen uso de tecnicas como el acoplamiento abstracto y la estructuracion de capas para promover sistemas escasamente acoplados.</p>
<p>Patrones de diseño: <a href="#abstract-factory" >Abstract Factory</a>, <a href="#bridge" >Bridge</a>, <a href="#chain-of-responsibility" >Chain of Responsibility</a>, <a href="#command" >Command</a>, <a href="#facade" >Facade</a>, <a href="#mediator" >Mediator</a>, <a href="#observer" >Observer</a>.</p>
</li>
<li>
<p><em>Añadir funcionalidad mediente la herencia.</em> Particularizar un objeto derivando de otra clase no suele ser facil. Cada nueva clase tiene un coste de implementacion (inicializacion, finalizacion, etc). Definir una subclase tambien requiere un profundo conocimiento de la clase padre. Por ejemplo, redefinir una operacion puede requerir redefinir otra, o tener que llamar a una operacion heredada. Ademas, la herencia puede conducir a una explosion de clases, ya que una simple extension puede obligar a introducir un monton de clases nuevas.</p>
<p>La composicion de objetos en general y la delegacion en particular proporcionan alternativas flexibles a la herencia para combinar comportamiento. Se puede añadir nueva funcionalidad a una aplicacion componiendo los objetos existentes de otra forma en vez de definir subclases nuevas de otras clases existentes. No abstante, tambien es cierto que un uso intensivo de la composicion de objetos puede hacer que los diseños sean mas dificiles de entender. Muchos patrones de diseño producen diseños en los que se puede introducir nueva funcionalidad simplemente definiendo una subclase y componiendo sus instancias con otras existentes.</p>
<p>Patrones de diseño: <a href="#bridge" >Bridge</a>, <a href="#chain-of-responsibility" >Chain of Responsibility</a>, <a href="#compose" >Compose</a>, <a href="#decorator" >Decorator</a>, <a href="#observer" >Observer</a>, <a href="#strategy" >Strategy</a>.</p>
</li>
<li>
<p><em>Incapacidad para modificar las clase convetientemente.</em> A veces hay que modificar una clase que no puede ser modificada convenientemente. Quiza necesitemos el codigo fuente y no lo tengamos (como puede ser el caso de una biblioteca de clases comercial). O tal vez cualquier cambio requiera modificar muchas de las subclases existentes. Los patrones de diseño ofrecen formas de modificar las clases en tales circunstancias.</p>
<p>Patrones de diseño: <a href="#adapter" >Adapter</a>, <a href="#decorator" >Decorator</a>, <a href="#visitor" >Visitor</a>.</p>
</li>
</ol>
<p>Estos ejemplos reflejan la flexibilidad que los patrones de diseño pueden ayudarnos a conseguir en nuestro software. Como sea esta flexibilidad de crucial depende del tipo de software que estemos desarrollando. Echemos un vistaso al papel que desempeñan los patrones de dediseño en el desarrollo de tres amplias clases de software: programas de aplicacion, <em>toolkits</em> y <em>frameworks</em>.</p>
</div>
<h5 id="programas-de-aplicacion" >Programas de aplicacion</h5>
<div class="hBody-5" >
<p>Si estamos construyendo un programa de aplicacion, como un editor de documentos o una hoja de calculo, la reutilizacion interna, la facilidad de mantenimiento y la extension son las principales prioridades. La reutilizacion interna hace que no haya que diseñar e implementar mas de lo estrictamente necesario. Los patrones de diseño que reducen dependencias pueden aumentar la reutilizacion interna. Un acoplamiento mas bajo aumenta la probabilidad de que una clase de objeto pueda cooperar con otras. Por ejemplo, cuando eliminamos las dependencias de operaciones especificas aislando y encapsulando cada operacion, estamos haciendo que sea mas facil reutilizar una operacion en diferentes contextos. Lo mismo ocurre cuando eliminamos dependencias algoritmicas y de representacion.</p>
<p>Los patrones de diseño tambien hacen que una aplicacion sea mas facil de mantener cuando se usan para limitar las dependencias de plataforma y para organizar un sistema en capas. Mejoran la extensibilidad al ilustrar como extender jerarquias de clases y como explotar la composicion de objetos. Reducir el acoplamiento tambien mejora la extensibilidad. Extender una clase aislada es mas facil si esta no depende de otras muchas clases.</p>
</div>
<h5 id="toolkits5" >Toolkits<span class="note" ><sup><a href="#5" >5</a></sup></span></h5>
<div class="hBody-5" >
<p>Muchas veces una aplicacion incorpora clases de una o mas biblitecas de clases predefinidas llamadas <em>toolkits</em>. Un toolkit es un conjunto de clases relacionadas y reutilizables diseñadas para proporcionar funcionalidad util de proposito general. Un ejemplo de toolkit es un conjunto de clases para tratar con listas, tablas asociativas, pilas y similares. La biblioteca de flujos de entrada/salida de C++ es otro ejemplo. Los toolkits no imponen un diseño particular en una aplicacion; simplemente proporcionan funcionalidad que puede ayudar a que la aplicacion haga su trabajo. Nos permiten, como desarrolladores, evitar recodificar funcionalidad comun. Los toolkits se centran en la <em>reutilizacion de codigo</em>, siendo el equivalente orientado a objetos de las bibliotecas de subrutinas.</p>
<p>Diseñar toolkits es posiblemente mas dificil que diseñar una aplicacion, ya que aquellos tienen que funcionar en muchas aplicaciones para ser utiles. Ademas, el creador del toolkit no puede saber cuales van a ser esas aplicaciones o cuales seran sus necesidades especiales. Eso hace que lo mas importante sea evitar suposiciones y dependencias que puedan limitar la flexibilidad del tookit y consecuentemente su aplicabilidad y efectividad.</p>
</div>
<h5 id="frameworks6" >Frameworks<span class="note" ><sup><a href="#6" >6</a></sup></span></h5>
<div class="hBody-5" >
<p>Un <em>framework</em> es un conjunto de clases cooperantes que constituyen un diseño reutilizable para una clase especifica de software [<a href="#deu89" >Deu89</a>, <a href="#jf88" >JF88</a>]. Por ejemplo, un framework puede estar orientado a la construccion de editores graficos para dominios diferentes, como el dibujo artistico, la composicion musical y el CAD [<a href="#vl90" >VL90</a>, <a href="#joh92" >Joh92</a>]. Otro puede ayudar a construir compiladores para diferentes lenguajes de programacion y maquinas de destino [<a href="#jml92" >JML92</a>]. Otro podria ayudar a construir aplicaciones de modelado financiero [<a href="#be93" >BE93</a>]. Personalizamos un framework para una aplicacion concreta creando subclases especificas de la aplicacion de clases abstractas del framework.</p>
<p>El framework determina la arquitectura de nuestra aplicacion. Definira la estructura general, su particion de clases y objetos, las reponsabilidades clave, como colaboran las clases y objetos y el hilo de control. Un framework predefine estos parametros de diseño de manera que el diseñador o el programador de la aplicacion puedan concentrarse en las particularidades de dicha aplicacion. El Framework representa las decisiones de diseño que son comunes a su dominio de aplicacion. Los frameworks hacen incapie asi en la reutilizacion de diseño frente a la reutilizacion de codigo, si bien un framework incluira normalmente subclases concretas listas para trabajar con ellas inmediatamente.</p>
<p>La reutilizacion a este nivel lleva a una inversion de control entre la aplicacion y el software en el que se basa. Cuando utilizamos un toolkit (o una biblioteca de subrutinas tradicional) escribimos el cuerpo principal de la aplicacion y llamamos al codigo que queremos reutilizar. Cuando usamos un framework podemos reutilizar el cuerpo principal y escribir el codigo al que llama. Habra que escribir operaciones con nombres especificos y convenios de llamada, pero eso reduce las decisiones de diseño que hay que tomar.</p>
<p>Como resultado, no solo se pueden construir aplicaciones mas rapidamente, sino que las aplicaciones tienen estructuras parecidas, por lque son mas facil de mantener y resultan mas consistentes para los usuarios. Por otro lado, perdemos algo de libertad creativa, puesto que muchas decisiones de diseño ya han sido tomadas por nosotros.</p>
<p>Si las aplicaciones son dificiles de diseñar, y los toolkits mas dificiles todavia, los frameworks son los mas dificiles de todos. Un diseñador de frameworks supone que una misma arquitectura servira para todas las aplicaciones de ese dominio. Cualquier cambio sustantivo en el diseño del framework reducira considerablemente sus beneficios, puesto que su principal contribucion a una aplicacion es la arquitectura que define. Por tanto, es necesario diseñar el framework para que sea tan flexible y extensible como sea posible.</p>
<p>Ademas, como las aplicaciones dependen tanto del framework, son particularmente sensibles a los cambios en las interfaces de este. A medida que un framework evoluciona, las aplicaciones tienen que evolucionar con el. Esto hace que un bajo acoplamiento sea lo mas importante de todo; si no, hasta el mas minimo cambio del framework tendra importantes repercusiones.</p>
<p>Los problemas de diseño que acabamos de estudiar son fundamentales en el diseño del framework. Un framework que los resuelva usando patrones de diseño es mucho mas probable que consiga alto grado de reutilizacion del diseño y del codigo que otro que no lo haga. Los frameworks maduros normalmente incorporan varios patrones de diseño. Los patrones ayudan a hacer que la arquitectura del framework sirva para muchas aplicaciones diferentes sin necesidad de rediseño.</p>
<p>Una ventaja añadida se produce cuando el framework se documenta con los patrones de diseño que usa [<a href="#bj94" >BJ94</a>]. Quien conoce los patrones aprende como esta hecho el framework mucho mas rapidamente. Incluso quienes no conocen los patrones se pueden beneficiar de la estructura que estos confieren a la documentacion del framework. Mejorar la documentacion es importante para cualquier tipo de software, pero es particularmente importante en el caso de los frameworks, ya que suelen tener una curva de aprendizaje que es necesario superar para que comiencen a ser utiles. Si bien los patrones de diseño puede que no allanen del todo dicha curva de aprendizaje, si la pueden hacer menos pediente al hacer explicitos los elementos clave del diseño del framework.</p>
<p>Como los patrones y los frameworks tienen similitudes, mucha gente se pregunta en que se diferencian, si es que se diferencian en algo. Son diferentes en tres aspectos fundamentales:</p>
<ol class="num" >
<li>
<p><em>Los patrones de diseño son mas abstractos que los frameworks.</em> Los frameworks pueden plasmarse en codigo, pero solo los ejemplos de los patrones pueden ser plasmados en codigo. Uno de los puntos fuertes de los frameworks es que se pueden escribir en los lenguajes de programacion y de ese modo ser no solo estudiados, sino ejecutados y reutilizados directamente. Por el contrario, los patrones de diseño de este libro tienen que ser implementados cada vez que se emplean. Los patrones de diseño tambien reflejan la intencion, las ventajas e inconvenientes y las consecuencias de un diseño.</p>
</li>
<li>
<p><em>Los patrones de diseño son elementos arquitectonicos mas pequeños que los frameworks.</em> Un framework tipico contiene varios patrones de diseño, pero lo contrario nunca es ciento.</p>
</li>
<li>
<p><em>Los patrones de diseño estan menos especializados que los frameworks.</em> Los frameworks siempre tienen un dominio de aplicaciones concreto. Un editor grafico se puede usar en una simulacion de una fabrica, pero nadie lo tomara por un framework de simulacion. Sin embargo, los patrones de diseño de este catalogo se pueden usar en practicamente cualquier tipo de aplicacion. Aunque es posible tener patrones de diseño mas especializados que los nuestros (como, por ejemplo, patrones de diseño para programacion concurrente), incluso estos no imponen una arquitectura de aplicacion como haria un framework.</p>
</li>
</ol>
<p>Los frameworks se estan convirtiendo en algo cada vez mas comun e importante. Son el modo en que los sistemas orientados a objetos consiguen la mayor reutilizacion. Las aplicaciones orientadas a objetos mas grandes terminaran consistiendo en capas de framework que cooperan unos con otros. La mayoria del diseño y del codigo de una aplicacion vendra dado o estara influido por los frameworks que utilice.</p>
</div>
<h3 id="1.7" >Como seleccionar un patron de diseño</h3>
<div class="hBody-3" >
<p>Con mas de 20 patrones de diseño para elegir en el catalogo, puede ser dificil encontrar aquel que resuelva un problema de diseño concreto, especialmente si el catalogo es nuevo y desconocido para el lector. A continuacion se muestran diferentes enfoques para encontrar el patron de diseño que se adecue a su problema:</p>
<ul>
<li>
<p><em>Considere como los patrones de diseño solucionan problemas de diseño.</em> En la <a href="#1.6" >Seccion 1.6</a> se vio como los patrones de diseño ayudan a encontrar los objetos apropiados, a determinar la granularidad, a especificar interfaces de objetos y otros aspectos en los que los patrones ayudan a resolver problemas de diseño. Consultar estas discuciones puede ayudarle a guiar su busqueda del patron adecuado.</p>
</li>
<li>
<p><em>Hojee las secciones Proposito.</em> La  <a href="#1.4" >Seccion 1.4</a> enumera las secciones <em>Proposito</em> de todos los patrones del catalogo. Lea el proposito de cada patron para encontrar uno o varios que parezcan relevantes para su problema. Puede usar el esquema de clasificacion de la <a href="#tabla-1.1" >Tabla 1.1</a> para guiar su busqueda.</p>
</li>
<li>
<p><em>Estudie como se interrelacionan los patrones.</em> La <a href="#figura-1.1" >Figura 1.1</a> muestra graficamente las relaciones entre los patrones de diseño. Estudiar dichas relaciones puede ayudarle a dirigirse al patron o grupo de patrones de diseño. Estudiar dichas relaciones puede ayudarle a dirigirse al patron o grupo de patrones apropiado.</p>
</li>
<li>
<p><em>Estudie patrones de proposito similar.</em> El <a href="#Catalogo-de-Patrones-de-Diseño" >Catalogo</a> tiene tres capitulos: uno para patrones de creacion, otro para los patrones estructurales y un tercero para patrones de comportamiento. Cada capitulo comienza con unos comentarios de introduccion sobre los patrones y termina con una seccion que los compara y contrasta. Estas secciones le ayudan a comprender las similitudes y diferencias entre patrones de proposito similar.</p>
</li>
<li>
<p><em>Examine una causa de rediseño.</em> Observe las causas de rediseño que comienzan en la seccion <a href="#diseñar-para-el-cambio" >Diseñar para el cambio</a> para ver si su problema involucra a una o varias de ellas. Una vez hecho eso, vea los patrones que ayudan a evitar las causas de rediseño.</p>
</li>
<li>
<p><em>Piense que deberia ser variable en su diseño.</em> Este enfoque es el opuesto a centrarse en las causas de rediseño. En vez de tener en cuenta que podria forzar un cambio en el diseño, piense en que quiere que <em>pueda</em> ser cambiado sin necesidad de rediseñar. Se trata de centrarse en encapsular el concepto que puede variar, un tema comun a muchos patrones de diseño. la Tabla 1.2 enumera los aspectos de diseño que los patrones permiten variar de forma independiente, es decir, sin rediseño.</p>
</li>
</ul>
<div class="figure" >
<h1 class="figure"><span id="tabla-1.2" >Tabla 1.2</span>: Aspectos de diseño que los patrones de diseño permiten modificar</h1>
<table border="1">
<thead>
<tr><th><p>Proposito</p>
</th><th><p>Patrones de diseño</p>
</th><th><p>Aspectos que pueden variar</p>
</th></tr>
</thead>
<tbody>
<tr><td rowspan="5"><p>De Creacion</p>
</td><td><p><a href="#abstract-factory" >Abstract Factory</a></p>
</td><td><p>la familia de los objetos producidos</p>
</td></tr>
<tr><td><p><a href="#builder" >Builder</a></p>
</td><td><p>como se crea un objeto compuesto</p>
</td></tr>
<tr><td><p><a href="#factory-method" >Factory Method</a></p>
</td><td><p>la subclase del objeto que es instanciado</p>
</td></tr>
<tr><td><p><a href="#prototype" >Prototype</a></p>
</td><td><p>la clase del objeto que es instaciado</p>
</td></tr>
<tr><td><p><a href="#singleton" >Singleton</a></p>
</td><td><p>la unica instancia de una clase</p>
</td></tr>
<tr><td rowspan="7"><p>Estructurales</p>
</td><td><p><a href="#adapter" >Adapter</a></p>
</td><td><p>la interfaz de un objeto</p>
</td></tr>
<tr><td><p><a href="#bridge" >Bridge</a></p>
</td><td><p>la implementacion de un objeto</p>
</td></tr>
<tr><td><p><a href="#composite" >Composite</a></p>
</td><td><p>la estructura y composicion de un objeto</p>
</td></tr>
<tr><td><p><a href="#decorator" >Decorator</a></p>
</td><td><p>las responsabilidades de un objeto sin usar la herencia</p>
</td></tr>
<tr><td><p><a href="#facade" >Facade</a></p>
</td><td><p>la interfaz de un subsistema</p>
</td></tr>
<tr><td><p><a href="#flyweight" >Flyweight</a></p>
</td><td><p>el coste de almacenamiento de los objetos</p>
</td></tr>
<tr><td><p><a href="#proxy" >Proxy</a></p>
</td><td><p>como se accede a un objeto; su ubicacion</p>
</td></tr>
<tr><td rowspan="11"><p>De comportamiento</p>
</td><td><p><a href="#chain-of-responsibility" >Chain of Responsibility</a></p>
</td><td><p>el objeto que puede satisfacer una peticion</p>
</td></tr>
<tr><td><p><a href="#command" >Command</a></p>
</td><td><p>cuando y como se satisface una peticion</p>
</td></tr>
<tr><td><p><a href="#interpreter" >Interpreter</a></p>
</td><td><p>la gramatica e interpretacion de un lenguaje</p>
</td></tr>
<tr><td><p><a href="#iterator" >Iterator</a></p>
</td><td><p>como se recorren los elementos de un agregado</p>
</td></tr>
<tr><td><p><a href="#mediator" >Mediator</a></p>
</td><td><p>que objetos interactuan entre si, y como</p>
</td></tr>
<tr><td><p><a href="#memento" >Memento</a></p>
</td><td><p>que informacion privada se almacena fuera de un objeto y cuando</p>
</td></tr>
<tr><td><p><a href="#observer" >Observer</a></p>
</td><td><p>el numero de objetos que dependen de otro; como se mantiene actualizado el objeto dependiente</p>
</td></tr>
<tr><td><p><a href="#state" >State</a></p>
</td><td><p>el estado de un objeto</p>
</td></tr>
<tr><td><p><a href="#strategy" >Strategy</a></p>
</td><td><p>un algoritmo</p>
</td></tr>
<tr><td><p><a href="#template-method" >Template Method</a></p>
</td><td><p>los pasos de un algoritmo</p>
</td></tr>
<tr><td><p><a href="#visitor" >Visitor</a></p>
</td><td><p>las operaciones que pueden aplicarse a objetos sin cambiar sus clases</p>
</td></tr>
</tbody>
</table>
</div>
</div>
<h3 id="1.8" >Como usar un patron de diseño</h3>
<div class="hBody-3" >
<p>Una vez que haya elegido un patron de diseño, ¿como usarlo? Lo que sigue a continuacion es un enfoque paso a paso para aplicar un patron de diseño de manera efectiva:</p>
<ol class="num" >
<li>
<p><em>Lea el patron de principio a fin para tener una perspectiva.</em> Preste patircular atencion a las secciones de Aplicabilidad y Consecuencias para asegurarse de que el patron es el adecuado para su problema.</p>
</li>
<li>
<p><em>Vuelva atras y estudie las secciones Estructura, Participantes y Colaboraciones.</em> Asegurese de entender las clase y objetos del ptaron y como se relacionan entre ellos.</p>
</li>
<li>
<p><em>Examine la seccion Codigo de Ejemplo para ver un ejemplo concreto del patron en codigo.</em> Estudiar el codigo ayuda a entender como implementar el patron.</p>
</li>
<li>
<p><em>Elija nombres significativos en el contexto de la aplicacion para los participantes en el patron.</em> Los nombres de los participantes de los patrones de diseño normalmente son demasiado abstractos como para aparecer directamente en una aplicacion. Sin embargo, es util incorporar el nombre del participante en el nombre que aparece en la aplicacion. Eso ayuda a hacer el patron mas explicito en la implementacion. Por ejemplo, si usa el patron Strategy para un algoritmo de composicion de texto, es posible que tenga las clases <code>EstrategiaComposicionSimple</code> o <em>EstrategiaComposicionTeX</em>.</p>
</li>
<li>
<p><em>Defina las clases</em>. Declare sus interfaces, establezca sus relaciones de herencia y defina las variables de instancia que representan datos y referencias de objetos. Identifique las clases existentes en su aplicacion a las que afectara el patron y modifiquelas en consecuencia.</p>
</li>
<li>
<p><em>Defina nombres especificos de la aplicacion para las operaciones del patron.</em> Los nombres generalmente dependen de la aplicacion. Use las responsabilididades y colaboraciones asociadas con cada operacion como una guia. Tambien debe ser coherente en sus convenciones de nombres. Por ejemplo, podria usar el prefijo <q><code>Crear-</code></q> de forma constante para denotar un metodo de fabricacion.</p>
</li>
<li>
<p><em>Implemente las operaciones para llevar a cabo las responsabilidades y colaboraciones del patron.</em> La seccion Implementacion ofrece pistas que le guiaran en la implementacion. Tambien pueden serle de ayuda los ejemplos de la seccion Codigo de Ejemplo.</p>
</li>
</ol>
<p>Estas son solo unas directrices generales que le pueden servir para empezar. A medida que pase el tiempo desarrollara su propio metodo para trabajar con patrones de diseño.</p>
<p>Ninguna discusion sobre como usar patrones de diseño estara completa sin unas pocas palabras sobre como <em>no</em> usarlos. Los patrones de diseño no deberian ser aplicados indiscriminadamente. Muchas veces estos consiguen la flexibilidad y la variabilidad a costa de introducir niveles adicionales de indireccion, y eso puede complicar un diseño o disminuir el rendimiento. Un patron solo deberia ser aplicado cuando la flexibilidad que proporcione sea realmente necesaria. Las secciones de Consecuencias son las mas valiosas a la hora de evaluar los beneficios y los costes de un patron.</p>
</div>
<h2 id="capitulo-2" >Un Caso de estudio: diseñando un editor de documentos</h2>
<div class="hBody-2" >
<p>Este capitulo presenta un caso de estudio consistente en el diseño de un editor de documentos <em>What-You-See-Is-What-You-Get</em><span class="note" ><sup><a href="#7" >7</a></sup></span> (o <q>WYSIWYG</q>) llamado <b>Lexi</b>.<span class="note" ><sup><a href="#8" >8</a></sup></span> Veremos como los patrones de diseño representan soluciones a problemas de diseño de Lexi y otras aplicaciones similares. Al final del capitulo habra experimentado con ocho patrones, aprendiendolos mediante ejemplos.</p>
<p>La Figura 2.1 muestra la interfaz de usuario de Lexi. Una representacion WYSIWYG del documento ocupa el area rectangular grande del centro. El documento puede combinar el texto y graficos con diferentes estilos de formateado. Alrededor del documento estan los tipicos menus desplegables y barras de desplazamiento, mas una serie de iconos de pagina que permiten ir a una determinada pagina del documento.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.1" >Figura 2.1</span>: La interfaz de usuario de Lexi</h1>
<figure>
<img src="img/009.png" />
</figure>
</div>
</div>
<h3 id="2.1" >Problemas de diseño</h3>
<div class="hBody-3" >
<p>A continuacon examinaremos siete problemas del diseño de Lexi:</p>
<ol class="num" >
<li>
<p><em>Estructura de los documentos.</em> La eleccion de la representacion interna del documento afecta a practicamente todos los aspectos del diseño de Lexi. Tanto la edicion como el formateado, visualizacion y analisis del texto necesitaran recorrer dicha representacion. La manera en que organicemos esta informacion influira, por tanto, en el resto de la aplicacion.</p>
</li>
<li>
<p><em>Formateado.</em> ¿Como coloca realmente lexi el texto y los graficos en lineas y columnas? ¿Que objetos son responsables de llevar a cabo las diferentes politicas de formateado? ¿Como interactuan estas con la representacion interna del documento?</p>
</li>
<li>
<p><em>Adornos de la interfaz de usuario.</em> La interfaz de usuario de Lexi incluye barras de desplazamiento, bordes y sombras que mejoran la apariencia del documento WYSIWYG. Es probable que dichos elementos graficos cambien a medida que evolucione la interfaz, de hay la importancia de poderlos añadir y quitar facilmente, sin que esto afecte al resto de la aplicacion.</p>
</li>
<li>
<p><em>Permitir multiples estandares de interfaz de usuario.</em><span class="note" ><sup><a href="#9" >9</a></sup></span> Lexi deberia poder adaptarse facilmente a diferentes estandares de interfaz de usuario, tales como Motif o Presentation Manager (PM), sin falta de grandes modificaciones.</p>
</li>
<li>
<p><em>Permitir multiples sistemas de ventanas.</em> Los distintos estandares de interfaz de usuario suelen estar implementados en sistemas de ventanas diferentes. El diseño de Lexi deberia ser tan independiente como fuera posible del sistema de ventanas.</p>
</li>
<li>
<p><em>Operaciones de usuario.</em> El usuario controla Lexi a traves de varios elementos de la interfaz, incluyendo botones y menus desplegables. La funcionalidad que hay tras estos elementos de la interfaz se encuentra repartida entre los objetos de la aplicacion. El objetivo es proporcionar un mecanismo uniforme tanto para acceder a esta funcionalidad dispersa como para deshacer sus efectos.</p>
</li>
<li>
<p><em>Comprobacion ortografica y separacion de palabras.</em> ¿Como permite Lexi operaciones de analisis tales como la comprobacion de palabras mal escritas o determinar los puntos donde debe insertarse un guion de separacion? ¿Como podemos minimizar el numero de clases que deben ser modificadas para añadir una nueva operacion de este tipo?</p>
</li>
</ol>
<p>Discutiremos estos problemas de diseño en las secciones siguientes. Cada problema tiene asociados una serie de objetivos, ademas de restricciones sobre como lograr dichos objetivos. Los objetivos y sus restricciones seran explicados en detalle antes de proponer una solucion concreta. El problema y su solucion ilustraran uno o mas patrones de diseño. La discusion de cada problema culminara con una breve introduccion a los patrones relevantes.</p>
</div>
<h3 id="2.2" >Estructura del documento</h3>
<div class="hBody-3" >
<p>Un documento al final no es mas que una disposicion de elementos graficos basicos, como caracteres, lineas, poligonos y otras formas. Estos elementos representan toda la informacion contenida en el documento. Sin embargo, el autor del documento no los suele ver como elmentos graficos, sino en terminos de la estructura fisica del documento ––lineas, columnas, figuras, tablas y otras subestructuras––.<span class="note" ><sup><a href="#10" >10</a></sup></span> A su vez, estas subestructuras tienen otras subestructuras propias, y asi sucesivamente.</p>
<p>La interfaz de usuario de Lexi deberia permitir manipular estas subestructuras directamente. Por ejemplo, un usuario deberia ser capaz de manipular un diagrama como una unidad, en vez de como una coleccion de primitivas graficas individuales, o de poder referirse a una tabla como un todo y no como un amasijo de texto y graficos sin estructura. Esto contribuye a que la intenfaz de Lexi sea mas simple e intuitiva. Para que la implementacion tenga unas caracteristicas similares debemos elegir una representacion interna que se corresponda con la estructura fisica del documento.</p>
<p>En concreto, la representacion interna deberia permitir lo siguiente:</p>
<ul>
<li>
<p>Mantener las estructura fisica del documento, es decir, la disposicion de texto y graficas en lineas, columnas, tablas, etc.</p>
</li>
<li>
<p>Generar y presentar visualmente el documento.</p>
</li>
<li>
<p>Establecer una correspondencia entre las posiciones en pantalla y los elementos de la representacion interna. De esta manera. Lexi puede determinar a que se esta refiriendo el usuario cuando apunta a algo en la representacion visual.</p>
</li>
</ul>
<p>Ademas de estos objetivos hay una serie de restricciones. En primer lugar, deberiamos tratar uniformemente al texto y a los graficos. La interfaz de usuario permite añadir texto a los graficos y viceversa, por lo que deberiamos evitar tratar los graficos como un caso especial de texto, o el texto como un caso especial de grafico. de no hacerlo asi, acabaremos por tener mecanismos redundantes de formateado y manipulacion. Debe ser suficiente con un unico conjunto de mecanismos para el texto y los graficos.</p>
<p>En segundo lugar, nuestra implementacion no deberia distinguir, en la representacion interna, entre elementos individuales y grupos de elementos. Lexi tendria que ser capaz de tratar de manera uniforme elementos simples y compuestos, permitiendo asi documentos todo lo complejos que se quiera. Por ejemplo, el decimo elemento de la linea cinco, columna dos, podria ser un caracter individual o un intricado diagrama con muchos subelementos. En la medida en que sepamos que dicho elemento puede dibujarse a si mismo y especificar sus dimenciones, su complejidad no influye en como y donde debe aparecer en la pagina.</p>
<p>Sin embargo, opuesta a esta segunda restriccion esta la necesidad de analizar el texto para asuntos como los errores ortograficos y los puntos potenciales de division de palabras con guiones. Aunque normalmente no nos preocuparemos de si el elemento de una linea es un objeto simple o compuesto, a veces un analisis depende de los objetos que estan siendo analizados. Tiene poco sentido, por ejemplo, comprobar la ortografia de un poligono, o dividirlo con un guion al final de la linea. El diseño de la representacion interna deberia tener en cuenta estas y otras restricciones, potencialmente contradictorias.</p>
</div>
<h4 id="composicion-recursiva" >Composicion Recursiva</h4>
<div class="hBody-4" >
<p>Una manera sencilla de representar jararquicamente informacion estructurada es mediante una tecnica denominada <b>composicion recursiva</b>, que consiste en construir objetos cada vez mas complejos a partir de otros mas simples. La composicion recursiva nos da la posibilidad de componer un documento a partir de elementos graficos. Como primer paso, podemos disponer una serie de caracteres y graficos de izquierda a derecha para formar una linea del documento. Despues, podemos colocar varias lineas formando una columna, varias columnas formando una pagina, y asi sucesivamente (vease la Figura 2.2).</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.2" >Figura 2.2</span>: Composicion recursiva de texto y graficos</h1>
<figure>
<img src="img/010.png" />
</figure>
</div>
<p>Podemos representar esta estructura fisica dedicando un objeto para cada elemento importante. Eso incluye no solo los elementos visibles como caracteres y graficos, sino tambien los elementos estructurales, invisibles ––lineas y columnas––. El resultado es la estructura de objetos mostrada en la Figura 2.3.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.3" >Figura 2.3</span>: Estructura de objetos para la compososicion recursiva de texto y graficos</h1>
<figure>
<img src="img/011.png" />
</figure>
</div>
<p>Al utilizar un objeto para cada caracter y elemento grafico del documento, estamos llevando la flexibilidad en el diseño de Lexi a su grado maximo. Podemos tratar al texto y a los graficos de manera uniforme con respecto a como se dibujan, se formatean y se insertan unos en otros. Y podemos ampliar Lexi para que admita nuevos juegos de cararteres sin afectar al resto de la funcionalidad. La estructura de objetos de Lexi mimetiza la estructura del documento fisico.</p>
<p>Este enfoque tiene dos repercusiones importantes. La primera es obvia: los objetos necesitan sus correspondientes clases. La segunda, que puede resultar menos evidente, es que estas clases deben tener interfaces compatibles, ya que queremos tratar uniformemente a los objetos. La manera de hacer que las interfaces sean compatibles en un lenguaje como C++ es relacionar las clases a traves de la herencia.</p>
</div>
<h4 id="glifos11" >GLIFOS<span class="note" ><sup><a href="#11" >11</a></sup></span></h4>
<div class="hBody-4" >
<p>Definiremos una clase abstracta <code>Glifo</code> para todos los objetos que pueden aparecer en la estructura de un documento.<span class="note" ><sup><a href="#12" >12</a></sup></span> Sus subclases definen tanto elementos graficos primitivos (por ejemplo, caracteres e imagenes) como elementos estructurales (por ejemplo, filas y columnas). La Figura 2.4 muestra una parte representativa de la jerarquia de las clases <code>Glifo</code>, y la <a href="#tabla-2.1" >Tabla 2.1</a> presenta la interfaz basica de un glifo mas detalladamente, empleando notacion C++.<span class="note" ><sup><a href="#13" >13</a></sup></span></p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.4" >Figura 2.4</span>: Parte de la jerarquia de clases de <code>Glifo</code></h1>
<figure>
<img src="img/012.png" />
</figure>
</div>
<div class="figure" >
<h1 class="figure"><span id="tabla-2.1" >Tabla 2.1</span> Interfaz basica de un glifo</h1>
<table border="1">
<thead>
<tr><th><p>Responsabilidad</p>
</th><th><p>Operaciones</p>
</th></tr>
</thead>
<tbody>
<tr><td rowspan="2"><p>Apariencia</p>
</td><td><p><code>virtual void Dibujar(Ventana*)</code></p>
</td></tr>
<tr><td><p><code>virtual void Limites(Rect&amp;)</code></p>
</td></tr>
<tr><td><p>detectar cortes</p>
</td><td><p><code>virtual bool Interseca(const Punto&amp;)</code></p>
</td></tr>
<tr><td rowspan="4"><p>estructura</p>
</td><td><p><code>virtual void Insertar(Glifo*, int)</code></p>
</td></tr>
<tr><td><p><code>virtual void Borrar(Glifo*)</code></p>
</td></tr>
<tr><td><p><code>virtual Glifo* Hijo(int)</code></p>
</td></tr>
<tr><td><p><code>virtual Glifo* Padre()</code></p>
</td></tr>
</tbody>
</table>
</div>
<p>Los glifos tiene tres responsabilidades basicas: (1) saber como dibujarse a si mismos, (2) que espacio ocupan y (3) cuales son sus hijos y su padre.</p>
<p>Las subclases de <code>Glifo</code> redefinen la operacion <code>Dibujar</code> para visualizarse en una ventana, pasandoles en la llamada a <code>Dibujar</code> una referencia al objeto <code>Ventana</code>. La clase <code>Ventana</code> define operaciones graficas para visualizar texto y figuras basicas en una ventana de la pantalla. Una subclase <code>Rectangulo</code> puede definir <code>Dibujar</code> como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Rectangulo</span><span class="o">::</span><span class="n">Dibujar</span> <span class="p">(</span><span class="n">Ventana</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">v</span><span class="o">-&gt;</span><span class="n">DibujarRect</span><span class="p">(</span><span class="n">_x0</span><span class="p">,</span> <span class="n">_y0</span><span class="p">,</span> <span class="n">_x1</span><span class="p">,</span> <span class="n">_y1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>donde <code>_x0</code>, <code>_y0</code>, <code>_x1</code>, <code>_y1</code> son datos miembro de <code>Rectangulo</code> que definen dos esquinas opuestas del rectangulo. <code>DibujarRect</code> es la operacion de <code>Ventana</code> que hace que el rectangulo aparezca en la pantalla.</p>
<p>Un glifo padre muchas veces necesita saber cuanto espacio ocupa uno de sus hijos, por ejemplo para situarlo junto con otros glifos en una linea de manera que no se solapen (como se muestra en la <a href="#figura-2.2" >Figura 2.2</a>). La operacion <code>Limites</code> devuelve el area rectangular que ocupa el glifo, es decir, las equinas opuestas del rectangulo mas pequeño que lo contiene. Las subclases de <code>Glifo</code> redefinen esta operacion para devolver el area rectangular en que se inscriben.</p>
<p>La operacion <code>Interseca</code> comprueba si un punto concreto corta al glifo. Cada vez que el usuario hace clic en algun punto del documento, Lexi llama a esta operacion para determinar que figura (o estructura de figuras) esta situada bajo el cursor del raton. La clase <code>Rectangulo</code> redefine esta operacion para calcular la interseccion del rectangulo y el punto especifico.</p>
<p>Puesto que los glifos pueden tener hijos, necesitamos una interfaz comun para añadir, borrar y acceder a dichos hijos. Por ejemplo, los hijos de una <code>Fila</code> son los glifos que esta coloca en una fila. La operacion <code>Insertar</code> inserta un glifo en la posicion especificada por un indice entero.<span class="note" ><sup><a href="#14" >14</a></sup></span>. La operacion <code>Borrar</code> borra la figura especificada en caso de que realmente se trate de un hijo.</p>
<p>La operacion <code>Hijo</code> devuelve el hijo de la posicion indicada, si es que existe. Los glifos que, como <code>Fila</code> Pueden tener hijos, deberian usar la operacion <code>Hijo</code> internamente, en vez de acceder directamente a la estructura de datos donde se encuentran estos. De esa manera no habra que modificar operaciones como <code>Dibujar</code> que iteran atraves de los hijos cuando se cambie la estructura de datos de, por ejemplo, un array a una lista enlazada. De manera similar, <code>Padre</code> proporciona una interfaz estandar al padre de glifo, si es que existe. En lexi los glifos tienen una referencia a su padre, y su operacion <code>Padre</code> simplemente devuelve dicha referencia.</p>
</div>
<h4 id="patron-composite" >Patron Composite</h4>
<div class="hBody-4" >
<p>La composicion recursiva no solo es util para los documentos. Tambien la podemos usar para representar cualquier estructura jerarquica potencialmente compleja. El patron <a href="#composite" >Composite</a> representa la esencia de la composicion recursiva en terminos de orientacion a objetos. Este podria ser un buen momento para acudir a ese patron y estudiarlo, volviendo a este escenario cuando sea necesario.</p>
</div>
<h3 id="2.3" >Formateando</h3>
<div class="hBody-3" >
<p>Ya nos hemos puesto de acuerdo sobre el modo de <em>representar</em> la estructura fisica de un documento. Ahora necesitamos saber como construir una estructura fisica en <em>particular</em>, es decir, una que corresponda a un documento concreto, correctamente formateado. La representacion y el formateado son diferentes: la capacidad de representar la estructura fisica del documento no nos dice como llegar a una estructura concreta. Esta responsabilidad recae principalmente en Lexi. Es el quien debe separar el texto en lineas, las lineas en columnas y asi sucesivamente, teniendo en cuenta los deseos del usuario. Por ejemplo, este puede querer variar la anchura de los margenes, el sangrado y las tabulaciones, interlineado sencillo o doble, y probablemente muchas otras restricciones de formateado.<span class="note" ><sup><a href="#15" >15</a></sup></span> El algoritmo de formateado de Lexi debe tener en cuenta todas estas cosas.</p>
<p>Por cierto, restringiremos el termino <q>formateado</q> para referirnos a la separacion de glifos en lineas. De hecho, usaremos los terminos <q>formateado</q> y <q>separacion de lineas</q> como sinonimos. Las tecnicas que veremos se aplican por igual a la separacion de las lineas en columnas y a la separacion de columnas en paginas.</p>
</div>
<h4 id="encapsulacion-del-algoritmo-de-formateado" >Encapsulacion del algoritmo de formateado</h4>
<div class="hBody-4" >
<p>El proceso de formateado, con todos sus detalles y restricciones, no es facil de automatizar. Hay muchas aproximaciones al problema, y la gente ha ideado una variedad de algoritmos de formateado con diferentes puntos fuertes y debiles. Dado que Lexi es un editor WYSYWYG, una cuestion importante a tener en cuenta es el equilibrio entre calidad y velocidad de formateado. Generalmente queremos una buena respuesta del editor sin sacrificar la apariencia del documento. Este equilibrio depende de muchos factores, no todos los cuales pueden determinarse en tiempo de compilacion. Por ejemplo, el usuario puede tolerar una respuesta ligeramente mas lenta si a cambio obtiene un formateado mejor. Esto puede hacer que sea mas apropiado un algoritmo de formateado distinto del original. Otro equilibrio, mas orientado a la implementacion, es que se pueda establecer entre la velocidad de formateado y los requisitios de almacenamiento: tal vez sea posible reducir el tiempo de formateado guardando mas informacion.</p>
<p>Como los algoritmos de formateado tienden a ser complicados, tambien es deseable mantener los contenidos o ––mejor aun–– que sean completamente independientes de la estructura del documento. Idealmente, podriamos añadir una nueva subclase de Glifo sin depender del algritmo de formateado. A la inversa, añadir un nuevo algoritmo de formateado no deberia requerir modificar los glifos existentes.</p>
<p>Estas caracteristicas sugieren que deberiamos diseñar Lexi para que sea facil cambiar el algoritmo de formateado, al menos en tiempo de compilacion, si no en tiempo de ejecucion. Podemos aislar el algoritmo y a la vez hacer que sea facilmente reemplazable encapsulandolo en un objeto. Mas concretamente, definiremos una jerarquia de clases separada para los objetos que encapsulan algoritmos de formateado. La raiz de la jerarquia definira una interfaz que soporta una gran variedad de algoritmos de formateado, y cada subclase implementara la interfaz para llevar a cabo un algoritmo concreto. Luego podemos introducir una subclase de <code>Glifo</code> que estructurara sus hijos automaticamente usando un objeto algoritmo dado.</p>
</div>
<h4 id="componedor-y-composicion" >Componedor y composicion</h4>
<div class="hBody-4" >
<p>Definiremos una clase <code>Componedor</code> para los objetos que pueden encapsular un algoritmo de formateado. La interfaz (<a href="#tabla-2.2" >Tabla 2.2</a>) permite que el componedor sepa <em>que</em> glifos formatear y <em>cuando</em> hacer el formateado. Los glifos que formatea son los hijos de una subclase especial de <code>Glifo</code> llamada <code>Composicion</code>, que obtiene una instancia de una subclase <code>Componedor</code> (especializada para un algoritmo concreto de separacion de lineas) cuando se crea y le ordena al componedor <code>Componer</code> sus glifos cuando sea necesario (por ejemplo, cuando el usuario cambia de documento). La <a href="#figura-2.5" >Figura 2.5</a> muestra las relaciones entre las clases <code>Composicion</code> y <code>Componedor</code>.</p>
<div class="figure" >
<h1 class="figure"><span id="tabla-2.2" >Tabla 2.2</span> Interfaz de un componedor basico</h1>
<table border="1">
<thead>
<tr><th><p>Responsabilidades</p>
</th><th><p>Operaciones</p>
</th></tr>
</thead>
<tbody>
<tr><td><p>que formatear</p>
</td><td><p><code>void EstablecerComposicion(Composicion*)</code></p>
</td></tr>
<tr><td><p>cuando formatear</p>
</td><td><p><code>virtual void Componer()</code></p>
</td></tr>
</tbody>
</table>
</div>
<div class="figure" >
<h1 class="figure"><span id="figura-2.5" >Figura 2.5</span>: Relaciones entre las clases <code>Composicion</code> y <code>Componer</code></h1>
<figure>
<img src="img/013.png" />
</figure>
</div>
<p>Un objeto <code>Composicion</code> sin formatear solo contiene los glifos visibles que constituyen el contenido basico del documento. No contiene glifos que determinan la estructura fisica del documento, tales como <code>Fila</code> y <code>Columna</code>. La composicion se encuentra en este estado justo despues de ser creada e inicializada con los glifos que deberia formatear. Cuando necesita ser formateada, llama a su operacion <code>Componer</code>. A su vez el componedor itera atraves de los hjos de la composicion e inserta nuevos glifos <code>Fila</code> y <code>Columna</code> en funsion de su algoritmo de separacion de lineas.<span class="note" ><sup><a href="#16" >16</a></sup></span> La <a href="#figura-2.6" >Figura 2.6</a> muestra la estructura de objetos resultante. Los glifos que han sido creados e insertados en la estructura de objetos por el componedor aparecen con fondo gris en la figura.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.6" >Figura 2.6</span>: Estructura de objetos que muestra el interlineado dirigido por un componedor</h1>
<figure>
<img src="img/014.png" />
</figure>
</div>
<p>Cada subclase de <code>Componedor</code> puede implementar un algoritmo diferente de separacion de lineas. Por jemplo un <code>ComponenteSimple</code> puede hacer una pasada rapida sin preocuparse de cuestiones como el <q>color</q> del documento. Un buen color significa que el documento tiene una distribucion uniforme del texto y espacios en blanco. Un <code>ComponendorTeX</code> implementaria el algoritmo <b>TeX</b> [<a href="#knu84" >Knu84</a>] completo, que tiene en cuenta cosas como el color a cambio de mayores tiempos de formateado.</p>
<p>Tener dos clases distintas <code>Componedor</code> y <code>Composicion</code> garantiza una gran separacion entre el codigo correspodiente a la estructura fisica del documento y el que lleva a cabo diferentes algoritmos de formateado. Podemos añadir nuevas subclases de <code>Componedor</code> sin tocar las clases de glifos, y viceversa. De hecho, podemos cambiar el algoritmo de separacion de lineas en tiempo de ejecucion añadiendo una unica operacion <code>EstablecerComponedor</code> a la interfaz basica de un glifo <code>Composicion</code>.</p>
</div>
<h4 id="patron-strategy-(estrategia)" >Patron Strategy (Estrategia)</h4>
<div class="hBody-4" >
<p>El proposito del patron <code>Strategy</code> es encapsular un algoritmo de un objeto. Los participantes principales en este patron son los objetos <code>Estrategia</code> (que encapsulan diferentes algoritmos) y el contexto en el que estos operan. Los componedores son estrategias que encapsulan diferentes algoritmos de formateado. Una composicion representa el contexto de estas estrategias.</p>
<p>La clave para aplicar el patron <code>Strategy</code> es diseñar interfaces para la estrategia y su contexto que sean lo suficientemente generales como para permitir diversos algoritmos. No deberiamos tener que cambiar la interfaz de la estrategia o de su contexto para dar cabida a un nuevo algoritmo. En nuestro ejemplo, la capacidad de la interfaz basica de un <code>Glifo</code> para acceder a sus hijos, insertarlos y borrarlos es lo bastante general como para que las subclases de <code>Componedor</code> cambien la estructura fisica del documento, independientemente del algoritmo que usen para hacerlo. Asi mismo, la interfaz de <code>Componedor</code> ofrece a las composiciones todo lo que necesitan para empezar el formateado.</p>
</div>
<h3 id="2.4" >Adornar la interfaz de usuario</h3>
<div class="hBody-3" >
<p>Hemos considerado dos adornos para la interfaz de usuario de Lexi. El primero añade un borde alrededor del area de edicion de texto para delimitar la pagina. El segundo añade barras de desplazamiento que permite al usuario ver diferentes partes de la pagina. Para que sea facil añadir y borrar estos adornos (especialmente en tiempo de ejecucion) no deberiamos usar la herencia para añadirlos a la interfaz de usuario. Conseguiremos la maxima flexibilidad si otros objetos de la interfaz de usuario ni siquiera son concientes de la presencia de esos adornos, lo que nos permitira añadirlos y borrarlos sin cambiar otras clases.</p>
</div>
<h4 id="recinto-transparente17" >Recinto Transparente<span class="note" ><sup><a href="#17" >17</a></sup></span></h4>
<div class="hBody-4" >
<p>Desde un punto de vista programatico, mejorar el aspecto de la interfaz de usuario implica ampliar el codigo existente. Usar la herencia para realizar dicha extension impide cambiar los adornos en tiempo de ejecucion, pero este enfoque presenta ademas otro problema igual de importante, como es la explosion de clases a la que puede dar lugar.</p>
<p>Podriamos añadir un borde a <code>Composicion</code> heredando de ella para obtener clase <code>ComposicionConBorde</code>, o añadir una interfaz de desplazamiento de la misma manera para dar lugar a una clase <code>ComposicionDesplazable</code>. Si quisieramos tanto las barras de desplazamiento como un borde, podriamos tener una <code>ComposicionDesplazableConBorde</code>, y asi sucesivamente. Llevandolo al extremo, acabariamos por tener una clase para cada posible combinacion, una solucion que rapidamente se convierte en impracticable en cuanto aumente el numero de adornos.</p>
<p>La composicion de objetos ofrece un mecanismo de aplicacion mas viable y extensible. Pero, ¿que objetos componemos? Puesto que sabemos que estamos adornando un glifo existente, podriamos hacer que el propio adorno fuese un objeto (por ejemplo, una instancia de la clase <code>Borde</code>). Eso nos da dos candidatos para la composicion: el glifo y el borde. El paso siguiente es decir quien contiene a quien. Podriamos hacer que el borde contenga el glifo, lo que tiene sentido dado que el borde rodeara al glifo en la pantalla. O podriamos hacer lo contrario ––poner el borde dentro del glifo––, pero entonces tenemos que hacer modificaciones a las correspondientes subclases de <code>Glifo</code> para que sean concientes del borde. Nuestra primer eleccion, introducir el glifo en el borde, mantiene el codigo que se encarga de dibujar el borde enteramente en la clase <code>Borde</code>, dejando las otras clases intactas.</p>
<p>¿A que se parece la clase <code>Borde</code>? El hecho de que los bordes tengan representacion visual sugiere que deberian ser glifos; es decir, que el borde deberia ser una subclase de <code>Glifo</code>. Pero hay una razon mas convincente de que estos tengan bordes o no. Cuando los clientes le dicen a un glifo normal, sin borde, que se dibuje, este deberia hacerlo sin ningun tipo de adorno. Si ese glifo esta dentro de un borde, los clientes no deberian tener que tratar de modo diferente al borde que lo contiene, sino que simplemente le diran que se dibuje, igual que se lo dijeron antes al glifo normal. Esto implica que la interfaz de <code>Borde</code> debe coincidir con la de <code>Glifo</code>, por lo que heredamos <code>Borde</code> de <code>Glifo</code> para garantizar dicha relacion.</p>
<p>Todo esto nos lleva al concepto de <b>recinto trasparente</b>, que auna las nociones de (1) composicion de un unico hijo (o componente individual) y (2) interfaces compatibles. Generalmente los clientes no saben si estan tratando con un componente o con su <b>recinto</b> (es decir, su padre), sobre todo si este no hace mas que delegar en su componente todas sus operaciones. Pero el recinto tambien puede <em>aumentar</em> el comportamiento del componente haciendo tareas propias antes y despues de delegar una operacion. Asi mismo, puede tambien añadir estado al componente. A continuacion veremos como.</p>
</div>
<h4 id="monoglifo" >Monoglifo</h4>
<div class="hBody-4" >
<p>Podemos aplicar el concepto de recinto transparente a todos los glifos que pueden adornar a otros. Para concretar este concepto, definiremos una subclase de <code>Glifo</code> llamada <code>MonoGlifo</code>, que servira de clase abstracta para los <q>glifos de adorno</q>, como <code>Borde</code> (vease la Figura 2.7). <code>MonoGlifo</code> guarda una referencia a un componente y reenvia todas las peticiones a el.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.7" >Figura 2.7</span>: Relaciones de la clase <code>MonoGlifo</code></h1>
<figure>
<img src="img/015.png" />
</figure>
</div>
<p>Eso hace que, por omision, <code>MonoGlifo</code> sea totalmente trasparente a los clientes. Por ejemplo, <code>Monoglifo</code> implementa la operacion <code>Dibujar</code> como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">MonoGlifo</span><span class="o">::</span><span class="n">Dibujar</span> <span class="p">(</span><span class="n">Ventana</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">_componente</span><span class="o">-&gt;</span><span class="n">Dibujar</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Las subclases de <code>MonoGlifo</code> reimplementan al menos una de estas operaciones de reenvio. <code>Borde::Dibujar</code>, por ejemplo, primero invoca a la operacion de la clase padre del componente, <code>MonoGlifo::Dibujar</code>, para que el componente haga su parte, es decir, dibujar todo menos el borde. Despues, <code>Borde::Dibujar</code> dibuja el borde llamado a una operacion privada <code>DibujarBorde</code>, cuyos detalles omitiremos:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Borde</span><span class="o">::</span><span class="n">Dibujar</span> <span class="p">(</span><span class="n">Ventana</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MonoGlifo</span><span class="o">::</span><span class="n">Dibujar</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="n">DibujarBorde</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Notese como <code>Borde::Dibujar</code> efectivamente <em>extiende</em> la operacion de la clase padre para dibujar el borde, en vez de simplemente <em>reemplazar</em> la operacion de la clase padre, lo que omitiria la llamada a <code>MonoGlifo::Dibujar</code>.</p>
<p>Otra subclase de <code>MonoGlifo</code> aparece en la <a href="#figura-2.7" >Figura 2.7</a>. <code>Desplazamiento</code><span class="note" ><sup><a href="#18" >18</a></sup></span> es un <code>MonoGlifo</code> que dibuja a su componente en diferentes ubicaciones basandose en la posicion de las dos barras de desplazamiento que le añade como adornos. El <code>Desplazamiento</code>, al dibujar su componente, le dice al sistema de graficos que lo ajuste a sus limites. Al recortar las partes del componente que estan desplazadas fuera de la vista se evita que aparezcan en la pantalla.</p>
<p>Ahora ya contamos con todas las piezas necesarias para añadir un borde y una interfaz de desplazamiento al area de edicion de texto de Lexi. Para ello, compondremos la instancia existente de <code>Composicion</code> en una instancia de <code>Desplazamiento</code>, para añadir la capacidad de desplazamiento, y el resultado lo compondremos en una instancia de Borde. La estructura de objetos resultante es la que se muestra en la Figura 2.8.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.8" >Figura 2.8</span>: Estructura de objetos con los adornos</h1>
<figure>
<img src="img/016.png" />
</figure>
</div>
<p>Notese que podemos cambiar el orden de la composicion, poniendo la composicion con el borde en la instancia de <code>Desplazamiento</code>. En ese caso el borde se desplazaria con el texto, lo cual puede ser o no deseable. La cuestion es que el recinto transparente hace que sea facil experimentar con diferentes alternativas, liberando a los clientes del codigo de adorno.</p>
<p>Es tambien importante notar como el borde compone un solo glifo, y no dos o mas. Esto es diferente de las composiciones que definimos antes en las que los objetos padre podian tener un numero arbitrario de hijos. Aqui, poner un borde alrededor de algo implica que ese <q>algo</q> es singular. Podriamos dar un significado a adornar mas de un objeto a la vez, pero entonces tendriamos que mezclar muchos tipos de composicion con la nocion de adorno: adorno de fila, de columna, etcetera. Eso no nos seria de ayuda, puesto que ya tenemos clases que hacen ese tipo de composiciones. Asi que es mejor usar las clases existentes para la composicion y añadir nuevas clases para adornar el resultado. Mantener los adornos independientes de otros tipos de composicon simplifica las clases que se encargan de los adornos y reduce su numero. Tambien nos evita tener que replicar la funcionalidad de composicion existente</p>
</div>
<h4 id="patron-decorator-(decorador)" >Patron Decorator (Decorador)</h4>
<div class="hBody-4" >
<p>El patron <a href="#decorator" >Decorator</a> expresa las relaciones de clases y objetos que permiten decorar la interfaz mediante los recintos transparentes. El termino <q>decoracion</q> en realidad tiene un significado mas amplio que el que hemos considerado aqui. En el patron Decorator, la decoracion se refiere a cualquier cosa que añada responsabilididades a un objeto. Podemos pensar, por ejemplo, en adornar un arbol sintactico abstacto con acciones semanticas, un automata de estados finitos con nuevas transiciones, o una red de objetos persistentes con nuevas etiquetas de atributos. El patron Decorator generaliza el enfoque que hemos seguido en Lexi para hacerlo aplicable en otros ambitos.</p>
</div>
<h3 id="2.5" >Permitir multiples estandares de interfaz de usuario</h3>
<div class="hBody-3" >
<p>Conseguir portabilidad entre plataformas hardware y software es uno de los principales problemas del diseño de sistemas. Adaptar Lexi a una nueva plataforma no deberia requerir una revision a fondo, o de lo contrario no mereceria la pena la adaptacion. Debemos hacer que portar el sistema sea lo mas facil posible.</p>
<p>Un obstaculo para conseguir la portabilidad es la variedad de estandares de interfaz de usuario existentes, pensados para imponer una uniformidad entre las distintas aplicaciones. Estos estandares definen directrices sobre la apariencia de las aplicaciones y como estas reaccionan ante el usuario. Aunque los estandares existen no son tan diferentes entre si, lo cierto es que nadie los confudira ––las aplicaciones para Motif no tienen exactamente el mismo aspecto que sus homologas en otras plataformas, y viceversa––. Una aplicacion que ese ejecuta en mas de una plataforma debe ajustarse a la guia de estilo de interfaces de usuario de cada una de ellas.</p>
<p>Nuestros objetivos de diseño son hacer que Lexi se ajuste a multiples estandares de unterfaz de usuario y que sea facil admitir otros nuevos a medida que vayan surgiendo (como invariablemente sucedera). Tambien queremos que nuestro diseño tenga la maxima flexibilidad: que se pueda cambiar la interfaz de usuario de Lexi en tiempo de ejecucion.</p>
</div>
<h4 id="abstrayendo-la-creacion-de-objetos" >Abstrayendo la creacion de objetos</h4>
<div class="hBody-4" >
<p>Cualquier cosa que veamos y con la que interactuemos en la interfaz de Lexi es un glifo combinado con otros glifos invisibles, como la <code>Fila</code> y <code>Columna</code>. Los glifos invisibles componen a otros visibles, como <code>Boton</code> y <code>Caracter</code>, y los ubican corretamente. Las guias de estilo tienen mucho que decir acerca de la apariencia y el comportamiento de los llamados <q>utiles</q><span class="note" ><sup><a href="#19" >19</a></sup></span>, otro termino con el que se designa a los glifos visibles, como botones, barras de desplazamiento y menus, que controlan los elementos de una interfaz de usuario. Los utiles podrian usar glifos mas sencillos como caracteres, circulos, rectangulos y poligonos para presentar los datos.</p>
<p>Supondremos que tenemos dos conjuntos de clases de glifos de utiles con los que implementar multiples estandares de interfaz de usuario:</p>
<ol class="num" >
<li>
<p>Un conjunto de subclases abstractas de <code>Glifo</code> para cada categoria de glifo de util. Por ejemplo, una clase abstracta <code>BarraDeDesplazamiento</code> aumentara la interfaz de un glifo basico para añadir operaciones generales de desplazamiento; <code>Boton</code> es una clase abstracta que añade operaciones relacionadas con los botones; etcetera.</p>
</li>
<li>
<p>Un conjunto de subclases concretas para cada subclase abstracta, las cuales implementan diferentes estandares de interfaz de usuario. Por ejemplo, <code>BarraDeDesplazamiento</code> podria tener las subclases <code>BarraDeDesplazamientoMotif</code> y <code>BarraDeDesplazamientoPM</code>, que implementan barras de desplazamiento para Motif y Presentation Manager, respectivamente.</p>
</li>
</ol>
<p>Lexi debe distinguir entre los glifos de utiles para diferentes estilos de interfaces de usuario. Por ejemplo, cuando necesita colocar un boton en su interfaz, debe crear una instancia de una subclase de <code>Glifo</code> con el estilo adecuado de boton (<code>BotonBoton</code>, <code>BotonPM</code>, <code>BotonMac</code>, etc.).</p>
<p>Esta claro que la implementacion de Lexi no puede hacer esto directamente (por ejemplo, mediente una llamada a un constructor de C++). Eso fijaria en el codigo el boton de un estilo concreto, haciendo imposible seleccionar el estilo en tiempo de ejecucion. Tambien tendramos que localizar cada llamada a dicho constructor y cambiarlas para portar Lexi a otra plataforma. Y los botones son solo uno de muchos utiles de los que consta la interfaz de usuario de lexi. Plagar nuestro codigo con llamadas a los constructores de las clases de una interfaz de usuario concreta da como resultado una pesadilla de mantenimiento, donde pasar por alto uno solo de estos constructores hara que nos encontremos un menu de Motif en medio de nuestra aplicacion para Mac.</p>
<p>Lexi necesita un modo de determinar los estandares de interfaz de usuario a los que esta dirigido, para asi crear los utiles apropiados. No solo debemos evitar hacer llamadas explicitas a constructores; tambien debemos ser capaces de reemplazar un conjunto completo de utiles facilmente. Podemos lograr ambas cosas <em>abstrayendo el proceso de creacion de objetos</em>. Un ejemplo ilustrara que queremos decir con esto.</p>
</div>
<h4 id="clases-fabrica-y-producto" >Clases Fabrica y Producto</h4>
<div class="hBody-4" >
<p>Normalmente podemos crear una instancia de una barra de desplazamiento de Motif con el siguiente codigo C++:</p>
<pre class="code" ><code class="chroma" ><span class="n">BarraDeDesplazamiento</span><span class="o">*</span> <span class="n">barra</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BarraDeDesplazamientoMotif</span><span class="p">;</span>
</code></pre>
<p>Esta es la clase de codigo que debemos evitar si queremos minimizar las dependencias de la interfaz de usuario en Lexi. Supongamos que inicializamos barra como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="n">BarraDeDesplazamiento</span><span class="o">*</span> <span class="n">barra</span> <span class="o">=</span> <span class="n">FabricaIGU</span><span class="o">-&gt;</span><span class="n">CrearBarraDeDesplazamiento</span><span class="p">();</span>
</code></pre>
<p>donde <code>fabricaIGU</code> es una instancia de la clase <code>FabricaMotif</code>. <code>CrearBarraDeDesplazamiento</code> devuelve una instancia de la subclase correcta de <code>BarraDeDesplazamiento</code> para la interfaz de usuario deseada, en este caso Motif. En cuanto a los clientes, el efecto es el mismo que llamar directamente al constructor de <code>BarraDeDesplazamientoMotif</code>, pero con una diferencia crucial: ya no hay nada en el codigo que haga referencia a Motif por su nombre. El objeto <code>fabricaIGU</code> abstrae el proceso de creacion no solo de barras de desplazamiento para Motif, sino de barras de desplazamiento para <em>cualquier</em> estandar de interfaz de usuario. y tampoco se limita a producir barras de desplazamiento, sino que puede fabricar una amplia variedad de utiles, incluyendo barras de desplazamiento, botones, campos de entrada, menus, etcetera.</p>
<p>Todo esto es posible porque <code>FabricaMotif</code> es una subclase de <code>FabricaIGU</code>, una clase abstracta que define una interfaz general para crear glifos de utiles. Incluye operaciones como <code>CreacBarraDeDesplazamiento</code> y <code>CrearBoton</code> para diferentes tipos de glifos de utiles (<em>widgets</em>). Las subclases de <code>FabricaIGU</code> implementan estas operaciones para devolver glifos tales como <code>BarraDeDesplazamientoMotif</code> y <code>BotonPM</code> que implementan una interfaz de usuario en concreto. La <a href="#figura-2.9" >Figura 2.9</a> muestra la jerarquia de clases resultante para los objetos <code>fabricaIGU</code>.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.9" >Figura 2.9</span>: Jerarquia de clases de <code>FabricaIGU</code></h1>
<figure>
<img src="img/017.png" />
</figure>
</div>
<p>Decimos que las fabricas crean objetos <b>producto</b>. Ademas, los productos creados por una fabrica se realacionan entre si; en este caso, los productos son todos utiles (<em>widgets</em>) con el mismo estilo de interfaz de usuario. La Figura 2.10 muestra algunas de las clases necesarias para que las fabricas trabajen con glifos de utiles.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.10" >Figura 2.10</span>: Clases abstractas de producto y subclases concretas</h1>
<figure>
<img src="img/018.png" />
</figure>
</div>
<p>La ultima cuestion a la que tenemos que responder es de donde viene la instancia de <code>FabricaIGU</code>. La respuesta es que de cualquier sitio. La variable <code>fabricaIGU</code> pobria ser un miembro estatico de una clase conocida, o incluso una variable local si toda la interfaz de usuario se creara dentro de la misma clase o funcion. Hay un patron de diseño, el <a href="#sigleton" >Sigleton</a>, que permite tratar con objetos conocidos de los que solo hay una instancia, como es este caso. Lo importante es inicializar <code>fabricaIGU</code> en un punto del programa que este <em>antes</em> de que se use por primera vez para crear utiles, pero <em>despues</em> de que este claro que interfaz de usuario se desea.</p>
<p>Si la interfaz de usuario se conoce en tiempo de compilacion, <code>fabricaIGU</code> puede ser inicilizada con una simple asignacion de una nueva instancia de una fabrica al comienzo del programa:</p>
<pre class="code" ><code class="chroma" ><span class="n">FabricaIGU</span><span class="o">*</span> <span class="n">fabricaIGU</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FabricaMotif</span><span class="p">;</span>
</code></pre>
<p>Si el usuario puede especificar la interfaz de usuario con un nombre al inicializar el programa, entonces el codigo para crear la fabrica podria ser el siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="n">FabricaIGU</span><span class="o">*</span> <span class="n">fabricaIGU</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombreEstilo</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="o">*</span><span class="n">INTERFAZ_DE_USUARIO</span><span class="o">*</span><span class="p">);</span>
  <span class="c1">// el usuario o el entorno lo proporciona al principio
</span><span class="c1"></span>
<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">nombreEstilo</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;Motif&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">fabricaIGU</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FabricaMotif</span><span class="p">;</span>

<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">nombreEstilo</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;Presentation_Manager&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">fabricaIGU</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FabricaPM</span><span class="p">;</span>

<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">fabricaIGU</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FabricaIGUPredeterminada</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Hay formas mas sofisticadas de seleccionar la fabria en tiempo de ejecucion. Por ejemplo, podriamos tener un registro que hiciera corresponder cadenas de texto con objetos fabrica. Eso nos permitira registrar instancias de nuevas subclases de fabricas sin modificar el codigo existente, como requiere el enfoque anterior. y no tenemos que enlazar todas las fabricas dependientes de la plataforma en la aplicacion. Esto es importante, porque podria no ser posible enlazar una <code>FabricaMotif</code> en una plataforma que no admita Motif.</p>
<p>Pero la clave es que una vez que hemos configurado la aplicacion con el objeto fabrica adecuado, a partir de entonces se activa su estilo de interfaz de usuario. Si cambiamos de idea, podemos reinicializar <code>fabricaIGU</code> con una fabrica para otro estilo de interfaz de usuario, y reconstruir entonces la interfaz. Independientemente de como y cuando decidamos inicializar <code>fabricaIGU</code>, sabemos que una vez que lo hagamos la aplicacion puede crear la interfaz de usuario apropiada sin ninguna modificacion.</p>
</div>
<h4 id="patron-abstract-factory-(fabrica-abstracta)" >Patron Abstract Factory (Fabrica Abstracta)</h4>
<div class="hBody-4" >
<p>Las fabricas y los productos son los principales participantes del patron <a href="#abstract-factory" >Abstract Factory</a>. Este patron muestra como crear familias de objetos producto relacionados sin instanciar las clases directamente y hay diferencias entre las distintas familias de productos. Podemos elegir entre las distintas familias creando una instancia de una fabrica concreta y usandola de forma consistente para crear productos a partir de entonces. Tambien podemos cambiar familias completas de productos reemplazando la fabrica concreta con una instancia de otra diferente. La importancia que el patron Abstract Factory da a las <em>familias</em> de productos diferencia a este de otros patrones de creacion, que comprenden un solo tipo de objetos producto.</p>
</div>
<h3 id="2.6" >Permitir multiples sistemas de ventanas</h3>
<div class="hBody-3" >
<p>El estilo de la interfaz de usuario es solo una de las muchas cuestiones que tienen que ver con la portabilidad. Otra es el entorno de ventanas en el que se ejecuta Lexi. Un sistema de ventanas crea la ilusion de ventanas solapadas en una pantalla de mapa de bits. Tambien controla el espacio en pantalla para las ventanas y dirige hacia ellas la entrada del teclado y del raton. Actualemente existen varios sistemas de ventanas importantes y, en gran medida, incompatibles (por ejemplo, Macintosh, Presentation Manager, Windows, X). Nos gustaria que Lexi se ejecutase en tantos de ellos como fuese posible, por la misma razon por la que permitimos multiples estandares de interfaz de usuario.</p>
</div>
<h4 id="podemos-usar-una-fabrica-abstracta?" >Podemos usar una Fabrica Abstracta?</h4>
<div class="hBody-4" >
<p>A primera vista esto puede parecer otra ocasion para aplicar el patron Abstract Factory. Pero las restricciones en cuanto a la portabilidad del sistema de ventanas difieren significativamente de las de la independencia de la interfaz de usuario.</p>
<p>En aquel caso, cuando aplicabamos el patron Abstract Factory estabamos asumiendo que definiriamos clases concretas de utiles para cada estandar de interfaz de usuario. Eso significaba que podriamos derivar cada producto concreto para un estandar en particular (por ejemplo, <code>BarraDeDesplazamientoMotif</code> y <code>BarraDeDesplazamientoMac</code>) de una clase de producto abstracta (por ejemplo, <code>BarraDeDesplazamiento</code>. Pero supongamos que ya tenemos varias jerarquias de clases de diferentes vendedores, una por cada estandar de interfaz de usuario. Por supuesto, es altamente improbable que estas jeraquias sean en modo alguno compatibles. Asi que no tendremos una clase de producto abstracta por cada tipo de util (<code>BarraDeDesplazamiento</code>, <code>Boton</code>, <code>Menu</code>, etc.) y el patron Abstract Factory no funcionara sin esas clase cruciales. Tenemos que hacer que las diferentes jerarquias de utilies se adhieran a un conjunto camun de interfaces de productos abstractas. Solo entonces podriamos declarar las operaciones <code>Crear...</code> en nuestra interfaz de fabrica abstracta.</p>
<p>En el caso de los utiles resolvimos este problema desarrollando nuestras propias clases abstractas y concretas de productos. Ahora nos enfrentamos a un problema similar cuando intentamos que Lexi funcione en diferentes sistemas de ventanas; a saber, que los diferentes sistemas de ventanas tienen interfaces de programacion incompatibles. Esta vez, no obstante, las cosas son un poco mas dificiles, porque no podemos permitirnos implementar nuestro propio sistema de ventanas no estandar.</p>
<p>Pero nos salva que las interfaces de los sistemas de ventanas, al igual que las de los diferentes estandares de interfaces de usuario, no son radicalemente diferentes unas de otras, porque por lo general todos los sistemas de ventanas hacen las mismas cosas. Necesitamos un conjunto uniforme de abstracciones de ventanas que nos premitan tomas diferentes implementaciones de sistemas de ventanas y poner cualquiera de ellas bajo una interfaz comun.</p>
</div>
<h4 id="encapsular-dependencias-de-implementacion" >Encapsular dependencias de implementacion</h4>
<div class="hBody-4" >
<p>En la <a href="#2.2" >Seccion 2.2</a> introducimos una clase <code>Ventana</code> para mostrar un glifo o una estructura de glifos en pantalla. No especificamos el sistema de ventanas con el que trabajaba este objeto, porque la verdad es que no proviene de ningun sistema de ventanas. La clase <code>Ventana</code> encapsula las operaciones que suelen hacer las ventanas en los diferentes sistemas de ventanas:</p>
<ul>
<li>
<p>Proporciona operaciones para dibujar formas geometricas basicas.</p>
</li>
<li>
<p>Pueden minimizarse y maximisarse a si mismas.</p>
</li>
<li>
<p>Pueden cambiar su tamaño</p>
</li>
<li>
<p>Pueden (re)dibujar sus contenidos a peticion, por ejemplo cuando son maximizadas o cuando se muestra una parte que permanecia oculta de su espacio en pantalla.</p>
</li>
</ul>
<p>La clase <code>Ventana</code> debe abarcar la funcionalidad de las ventanas de diferentes sistemas de ventanas. Consideremos dos filosofias extremas:</p>
<ol class="num" >
<li>
<p><em>Interseccion de funcionalidad.</em> La clase <code>Ventana</code> proporciona solo la funcionalidad que es comun a <em>todos</em> los sistemas de ventanas. El problema de este enfoque es que nuestra interfaz de <code>Ventana</code> acaba siendo solo tan potente como el sistema de ventanas con menos capacidades. No podemos aprovecharnos de caracteristicas mas avanzadas incluso aunque la mayoria (pero no todos) los sistemas de ventanas las admitan.</p>
</li>
<li>
<p><em>Union de funcionalidad</em>. Crear una interfaz que incorpora las capacidades de <em>todos</em> los sistemas exitente. El problema es que la interfaz resultante puede ser gigantesca e incoherente. Ademas, tendremos que cambiarla (y a Lexi, que depende de ella) cada ves que un vendedor revise la interfaz de su sistema de ventanas.</p>
</li>
</ol>
<p>Ninguno de los dos extremos es una solucion viable, de manera que nuestro diseño se situara en algun punto intermedio entre ambos. La clase <code>Ventana</code> proveera una interfaz adecuada que tenga las caracteristicas mas populares de los sistemas de ventanas. Como Lexi tratara directamente con ella, la clase <code>Ventana</code> debera incluir tambien un conjunto basico de operaciones graficas que permita a los glifos dibujarse a si mismos en una ventana. La Tabla 2.3 muestra un ejemplo de las operaciones de la interfaz de la clase <code>Ventana</code>.</p>
<div class="figure" >
<h1 class="figure"><span id="tabla-2.3" >Tabla 2.3</span>: Interfaz de la clase <code>Ventana</code></h1>
<table border="1">
<thead>
<tr><th><p>Responsabilidades</p>
</th><th><p>Operaciones</p>
</th></tr>
</thead>
<tbody>
<tr><td rowspan="6"><p>gestion de ventanas</p>
</td><td><p><code>Virtual void Redibujar()</code></p>
</td></tr>
<tr><td><p><code>Virtual void TraerAdelante()</code></p>
</td></tr>
<tr><td><p><code>Virtual void EnviarAtras()</code></p>
</td></tr>
<tr><td><p><code>Virtual void Minimizar()</code></p>
</td></tr>
<tr><td><p><code>Virtual void Maximizar()</code></p>
</td></tr>
<tr><td><p>...</p>
</td></tr>
<tr><td rowspan="5"><p>graficos</p>
</td><td><p><code>Virtual void DibujarLinea(...)</code></p>
</td></tr>
<tr><td><p><code>Virtual void DibujarRect(...)</code></p>
</td></tr>
<tr><td><p><code>Virtual void DibujarPoligono(...)</code></p>
</td></tr>
<tr><td><p><code>Virtual void DibujarTexto(...)</code></p>
</td></tr>
<tr><td><p>...</p>
</td></tr>
</tbody>
</table>
</div>
<p><code>Ventana</code> es una clase abstracta. Sus subclases concretas admiten los diferentes tipos de ventanas con las que trataran. Por ejemplo, las ventanas de aplicacion, los iconos y los dialogos de avisos, son todos ellos ventanas, pero tienen comportamientos diferentes. Asi que podemos definir subclases como <code>VentanaDeAplicacion</code>, <code>VentanaIcono</code> y <code>VentanaDialogo</code> para representar tales diferencias. La jerarquia de clases resultante le da a las aplicaciones como Lexi una abstraccion de las ventanas uniforme e intuitiva, que no depende del sistema de ventas de ningun vendedor en particular.</p>
<p>Ahora que hemos definido una interfaz de ventana para que Lexi trabaje con ella, ¿cual es el papel del sistema de ventas real de una plataforma concreta? Dado que no estamos implementando nuestro propio sistema de ventanas, nuestra abstraccion de ventana debera ser implementada en algun lugar en terminos de lo que proporciona el sistema de ventanas nativo. ¿Donde reside esa implementacion?</p>
<figure>
<img src="img/019.png" />
</figure>
<p>Un enfoque es implementar multiples versiones de la clase <code>Ventana</code> y sus subclases, una para cada plataforma de ventanas. Tendriamos que elegir la version a usar cuando construyeramos Lexi para una plataforma dada. Pero imagine los dolores de cabeza que daria el mantenimiento si tuviesemos que estar pendientes de multiples clases, todas llamadas <q><code>Ventana</code></q>, pero cada una implementada en un sistema de ventanas diferente. Otra alternativa seria crear subclases dependientes de la implementacion para cada clase de la jerarquia de <code>Ventana</code> ––y acabar teniendo otro problema de explosion de subclases como el que tuvimos cuando tratabamos de añadir adornos––. Ambas alternativas tiene sus deventajas: ninguna nos da la flexibilidad de cambiar el sistema de ventanas despues de haber compilado el programa. De manera que tendremos que tener diferentes ejecutables.</p>
<p>Ninguna de estas opciones es muy atractiva, pero ¿que otra cosa podemos hacer? Lo mismo que hicimos para el formateado y la decoracion, es decir, <em>encapsular el concepto que varia</em>. Lo que cambia en este caso es la implementacion del sistema de ventanas. Si encapsulamos la funcionalidad de un sistema de ventanas en un objeto, podemos implementar nuestra clase <code>Ventana</code> y sus subclases en terminos de la interfaz de ese objeto. Ademas, si esa interfaz sirve para todos los sistemas de ventanas en los que estamos interesados, no tendremos que cambiar <code>Ventanas</code> ni ninguna de sus subclases para permitir diferentes sistemas de ventanas. Podemos configurar los objetos ventana para el sistema de ventanas que queramos simplemente pasandoles el objeto apropiado que lo encapsula. Incluso podemos configurar la ventana en tiempo de ejecucion.</p>
</div>
<h4 id="ventana-y-ventanaimp" ><code>Ventana</code> y <code>VentanaImp</code></h4>
<div class="hBody-4" >
<p>Definiremos una jerarquia de clases <code>VentanaImp</code> aparte, para ocultar las implementaciones de los diferentes sistemas de ventanas. <code>VentanaImp</code> es una clase abstracta para los objetos que encapsulan codigo dependiente del sistema de ventanas. Para que Lexi funcione en un sistema de ventanas concreto, configuramos cada objeto ventana con una instancia de la subclase de <code>VentanaImp</code> para ese sistema. El diagrama siguiente muestra la relacion entre las jerarquias de <code>Ventana</code> y <code>VentanaImp</code>:</p>
<figure>
<img src="img/020.png" />
</figure>
<p>Al ocultar las implementaciones en la clase <code>VentanaImp</code>, evitamos contaminar las clase <code>Ventana</code> con dependencias del sistema de ventanas, lo que mantiene a la jerarquia de clases de <code>Ventanas</code> relativamente pequeña y estable. Ademas, podemos ampliar facilmente la jerarquia de implementacion para admitir nuevos sistemas de ventanas.</p>
</div>
<h5 id="subclases-de-ventanaimp" >Subclases de <code>VentanaImp</code></h5>
<div class="hBody-5" >
<p>Las subclases de <code>VentanaImp</code> convierten peticiones en operaciones especificas del sistema de ventanas. Piense en el ejemplo que empleamos en la <a href="#2.2" >Seccion 2.2</a>. Definiamos <code>Rectangulo::Dibujar</code> en terminos de la operacion <code>DibujarRect</code> de la instancia de <code>Ventana</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Rectangulo</span><span class="o">::</span><span class="n">Dibujar</span> <span class="p">(</span><span class="n">Ventana</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">v</span><span class="o">-&gt;</span><span class="n">DibujarRect</span><span class="p">(</span><span class="n">_x0</span><span class="p">,</span> <span class="n">_y0</span><span class="p">,</span> <span class="n">_x1</span><span class="p">,</span> <span class="n">_y0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>La implementacion predeterminada de <code>DibujarRect</code> usa la operacion abstracta para dibujar rectangulos declarada por <code>VentanaImp</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Ventana</span><span class="o">::</span><span class="n">DibujarRect</span> <span class="p">(</span>
  <span class="n">Coord</span> <span class="n">x0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y1</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="n">_imp</span><span class="o">-&gt;</span><span class="n">DispositivoRect</span><span class="p">(</span><span class="n">_x0</span><span class="p">,</span> <span class="n">_y0</span><span class="p">,</span> <span class="n">_x1</span><span class="p">,</span> <span class="n">_y0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>donde <code>_imp</code> es una varible miembro de <code>Ventana</code> que guarda el objeto <code>VentanaImp</code> con el que se configuro la ventana. La implementacion de la ventana esta definida por la instancia de la subclase <code>VentanaImp</code> a la que apunta <code>_imp</code>. Para una <code>VentanaImpX</code> (esto es, una subclase de <code>VentanaImp</code> para el sistema de ventanas X), la implementacion de <code>DispositivoRect</code> puede parecerse a</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">VentanaImpX</span><span class="o">::</span><span class="n">DispositivoRect</span> <span class="p">(</span>
  <span class="n">Coord</span> <span class="n">x0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y1</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">ancho</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">alto</span>  <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">y1</span><span class="p">));</span>
  <span class="n">XDrawRectangle</span><span class="p">(</span><span class="n">_dpy</span><span class="p">,</span> <span class="n">_winid</span><span class="p">,</span> <span class="n">_cg</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ancho</span><span class="p">,</span> <span class="n">alto</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p><code>DispositivoRect</code> esta asi definido porque <code>XDrawRectangle</code> (la interfaz de X para dibujar un rectangulo) define un rectangulo en terminos de su esquina inferior izquierda, su ancho y su alto. <code>DispositivoRect</code> debe calcular estos valores a partir de los que recive. En primer lugar determina la esquina inferior izquierda (ya que (<code>x0, y0</code> puede ser cualquiera de las cuatro esquinas del rectangulo) y luego calcula el ancho y el alto.</p>
<p><code>VentanaImpPM</code> (una subclase de <code>VentanaImp</code> para Presentation Manager) definiria <code>DispositivoRect</code> de esta otra forma:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">VentanaImpPM</span><span class="o">::</span><span class="n">DibujarRect</span> <span class="p">(</span>
  <span class="n">Coord</span> <span class="n">x0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y1</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="n">Cord</span> <span class="n">izquierda</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
  <span class="n">Cord</span> <span class="n">derecha</span>   <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
  <span class="n">Cord</span> <span class="n">inferior</span>  <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">);</span>
  <span class="n">Cord</span> <span class="n">superior</span>  <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">);</span>

  <span class="n">PPDINTL</span> <span class="n">punto</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

  <span class="n">punto</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">izquierda</span><span class="p">;</span> <span class="n">punto</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">superior</span><span class="p">;</span>
  <span class="n">punto</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span>   <span class="n">derecha</span><span class="p">;</span> <span class="n">punto</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">superior</span><span class="p">;</span>
  <span class="n">punto</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span>   <span class="n">derecha</span><span class="p">;</span> <span class="n">punto</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">inferior</span><span class="p">;</span>
  <span class="n">punto</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">izquierda</span><span class="p">;</span> <span class="n">punto</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">inferior</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span>
    <span class="p">(</span><span class="n">GpiBeginPath</span><span class="p">(</span><span class="n">_hps</span><span class="p">,</span> <span class="mi">1L</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="o">||</span>
    <span class="p">(</span><span class="n">GpiSetCurrentPosition</span><span class="p">(</span><span class="n">_hps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">punto</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="o">||</span>
    <span class="p">(</span><span class="n">GpiPolyLine</span><span class="p">(</span><span class="n">_hps</span><span class="p">,</span> <span class="mi">4L</span><span class="p">,</span> <span class="n">punto</span><span class="p">)</span> <span class="o">==</span> <span class="n">GPI_ERROR</span><span class="p">)</span> <span class="o">||</span>
    <span class="p">(</span><span class="n">GpiEndPath</span><span class="p">(</span><span class="n">_hps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// informar del error
</span><span class="c1"></span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">GpiStrokePath</span><span class="p">(</span><span class="n">_hps</span><span class="p">,</span> <span class="mi">1L</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>¿Por que es tan diferente la version para X? Bueno, PM no tiene una operacion para dibujar rectangulos explicitamente, como si tenia X. En lugar de eso, PM tiene una interfaz mas general para especificar vertices de figuras formadas por varios segmentos (lo que se conoce como un <em>path</em>) y para trazar o rellenar el area que encierran.</p>
<p>La implementacion para PM de <code>DispositivoRect</code> difiere bastante de la de X, pero eso no importa. <code>VentanaImp</code> oculta las diferencias de las interfaces de los sistemas de ventanas tras una interfaz potencialmente grande pero estable. Esto permite que los creadores de las subclases de <code>Ventana</code> se centren en la abstraccion de ventana y no en los detalles del sistema de ventanas. Tambien nos permite añadir nuevos sistemas de ventanas sin afectar a las clases <code>Ventana</code>.</p>
</div>
<h5 id="configurar-ventanas-con-ventanaimps" >Configurar <code>Ventanas</code> con <code>VentanaImp</code>s</h5>
<div class="hBody-5" >
<p>Una cuestion clave que aun no hemos considerado es como se configura una ventana con la subclase correcta de <code>VentanaImp</code>. Dicho de otra forma, ¿cuando se inicializa <code>_imp</code>, y quien sabe que sistema de ventanas (y, consecuentemente, que subclase de <code>VentanaImp</code>) se esta usando? La ventana necesitara algun tipo de <code>VentanaImp</code> antes de que pueda hacer nada interesante.</p>
<p>Hay varias posibilidades, pero nos centraremos en una que hace uso del patron <a href="#abstract-factory" >Abstract Factory</a>. Podemos definir una clase fabrica abstracta <code>FabricaSistemaDeVentanas</code> que proporciona una interfaz para crear diferentes tipos de implementaciones de objetos dependientes del sistema de ventanas:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">FabricaSistemaDeVentanas</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="n">VentanaImp</span><span class="o">*</span> <span class="n">CrearVentanaImp</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">ColorImp</span><span class="o">*</span>   <span class="nf">CrearColorImp</span>  <span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">FuenteImp</span><span class="o">*</span>  <span class="nf">CrearFuenteImp</span> <span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="c1">// una operacion &#34;Crear...&#34; para todos los recursos
</span><span class="c1"></span>  <span class="c1">// del sistema de ventanas
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>Ahora podemos definir una fabrica concreta para cada sistema de ventanas:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">FabricaSistemaDeVentanasPM</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FabricaSistemaDeVentanas</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="n">VentanaImp</span><span class="o">*</span> <span class="n">CrearVentanaImp</span><span class="p">()</span>
  <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">VentanaImpPM</span><span class="p">;</span> <span class="p">}</span>
  <span class="c1">// ..
</span><span class="c1"></span><span class="p">};</span>

<span class="k">class</span> <span class="nc">FabricaSistemaDeVentanasX</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FabricaSistemaDeVentanas</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="n">VentanaImp</span><span class="o">*</span> <span class="n">CrearVentanaImp</span><span class="p">()</span>
  <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">VentanaImpX</span><span class="p">;</span> <span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>el constructor de la clase base <code>Ventana</code> puede usar la interfaz de <code>FabricaSistemaDeVentanas</code> para inicializar el miembro <code>_imp</code> con el objeto <code>VentanaImp</code> apropiado para el sistema de ventanas:</p>
<pre class="code" ><code class="chroma" ><span class="n">Ventana</span><span class="o">::</span><span class="n">Ventana</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">_imp</span> <span class="o">=</span> <span class="n">fabricaSistemaDeVentanas</span><span class="o">-&gt;</span><span class="n">CrearVentanaImp</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>La variable <code>fabricaSistemaDeVentanas</code> es una instancia conocida de una subclase <code>FabricaSistemaDeVentanas</code>, similar a la variable <code>fabricaIGU</code> que definia el estandar de interfaz de usuario. La variable <code>fabricaSistemaDeVentanas</code> se puede inicializar del mismo modo.</p>
</div>
<h4 id="patron-bridge-(puente)" >Patron Bridge (Puente)</h4>
<div class="hBody-4" >
<p>La clase <code>VentanaImp</code> define una interfaz con los servicios comunes de los sistemas de ventanas, pero su diseño viene dado por otras restricciones que las de la intefaz de <code>Ventana</code>. Los programadores de aplicaciones no trataran directamente con la interfaz de <code>VentanaImp</code>, sino solo con objetos <code>Ventana</code>. Por tanto, la interfaz de <code>VentanaImp</code> no tiene por que coincidir con la vision del mundo que tiene el programador de la aplicacion, como fue nuestra preocupacion al diseñar la interfaz y la jerarquia de clases de <code>Ventana</code>. La interfaz de <code>VentanaImp</code> puede reflejar mejor lo que proporcionan realmente los distintos sistemas de ventanas, con todas sus imperfecciones. Puede aproximarse a uno cualquiera de los enfoques de interseccion o de union de funcionalidad, el que mejor se adapte al sistema de ventanas de destino.</p>
<p>Lo importante aqui es darse cuenta de que la interfaz de <code>Ventana</code> esta dirigida al programador de aplicaciones, mientras que <code>VentanaImp</code> esta dirigida a los sistemas de ventanas. Separar la funcionalidad de las ventanas en las jerarquias de <code>Ventana</code> y <code>VentanaImp</code> nos permite implementar y especializar estas interfaces de forma independiente. Los objetos de estas jerarquias cooperan entre si para que Lexi funcione en varios sistemas de ventanas sin ninguna modificacion.</p>
<p>La relacion entre <code>Ventana</code> y <code>VentanaImp</code> es un ejemplo del patron Brige. El proposito de este patron es permitir separar jerarquias de clases para que trabajen juntas incluso cuando ambas evolucionan de forma independiente. Nuestro criterio de diseño nos lleva a crear dos jerarquias de clases sesparadas, una que representa la nocion logica de ventana, y otra para representar diferentes implementaciones de ventanas. El patron Bridge nos permite mantener y mejorar nuestras abstracciones de ventanas sin tocar el codigo dependiente del sistema de ventanas, y a la inversa.</p>
</div>
<h3 id="2.7" >Operaciones de usuario</h3>
<div class="hBody-3" >
<p>Parte de la funcionalidad de Lexi esta disponible en la representacion WYSIWYG del documento. El usuario introduce y borra texto, mueve el punto de insercion y selecciona partes del texto mediente el raton o teclado directamente sobre el documento. A otras funciones se accede de manera indirecta a traves de operaciones de usuario de los menus desplegables, botones y atajos de teclado de Lexi. La funcionalidad incluye operaciones para</p>
<ul>
<li>
<p>crear un nuevo documento,</p>
</li>
<li>
<p>abrir, guardar e imprimir un documento existente,</p>
</li>
<li>
<p>cortar y pegar el texto seleccionado,</p>
</li>
<li>
<p>cambiar la fuente y el estilo del texto seleccionada,</p>
</li>
<li>
<p>cambiar el formateo del texto, como su alineacion y justificado,</p>
</li>
<li>
<p>salir de la aplicacion,</p>
</li>
<li>
<p>etcetera, etcetera.</p>
</li>
</ul>
<p>Lexi proporciona diferentes interfaces de usuario para llevar a cabo estas operaciones, pero no queremos asociar una determinada operacion de usuario con una interfaz en particular, ya que podemos querer tener varias interfaces de usuario para la misma operacion (por ejemplo, podemos pasar la pagina usando un boton o una operacion de menu). Tambien podemos querer cambiar la interfaz en un futuro.</p>
<p>Ademas, estas operaciones estan implementandasa en muchas clases distintas. Como programadores, queremos acceder a su funcionalidad sin crear muchas dependencias entre las clases de implementacion y de usuario. Si no, acabariamos por tener una implementacion fuertemente acoplada, que seria mas dificil de comprender, ampliar y mantener.</p>
<p>Para complicar mas las cosas, queremos que Lexi soporte operaciones de deshacer y repetir<span class="note" ><sup><a href="#20" >20</a></sup></span> para la mayoria de sus funciones, <em>pero no para todas</em>. En concreto, queremos ser capaces de deshacer operaciones que modifican el documento, como eliminar, con las que el usuario puede perder muchos datos sin darse cuenta. Sin embargo, no deberiamos intentar deshacer operaciones como guardar un dibujo o salir de la aplicacion. Estas operaciones no deberian tener efecto en el proceso de deshacer. Tampoco queremos un limite arbitrario en el numero de niveles de deshacer y repetir.</p>
<p>Esta claro que permitir operaciones de usuario es fundamental en la aplicacion. El objetivo es coseguir un mecanismo simple y extensible que satisfaga todas estas necesidades.</p>
</div>
<h4 id="encapsular-una-peticion" >Encapsular una peticion</h4>
<div class="hBody-4" >
<p>Desde nuestra perspectiva de diseñadores, un menu desplegable no es mas que otro tipo de glifo que contiene otros glifos. Lo que distingue a los menus desplegables de otros glifos que tienen hijos es que la mayoria de los glifos de los menus hacen alguna operacion en respuesta a un clic del raton.</p>
<p>Supongamos que estos glifos son instancias de una subclase de <code>Glifo</code> llamada <code>ElementoDeMenu</code> y que estos hacen su trabajo en respuesta a una peticion de un cliente<span class="note" ><sup><a href="#21" >21</a></sup></span>. Llevar a cabo la peticion puede implicar una operacion en un objeto, o muchas operaciones sobre muchos objetos, o algo entre medias.</p>
<p>Podriamos definir una subclase de <code>ElementoDeMenu</code> para cada operacion de usuario y luego codificar cada subclase para que realizase la peticion. Pero eso no es lo correcto: no necesitamos una subclase de <code>ElementoDeMenu</code> para cada peticion, de la misma manera que no necesitamos una subclase para cada cadena de texto de un menu desplegable. Es mas, este enfoque acopla la peticion a una interfaz de usuario determinada, haciendo que sea dificil satisfacer la peticion a travez de otro elemento de la interfaz.</p>
<p>Para ilustrar esto, supongamos que pudieramos avanzar a la ultima pagina del documento <em>tanto</em> con un elemento de menu <em>como</em> pulsando en un icono de la interfaz de Lexi (que puede ser mas conveniente para documentos cortos). Si asociamos la peticion con un <code>ElementoDeMenu</code> a traves de la herencia, tendremos que hacer lo mismo para el icono y cualquier otro tipo de util que pueda responder a dicha peticion. Esto puede dar lugar a un numero de clases cercano al producto del numero de tipos de utiles por el numero de peticiones.</p>
<p>Lo que falta es un mecanismo que nos permita parametrizar los elementos de menu con la peticion que deben llevar a cabo. De esa forma evitariamos la proliferacion de subclases y permitiriamos mas flexibilidad en tiempo de ejecucion. Podriamos parametrizar <code>ElementoDeMenu</code> con la funcion a llamar, pero eso no seria una buena solucion, por al menos tres razones:</p>
<ol class="num" >
<li>
<p>No soluciona el probelma deshacer/repetir.</p>
</li>
<li>
<p>Es dificil asociar el estado a una funcion. Por ejemplo, una funcion que cambia la fuente necesita saber <em>que</em> fuente cambiar.</p>
</li>
<li>
<p>Las funciones son dificiles de extender y es dificil reutilizar partes de ellas.</p>
</li>
</ol>
<p>Estas razones sugieren que deberiamos paramentrizar los elementos de menu con un <em>objeto</em>, y no con una funcion. De ese modo podriamos usar la herencia para ampliar y reutilizar la implementacion de la peticion, y tambien tendriamos un lugar donde almacenar el estado e implementar la funcionalidad de deshacer/repetir. Este es otro ejemplo de encapsulacion del concepto que varia, en este caso una peticion. Encapsularemos cada peticion en un objeto <b>orden</b>.<span class="note" ><sup><a href="#22" >22</a></sup></span></p>
</div>
<h4 id="clase-orden-y-sus-subclases" >Clase <code>Orden</code> y sus Subclases</h4>
<div class="hBody-4" >
<p>En primer lugar definiremos una clase abstracta <code>Orden</code> que proporciona una interfaz para emitir una peticion. La interfaz basica consiste en una unica operacion abstracta denominada <q>Ejecutar</q>. Las subclases de <code>Orden</code> implementan <code>Ejecutar</code> de distintas formas para satisfacer diferentes peticiones. Algunas subclases pueden delegar parte del trabajo, o todo, en otros objetos. Otras subclases pueden ser capaces de responder a la peticion por si solas (vease la <a href="#figura-2.11" >Figura 2.11</a>). No obstante, para el solicitante un objeto <code>Orden</code> no es mas que eso, un objeto <code>Orden</code> ––todos son tratados por igual––.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.11" >Figura 2.11</span>: Parte de la jeraquia de clases de <code>Orden</code></h1>
<figure>
<img src="img/021.png" />
</figure>
</div>
<p>Ahora <code>ElementoDeMenu</code> puede almacenar un objeto <code>Orden</code> que satisface una peticion (<a href="#figura-2.12" >Figura 2.12</a>). Le damos a cada objeto elemento de menu una instancia de la subclase de <code>Orden</code> que resulta apropiada para ese elemento, de la misma manera que especificamos el texto que aparecera en el. Cuando el usuario selecciona un elemento de menu en concreto, el correspondiente <code>ElementoDeMenu</code> simplemente llama a <code>Ejecutar</code> sobre su objeto <code>Orden</code> para realizar la peticion. Notese que los botones y otros utiles pueden usar objetos <code>Orden</code> igual que lo hacen los elementos del menu.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.12" >Figura 2.12</span>: Relacion entre <code>ElementoDeMenu</code> y <code>Orden</code></h1>
<figure>
<img src="img/022.png" />
</figure>
</div>
</div>
<h4 id="capacidad-de-deshacer23" >Capacidad de Deshacer<span class="note" ><sup><a href="#23" >23</a></sup></span></h4>
<div class="hBody-4" >
<p>Es importante que las aplicaciones interactivas cuenten con la capacidad de deshacer/repetir. Para deshacer y repetir ordenes, añadiremos una operacion <code>Deshacer</code> a la interfaz de <code>Orden</code>, que anula los efectos de la operacion <code>Ejecutar</code> precedente, usando la informacion que esta haya guardado. Por ejemplo, en el caso de una <code>OndenFuente</code>, la operacion <code>Ejecutar</code> deberia guardar la parte del texto a la que afecta el cambio de fuente junto con la fuente o fuentes originales. La operacion <code>Deshacer</code> de <code>OrdenFuente</code> devolveria el texto a su fuente original.</p>
<p>A veces la capacidad de deshacer tiene que ser establecida en tiempo de ejecucion. Una peticion para cambiar la fuente de una seleccion no hace nada si el texto ya aparece en esa fuente. Supongamos que el usuario selecciona parte del texto y realiza un cambio de fuente que no tiene ningun efecto. ¿Cual deberia ser el resultado de la siguiente peticion deshacer? ¿Un cambio sin sentido deberia causar que la peticion deshacer hiciera algo igualmente sin sentido? Probablemente no. Si el usuario repite ese cambio de fuente varias veces, no deberia tener que realizar exactamente el mismo numero de operaciones deshacer para regresar a la ultima operacion con sentido. Si el resultado final de ejecutar una orden fue nulo, entoces no hay necesidad de la correspodiente operacion deshacer.</p>
<p>Asi que para determinar si una orden se puede deshacer, añadiremos una operacion abstracta <code>Reversible</code> a la interfaz de <code>Orden</code>. Reversible devuelve un valor logico, y las subclases de <code>Orden</code> pueden redefinir esta operacion para devolver verdadero o falso basandose en criterios de tiempo de ejecucion.</p>
</div>
<h4 id="historial-de-ordenes" >Historial de Ordenes</h4>
<div class="hBody-4" >
<p>El paso final para soportar niveles arbitrarios de deshacer y repetir es definir un <b>historial de ordenes</b>, es decir, una lista de ordenes ejecutadas (y las anuladas). Conceptualmente, el hitorial de ordenes se parece a esto:</p>
<figure>
<img src="img/023.png" />
</figure>
<p>Cada circulo representa un objeto <code>Orden</code>. En este caso el usuario ha ejecutado cuatro ordenes. La de mas a la izquierda fue la primera que se ejecuto, seguida por la segunda de mas a la izquierda y asi sucesivamente hasta la orden mas recientemente ejecutada, que es la mas a la derecha. La linea etiquetada como <q>presente</q> lleva la cuenta de cual fue la ultima orden ejecutada (o anulada).</p>
<p>Para deshacer la ultima orden, simplemente llamaremos a <code>Deshacer</code> sobre la orden mas reciente:</p>
<figure>
<img src="img/024.png" />
</figure>
<p>Despues de la operacion de deshacer, movemos la linea <q>presente</q> una orden hacia la izquierda. Si el usuario elige de nuevo deshacer, se anulara la siguiente orden mas recientemente ejecutada de la misma manera que se hizo con esta, y nos encontraremos en el estado que se muestra a continuacion:</p>
<figure>
<img src="img/025.png" />
</figure>
<p>Puede observarse como simplemente repitiendo este procedimiento obtenemos multiples niveles de operaciones de deshacer. El numero de estos niveles solo esta limitado por la longitud del historial de ordenes.</p>
<p>Para repetir una orden que se acaba de deshacer, hacemos lo mismos pero a la inversa. Las ordenes a la derecha de la linea del presente son las que se pueden dashacer en un futuro. Para repetir la ultima orden anulada, llamamos a <code>Ejecutar</code> en la orden situada a la izquierda de la linea actual:</p>
<figure>
<img src="img/026.png" />
</figure>
<p>A continuacion movemos la linea del presente de manera que la siguiente operacion de repetir llamara a repetir sobre la siguiente orden en el futuro.</p>
<figure>
<img src="img/027.png" />
</figure>
<p>Por supuesto, si la siguiente operacion no es otro repetir, sino un deshacer, entonce se anulara la <em>orden</em> a la izquierda de la linea <q>presente</q>. De esta manera el usuario puede ir hacia adelante y hacia atras en el tiempo tanto como sea necesario para recuperarse de los errores.</p>
</div>
<h4 id="patron-command-(orden)" >Patron Command (Orden)</h4>
<div class="hBody-4" >
<p>Las ordenes de Lexi son una aplicacion del patron <a href="#command" >Command</a>, el cual describe como encapsular una peticion. El patron Command prescribe una interfaz uniforme para emitir peticiones que permite configurar los clientes para que traten diferentes peticiones. La interfaz oculta a los clientes la implementacion de las peticiones. Una orden puede delegar toda la implementacion de la peticion, parte de ella o nada en otros objetos. Esto es perfecto para aplicaciones como Lexi, que deben proporcionar un acceso centralizado a la funcionalidad que se encuentra desperdigada por toda la aplicacion. El patron tambien trata los mecanismos de deshacer y repetir incorporados en la interfaz basica de <code>Orden</code>.</p>
</div>
<h3 id="2.8" >Revision ortografica e insercion de guiones<span class="note" ><sup><a href="#24" >24</a></sup></span></h3>
<div class="hBody-3" >
<p>El ultimo problema de diseño tiene que ver con el analisis del texto, en concreto con la revision ortografica y la introduccion de puntos de insercion de guiones donde sea necesario para lograr un buen formateado.</p>
<p>Las restricciones son similares a las que tuvimos en el problema de diseño del formateado, en la <a href="#2.3" >Seccion 2.3</a>. Al igual que con las estrategias de division de lineas, hay mas de una manera de revisar la ortografia y de calcular los puntos donde se pueden insertar guiones de separacion. Por tanto, aqui tambien queremos permitir multiples algoritmos. Un conjunto de algoritmos puede proporcionar una eleccion de compromiso entre espacio/tiempo/calidad.</p>
<p>Tambien queremos evitar implementar esta funcionalidad en la estructura del documento. Este objetivo es incluso mas importante aqui que en el caso del formateado, ya que la revision ortografica y la insercion de guiones son solo dos de todos los tipos potenciales de analisis que podemos querer que permita Lexi. Sin duda, querremos ampliar las capacidades analiticas de Lexi con el tiempo. Podemos añadir busquedas, herramientas de contar palabras, una utilidad de calculo para sumar los valores de una tabla, revision gramatical, etcetera. Pero no queremos cambiar la clase <code>Glifo</code> y todas sus subclases cada vez que introducimos nuevas funcionalidades de este tipo.</p>
<p>Este rompecabezas lo forman en realidad dos piezas: (1) acceder a la informacion que va a ser analizada, que se encuentra repartida entre los glifos de la estructura del docuemento, y (2) hacer el analisis. Veamos ambas piezas por separado</p>
</div>
<h4 id="acceder-a-informacion-dispersa" >Acceder a informacion dispersa</h4>
<div class="hBody-4" >
<p>Hay muchos tipos de analisis que requieren examinar el texto caracter a caracter. El texto a analizar esta repartido en una estructura jerarquica de objetos glifo. Para axeminar el texto en dicha estructura necesitamos un mecanismo de acceso que conozca las estructuras de datos en las que se almacenan los objetos. Algunos glifos pueden almacenar sus hijos en listas enlazadas, otros tal vez usen arrays, y otros pueden usar estructuras de datos mas extrañas. Nuestro mecanismo de acceso debe ser capaz de tratar con todas estas posibilidades.</p>
<p>Una complicacion añadida es que los diferentes analisis acceden a la informacion de diferentes formas. La mayoria de los analisis recorreran el texto de pricipo a fin, pero algunos haran lo contrario ––una busqueda hacia atras, por ejemplo, necesita examinar hacia atras en vez de hacia delante––. Otras operaciones, como la evaluacion de expresiones algebraicas, podrian necesitar un recorrido en-orden.</p>
<p>Por tanto, nuestro mecanismo de acceso se tiene que acomodar a diferentes estructuras de datos y debemos permitir diferentes tipos de recorridos, como pre-orden y en-orden.</p>
</div>
<h4 id="encapsular-el-acceso-y-el-recorrido" >Encapsular el acceso y el recorrido</h4>
<div class="hBody-4" >
<p>Por ahora nuestra interfaz de glifo usa un indice entero para que los clientes se refieran a sus hijos. Si bien esto puede ser razonable para las clases de glifo que almacenan sus hijos en una array, puede ser ineficiente para glifos que utilizan una lista enlazada. Un papel importante de la abstraccion de glifo es ocultar la estructura de datos en la que se almacenan los hijos. De ese modo podemos  cambiar la estructura de datos de un glifo sin que esto afecte a otras clases.</p>
<p>Por tanto, solo el glifo puede saber la estructura de datos que usa. Como corolario, la interfaz de glifo no deberia orientarse hacia una estructura de datos u otra; no deberia adecuacuarse mejor a arrays que a listas enlazadas, por ejemplo.</p>
<p>Podemos solucionar este problema y permitir diferentes tipos de recorridos al mismo tiempo. Podemos poner diferentes capacidades de acceso y recorrido directamente en las clases glifo y proporcionar un modo de elegir entre ellas, tal ves mediante una constante enumerada como parametro. Las clases se pasarian este parametro de unas a otras durante un recorrido para garantizar que estan haciendo el mismo tipo de recorrido. Tambien deben pasar cualquier informacion acumulada durante el recorrido.</p>
<p>Podriamos añadir las siguientes operaciones abstractas a la interfaz de Glifo para permitir este enfoque:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="nf">Primero</span><span class="p">(</span><span class="n">Recorrido</span> <span class="n">tipo</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">Siguiente</span><span class="p">();</span>
<span class="kt">bool</span> <span class="nf">HaTerminado</span><span class="p">();</span>
<span class="n">Glifo</span><span class="o">*</span> <span class="nf">ObtenerActual</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">Insertar</span><span class="p">(</span><span class="n">Glifo</span><span class="o">*</span><span class="p">);</span>
</code></pre>
<p>Las operaciones <code>Primero</code>, <code>Siguiente</code> y <code>HaTerminado</code> controlan el recorrido. <code>Primero</code> lo inicializa. Recibe el tipo de recorrido como un parametro de tipo <code>Recorrido</code>, una constante enumerada que tiene valores tales como <code>HIJOS</code> (para recorrer solo los hijos directos del glifo), <code>PREORDEN</code> para recorrer la estructura completa en preorden), <code>POSTORDEN</code> y <code>ENORDEN</code>. <code>Siguiente</code> avanza hasta el siguiente glifo del recorrido, y <code>HaTerminado</code> informa si el recorrido ha terminado o no. <code>ObtenerActual</code> sustituye a la operacion <code>Hijo</code>, y accede al glifo actual del recorrido. <code>Insertar</code> substituye la operacion antigua, insertando el glifo dado en la poscion actual.</p>
<p>Un analisis usaria el siguiente codigo C++ para hacer un recorrido preorden de una estructura de glifos que tiene como raiz <code>g</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">Glifo</span><span class="o">*</span> <span class="n">g</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">Primero</span><span class="p">(</span><span class="n">PREORDEN</span><span class="p">);</span> <span class="o">!</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">HaTerminado</span><span class="p">();</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">Siguiente</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Glifo</span><span class="o">*</span> <span class="n">actual</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">ObtenerActual</span><span class="p">();</span>

  <span class="c1">// hace algun analisis
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Notese como ha desaparecido el indice entero de la interfaz de glifo. Ya no hay nada que predisponga la interfaz hacia un tipo de coleccion u otra. Tambien les ahorramos a los clientes tener que implementar ellos mismos algunos tipos de recorridos habituales.</p>
<p>Pero este enfoque sigue teniendo problemas. Por un lado, no pueden permitir nuevo recorridos sin ampliar el conjunto de valores enumerados o sin añadir nuevas operaciones. Supongamos que queremos una variacion de un recorrido preorden que se salte automaticamente glifos no textuales. Tendriamos que cambiar la enumeracion <code>Recorrido</code> para incluir algo como <code>PREORDEN_TEXTUAL</code>.</p>
<p>Nos gustaria no tener que cambiar las declaraciones existentes. Poner todo el mecanismo de recorrido en la jerarquia de la clase <code>Glifo</code> haria que fuese dificil modificarlo o ampliarso sin cambiar a su vez muchas otras clases. Tambien seria dificil reutilizar el mecanismo para recorrer otros tipos de estructuras de objetos. Y no podemos hacer mas de un recorrido a la vez sobre la misma estructura.</p>
<p>Una solucion mejor es, de nuevo, encapsular el concepto que varia, en este caso los mecanismos de acceso y recorrido. Podemes introducir una clase de objetos llamados <code>Iteradores</code>, cuyo unico proposito es definir diferentes tipos de tales mecanismos. Podemos usar la herencia para poder acceder a estructuras de datos diferentes de una manera uniforme, asi como permitir nuevos tipos de recorridos. Y no tendriamos que cambiar las interfaces de los glifos o tocar sus implementaciones para hacerlo.</p>
</div>
<h4 id="clase-iterador-y-sus-subclases" >Clase <code>Iterador</code> y sus subclases</h4>
<div class="hBody-4" >
<p>Usaremos una clase abstracta llamada <code>Iterador</code> para definir una interfaz general que permita recorrer una estructura de objetos y acceder a cada uno de sus elementos. Las subclases concretas como <code>IteradorArray</code> o <code>IteradorLista</code> implementan la interfaz para proporcionar acceso a arrays y listas, mientras que <code>IteradorPreorden</code>, <code>IteradorPostorden</code> y similares implementan diferentes recorridos sobre determinadas estructuras. Cada subclase de <code>Iterador</code> tiene una referencia a la estructura que recorre. Las instancias de estas subclases se inicializan con dicha referencia cuando se crean. La Figura 2.13 muestra la clase <code>Iterador</code> junto con varias subclases. Notese que hemos añadido una operacion abstracta <code>CrearIterador</code> a la interfaz de la clase <code>Glifo</code> para dar cabida a los iteradores.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-2.13" >Figura 2.13</span>: Clase <code>Iterador</code> y sus subclases</h1>
<figure>
<img src="img/028.png" />
</figure>
</div>
<p>La interfaz <code>Iterador</code> provee las operaciones <code>Primero</code>, <code>Siguiente</code> y <code>HaTerminado</code> para controlar el recorrido. La clase <code>IteradorLista</code> implementa <code>Primero</code> para que apunte al primer elemento de la lista, y <code>Siguiente</code> hace avanzar al iterador hasta el siguiente elemento de la lista. <code>HaTerminado</code> devuelve si el puntero de la lista apunta mas alla del ultimo elemento de la lista. <code>ElementoActual</code> desreferencia el iterador para devolver el glifo al que apunta. Una clase <code>IteradorArray</code> haria cosas similares pero sobre un array de glifos.</p>
<p>Ahora podemos acceder a los hijos de una estructura de glifos sin conocer su representacion:</p>
<pre class="code" ><code class="chroma" ><span class="n">Glifo</span><span class="o">*</span> <span class="n">g</span><span class="p">;</span>
<span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Glifo</span><span class="o">*&gt;*</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">CrearIterador</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">Primero</span><span class="p">();</span> <span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">HaTerminado</span><span class="p">();</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">Siguiente</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Glifo</span><span class="o">*</span> <span class="n">Hijo</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">ElementoActual</span><span class="p">();</span>

  <span class="c1">// hace algo con el hijo actual
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p><code>CrearIterador</code> devuelve, de manera predeterminada, una instancia de <code>IteradorNulo</code>. Un <code>IteradorNulo</code> es un iterador degenerado para glifos que no tiene ningun hijo, es decir, para los glifos hoja. La operacion <code>HaTerminado</code> de un <code>IteradorNulo</code> siempre devuelve verdadero.</p>
<p>Una subclase de glifo que tiene hijos redefinira <code>CrearIterador</code> para devolver una instancia de una subclase de <code>Iterador</code> diferente. La subclase concreta depende de la estructura donde se guardan los hijos. Si la subclase de <code>Glifo</code>, <code>Fila</code>, guarda sus hijos en una lista <code>_hijos</code>, entonces su operacion <code>CrearIterador</code> se paracera a esto:</p>
<pre class="code" ><code class="chroma" ><span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Glifo</span><span class="o">*&gt;*</span> <span class="n">Fila</span><span class="o">::</span><span class="n">CrearIterador</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Glifo</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_hijos</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Los iteradores para recorridos preorden y enorden se implimentan en terminos de iteradores especificos de glifos. Los iteradores para estos recorridos son proporcionados por el glifo raiz de la estructura que recorren. Llaman a <code>CrearIterador</code> sobre los glifos de la estructura y usan una pila para guardar los iteradores resultantes.</p>
<p>Por ejemplo, la clase <code>IteradorPreorden</code> obtiene el iterador de glifo raiz, lo inicializa para que apunte a su primer elemento y luego lo mete en la pila:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">IteradorPreorden</span><span class="o">::</span><span class="n">Primero</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Glifo</span><span class="o">*&gt;*</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_raiz</span><span class="o">-&gt;</span><span class="n">CrearIterador</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">i</span><span class="o">-&gt;</span><span class="n">Primero</span><span class="p">();</span>
    <span class="n">_iteradores</span><span class="p">.</span><span class="n">BorrarTodos</span><span class="p">();</span>
    <span class="n">_iteradores</span><span class="p">.</span><span class="n">Meter</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><code>ElementoActual</code> simplemente llamaria a <code>ElementoActual</code> del iterador de la cima de la pila:</p>
<pre class="code" ><code class="chroma" ><span class="n">Glifo</span><span class="o">*</span> <span class="n">IteradorPreorden</span><span class="o">::</span><span class="n">ElementoActual</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span>
    <span class="n">_iteradores</span><span class="p">.</span><span class="n">Tamano</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span>
    <span class="n">_iteradores</span><span class="p">.</span><span class="n">Cima</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ElementoActual</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>La operacion <code>Siguiente</code> devuelve el iterador de la cima de la pila y le pide a su elemento actual que cree un iterador, en un intento de descender en la estructura de glifos tanto como sea posible (despues de todo, en esto consiste un recorrido en preorden). <code>Siguiente</code> hace que el nuevo iterador apunte al primer elemento a recorrer y lo mete en la pila. Despues, <code>Siguiente</code> comprueba el ultimo iterador; si su operacion <code>HaTerminado</code> devuelve verdadero significa que hemos terminado de recorrer el subarbol (o la hoja) actual. En ese caso, <code>Siguiente</code> saca el iterador de la cima de la pila y repite este proceso hasta que encuentra el siguiente recorrido incompleto, si es que hay alguno; si no, es que hemos terminado de recorrer la estructura.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">IteradorPreorden</span><span class="o">::</span><span class="n">Siguiente</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Glifo</span><span class="o">*&gt;*</span> <span class="n">i</span> <span class="o">=</span>
    <span class="n">_iteradores</span><span class="p">.</span><span class="n">Cima</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ElementoActual</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">CrearIterador</span><span class="p">();</span>

  <span class="n">i</span><span class="o">-&gt;</span><span class="n">Primero</span><span class="p">();</span>
  <span class="n">_iteradores</span><span class="p">.</span><span class="n">Meter</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">_iteradores</span><span class="p">.</span><span class="n">Tamano</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">_iteradores</span><span class="p">.</span><span class="n">Cima</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">HaTerminado</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">_iteradores</span><span class="p">.</span><span class="n">Sacar</span><span class="p">();</span>
    <span class="n">_iteradores</span><span class="p">.</span><span class="n">Cima</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Siguiente</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Notese como la clase <code>Iterador</code> nos permite añadir nuevos tipos de recorridos sin modificar las clases de glifos, simplemente heredamos de <code>Iterador</code> y añadimos un nuevo recorrido, como hemos hecho con <code>IteradorPreorden</code>. Las subclases de <code>Glifo</code> usan la misma interfaz para dar a los clientes acceso a sus hijos sin revelar la estructura de datos subyacente que usan para almacenarlos. Como los iteradores guardan su propia copia del estado del recorrido podemos realizar varios recorridos simultaneamente, incluso sobre la misma estructura. Y aunque los recorridos que hemos hecho en este ejemplo han sido sobre estructuras de glifos, no hay nunguna razon por la que no podamos parametrizar una clase como <code>IteradorPreorden</code> con el tipo de objeto de la estructura. En C++ lo hariamos mediante plantillas. Acto seguido podriamos reutilizar el mecanismo de <code>IteradorPreorden</code> para recorrer otras estructuras.</p>
</div>
<h4 id="patron-iterator-(iterador)" >Patron Iterator (Iterador)</h4>
<div class="hBody-4" >
<p>El patron <a href="#iterator" >Iterator</a> representa estas tecnicas para permitir recorrer estructuras de objetos y acceder a sus elementos. No solo se puede aplicar a estructuras compuestas, sino tambien a colecciones. Abstrae el algoritmo de recorrido y oculta a los clientes la estructura interna de los objetos que recorre. El patron <code>Iterator</code> ilustra, una vez mas, como al encapsular el concepto que varia ganamos en flexibilidad y reutilizacion. Incluso asi, el problema de la iteracion es sorprendentemente complejo, y el patron Iterator tiene muchos mas matices y ventajas e inconvenientes que los que hemos considerado aqui.</p>
</div>
<h4 id="recorrido-y-acciones-del-recorrido" >Recorrido y acciones del recorrido</h4>
<div class="hBody-4" >
<p>Ahora que tenemos un modo de recorrer la estructura de glifos, necesitamos comprobar la ortografia y la insercion de guiones de separacion. Ambos analisis implican acumular informacion durante el recorrido.</p>
<p>En primer lugar tenemos que decidir donde poner la responsabilidad del analisis. Podriamos ponerla en las clases <code>Iterador</code>, haciendo asi al analisis una parte integral del recorrido. Pero tendremos mucha mas flexibilidad y posibilidad de reutilizacion si diferenciamos entre el recorrido y las acciones a realizar durante dicho recorrido. Eso es debido a que distintos analisis muchas veces requieren el mismo tipo de recorrido . De hay que podamos reutilizar el mismo conjunto de iteradores para diferentes analisis. Por ejemplo, el recorrido en preorden es comun a muchos analisis, incluyendo la revision ortografica, la separacion de palabras mediante guiones, la busqueda hacia delante y el recuento de palabras.</p>
<p>Por tanto habria que separar el analisis y el recorrido. ¿En que otro lugar podemos poner la responsabilidad del analisis? Sabemos que hay muchos tipos de analisis que podemos querere hacer. Cada analisis hara diferentes cosas en distintos puntos del recorrido. Algunos glifos son mas significativos que otros, dependiendo del tipo de analisis. Si estamos comprobando la ortografia o la insercion de guiones, querremos tener en cuenta los glifos de caracter y no los graficos, como lineas o imagenes de mapas de bits. Si estamos haciendo separaciones de color, nos interesan los glifos visibles y no los invisibles. Es inevitable que haya analisis diferentes para glifos diferentes.</p>
<p>Por tanto, un determinado analisis debe ser capaz de distinguir diferentes tipos de glifos. un enfoque obvio es poner la capacidad analitica en las propias clases glifo. Para cada analisis podemos añadir una o mas operaciones abstractas a la clase <code>Glifo</code> y tener subclases que las implementen segun el papel que cada una desepeñe en el analisis.</p>
<p>Pero el problema de ese enfoque es que tendremos que cambiar cada clase glifo cada vez que añadamos un nuevo tipo de analisis. Podemos paliar este problema en algunos casos: si en el analisis participan unas pocas clases, o si la mayoria de las clases hacen el analisis de la misma manera, podemos proporcionar una implementacion predeterminada para la operacion abstracta en la clase <code>Glifo</code>. La operacion predeterminada cubriria asi el caso general. De esa manera limitariamos los cambios a la clase <code>Glifo</code> y a aquellas subclases que se aparten de la norma general</p>
<p>Si bien una implementacion predeterminada reduce el numero de cambios, todavia permanece un problema insidioso: la interfaz de <code>Glifo</code> se expande con cada nueva capacidad de analisis. A medida que pase el tiempo las operaciones de analisis comenzaran a oscurecer la interfaz basica de <code>Glifo</code>, haciendo dificil ver que el principal proposito de un glifo es definir una estructura de objetos que tienen apariencia y forma (esa interfaz se pierde entre el ruido).</p>
</div>
<h4 id="encapsular-el-analisis" >Encapsular el analisis</h4>
<div class="hBody-4" >
<p>Segun todos los indicios, necesitamos encapsular el analisis en un objeto aparte, de forma similar a como hemos hecho muchas veces hasta ahora. De ese modo podriamos todos los mecanismos de un determinado analisis en su propia clase. Podriamos usar una instancia de esta clase en conjuncion con el iterador apropiado. El iterador <q>llevaria</q> la instancia a cada glifo de la estructura. Este objeto podria entonces realizar una porcion del analisis en cada punto del recorrido. El analizador acumula informacion de interes (caracteres en este caso) a medida que avanza el recorrido</p>
<figure>
<img src="img/029.png" />
</figure>
<p>La cuestion fundamental con este enfoque es como distingue el objeto de analisis los tipos de glifos sin recurrir a comprobaciones de tipo o conversiones a un tipo inferior (<em>downcast</em>). No queremos una clase <code>RevisorOrtografico</code> que incluya (pseudo)codigo como</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">RevisorOrtografico</span><span class="o">::</span><span class="n">Revisar</span> <span class="p">(</span><span class="n">Glifo</span><span class="o">*</span> <span class="n">glifo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Caracter</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">Fila</span><span class="o">*</span> <span class="n">f</span><span class="p">;</span>
  <span class="n">Imagen</span><span class="o">*</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Caracter</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">glifo</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// analizar el caracter
</span><span class="c1"></span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Fila</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">glifo</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// se prepara para analizar sus hijos
</span><span class="c1"></span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Imagen</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">glifo</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// no hace nada
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Este codigo es bastante feo. Se basa en caracteristicas bastante esotericas como los ahormados de tipo seguros. Tambien resulta dificil de ampliar. Tendremos que recordar cambiar el cuerpo de esta funcion cada vez que cambiemos de jerarquia de la clase <code>Glifo</code>. De hecho, esta es la clase de codigo que los lenguajes orientados a objetos trataban de eliminar.</p>
<p>Queremos evitar tal enfoque basado en la fuerza bruta, pero ¿como? Pensemos que sucede cuando añadimos la siguiente operacion abstracta a la clase <code>Glifo</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Revisame</span><span class="p">(</span><span class="n">RevisorOrtografico</span><span class="o">&amp;</span><span class="p">)</span>
</code></pre>
<p>Definimos <code>Revisame</code> en cada subclase de <code>Glifo</code> como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">SubclaseGlifo</span><span class="o">::</span><span class="n">Revisame</span> <span class="p">(</span><span class="n">RevisorOrtografico</span><span class="o">&amp;</span> <span class="n">revisor</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">revisor</span><span class="p">.</span><span class="n">RevisarSubclaseGrifo</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>donde <code>SubclaseGlifo</code> sera reemplazada por el nombre da la subclase del glifo. Notese que cuando se llama a <code>Revisame</code>, se conoce la subclase concreta de <code>Glifo</code> ––despues de todo, estamos en una de sus operaciones––. A su vez, la interfaz de la clase <code>RevisorOrtorgrafico</code> incluye una operacion como <code>RevisarSubclaseGlifo</code> para cada subclase de <code>Glifo</code>.<span class="note" ><sup><a href="#25" >25</a></sup></span></p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">RevisorOrtografico</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">RevisorOrtografico</span><span class="p">();</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">RevisarCaracter</span><span class="p">(</span><span class="n">Caracter</span><span class="o">*</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">RevisarFila</span><span class="p">(</span><span class="n">Fila</span><span class="o">*</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">RevisarImagen</span><span class="p">(</span><span class="n">Imagen</span><span class="o">*</span><span class="p">);</span>

  <span class="c1">// ... etcetera
</span><span class="c1"></span>
  <span class="n">Lista</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;&amp;</span> <span class="n">ObtenerErroresOrtograficos</span><span class="p">();</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">EstaMalEscrito</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">char</span> <span class="n">_palabraActual</span><span class="p">[</span><span class="n">MAX_TAM_PALABRA</span><span class="p">];</span>
  <span class="n">Lista</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span> <span class="n">_errores</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>La operacion del <code>RevisorOrtografico</code> para glifos de <code>Caracter</code> puede parecerse a esto:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">RevisorOrtografico</span><span class="o">::</span><span class="n">RevisarCaracter</span> <span class="p">(</span><span class="n">Caracter</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ObtenerCodigoDeCaracter</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// añade el caracter alfabetico a _palabraActual
</span><span class="c1"></span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// hemos encontrado un glifo que no es un caracter
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EstaMalEscrito</span><span class="p">(</span><span class="n">_palabraActual</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// añade la _palabraActual a _errores
</span><span class="c1"></span>      <span class="n">_errores</span><span class="p">.</span><span class="n">Insertar</span><span class="p">(</span><span class="n">strdup</span><span class="p">(</span><span class="n">_palabraActual</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">_palabraActual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa"></span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>

    <span class="c1">// inicializa _parablaActual para comprobar
</span><span class="c1"></span>    <span class="c1">// la siguiente palabra
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Notese que hemos definido una operacion especial <code>ObtenerCodigoDeCaracter</code> en la clase <code>Caracter</code>. El revisor gramatical puede tratar con operaciones especificas de las subclases sin depender de comprobaciones de tipo o ahormados ––nos permite tratar a los objetos de forma especial––.</p>
<p><code>RevisarCaracter</code> acumula caracteres alfabeticos en el bufer <code>_palabraActual</code>.<span class="note" ><sup><a href="#26" >26</a></sup></span> Cuando encuentra un caracter no alfabetico, como un guion de subrayado, hace uso de la operacion <code>EstaMalEscrito</code> para comprobar la ortografia de la palabra que esta en <code>_palabraActual</code>. Si la palabra esta mal escrita, <code>RevisarCaracter</code> la añade a la lista de palabras mal escritas. A continuacion debe vaciar el bufer <code>_palabraActual</code> para dejarlo listo para la siguiente palabra. Cuando termina el recorrido, se puede obtener la lista de palabras mal escritas con la operacion <code>ObtenerErroresOrtograficos</code>.</p>
<p>Ahora podemos recorrer la estructura, llamando a <code>Revisame</code> sobre cada glifo, con el revisor gramatical como argumento. Esto permite al <code>RevisorOrtografico</code> identificar a cada glifo.</p>
<pre class="code" ><code class="chroma" ><span class="n">RevisorOrtografico</span> <span class="n">revisorOrtografico</span><span class="p">;</span>
<span class="n">Composicion</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>

<span class="c1">// ...
</span><span class="c1"></span>
<span class="n">Glifo</span><span class="o">*</span> <span class="n">g</span><span class="p">;</span>
<span class="n">IteradorPreorden</span> <span class="nf">i</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">Primeno</span><span class="p">();</span> <span class="o">!</span><span class="n">i</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">g</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">();</span>
  <span class="n">g</span><span class="o">-&gt;</span><span class="n">Revisame</span><span class="p">(</span><span class="n">revisorOrtografico</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>El siguiente diagrama de interaccion muestra como trabajan juntos los glifos de <code>Caracter</code> y el objeto <code>RevisorOrtografico</code>:</p>
<figure>
<img src="img/030.png" />
</figure>
<p>Este enfoque nos sirve para encontrar errores gramaticales, pero ¿como nos ayuda a permitir multiples tipos de analisis? Parece como si tuvieramos que añadir una operacion como <code>Revisame(RevisorOrtografico&amp;)</code> a <code>Glifo</code> y sus subclases cada vez que añadamos un nuevo tipo de analisis. Esto es cierto si insistimos en una clase <em>independiente</em> para cada analisis. Pero no hay ningun motivo que nos impida dar la misma interfaz a <em>todas</em> las clases de analisis. Al hacerlo asi podemos usarlas polimorficamente. Eso significa que podemos reemplazar operaciones especificas de cada analisis como <code>Revisame(RevisorOrtografico&amp;)</code> con una operacion independiente del analisis que tome un parametro mas general.</p>
</div>
<h4 id="clase-visitante-y-sus-subclases" >Clase <code>Visitante</code> y sus subclases</h4>
<div class="hBody-4" >
<p>Usaremos el termino <b>visitante</b> para referirnos generalmente a clases de objetos que <q>visitan</q> otros objetos durante un recorrido y hacen algo apropiado.<span class="note" ><sup><a href="#27" >27</a></sup></span> En este caso podemos definir una clase <code>Visitante</code> con una interfaz abstracta para visitar glifos en una estructura.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Visitante</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">VisitarCaracter</span><span class="p">(</span><span class="n">Caracter</span><span class="o">*</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">VisitarFila</span><span class="p">(</span><span class="n">Fila</span><span class="o">*</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">VisitarImagen</span><span class="p">(</span><span class="n">Imagen</span><span class="o">*</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// ... etcetera
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>Las subclases concretas de <code>Visitante</code> realizan distintos analisis. Por ejemplo, podriamos tener una subclase <code>VisitanteRevisionOrtografica</code> para comprobar la ortografia, y una subclase <code>VisitanteSeparacionGuiones</code> para la division de las palabras con guiones al final de la linea. <code>VisitanteRevisionOrtografica</code> se implementaria exactamente como implementamos antes el <code>RevisorOrtografico</code>, salvo los nombres de la operacion, que reflejarian la interfaz mas general de <code>Visitante</code>. Por ejemplo, <code>RevisarCaracter</code> se llamaria <code>VisitarCaracter</code>.</p>
<p>Como <code>Revisame</code> no resulta apropiado para los visitantes que no comprueban nada, le daremos un nombre mas general: <code>Aceptar</code>. Su argumento tambien tiene que cambiar para recibir un <code>Visitante&amp;</code>, reflejando el hecho de que puede aceptar cualquier visitante. Ahora, para añadir un nuevo analisis basta con definir una nueva subclase de <code>Visitante</code> ––no tenemos que tocar ninguna de las clases glifo––. Añadiendo la citada operacion a <code>Glifo</code> y sus subclases permitimos cualquier analisis futuro.</p>
<p>Ya hemos visto como funciona la revision ortografica. Usaremos un enfoque similar en <code>VisitanteSeparacionGuiones</code> para acumular texto. Pero una vez que la operacion <code>VisitarCaracter</code> de <code>VisitanteSeparacionGuiones</code> ha ensamblado una palabra completa, funciona algo diferente. En vez de comprobar la ortografia de la palabra, aplica un algoritmo de separacion de silabas para adeterminar los puntos potenciales de insercion de guiones en la palabra, si es que hay alguno. Entonces, en cada punto de insercion de guiones, inserta un glifo discrecional en la composicion. Los glifos discrecionales son instancias de <code>Discrecional</code>, una subclase de <code>Glifo</code>.</p>
<p>Un glifo discrecional tiene dos apariencias posibles, dependiendo de si es o no el ultimo caracter de una linea. Si es el ultimo caracter, entonces se representa como un guion; si no, no tiene ninguna representacion. El glifo discrecional comprueba su padre (un objeto <code>Fila</code>) para ver si es el ultimo hijo. Hace  esta operacion cada vez que es llamado para que dibuje o calcule sus limites. La estrategia de formateado trata a los glifos discrecionales como a los espacios en blanco, haciendolos candidatos para terminar una linea. El siguiente diagrama muestra como puede aparcer un glifo discrecional insertado.</p>
<figure>
<img src="img/031.png" />
</figure>
</div>
<h4 id="patron-visitor-(visitante)" >Patron Visitor (Visitante)</h4>
<div class="hBody-4" >
<p>Lo que se ha descrito hasta aqui es una aplicacion del patron <a href="#visitor" >Visitor</a>. La clase <code>Visitante</code> que se describio anteriormente y sus subclases son los participantes clave del patron. El patron Visitor representa la tecnica que hemos usado para permitir un numero indefinido de analisis de estructuras de glifos sin tener que cambiar las propias clases de los distintos glifos. Otra caracteristica interesante de los visitantes es que se pueden aplicar no solo a elementos compuestos como nuestras estructuras de glifos, sino a cualquier estructura de objetos. Eso incluye conjuntos, listas e incluso grafos dirigidos aciclicos. Es mas, las clases que puede visitar un visitante no necesitan estar relacionadas unas con otras por medio de una clase padre comun. Esto significa que los visitantes pueden funcionar en varias jerarquias de clases.</p>
<p>Una cuestion importante que debemos preguntarnos antes de aplicar el patron Visitor es: ¿que jerarquias de clases cambian mas frecuentemente? El patron resulta mas apropiado cuando queremos ser capaces de realizar varias operaciones diferentes sobre unos objetos que tienen una estructura de clases estable. Añadir un nuevo tipo de visitante no requiere ningun cambio en la estructura de clases, lo que es especialmente importante cuando la estructura de clases es grande. Pero cada vez que se añade una subclase a la estructura, tambien habra que actualizar todas nuestras interfaces de visitantes para incluir una operacion <code>Visitar</code>... para cada subclase. en nuestro ejemplo, eso significa que añadir una nueva subclase de <code>Glifo</code> llamada <code>Foo</code> requerira cambiar <code>Visitante</code> y todas sus subclases para que incluyan una operacion <code>VisitarFoo</code>. Pero, dadas las restricciones de nuestro diseño, es mucho mas probable que añadamos nuevos tipos de analisis a Lexi que un nuevo tipo de Glifo. De manera que el patron Visitor resulta apropiado para nuestras necesidades.</p>
</div>
<h3 id="2.9" >Resumen</h3>
<div class="hBody-3" >
<p>Hemos aplicado ocho patrones diferentes al diseño de Lexi:</p>
<ol class="num" >
<li>
<p><a href="#composite" >Composite</a> para representar la estructura fisica del documento</p>
</li>
<li>
<p><a href="#strategy" >Strategy</a> para permitir diferentes tipos de algoritmos de formateado,</p>
</li>
<li>
<p><a href="#decorator" >Decorator</a> para adornar la interfaz de usuario,</p>
</li>
<li>
<p><a href="#abstract-factory" >Abstract Factory</a> para permitir multiples estandares de interfaz de usuario,</p>
</li>
<li>
<p><a href="#bridge" >Bridge</a> para permitir diferentes platafarmas de ventanas,</p>
</li>
<li>
<p><a href="#command" >Command</a> para deshacer operaciones de usuario,</p>
</li>
<li>
<p><a href="#iterator" >Iterator</a> para recorrer estructuras de objetos y acceder a sus elemenentos, y</p>
</li>
<li>
<p><a href="#visitor" >Visitor</a> para permitir un numero indeterminado de capacidades de analisis sin complicar la implementacion de la estructura del documento.</p>
</li>
</ol>
<p>Ninguno de estos problemas de diseño se reduce a aplicaciones de edicion de documentos como Lexi. De hecho, la mayoria de aplicaciones no triviales tendran ocasion de usar muchos de estos patrones, aunque tal vez para hacer cosas diferentes. Una aplicacion de analisis financiero podria usar el patron Composite para definir carteras de inversiones formadas por subcarteras y cuentas de diferentes tipos. Un compilador podria usar el patron Strategy para permitir diferentes esquemas de asignacion de registros para diferentes maquinas de destino. Las aplicaciones con una interfaz grafica probablemente aplicaran al menos los patrones Decorator y Command tal y como hemos hecho aqui.</p>
<p>Aunque hemos cubierto varios problemas importantes de diseño de Lexi, hay mucho otros que no hemos discutido. Este libro describe mas de los ocho patrones que hemos usado aqui. Asi que a medida que estudie el resto de patrones, piense como podria usar cada uno de ellos en Lexi. O, mejor aun, ¡piense como utilizarlos en sus propios diseños!</p>
</div>
<h2 id="catalogo-de-patrones-de-diseño" >Catalogo de Patrones de Diseño</h2>
<h2 id="capitulo-3" >Patrones de Creacion</h2>
<div class="hBody-2" >
<p>Los patrones de diseño de creacion abstraen el proceso de creacion de instancias. Ayudan a hacer a un sistema independiente de como se crean, se componen y se representan sus objetos. Un patron de creacion de clases usa la herencia para cambiar la clase de la instancia a crear, mientras que un patron de creacion de objetos delega la creacion de la instancia en otro objeto.</p>
<p>Los patrones de creacion se hacen mas importantes a medida que los sistemas evolucionan para depender mas de la composicion de objetos que de la herencia de clases. Cuando esto sucede, se pasa de codificar una serie de comportamientos fijos a definir un conjunto mas pequeño de comportamientos fundamentales que  pueden componerse con otros mas complejos. Asi, para crear objetos con un determinado comportamiento es necesario algo mas que simplemente crear una instancia de una clase.</p>
<p>Hay dos temas recurrentes en estos patrones. En primer lugar, todos ellos encapsulan el conocimiento sobre las clases concretas que usan el sistema. Segundo, todos ocultan como se crean y se asocian las instancias de estas clases. Todo lo que el sistema como tal conoce acerca de los objetos son sus interfaces, tal y como las definen sus clases abstractas. Por tanto, los patrones de creacion dan mucha flexibilidad a que es lo que se crea, quien lo crea y cuando. Permiten configurar un sistema con objetos <q>producto</q> que varian mucho en estructura y funcionalidad. La configuracion puede ser estatica (esto es, especificada en tiempo de compilacion) o dinamica (en tiempo de ejecucion).</p>
<p>A veces, los patrones de creacion son rivales entre si. Por ejemplo, hay casos en los que tanto el patron <a href="#prototype" >Prototype</a> como el <a href="#abstract-factory" >Abstract Factory</a> podrian usarse provechosamente. Otras veces son complementarios: el patron <a href="#builder" >Builder</a> puede usar uno de los otros patrones de creacion para implementar que componentes debe construir; el patron <a href="#prototype" >Prototype</a> puede usar el <a href="#singleton" >Singleton</a> en su implementacion.</p>
<p>Dado que los patrones de creacion estan estrechamente relacionados, estudiaremos los cinco juntos para resaltar sus similitudes y diferencias. Tambien usaremos un ejemplo comun ––construir un laberinto para un juego de computadora–– para ilustrar sus implementaciones. El laberinto y el juego cambiaran ligeramente de un patron a otro. A veces el juego consistira simplemente en encontrar la salida del laberinto; en ese caso el jugador probablemente solo tendra una vision local del laberinto. Otras veces el laberinto contendra problemas que resolver y peligros que superar, y estos juegos pueden proporcionar un plano de la parte del laberinto que ha sido explorada.</p>
<p>Omitiremos muchos detalles sobre que puede haber en un laberinto y si el juego tiene uno o varios jugadores. En vez de eso, nos centraremos en como se crean los laberintos. definimos un laberinto como un conjunto de habitaciones. Una habitacion conoce sus lindes; estos pueden ser otra habitacion, una pared o una puerta a otra habitacion.</p>
<p>Las clases <code>Habitacion</code>, <code>Puerta</code> y <code>Pared</code> definen los componentes del laberinto usado en todos nuestros ejemplos. Definiremos solo las partes de esas clases que son importantes para crear un laberinto. Obviaremos los jugadores, las operaciones de visualizacion y aquellas para caminar por el laberinto, ademas de otras funcionalidades importantes que no son relevantes para construir el laberinto.</p>
<p>El diagrama siguiente muestra la relacion entre estas clases.</p>
<figure>
<img src="img/032.png" />
</figure>
<p>Cada habitacion tiene cuatro lados. Usaremos una enumeracion <code>Direccion</code> en las implementaciones en C++ para especificar los lados norte, sur, este y oeste de una habitacion:</p>
<pre class="code" ><code class="chroma" ><span class="k">enum</span> <span class="n">Direccion</span> <span class="p">{</span><span class="n">Norte</span><span class="p">,</span> <span class="n">Sur</span><span class="p">,</span> <span class="n">Este</span><span class="p">,</span> <span class="n">Oeste</span><span class="p">};</span>
</code></pre>
<p>Las implementaciones en Smalltalk usan los simbolos correspondientes para representar estas direcciones.</p>
<p>La clase <code>LugarDelMapa</code> es la clase abstracta comun de todos los componentes de un laberinto. Para simplificar el ejemplo, <code>LugarDelMapa</code> solo define una operacion, <code>Entrar</code>. Su significado depende de en donde estemos entrando. Si entramos en una habitacion cambiara nuestra posicion. Si tratamos de entrar en una puerta, puede pasar una de estas dos cosas: si la puerta esta abierta, pasaremos a la siguiente habitacion; si esta cerrada, nos daremos con ella de nariz.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">LugarDelMapa</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Entrar</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>Entrar</code> proporciona una base para operaciones mas sofisticadas del juego. Por ejemplo, si estamos en una habitacion y decimos <q>ir hacia el Este</q>, el juego puede determinar facilmente que <code>LugarDelMapa</code> se encuentra inmediatamente al este, para a continuacion llamar a su operacion <code>Entrar</code>. La operacion <code>Entrar</code> de cada subclase concreta determina si cambia nuestra posicion o si nos golpeamos la nariz. En un juego real, <code>Entrar</code> podria tomar como argumento el objeto jugador que se esta moviendo.</p>
<p><code>Habitacion</code> es la subclase concreta de <code>LugarDelMapa</code> que define las relaciones pricipales entre los componentes del laberinto. Mantiene referencias a otros objetos <code>LugarDelMapa</code> y guarda su numero de habitacion. Este numero identificara las habitaciones en el laberinto.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Habitacion</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LugarDelMapa</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Habitacion</span><span class="p">(</span><span class="kt">int</span> <span class="n">numHabitacion</span><span class="p">);</span>

    <span class="n">LugarDelMapa</span><span class="o">*</span> <span class="nf">ObtenerLado</span><span class="p">(</span><span class="n">Direccion</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">EstablecerLado</span><span class="p">(</span><span class="n">Direccion</span><span class="p">,</span> <span class="n">LugarDelMapa</span><span class="o">*</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Entrar</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">LugarDelMapa</span><span class="o">*</span> <span class="n">_lados</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">_numeroHabitacion</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>Las clases siguientes representan la pared o la puerta que hay en cada lado de una estancia.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Pared</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LugarDelMapa</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Pared</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Entrar</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Puerta</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LugarDelMapa</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Puerta</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Entrar</span><span class="p">();</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="nf">OtroLadoDe</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Room</span><span class="o">*</span> <span class="n">_habitacion1</span><span class="p">;</span>
    <span class="n">Room</span><span class="o">*</span> <span class="n">_habitacion2</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">_estaAbierta</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>Necesitames conocer mas cosas ademas de las partes del laberinto. definiremos tambien una clase <code>Laberinto</code> que representa una serie de habitaciones. <code>Laberinto</code> tambien puede encontrar una determinada habitacion usando su operacion <code>NumeroDeHabitacion</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Laberinto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Laberinto</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">AnadirHabitacion</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span><span class="p">);</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="nf">NumeroDeHabitacion</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p><code>NumeroDeHabitacion</code> podria hacer una busqueda usando una busqueda lineal, una tabla de dispersion (<em>hash</em>) o incluso un simple array. Pero no nos preocuparemos aqui por esos detalles, si no que nos centraremos en como especificar los componentes de un objeto laberinto.</p>
<p>Otra clase que definimos es <code>JuegoDelLaberinto</code>, que es la que crea el laberinto. Una forma sencilla de crear el laberinto es con una serie de operaciones que añadan componentes a un laberinto y los conecten entre si. Por ejemplo, las siguientes funciones miembro crearan un laberinto consistente en dos habitaciones con una puerta entre ambas:</p>
<pre class="code" ><code class="chroma" ><span class="n">Laberinto</span><span class="o">*</span> <span class="n">JuegoDelLaberinto</span><span class="o">::</span><span class="n">CrearLaberinto</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">Laberinto</span><span class="o">*</span> <span class="n">unLaberinto</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Laberinto</span><span class="p">;</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Habitacion</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Habitacion</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">Puerta</span> <span class="o">*</span> <span class="n">laPuerta</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Puerta</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">);</span>

    <span class="n">unLaberinto</span><span class="o">-&gt;</span><span class="n">AnadirHabitacion</span><span class="p">(</span><span class="n">h1</span><span class="p">);</span>
    <span class="n">unLaberinto</span><span class="o">-&gt;</span><span class="n">AnadirHabitacion</span><span class="p">(</span><span class="n">h2</span><span class="p">);</span>

    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Norte</span><span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">);</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Este</span><span class="p">,</span> <span class="n">laPuerta</span><span class="p">);</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Sur</span><span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">);</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Oeste</span><span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">);</span>

    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Norte</span><span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">);</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Este</span><span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">);</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Sur</span><span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">);</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Oeste</span><span class="p">,</span> <span class="n">laPuerta</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">unLaberinto</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Esta funcion es bastante complicada, teniendo en cuenta que todo lo que hace es crear un laberinto con dos habitaciones. Hay maneras obvias de hacerla mas simple. Por ejemplo, el constructor de <code>Habitacion</code> podria inicializar por omision los lados con paredes. Pero eso simplemente moveria el codigo a otro lugar. El problema real de esta funcion miembro no es su tamaño, sino su <em>inflexibilidad</em>, al fijar en el codigo la distribucion del laberinto. Cambiar la distribucion significa cambiar esta funcion miembro, ya sea redefiniendola ––lo que significa reimplementarla en su totalidad–– o cambiando partes de ella ––lo que es propenso a errores y no promueve la reutilizacion––.</p>
<p>Los patrones de creacion muestran como hacer este diseño mas <em>flexible</em>, no necesariamente mas pequeño. En concreto, haran que sea mas facil cambiar las clases que definen los componentes de un laberinto.</p>
<p>Supongamos que quisieramos reutilizar la distribucion de un laberinto existente para un nuevo juego que contiene laberintos encantados. El juego de los laberintos encantados tiene nuevos tipos de componentes, como <code>PuertaQueNecesitaHechizo</code>, un tipo de puerta que solo puede cerrarse y abrirse con un hechizo; <code>HabitacionEncantada</code>, una habitaicon que puede contener elementos no convencionales, tales como llaves magicas o hechizos. ¿Como podemos cambiar <code>CrearLaberinto</code> facilmente para crear laberintos con estas nuevas clases de objetos?</p>
<p>En este caso, el principal obstaculo para el cambio reside en fijar en el codigo las clases de las que se crean las instancias. Los patrones de creacion proporcionan varias formas de eliminar las referencias explicitas a clases concretas en el codigo que necesita crear instancias de ellas:</p>
<ul>
<li>
<p>Si <code>CrearLaberinto</code> llama a funciones virtuales en vez de a constructores para crear las habitaciones, paredes y puertas que necesita, entonces podemos cambiar las clases de las instancias a crear haciendo una subclase de <code>JuegoDelLaberinto</code> y redefiniendo dichas funciones virtuales). Este enfoque es un ejemplo del patron <a href="#factory-method" >Factory Method</a>.</p>
</li>
<li>
<p>Si a <code>CrearLaberinto</code> le pasamos un objeto como parametro a usar para crear las habitaciones, paredes y puertas, podemos cambiar las clases de estos elementos pasandole un parametro diferente. Este es un ejemplo del patron <a href="#abstract-factory" >Abstract Factory</a>.</p>
</li>
<li>
<p>Si a <code>CrearLaberinto</code> le pasamos un objeto que puede crear un nuevo laberinto en su totalidad usando operaciones para añadir habitaciones, puertas y paredes al laberinto que construye, podemos usar la herencia para cambiar partes del laberinto o el modo en que este es construido. Este es un ejemplo del patron <a href="#builder" >Builder</a>.</p>
</li>
<li>
<p>Si parametrizamos <code>CrearLaberinto</code> con varias habitaciones, puertas y paredes prototipicas, las cuales copia y luego añade al laberinto, podemos cambiar la composicion del laberinto sustituyendo estos objetos prototipicos por otros diferentes. Este es un ejemplo del patron <a href="#prototype" >Prototype</a>.</p>
</li>
</ul>
<p>El patron de creacion que falta, el <a href="#singleton" >Singleton</a>, puede garantizar que solo haya un laberinto por juego y que todos los objetos del juego puedan acceder ––sin necesidad de acudir a variables o funciones globales––. El Singleton tambien hace mas facil ampliar o sustituir el laberinto sin tocar el codigo existente.</p>
</div>
<h3 id="abstract-factory" >Abstract Factory</h3>
<h4 id="abstract-factory-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Proporciona una interfaz para crear familias de objetos relacionados o que dependen entre si, sin especificar sus clases concretas.</p>
</div>
<h4 id="abstract-factory-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Kit</p>
</div>
<h4 id="abstract-factory-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Pensemos en un toolkit de interfaces de usuario que admita multiples estandares de interfaz de usuario,<span class="note" ><sup><a href="#9" >9</a></sup></span> tales como Motif y Presentation Manager. Los distintos estandares interfaz de usuario definen distintos aspectos y formas de comportamiento de los <q>utiles</q><span class="note" ><sup><a href="#28" >28</a></sup></span> de la interfaz de usuario, como las barras de desplazamiento, ventanas y botones. Para que una aplicacion pueda portarse a varios estandares de interfaz de usuario, esta no deberia codificar sus utilez para una interfaz de usuario en particular. Si la aplicacion crea instancias de clases o utiles especificos de la interfaz de usuario sera dificl cambiar esta mas tarde.</p>
<p>Podemos solucionar este problema definiendo una clase abstracta <code>FabricaDeUtiles</code> que declara una interfaz para crear cada tipo basico de util (<em>widget</em>). Tambien hay una clase abstracta para cada tipo de util, y las subclases concretas implementan utiles para un estandar concreto de interfaz de usuario. La interfaz de <code>FabricaDeUtiles</code> tiene una operacion que devuelve un nuevo objeto para cada clase abstracta de util. Los clientes llaman a estas operaciones para obtener instancias de utiles, pero no son conscientes de las clases concretas que estan usando. De esta manera los clientes son independientes de la interfaz de usuario.</p>
<p>Hay una subclase concreta de <code>FabricaDeUtiles</code> para cada estandar de interfaz de usuario. Cada subclase implementa las operaciones que crean el util apropiado para su interfaz de usuario. Por ejemplo, la operacion <code>CrearBarraDeDesplazamiento</code> de la <code>FabriacaDeUtilesMotif</code> crea y devuelve una instancia de una barra de desplazamiento Motif, mientras que la misma operacion de <code>FabricaDeUtilesPM</code> devuelve una barra de desplazamiento para Presentation Manager. Los clientes crean utiles unicamente a travez de la interfaz <code>FabricaDeUtiles</code> y no tienen conocimento de las clases que implementan los utiles para una determinada interfaz de usuario. En otras palabras, los clientes no tienen que atarse a una clase concreta, sino solo a una interfaz definida por una clase abstracta.</p>
<p>Una <code>FabricaDeUtiles</code> tambien fuerza a que se cumplan las dependencias entre las clase concretas de utiles. Una barra de desplazamiento Motif deberia usarse como un boton Motif y un editor de texto Motif, y esa restriccion se cumple automaticamente como consecuencia de usar una <code>FabricaDeUtilesMotif</code>.</p>
<figure>
<img src="img/033.png" />
</figure>
</div>
<h4 id="abstract-factory-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Abstract Facttory cuando</p>
<ul>
<li>
<p>un sistema debe ser independiente de como se crean, componen y representan sus productos.</p>
</li>
<li>
<p>un sistema debe ser configurado con una familia de productos de entre varias.</p>
</li>
<li>
<p>una familia de objetos producto relacionados esta diseñada para ser usada conjuntamente, y es necesario hacer cumplir esta restriccion.</p>
</li>
<li>
<p>quiere proporcionar una biblioteca de clases de productos, y solo quiere revelar sus interfaces, no sus implementaciones.</p>
</li>
</ul>
</div>
<h4 id="abstract-factory-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/034.png" />
</figure>
</div>
<h4 id="abstract-factory-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>FabricaAbstracta</code> (<code>FrabricaDeUtiles</code>)</p>
<ul>
<li>
<p>declara una interfaz para operaciones que crean objetos producto abstractos.</p>
</li>
</ul>
</li>
<li>
<p><code>FabricaConcreta</code> (<code>FabriacaDeUtilesMotif</code>, <code>FabriacaDeUtilesPM</code>)</p>
<ul>
<li>
<p>implementa las operaciones para crear objetos producto concretos.</p>
</li>
</ul>
</li>
<li>
<p><code>ProductoAbstrato</code> (<code>Ventana</code>, <code>BarraDeDesplazamiento</code>)</p>
<ul>
<li>
<p>declara una interfaz para un tipo de objeto producto.</p>
</li>
</ul>
</li>
<li>
<p><code>ProductoConcreto</code> (<code>VentanaMotif</code>, <code>BarraDeDesplazamientoMotif</code>)</p>
<ul>
<li>
<p>define un objeto producto para que sea creado por la fabrica correspondiente.</p>
</li>
<li>
<p>implementa la interfaz <code>ProductoAbstracto</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>Cliente</code></p>
<ul>
<li>
<p>solo usa interfaces declaradas por las clases <code>FabricaAbstracta</code> y <code>ProductoAbstracto</code>.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="abstract-factory-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p>Normalmente solo se crea una unica instancia de una clase <code>FabricaConcreta</code> en tiempo de ejecucion. Esta fabrica concreta crea objetos que tienen una determinada implementacion.</p>
<p>Para crear diferentes objetos producto los clientes deben usar una fabrica concreta diferente.</p>
</li>
<li>
<p><code>FabricaAbstracta</code> delega la creacion de objetos producto en su subclase <code>FabricaConcreta</code>.</p>
</li>
</ul>
</div>
<h4 id="abstract-factory-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron Abstract Factory tiene las siguientes ventajas e inconvenientes:</p>
<ol class="num" >
<li>
<p><em>Aisla las clases concretas.</em> El patron Abstract Factory ayuda a controlar las clases de objetos que crea una aplicacion. Como una fabrica encapsula la responsabilidad y el proceso de creacion de objetos producto, aisla a los clientes de las clases de implementacion. Los clientes manipulan las instancias a traves de sus interfaces abstractas. Los nombres de las clases producto quedan aisladas en la implementacion de la fabrica concreta; no aparecen en el codigo cliente.</p>
</li>
<li>
<p><em>Facilita el intercambio de familias de productos.</em> La clase de una fabrica concreta solo aparece una vez en una aplicacion ––cuando se crea––. Esto facilita cambiar la fabrica concreta que usa una aplicacion. Como una fabrica abstracta crea una familia completa de productos, toda la familia de productos cambia de una vez. En nuestro ejemplo de la interfaz de usuario, podemos cambiar de utiles Motif a utiles Presentation Manager simplemente cambiando los correspondientes objetos fabrica y volviendo a crear la interfaz.</p>
</li>
<li>
<p><em>Promueve la consistencia entre productos.</em> Cuando se diseñan objetos producto en una familia para trabajar juntos, es importante que una aplicacion use objetos de una sola familia a la vez. <code>FabricaAbstracta</code> facilita que se cumpla esta restriccion.</p>
</li>
<li>
<p><em>Es dificil dar cabida a nuevos tipos de productos.</em> Ampliar las fabricas abstractas para producir nuevos tipos de productos no es facil. Esto se debe a que la interfaz <code>FabricaAbstracta</code> fija el conjunto de productos que se pueden crear. Permitir nuevos tipos de productos requiere ampliar la interfaz de la fabrica, lo que a su vez implica cambiar la clase <code>FabricaAbstacta</code> y todas sus subclases. En la seccion de Implementacion se analiza una solucion a este problema.</p>
</li>
</ol>
</div>
<h4 id="abstract-factory-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Estas son algunas tecnicas utiles para implementar el patron Abstract Factory.</p>
<ol class="num" >
<li>
<p><em>Fabricas unicas.</em> Normalmente una aplicacion solo necesita una instancia de <code>FabricaConcreta</code> por cada familia de productos. Por tanto, suele implementarse mejor como un <a href="#singleton" >Singleton</a>.</p>
</li>
<li>
<p><em>Crear los productos.</em> <code>FabricaAbstracta</code> solo declara una <em>intarfaz</em> para crear productos. Se deja a las subclases <code>ProductoConcreto</code> el crearlos realmente. El modo mas comun de hacer esto es definiendo un metodo de fabricacion para cada producto (vease el patron <a href="#factory-method" >Factory Method</a>). Una fabrica concreta especificara sus productos redefiniendo el metodo fabrica de cada uno. Si bien esta implementacion es sencilla, requiere una nueva subclase fabrica concreta para cada familia de productos, incluso aunque las familias de productos difieran solo ligeramente.</p>
<p>En caso de que sea posible tener muchas familias de productos, la fabrica concreta puede implementarse usando el patron <a href="#prototype" >Prototype</a>. La fabrica concreta se inicializa con una instancia prototipica de cada producto de la familia, y crea un nuevo producto clonando su prototipo. El enfoque basado en prototipos elimina la necesidad de una nueva clase de fabrica concreta para cada nueva familia de productos.</p>
<p>A continuacion presentaremos un modo de implementar una fabrica basada en prototipos en Smalltalk. La fabrica concreta guarda los prototipos a clonar en un diccionario llamado <code>catalogoDePartes</code>. El metodo <code>hacer:</code> obtiene el prototipo y lo clona:</p>
<pre class="code" ><code class="chroma" ><span class="nf">hacer:</span> <span class="nv">nombre</span>
    <span class="o">^</span>  (<span class="nv">catalogoDePartes</span> <span class="nf">at:</span> <span class="nv">nombreParte</span>) <span class="nf">copy</span>
</code></pre>
<p>La fabrica concreta tiene un metodo para añadir partes de catalogo.</p>
<pre class="code" ><code class="chroma" ><span class="nf">anadirParte:</span> <span class="nv">plantillaParte</span> <span class="nf">nombre:</span> <span class="nv">nombreParte</span>
    <span class="nv">catalogoDePartes</span> <span class="nf">at:</span> <span class="nv">nombreParte</span> <span class="nf">put:</span> <span class="nf">plantillaParte</span>
</code></pre>
<p>Los prototipos se añaden a la fabrica identificandolos con un simbolo:</p>
<pre class="code" ><code class="chroma" ><span class="nv">unaFabrica</span> <span class="nf">anadirParte:</span> <span class="nv">unProtipo</span> <span class="nf">nombre:</span> <span class="ss">#utilACME</span>
</code></pre>
<p>Es posible una variacion del enfoque basado en prototipos en lenguajes que tratan a las clases como objetos en toda regla (Smalltalk y Objetive C, por ejemplo). En tales lenguajes podemos pensar en una clase como una fabrica degenerada que solo crea un tipo de producto. Podemos almacenar <em>clases</em> en variables dentro de una fabrica concreta que crea los distintos productos concretos, de manera muy parecida a los prototipos. Estas clases crean nuevas instancias en nombre de la fabrica concreta. Definimos una nueva fabrica inicializando una instancia de una fabrica concreta con <em>clases</em> de productos en vez de mediante subclases. Este enfoque se aprovecha de caracteristicas del lenguaje, mientras que el enfoque basado en prototipos puro es independiente del lenguaje.</p>
<p>Al igual que la fabrica basada en prototipos en Smalltalk que acabamos de ver, la version basada en clases tendra una unica variable de instancia <code>catalogoDePartes</code>, que es un diccionario cuya clave es el nombre de la parte. En vez de guardar los prototipos a ser clonados, <code>catalogoDePartes</code> almacena las clase de los productos. El metodo <code>hacer:</code> quedaria ahora asi:</p>
<pre class="code" ><code class="chroma" ><span class="nf">hacer:</span> <span class="nv">nombreParte</span>
    <span class="o">^</span>  (<span class="nv">catalogoDePartes</span> <span class="nf">at:</span> <span class="nv">nombreParte</span>) <span class="nb">new</span>
</code></pre>
</li>
<li>
<p><em>Definir Fabricas extensibles.</em> <code>FabricaAbstracta</code> por lo general define una operacion diferente para cada tipo de producto que puede producir. Los tipos de producto estan codificados en las signaturas de las operaciones. Añadir un nuevo tipo de producto requiere cambiar la interfaz de <code>FabricaAbstracta</code> y todas las clases que dependen de ella.</p>
<p>Un diseño mas flexible, aunque menos seguro, es añadir un parametro a las operaciones que crean objetos. Este parametro especifica el tipo de objeto a ser creado. Podria tratarse de un identificador de clase, un entero, una cadena de texto o cualquier otra cosa que identifique el tipo de producto. De hecho, con este enfoque, <code>FabricaAbstracta</code> solo necesita una unica operacion <q>Hacer</q> con un parametro que indique el tipo de objeto a crear. Esta es la tecnica usada en las fabricas abstractas basadas en clases y en prototipos que se examinaron anteriormente. Esta variacion es mas facil de usar en un lenguaje dinamicamente tipado, como Smalltalk, que en uno estaticamente tipado, como C++. Podemos aplicarla en C++ solo cuando todos los objetos tienen la misma clase base abstracta o cuando los objetos produco pueden ser convertidos con seguridad al tipo concreto por el objeto que los solicita. La seccion de implementacion del patron <a href="#factory-method" >Factory Method</a> muestra como implementar dichas operaciones parametrizadas en C++. Pero incluso cuando no es necesaria la conversion de tipos, tadavia subyace un problema inherente: todos los productos se devuelven al cliente con la <em>misma</em> interfaz abstracta que el tipo de retorno. El ciente no podra por tanto distinguir o hacer suposiciones seguras acerca de la clase de un producto. En caso de que los clientes necesiten realizar operaciones especificas de las subclases, estas no estaran accesibles a traves de la interfaz abstracta. Aunque el cliente podria hacer una conversion al tipo de una clase hija (esto es, un <em>downcast</em>) (por ejemplo, con <code>dynamic_cast</code> en C++), eso no siempre resulta viable o seguro, porque la conversion de tipos puede fallar. Este es el inconveniente tipico de una interfaz altamente flexible y extensible.</p>
</li>
</ol>
</div>
<h4 id="abstract-factory-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Aplicaremes el patron Abstract Factory para crear los laberintos de los que hablamos al principo de este capitulo.</p>
<p>La clase <code>FabricaDeLaberintos</code> puede crear los componentes de los laberintos. Construye habitaciones, paredes y puertas entre las habitaciones. Podria ser usada por un programa que lee de un fichero los planos de los laberinos y construye el correspodiente laberinto. O tal vez sea usada por un programa que construye los laberintos al azar. Los programas que construyen loberintes toman una <code>FabricaDeLaberintos</code> como argumento, de manera que el programador puede especificar las clases de habitaciones, paredes y puertas a construir</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">FabricaDeLaberintos</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">FabricaDeLaberintos</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">Laberinto</span><span class="o">*</span> <span class="nf">HacerLaberinto</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Laberinto</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">Pared</span><span class="o">*</span> <span class="nf">HacerPared</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="nf">HacerHabitacion</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Habitacion</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">Puerta</span><span class="o">*</span> <span class="nf">HacerPuerta</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span> <span class="n">h1</span><span class="p">,</span>
                                <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h2</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Puerta</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre>
<p>Recordemos que la funcion <code>CrearLaberinto</code> construye un pequeño laberinto consistente en dos habitaciones con una puerta entre ellas. <code>CrearLaberinto</code> fija en el codigo los nombres de clases, dificultando asi la posibilidad de crear laberintos con otros componentes.</p>
<p>Presentamos una version de <code>CrearLaberinto</code> que remedia esta deficiencia tomando como parametro una <code>FabricaDeLaberintos</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">Laberinto</span><span class="o">*</span> <span class="n">JuegoDelLaberinto</span><span class="o">::</span><span class="n">CrearLaberinto</span> <span class="p">(</span><span class="n">FabricaDeLaberintos</span><span class="o">&amp;</span> <span class="n">fabrica</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Laberinto</span><span class="o">*</span> <span class="n">unLaberinto</span> <span class="o">=</span> <span class="n">fabrica</span><span class="p">.</span><span class="n">HacerLaberinto</span><span class="p">();</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">fabrica</span><span class="p">.</span><span class="n">HacerHabitacion</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">fabrica</span><span class="p">.</span><span class="n">HacerHabitacion</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">Puerta</span><span class="o">*</span> <span class="n">unaPuerta</span> <span class="o">=</span> <span class="n">fabrica</span><span class="p">.</span><span class="n">HacerPuerta</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">);</span>

    <span class="n">unLaberinto</span><span class="o">-&gt;</span><span class="n">AnadirHabitacion</span><span class="p">(</span><span class="n">h1</span><span class="p">);</span>
    <span class="n">unLaberinto</span><span class="o">-&gt;</span><span class="n">AnadirHabitacion</span><span class="p">(</span><span class="n">h2</span><span class="p">);</span>

    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Norte</span><span class="p">,</span> <span class="n">fabrica</span><span class="p">.</span><span class="n">HacerPared</span><span class="p">());</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Este</span><span class="p">,</span> <span class="n">unaPuerta</span><span class="p">);</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Sur</span><span class="p">,</span> <span class="n">fabrica</span><span class="p">.</span><span class="n">HacerPared</span><span class="p">());</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Oeste</span><span class="p">,</span> <span class="n">fabrica</span><span class="p">.</span><span class="n">HacerPared</span><span class="p">());</span>

    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Norte</span><span class="p">,</span> <span class="n">fabrica</span><span class="p">.</span><span class="n">HacerPared</span><span class="p">());</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Este</span><span class="p">,</span> <span class="n">fabrica</span><span class="p">.</span><span class="n">HacerPared</span><span class="p">());</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Sur</span><span class="p">,</span> <span class="n">fabrica</span><span class="p">.</span><span class="n">HacerPared</span><span class="p">());</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Oeste</span><span class="p">,</span> <span class="n">unaPuerta</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">unLaberinto</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Podemos crear <code>FabricaDeLaberintosEncantados</code>, una fabrica para laberintos encantados, como una subclase de <code>FabricaDeLaberintos</code>. <code>FabricaDeLaberintosEncantados</code> redefinira diferentes funciones miembro y devolvera diferentes subclases de <code>Habitacion</code>, <code>Pared</code>, etc.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">FabricaDeLaberintosEncantados</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FabricaDeLaberintos</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">fabricaDeLaberintosEncantados</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="nf">HacerHabitacion</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">HabitacionEncantada</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">Hechizar</span><span class="p">());</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">Puerta</span><span class="o">*</span> <span class="nf">HacerPuerta</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span> <span class="n">h1</span><span class="p">,</span>
                                <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h2</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">PuertaQueNecesitaHechizo</span> <span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">);</span> <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="n">Hechizo</span><span class="o">*</span> <span class="n">Hechizar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>Supongamos ahora que queremos hacer un juego del laberinto en el que una habitacion puede tener puesta una bomba. Si la bomba explota, como minimo dañara las paredes. Podemos hacer una subclase de <code>Habitacion</code> que compruebe si la habitacion tiene una bomba y si ha explotado. Tambien necesitamos una subclase de <code>Pared</code> para saber el daño causado en ella. Llamaremos a estas clases <code>HabitacionConUnaBomba</code> y <code>ParedExplosionada</code>.</p>
<p>la ultima clase que definiremos es <code>FabricaDeLaberintosConBombas</code>, una subclase de <code>FabricaDeLaberintos</code> que garantiza que las parades son de la clase <code>ParedExplosionada</code> y que las habitaciones son de la clase <code>HabitacionConBomba</code>. <code>FabricaDeLaberintosConBombas</code> solo necesita refedinir dos funciones:</p>
<pre class="code" ><code class="chroma" ><span class="n">Pared</span><span class="o">*</span> <span class="n">FabricaDeLaberintosConBombas</span><span class="o">::</span><span class="n">HacerPared</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ParedExplosionada</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Habitacion</span><span class="o">*</span> <span class="n">FabricaDeLaberintosConBombas</span><span class="o">::</span><span class="n">HacerHabitacion</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">HabitacionConBomba</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Para construir un laberinto que pueda contener bombas, simplemente llamamos a <code>CrearLaberinto</code> con una <code>FabricaDeLaberintosConBombas</code>.</p>
<pre class="code" ><code class="chroma" ><span class="n">JuegoDelLaberinto</span> <span class="n">juego</span><span class="p">;</span>
<span class="n">FabricaDeLaberintosConBombas</span> <span class="n">fabrica</span><span class="p">;</span>

<span class="n">juego</span><span class="p">.</span><span class="n">CrearLaberinto</span><span class="p">(</span><span class="n">fabrica</span><span class="p">);</span>
</code></pre>
<p><code>CrearLaberinto</code> puede recibir igualmente una instancia de <code>FabricaDeLaberintosEncantados</code> para construir laberintos encantados.</p>
<p>Notese que <code>FabricaDeLaberintos</code> no es mas que una coleccion de metodos de fabricacion. Esta es la forma mas normal de implementar el patron Abstract Factory. Ademas, <code>FabricaDeLaberintos</code> no es una clase abstracta, de manera que hace tanto de <code>FabricaAbstracta</code> como de <code>FabricaConcreta</code>. Tambien esta es la implementacion mas comun del patron Abstract Fartory para aplicaciones sencillas. Al ser <code>FabricaDeLaberintos</code> una clase concreta que consiste solamente en metodos de fabricacion, es facil hacer una nueva <code>FabricaDeLaberintos</code> creando una subclase y redefiniendo las operacions que se necesite cambiar. <code>CrearLaberinto</code> usa la operacion <code>EstablecerLado</code> de las habitaciones para especificar sus lados. Si se crean habitaciones con un <code>FabricaDeLaberintosConBombas</code> el laberinto estara formado por objetos <code>HabitacionConBomba</code> que tendran objetos <code>ParedExplosionada</code> como lados. En caso de que <code>HabitacionConBomba</code> tuviera que acceder a un miembro de <code>ParedExplosionada</code> especifico de la subclase, tendria que convertir una referencia a sus paredes de <code>Pared*</code> a <code>ParedExplosionada*</code>. Esta conversion de tipos (<em>downcasting</em>) es seguro siempre y cuando el argumento sea realmente una <code>ParedExplosionada</code>, lo que esta garantizado si las paredes se costruyen unicamente mediante una <code>FabricaDeLaberintosConBombas</code>.</p>
<p>Por supuesto, en el caso de los lenguajes dinamicamente tipados, como Smalltalk, no es necesaria la conversion de tipos, pero podrian producirse errores en tiempo de ejecucion si encuentran una <code>Pared</code> donde esperaban una <em>subclase</em> de <code>Pared</code>. Usar una Fabrica Abstracta para crear las paredes ayuda a evitar estos errores de tiempo de ejecucion al garantizar que solo se pueden crear ciertos tipos de paredes.</p>
<p>Veamos una version de <code>FabricaDeLaberintos</code> en Smalltalk, con una unica operacion <code>hacer</code> que recibe como parametro el tipo de objeto a construir. Ademas, la fabrica concreta almacena las clases de los productos que crea.</p>
<p>En primer lugar, escribiremos un <code>CrearLaberinto</code> equivalente en Smalltalk:</p>
<pre class="code" ><code class="chroma" ><span class="nf">crearLaberinto:</span> <span class="nv">unaFabrica</span>
    <span class="o">|</span><span class="nv"> habitacion1 habitacion2 unaPuerta </span><span class="o">|</span>
    <span class="nv">habitacion1</span> <span class="o">:=</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#habitacion</span>) <span class="nf">numero:</span> <span class="m">1</span><span class="p">.</span>
    <span class="nv">habitacion2</span> <span class="o">:=</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#habitacion</span>) <span class="nf">numero:</span> <span class="m">2</span><span class="p">.</span>
    <span class="nv">unaPuerta</span>   <span class="o">:=</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#puerta</span>) <span class="nf">de:</span> <span class="nv">habitacion1</span> <span class="nf">a:</span> <span class="nv">habitacion2</span><span class="p">.</span>
    <span class="nv">habitacion1</span> <span class="nf">lado:</span> <span class="ss">#norte</span> <span class="nf">put:</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">.</span>
    <span class="nv">habitacion1</span> <span class="nf">lado:</span> <span class="ss">#este</span>  <span class="nf">put:</span> <span class="nv">unaPuerta</span><span class="p">.</span>
    <span class="nv">habitacion1</span> <span class="nf">lado:</span> <span class="ss">#sur</span>   <span class="nf">put:</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">.</span>
    <span class="nv">habitacion1</span> <span class="nf">lado:</span> <span class="ss">#oeste</span> <span class="nf">put:</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">.</span>
    <span class="nv">habitacion2</span> <span class="nf">lado:</span> <span class="ss">#norte</span> <span class="nf">put:</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">.</span>
    <span class="nv">habitacion2</span> <span class="nf">lado:</span> <span class="ss">#este</span>  <span class="nf">put:</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">.</span>
    <span class="nv">habitacion2</span> <span class="nf">lado:</span> <span class="ss">#sur</span>   <span class="nf">put:</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">.</span>
    <span class="nv">habitacion2</span> <span class="nf">lado:</span> <span class="ss">#oeste</span> <span class="nf">put:</span> <span class="nv">unaPuerta</span><span class="p">.</span>
    <span class="o">^</span> <span class="nc">Laberinto</span> <span class="nb">new</span> <span class="nf">anadirHabitacion:</span> <span class="nv">habitacion1</span><span class="p">;</span>
<span class="nf">anadirHabitacion:</span> <span class="nv">habitacion2</span><span class="p">;</span> <span class="nf">yourself</span>
</code></pre>
<p>Como ya dijimos en la seccion de Implementacion, <code>FabricaDeLaberintos</code> solo necesita una unica varible de instancia <code>catalogoDePartes</code>, que consiste en un diccionario cuya clave es la clase del componente. Recordemos tambien como implementamos el metodo <code>hacer:</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nf">hacer:</span> <span class="nv">nombreParte</span>
    <span class="o">^</span> (<span class="nv">catalogoDePartes</span> <span class="nf">at:</span> <span class="nv">nombreParte</span>) <span class="nb">new</span>
</code></pre>
<p>Ahora podemos crear una <code>FabricaDeLaberintos</code> y usarla para implementar <code>crearLaberinto</code>. Crearemos la fabrica usando el metodo <code>crearFabricaDeLaberintos</code> de la clase <code>JuegoDelLaberinto</code>.</p>
<pre class="code" ><code class="chroma" ><span class="nf">crearFabricaDeLaberintos</span>
    <span class="o">^</span> (<span class="nc">FabricaDeLaberintos</span> <span class="nb">new</span>
        <span class="nf">anadirParte:</span> <span class="nc">Pared</span> <span class="nf">nombre:</span> <span class="ss">#pared</span><span class="p">;</span>
        <span class="nf">anadirParte:</span> <span class="nc">Habitacion</span> <span class="nf">nombre:</span> <span class="ss">#habitacion</span><span class="p">;</span>
        <span class="nf">anadirParte:</span> <span class="nc">Puerta</span> <span class="nf">nombre:</span> <span class="ss">#puerta</span><span class="p">;</span>
        <span class="nf">yourself</span>)
</code></pre>
<p>Una <code>FabricaDeLaberintosConBombas</code> o una <code>FabricaDeLaberintosEncantados</code> se crean asociando diferentes clases con las claves. Por ejemplo, un <code>FabricaDeLaberintosEncantados</code> se podria crear como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="nf">crearFabricaDeLaberintos</span>
    <span class="o">^</span> (<span class="nc">FabricaDeLaberintos</span> <span class="nb">new</span>
        <span class="nf">anadirParte:</span> <span class="nc">Pared</span> <span class="nf">nombre:</span> <span class="ss">#pared</span><span class="p">;</span>
        <span class="nf">anadirParte:</span> <span class="nc">HabitacionEncantada</span> <span class="nf">nombre:</span> <span class="ss">#habitacion</span><span class="p">;</span>
        <span class="nf">anadirParte:</span> <span class="nc">PuertaQueNecesitaHechizo</span> <span class="nf">nombre:</span> <span class="ss">#puerta</span><span class="p">;</span>
        <span class="nf">yourself</span>)
</code></pre>
</div>
<h4 id="abstract-factory-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>InterViews usa el sufijo <q>Kit</q> [<a href="#lin92" >Lin92</a>] para denotar las clases <code>FabricaAbstracta</code>. Define las fabricas abstractas <code>WidgetKit</code> y <code>DialogKit</code> para generar objetos especificos de la interfaz de usuario. InterViews tambien incluye un LayoutKit que genera diferentes objetos de composicion dependiendo de la disposicion deseada. Asi por ejemplo, una distribucion horizontal puede necesitar diferentes objetos de composicion dependiendo de la orientacion del documento (vertical o apaisado).</p>
<p>ET++ [<a href="#wgm88" >WGM88</a>] usa el patron Abstract Factory para lograr portabilidad entre varios sistemas de ventanas (por ejemplo, X, Windows y SunView). La clase base abstracta <code>WindowSystem</code> define la interfaz para crear objetos que representan recursos del sistema de ventanas (por ejemplo, <code>MakeWindow</code>, <code>MakeFont</code>, <code>MakeColor</code>). Las subclases concretas implementan las interfaces para un determinado sistema de ventanas. En tiempo de ejecucion, ET++ crea una instancia de una subclase concreta de <code>WindowSystem</code> que es la encargada de crear objetos concretos de recursos del sistema.</p>
</div>
<h4 id="abstract-factory-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>Las clases <code>FabricaAbstracta</code> suelen implementarse con metodos de fabricacion (patron <a href="#factory-method" >Factory Method</a>), pero tambien se pueden implementar usando prototipos (patron <a href="#prototype" >Prototype</a>).</p>
<p>Una fabrica concreta suele ser un <a href="#singleton" >Singleton</a>.</p>
</div>
<h3 id="builder" >Builder</h3>
<h4 id="builder-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Separa la construccion de un objeto complejo de su representacion, de forma que el mismo proceso de construccion pueda crear diferentes representaciones.</p>
</div>
<h4 id="builder-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Un lector del formato de intercambio de documentos RTF (<em>Ritch Text format</em>) deberia poder convertir RTF a muchos formatos de texto. Podria convertir documentos RTF a texto ASCII o a un util<span class="note" ><sup><a href="#29" >29</a></sup></span> de texto que pueda editarse de forma interactiva. El problema, no obstante, es que el numero de conversiones posibles es indefinido. Por tanto, tendria que ser facil añadir una nueva conversion sin modificar el lector.</p>
<p>Una solucion es configurar la clase <code>LectorRTF</code> con un objeto <code>ConvertidorDeTexto</code> que convierta RTF a otra representacion textual. Cuando el <code>LectorRTF</code> analiza el documento RTF; usa el <code>ConvertidorDeTexto</code> para realizar la conversion. Cada vez que el <code>LectorRTF</code> reconozca un token RTF (ya sea texto normal o una palabra de control de RTF), envia una peticion al <code>ConvertidorDeTexto</code> para que lo convierta. Los objetos <code>ConvertidorDeTexto</code> son responsables de realizar la conversion de datos y de representar el token en un determinado formato.</p>
<p>Las subclases de <code>ConvertidorDeTexto</code> estan especializadas en diferentes coversiones y formatos. Por ejemplo, un <code>ConversorASCII</code> hace caso omiso de las peticiones de conversion de cualquier otra cosa que no sea texto sin formato. Por otro lado, un <code>ConversorTeX</code>, implementara operaciones para todas las peticiones, con el objetivo de producir una representacion TeX con toda la informacion de estilo que haya en el texto. Un <code>ConvertidorUtilDeTexto</code> producira un objeto de interfaz de usuario que permita al usuario ver y editar el texto.</p>
<figure>
<img src="img/035.png" />
</figure>
<p>La clase de cada tipo de convertidor toma el mecanismo de creacion y ensamblaje de un objeto complejo y lo oculta tras una interfaz abstracta. El convertidor se separa del lector, que es el responsable de analizar un documento RTF.</p>
<p>El patron Builder expresa todas estas relaciones. Cada clase de convertidor se denomina <b>constructor</b>, en el contexto de este patron, y al lector se le llama <b>director</b>. Aplicado a este ejemplo, el patron Builder separa el algoritmo para interpretar un formato textual (es decir, el analizador de documentos RTF) de la manera en que se crea y se representa el formato de destino. Esto permite reutilizar el algoritmo de analisis de <code>LectorRTF</code> para crear diferentes representaciones de texto a partir de documentos RTF ––basta con configurar el <code>LectorRTF</code> con diferentes subclases de <code>ConvertidoDeTexto</code>––.</p>
</div>
<h4 id="builder-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Use el patron Builder cuando</p>
<ul>
<li>
<p>el algoritmo para crear un objeto complejo deberia ser independiente de las partes de que se compone dicho objeto y de como se ensablan.</p>
</li>
<li>
<p>el proseso de costruccion debe permitir diferentes representaciones del objeto que esta siendo construido.</p>
</li>
</ul>
</div>
<h4 id="builder-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/036.png" />
</figure>
</div>
<h4 id="builder-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Constructor</code> (<code>ConvertidorDeTexto</code>)</p>
<ul>
<li>
<p>especifica una interfaz abstracta para crear las partes de un objeto <code>Producto</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>ConstructorConcreto</code> (<code>ConvertidorASCII</code>, <code>ConvertidorTeX</code>, <code>ConvertidorUtilDeTexto</code>)</p>
<ul>
<li>
<p>implementa la interfaz <code>Constructor</code> para construir y ensamblar las partes del producto.</p>
</li>
<li>
<p>define la representacion a crear.</p>
</li>
<li>
<p>proporciona una interfaz para devolver el producto (p. ej., <code>ObtenerTextoASCII</code>, <code>ObtenerUtilDeTexto</code>).</p>
</li>
</ul>
</li>
<li>
<p><code>Director</code> (<code>LectorRTF</code>)</p>
<ul>
<li>
<p>construye un objeto usando la interfaz <code>Constructor</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>Producto</code> (<code>TextoASCII</code>, <code>TextoTeX</code>, <code>UtilDeTexto</code>)</p>
<ul>
<li>
<p>representa el objeto complejo en construccion. El <code>ConstructorConcreto</code> construye la representacion interna del producto y define el proceso de ensamblaje.</p>
</li>
<li>
<p>incluye las clases que definen sus partes constituyentes, incluyendo interfaces para ensamblar las partes en el resultado final.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="builder-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p>El cliente crea el objeto <code>Director</code> y lo configura con el objeto <code>Constructor</code> deseado.</p>
</li>
<li>
<p>El <code>Director</code> notifica al constructor cada vez que hay que construir una parte de un producto.</p>
</li>
<li>
<p>El <code>Constructor</code> maneja las peticiones del director y las añade al producto.</p>
</li>
<li>
<p>El cliente obtiene el producto del constructor.</p>
</li>
</ul>
<p>El siguiente diagrama de interaccion ilustra como cooperan con un cliente el <code>Constructor</code> y el <code>Director</code>.</p>
<figure>
<img src="img/037.png" />
</figure>
</div>
<h4 id="builder-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>Estas son las consecuencias del patron Builder.</p>
<ol class="num" >
<li>
<p><em>Permite variar la representacion interna de un producto.</em> El objeto <code>Constructor</code> proporciona al director una interfaz abstracta para construir el producto. La interfaz permite que el constructor oculte la representacion y la estructura interna del producto. Tambien oculta el modo en que este es ensamblado. Dado que el producto se construye a traves de una interfaz abstracta, todo lo que hay que hacer para cambiar la representacion interna del producto es definir un nuevo tipo de constructor.</p>
</li>
<li>
<p><em>Aisla el codigo de construccion y representacion.</em> El patron Builder aumenta la modularidad al encapsular como se construyen y se representan los objetos complejos. Los clientes no necesitan saber nada de las clases que definen la estructura interna del producto; dichas clases no aparecen en la interfaz del <code>Constructor</code>.</p>
<p>Cada <code>ConstructorConcreto</code> contiene todo el codigo para crear y ensamblar un determinado tipo de producto. El codigo solo se escribe una vez; despues, los diferentes <code>Directores</code> pueden reutilizarlo para construir variantes de <code>Producto</code> a partir del mismo conjunto de partes. En el ejemplo anterior de RTF, podriamos definir un lector para otro formato distinto de RTF, como por ejemplo un <code>LectorSGML</code>, y usar los mismos objetos <code>ConvertidorDeTexto</code> para generar representaciones <code>TextoASCII</code>, <code>TextoTeX</code> y <code>UtilDeTexto</code> de documentos <code>SGML</code>.</p>
</li>
<li>
<p><em>Proporciona un control mas fino sobre el proceso de construccion.</em> A diferencia de los patrones de creacion que construyen los productos de una vez, el patron Builder construye el producto paso a paso, bajo el control del director. El director solo obtiene el producto del constructor una vez que este esta terminado. Por tanto, la interfaz <code>Constructor</code> refleja el proceso de construccion del producto mas que otros patrones de creacion. Esto da un control mas fino sobre el proceso de construccion y, por tanto, sobre la estructura interna del producto resultante.</p>
</li>
</ol>
</div>
<h4 id="builder-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Normalmente hay una clase abstracta <code>Builder</code> que define una operacion para cada componente que puede ser creado. La implementacion predeterminada de estas operaciones no hace nada. Una clase <code>ConstructorConcreto</code> redefine las operaciones para los componentes que esta interesado en crear.</p>
<p>Estas son otras cuestiones de implementacion que hay que considerar:</p>
<ol class="num" >
<li>
<p><em>Interfaz de ensamblaje y construccion.</em> Los constructores construyen sus productos paso a paso. Por tanto, la interfaz de la clase <code>Constructor</code> debe ser lo suficientemente general como para permitir construir productos por parte de todos los tipos de constructores concretos.</p>
<p>Una cuestion de diseño fundamental tiene que ver con el modelo del proceso de construccion y ensamblaje. Normalmente basta con un modelo segun el cual los resultados de las peticiones de construccion simplemente se van añadiendo al producto. En el ejemplo de RTF, el constructor convierte y añade el siguiente token al texto que ha convertido hasta la fecha. Pero a veces podriamos necesitar acceder a las partes del producto que ya fueron construidas.</p>
<p>En el ejemplo del laberinto que presentamos en el Codigo de Ejemplo, la interfaz de <code>ConstructorLaberinto</code> permite añadir una puerta entre habitacions existentes. Otro ejemplo son las estructuras arboreas, como los arboles sintacticos que se crean de abajo a arriba. En ese caso, el constructor devolveria nodos hijos al director, el cual los devolveria al constructor para construir los nodos padre.</p>
</li>
<li>
<p><em>¿Por que no usar clases abstractas para los productos?</em> En general, los productos creados por los constructores concretos tienen representaciones tan diferentes que seria de poca ayuda definir una clase padre comun para los diferentes productos. En el ejemplo de RTF, es poco probable que los objetos <code>TextoASCII</code> y <code>UtilDeTexto</code> tengan una interfaz comun. Como el cliente suele configurar al director con el constructor concreto adecuado, sabe que subclase concreta de <code>Constructor</code> se esta usando, y puede manjar sus productos en consecuencia.</p>
</li>
<li>
<p><em>Metodos vacios de manera predeterminada en el constructor.</em> En C++, los metodos de creacion no se declaran como funciones miembro virtuales puras a proposito. En ves de eso, se definen como metodos vacios, lo que permite que los clientes redefinan solo las operaciones en las que estan interesados.</p>
</li>
</ol>
</div>
<h4 id="builder-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Definiremos una variante de la funcion miembro <code>CrearLaberinto</code> que toma como argumento un constructor de la clase <code>ConstructorLaberinto</code>.</p>
<p>La clase <code>ConstructorLaberinto</code> define la siguiente interfaz para construir laberintos:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ConstructorLaberinto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ConstruirLaberinto</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ConstruirHabitacion</span><span class="p">(</span><span class="kt">int</span> <span class="n">habication</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ConstruirPuerta</span><span class="p">(</span><span class="kt">int</span> <span class="n">habitacionDesde</span><span class="p">,</span> <span class="kt">int</span> <span class="n">habitacionHasta</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">virtual</span> <span class="n">Maze</span><span class="o">*</span> <span class="n">ObtenerLaberinto</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">ConstructorLaberinto</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>Esta interfaz puede crear tres tipos de cosas: (1) el laberinto, (2) habitaciones con un determinado numero de habitacion y (3) puertas entre habitaciones numeradas. La operacion <code>ObteterLaberinto</code> devuelve el laberinto al cliente. Las subclases de <code>ConstructorLaberinto</code> redefiniran esta operacion para devolver el laberinto que construyen.</p>
<p>Todas las operaciones para construir el laberinto de <code>ConstructorLaberinto</code> por omision no hacen nada. No se declaran como virtuales puras para permitir que las clases derivadas redefinan solo aquellos metodos en los que esten interesadas.</p>
<p>Dada la interfaz de <code>ConstructorLaberinto</code>, podemos cambiar la funcion miembro <code>CrearLaberinto</code> para que tome como parametro este constructor.</p>
<pre class="code" ><code class="chroma" ><span class="n">Laberinto</span><span class="o">*</span> <span class="n">JuegoDelLaberinto</span><span class="o">::</span><span class="n">CrearLaberinto</span> <span class="p">(</span><span class="n">ConstructorLaberinto</span><span class="o">&amp;</span> <span class="n">constructor</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">constructor</span><span class="p">.</span><span class="n">ConstruirLaberinto</span><span class="p">();</span>

  <span class="n">constructor</span><span class="p">.</span><span class="n">ConstruirHabitacion</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">constructor</span><span class="p">.</span><span class="n">ConstruirHabitacion</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">constructor</span><span class="p">.</span><span class="n">ConstruirPuerta</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">constructor</span><span class="p">.</span><span class="n">ObtenerLaberinto</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Compare esta version de <code>CrearLaberinto</code> con la original. Fijese en como el constructor oculta la representacion interna de <code>Laberinto</code> ––esto, es las clases que definen habitaciones, puertas y paredes–– y como se ensamblan estas partes para completar el laberinto final. Alguien pobria preguntarse por que hay clases que representan habitaciones y puertas, pero no hay rastro de ninguna para las paredes. Esto facilita la manera de representar un laberinto, ya que no hay que cambiar ninguno de los clientes de <code>ConstructorLaberinto</code>.</p>
<p>Al igual que con los otros patrones de creacion, el patron Builder encapsula como se crean los objetos, en este caso a traves de la interfaz definida por <code>ConstructorLaberinto</code>. Eso significa que podemos reutilizar <code>ConstructorLaberinto</code> para construir diferentes tipos de laberintos. Un ejemplo de esto es la operacion <code>CrearLaberintoCompleto</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">Laberinto</span><span class="o">*</span> <span class="n">JuegoDelLaberinto</span><span class="o">::</span><span class="n">CrearLaberintoComplejo</span> <span class="p">(</span><span class="n">ConstructorLaberinto</span><span class="o">&amp;</span> <span class="n">constructor</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">constructor</span><span class="p">.</span><span class="n">ConstruirHabitacion</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="n">constructor</span><span class="p">.</span><span class="n">ConstruirHabitacion</span><span class="p">(</span><span class="mi">1001</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">constructor</span><span class="p">.</span><span class="n">ObtenerLaberinto</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Notese que <code>ConstructorLaberinto</code> no crea el laberinto en si; su principal proposito es simplemente definir una interfaz para crear laberintos. Define implementaciones vacias mas que nada por comodidad. Son las subclases de <code>ConstructorLaberinto</code> las que hacen el trabajo real.</p>
<p>La subclase <code>ConstructorLaberintoEstandar</code> es una implementacion que construye laberintos simples. Sabe que laberinto esta siendo creado gracias a la variable <code>_laberintoActual</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ConstructorLaberintoEstandar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ConstructorLaberinto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ConstructorLaberintoEstandar</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ConstruirLaberinto</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ConstruirHabitacion</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ConstruirPuerta</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="n">Laberinto</span><span class="o">*</span> <span class="nf">ObtenerLaberinto</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Direccion</span> <span class="n">ParedNormal</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span><span class="p">,</span> <span class="n">Habitacion</span><span class="o">*</span><span class="p">);</span>
    <span class="n">Laberinto</span><span class="o">*</span> <span class="n">_laberintoActual</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>ParedNormal</code> es una operacion auxiliar que calcula la direccion de la pared normal entre dos habitaciones.</p>
<p>El constructor de <code>ConstructorLaberintoEstandar</code> simplemente inicializa <code>_laberintoActual</code>.</p>
<pre class="code" ><code class="chroma" ><span class="n">ConstructorLaberintoEstandar</span><span class="o">::</span><span class="n">ConstructorLaberintoEstandar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_laberintoActual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p><code>ConstruirLaberinto</code> crea una instancia de un <code>Laberinto</code> que otras operaciones ensamblaran y al final devolveran al cliente (mediante <code>ObtenerLaberinto</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">ConstructorLaberintoEstandar</span><span class="o">::</span><span class="n">ConstruirLaberinto</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_laberintoActual</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Laberinto</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Laberinto</span><span class="o">*</span> <span class="n">ConstructorLaberintoEstandar</span><span class="o">::</span><span class="n">ObtenerLaberinto</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_laberintoActual</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>La operacion <code>ConstruirHabitacion</code> crea una habitacion y construye sus paredes adyacentes:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">ConstruirLaberintoEstandar</span><span class="o">::</span><span class="n">ConstruirHabitacion</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_laberintoActual</span><span class="o">-&gt;</span><span class="n">NumeroDeHabitacion</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Habitacion</span><span class="o">*</span> <span class="n">habitacion</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Habitacion</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">_laberintoActual</span><span class="o">-&gt;</span><span class="n">AnadirHabitacion</span><span class="p">(</span><span class="n">habitacion</span><span class="p">);</span>

        <span class="n">habitacion</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Norte</span> <span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">);</span>
        <span class="n">habitacion</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Sur</span> <span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">);</span>
        <span class="n">habitacion</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Este</span> <span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">);</span>
        <span class="n">habitacion</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Oeste</span> <span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Para construir una puerta entre dos habitaciones, <code>ConstructorLaberintoEstandar</code> busca ambas habitaciones en el laberinto y encuentra su pared adyacente:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">ConstructorLaberintoEstandar</span><span class="o">::</span><span class="n">ConstruirPuerta</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">_laberintoActual</span><span class="o">-&gt;</span><span class="n">NumeroDeHabitacion</span><span class="p">(</span><span class="n">n1</span><span class="p">);</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">_laberintoActual</span><span class="o">-&gt;</span><span class="n">NumeroDeHabitacion</span><span class="p">(</span><span class="n">n2</span><span class="p">);</span>
    <span class="n">Puerta</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Puerta</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">);</span>

    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">ParedNormal</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">ParedNormal</span><span class="p">(</span><span class="n">h2</span><span class="p">,</span> <span class="n">h1</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Ahora los clientes pueden usar <code>CrearLaberinto</code> junto con <code>ConstructorLaberintoEstandar</code> para crear un laberinto:</p>
<pre class="code" ><code class="chroma" ><span class="n">Laberinto</span><span class="o">*</span> <span class="n">laberinto</span><span class="p">;</span>
<span class="n">JuegoDelLaberinto</span> <span class="n">juego</span><span class="p">;</span>
<span class="n">ConstructorLaberintoEstandar</span> <span class="n">constructor</span><span class="p">;</span>

<span class="n">juego</span><span class="p">.</span><span class="n">CrearLaberinto</span><span class="p">(</span><span class="n">constructor</span><span class="p">);</span>
<span class="n">laberinto</span> <span class="o">=</span> <span class="n">constructor</span><span class="p">.</span><span class="n">ObtenerLaberinto</span><span class="p">();</span>
</code></pre>
<p>Podriamos haber puesto todas las operaciones de <code>ConstructorLaberintoEstandar</code> en <code>Laberinto</code> y dejar que cada <code>Laberinto</code> se construyese a si mismo. Pero al hacer a <code>Laberinto</code> mas pequeña es mas facil entenderla y modificarla, y <code>ConstructorLaberintoEstandar</code> es facil de separar de <code>Laberinto</code>. Lo que es mas importante, separar ambas clases permite tener varios objetos <code>ConstructorLaberinto</code>, usando cada uno clases diferentes para las habitaciones, paredes y puertas.</p>
<p>Un <code>ConstructorLaberinto</code> mas exotico es <code>ConstructorLaberintoContador</code>. Este constructor no crea un laberinto; simplemente cuenta los distintas tipos de componentes que han sido creados.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ConstructorLaberintoContador</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ConstructorLaberinto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ConstructorLaberintoContador</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ConstruirLaberinto</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ConstruirHabitacion</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ConstruirPuerta</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">AnadirPared</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">Direccion</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">ObtenerConteo</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_puertas</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_habitaciones</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>El constructor inicializa los contadores, y las operaciones redefinidas de <code>ConstructorLaberinto</code> los incrementan en consecuencia.</p>
<pre class="code" ><code class="chroma" ><span class="n">ConstructorLaberintoContador</span><span class="o">::</span><span class="n">ConstructorLaberintoContador</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_habitaciones</span> <span class="o">=</span> <span class="n">_puertas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConstructorLaberintoContador</span><span class="o">::</span><span class="n">ConstruirHabitacion</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_habitaciones</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConstructorLaberintoContador</span><span class="o">::</span><span class="n">ConstruirPuerta</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">_puertas</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConstructorLaberintoContador</span><span class="o">::</span><span class="n">GetCounts</span> <span class="p">(</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">habitaciones</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">puertas</span>
<span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">habitaciones</span> <span class="o">=</span> <span class="n">_habitaciones</span><span class="p">;</span>
    <span class="n">puertas</span> <span class="o">=</span> <span class="n">_puertas</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Asi es como un cliente podria usar un <code>ConstructorLaberintoContador</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kt">int</span> <span class="n">habitaciones</span><span class="p">,</span> <span class="n">puertas</span><span class="p">;</span>
<span class="n">JuegoDelLaberinto</span> <span class="n">juego</span><span class="p">;</span>
<span class="n">ConstructorLaberintoContador</span> <span class="n">constructor</span><span class="p">;</span>

<span class="n">juego</span><span class="p">.</span><span class="n">CrearLaberinto</span><span class="p">(</span><span class="n">constructor</span><span class="p">);</span>
<span class="n">constructor</span><span class="p">.</span><span class="n">ObtenerConteo</span><span class="p">(</span><span class="n">habitaciones</span><span class="p">,</span> <span class="n">puertas</span><span class="p">);</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sa"></span><span class="s">&#34;El laberinto tiene &#34;</span>
     <span class="o">&lt;&lt;</span> <span class="n">habitaciones</span> <span class="o">&lt;&lt;</span> <span class="sa"></span><span class="s">&#34; habitaciones y &#34;</span>
     <span class="o">&lt;&lt;</span> <span class="n">puertas</span> <span class="o">&lt;&lt;</span> <span class="sa"></span><span class="s">&#34; puertas&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre>
</div>
<h4 id="builder-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>La aplicacion que convierte RTF es de ET++ [<a href="#wgm88" >WGM88</a>]. Su bloque de construccion de texto usa un constructor para procesar texto almacenado en formato RTF.</p>
<p>Builder es un patron comun en Smalltalk-80 [<a href="#par90" >Par90</a>]:</p>
<ul>
<li>
<p>La clase <code>Parser</code> en el subsistema del compilador es un <code>Director</code> que toma un objeto <code>ProgramNodeBuilder</code> como argumento. Un objeto <code>Parser</code> notifica a su objeto <code>ProgramNodeBulider</code> cada vez que reconoce una construccion sintactica. Cuando finaliza el analisis, le pide al constructor el arbol de analisis sintactico y se lo devuelve al cliente.</p>
</li>
<li>
<p><code>ClassBuilder</code> es un constructor que usan los objetos <code>Class</code> para crear subclases de si mismas. En este caso un <code>Class</code> es tanto el <code>Director</code> como el <code>Producto</code>.</p>
</li>
<li>
<p><code>ByteCodeStream</code> es un constructor que crea un metodo compilado como un array de bytes. <code>ByteCodeStream</code> es un uso no estandar del patron Builder, ya que el objeto complejo que construye esta codificado como un array de bytes en vez de como un objeto Smalltalk normal. Pero la interfaz de <code>ByteCodeStream</code> es tipica de un constructor, y seria facil sustituir <code>ByteCodeStream</code> por una clase diferente que represente programas como un objeto compuesto.</p>
</li>
</ul>
<p>El framework Service Configurator de Adaptive Communications Environment usa un constructor para construir componentes de servicio de red que estan enlazados a un servidor en tiempo de ejecucion [<a href="#ss94" >SS94</a>]. Los componentes se describen con un lenguaje de configuracion que es analizado por un analizador LALR(1). Las aciones semanticas del analizador realizan operacion sobre el constructor que añaden informacion al componente de servicios. En este caso, el analizador es el <code>Director</code>.</p>
</div>
<h4 id="builder-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>El patron <a href="#abstract-factory" >Abstract Factory</a> se parece a un Builder en que tambien puede construir objetos complejos. La principal diferencia es que el patron Builder se centra en construir un objeto complejo paso a paso. El Abstract Factory hace hincapie en familias de objetos producto (simples o complejos). El Builder devuelve el producto como paso final, mientras que el Abstract Factory lo devuelve inmediatamente.</p>
<p>Muchas veces lo que construye el constructor es un <a href="#composite" >Composite</a>.</p>
</div>
<h3 id="factory-method" >Factory Method</h3>
<h4 id="factory-method-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan que clase instanciar. Permite que una clase delegue en sus subclases la creacion de objetos.</p>
</div>
<h4 id="factory-method-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Virtual Constructor (Constructor Virtual)</p>
</div>
<h4 id="factory-method-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Los <em>frameworks</em> usan clases abstractas para definir y mantener relaciones entre objetos y tambien son muchas veces responsables de crear esos mismos objetos.</p>
<p>Pensemos en un framework de aplicaciones que pueda presentar varios documentos al usuario. Dos abstraccciones clave de este framework son las clases <code>Aplicacion</code> y <code>Documento</code>. Ambas son abstractas, y los clientes tienen que heredar de ellas para llevar a cabo sus implementaciones especificas de la aplicacion. Por ejemplo, para crear una aplicacion de dibujo, definimos las clases <code>AplicacionDeDibujo</code> y <code>DocumentoDeDibujo</code>. La clase <code>Aplicacion</code> se encarga de gestionar <code>Documentos</code> y los creara cuando sea necesario, por ejemplo, cuando el usuario selecciona Abrir o Nuevo en el menu.</p>
<p>Dado que la subclase <code>Documento</code> concreta a instanciar es especifica de la aplicacion, la clase <code>Aplicacion</code> no puede predecir que subclase de <code>Documento</code> debe instanciar ––la clase <code>Aplicacion</code> solo sabe <em>cuando</em> deberia crearse un nuevo documento, no <em>que</em> tipo de <code>Documento</code> crear––. Esto causa un dilema: el framework debe crear instancias de clases, pero solo conoce clases abstractas, las cuales no pueden ser instanciadas.</p>
<p>El patron Factory Method ofrece una solucion al dilema. Encapsula el conocimiento acerca de que subclases de <code>Documento</code> crear y saca ese conocimiento fuera del framework.</p>
<figure>
<img src="img/038.png" />
</figure>
<p>Las subclases de <code>Aplicacion</code> redefinen su operacion abstracta <code>CrearDocumente</code> para que devuelva la subclase de <code>Documento</code> adecuada. Una vez que se crea una instancia de la subclase de <code>Aplicacion</code>, esta puede crear instancias de Documentos especificos de la aplicacion sin conocer sus clases. Llamaremos a <code>CrearDocumento</code> un <b>metodo de fabricacion</b> porque es el responsable de <q>fabricar</q> un objeto.</p>
</div>
<h4 id="factory-method-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron <code>Factory Method</code> cuando</p>
<ul>
<li>
<p>una clase no puede prever la clase de objetos que debe crear.</p>
</li>
<li>
<p>una clase quiere que sean sus subclases quienes especifiquen los objetos que esta crea.</p>
</li>
<li>
<p>las clases delegan las responsabilidad en una de entre varias clases auxiliares, y queremos localizar que subclase de auxiliar concreta es en la que se delega.</p>
</li>
</ul>
</div>
<h4 id="factory-method-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/039.png" />
</figure>
</div>
<h4 id="factory-method-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Producto</code> (<code>Documento</code>)</p>
<ul>
<li>
<p>define la interfaz de los objetos que crea el metodo de fabricacion.</p>
</li>
</ul>
</li>
<li>
<p><code>ProductoConcreto</code> (<code>MiDocumento</code>)</p>
<ul>
<li>
<p>implementa la interfaz <code>Producto</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>Creador</code> (<code>Aplicacion</code>)</p>
<ul>
<li>
<p>declara el metodo de fabricacion, el cual devuelve un objeto de tipo <code>Producto</code>. Tambien puede definir una implementacion predeterminada del metodo de fabricacion que devuelve un objeto <code>ProductoConcreto</code>.</p>
</li>
<li>
<p>puede llamar al metodo de fabricacion para crear un objeto <code>Producto</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>CredorConcreto</code> (<code>MiAplicacion</code>)</p>
<ul>
<li>
<p>redefine el metodo de fabricacion para devolver una instancia de un <code>ProductoConcreto</code>.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="factory-method-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p>El <code>Creador</code> se apoya en sus subclases para definir el metodo de fabricacion de manera que este devuelva una instancia del <code>ProductoConcreto</code> apropiado.</p>
</div>
<h4 id="factory-method-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>Los metodos de fabricacion eliminan la necesidad de ligar clases especificas de la aplicacion a nuestro codigo. El codigo solo trata con la interfaz <code>Producto</code>; ademas, puede funcionar con cualquier clase <code>ProductoConcreto</code> definida por el usuario.</p>
<p>Un inconveniente potencial de los metodos de fabricacion es que los clientes pueden tener que heredar de la clase <code>Creador</code> simplemente para crear un determinado objeto <code>ProductoConcreto</code>. La herencia esta bien cuando el cliente tiene que heredar de todos modos de la clase <code>Creador</code>, pero si no es asi estariamos introduciendo una nueva via de futuros cambios.</p>
<p>Estas son dos consecuencias mas del patron Factory Method:</p>
<ol class="num" >
<li>
<p><em>Proporciona enganches para las subclases.</em> Crear objetos dentro de una clase con un metodo de fabricacion es siempre mas flexible que hacerlo directamente. El Factory Method les da a las subclases un punto de enganche para proveer una version extendida de un objeto.</p>
<p>En el ejemplo del documento, la clase <code>Documento</code> podria definir un metodo de fabricacion llamado <code>CrearDialogoDeFichero</code> que crea un objeto de dialogo predeterminado para abrir un documento existente. Una subclase de <code>Documento</code> puede definir dialogos de ficheros especificos de la aplicacion redefiniendo este metodo. En este caso el metodo de fabricacion no es abstracto, sino que proporciona una implementacion predeterminada razonable.</p>
</li>
<li>
<p><em>Conecta jerarquias de clases paralelas.</em> En los ejemplos vistos hasta ahora, al metodo de fabricacion solo lo llaman los objetos <code>Creador</code>. Pero esto no tiene por que ser siempre asi; los clientes pueden encontrar utiles los metodos de fabricacion, especialmente en el caso de jerarquias de clase paralelas.</p>
<p>Las jerarquias de clases paralelas se producen cuando una clase delega alguna de sus responsabilidades a una clase separada. Pensemos en figuras graficas que pueden manipularse interactivamente; es decir, que pueden alargarse, moverse y girarse usando el raton. Implementar estas interacciones no siempre es facil. Muchas veces requiere almacenar y actualizar informacion que guarda el estado de la manipulacion en un momento dado. Este estado es necesario solo mientras dura la manipulacion; por tanto, no necesita ser almacenado en el objeto figura. Es mas, figuras diferentes se comportan de manera diferente cuando son maninpuladas por el usuario. Por ejemplo, alargar una linea puede tener el efecto de mover un extremo, mientras que alargar una figura de texto puede cambiar su espaciado entre lineas.</p>
<p>Con estas restricciones, es mejor usar un objeto <code>Manipulador</code> separado que implemente la interaccion y mantenga cualquier estado especifico de la manipulacion que sea necesario. Figuras diferentes usaran distintas subclases de <code>Manipulador</code> para manejar las interacciones. La jerarquia de clases de <code>Manipulador</code> resultante (al menos en parte) a la jerarquia de clases de <code>Figura</code>:</p>
<figure>
<img src="img/040.png" />
</figure>
</li>
</ol>
<p>La clase <code>Figura</code> proporciona un metodo de fabricacion <code>CrearManipulador</code> que permite que los clientes creen el <code>Manipulador</code> correspondiente a una figura. Las subclases de <code>Figura</code> redefinen este metodo para que devuelva una instancia de la subclase de <code>Manipulador</code> adecuada para cada una de ellas. Otra posibilidad es que la clase <code>Figura</code> implemente <code>CreacManipulador</code> para que devuelva una instancia predeterminada de <code>Manipulador</code>, y las subclases de <code>Figura</code> pueden simplemente heredar ese comportamiento predeterminado. Esas clases <code>Figura</code> no necesitan su correspondiente subclase de <code>Manipulador</code> ––de hay que las jerarquias sean paralelas solo en parte––.</p>
<p>Es importante notar como el metodo de fabricacion define la conexion entre las dos jerarquias de clases, localizando que clases van juntas.</p>
</div>
<h4 id="factory-method-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>A la hora de aplicar el patron Factory Method hemos de tener en cuenta las siguientes cuestiones:</p>
<ol class="num" >
<li>
<p><em>Dos variantes principales.</em> Las dos principales variantes del patron Factory Method son (1) cuando la clase <code>Creador</code> es una clase abstracta y no proporciona una implementacion para el metodo de fabricacion que declara y (2) cuando el <code>Creador</code> es una clase concreta y proporciona una implementacion predeterminada del metodo de fabricacion. Tambien es posible tener una clase abstracta que defina una implementacion predeterminada, pero esto es menos comun.</p>
<p>El primer caso <em>requiere</em> que las subclases definan una implementacion porque no hay nungun comportamiento predeterminado razonable. Esto lleva al dilema de tener que crear instancias de clase imprevisibles. En el segundo caso, el <code>Creador</code> concreto usa el metodo de fabricacion principalmente por flexibilidad. Lo hace siguiendo una regla que dice: <q>Crear objetos en una operacion aparte, para que las subclases puedan redefinir el modo en que son creados</q>. Esta regla asegura que los diseñadores de las subclases puedan cambiar la clase de objetos que instancia su clase padre si es necesario.</p>
</li>
<li>
<p><em>Metodos de fabricacion parametrizados.</em> Otra variante del patron permite que los metodos de fabricacion creen varios tipos de productos. El metodo de fabricacion recibe un parametro que identifica el tipo de objeto a crear. Todos los objetos creados por el metodo compartiran la interfaz <code>Producto</code>. En el ejemplo del documento, <code>Aplicacion</code> puede soportar diferentes tipos de Documentos. Pasando un parametro extra a <code>CrearDocumento</code> se especifica el tipo de documento a crear. El framework de edicion grafica  Unidraw [<a href="#vl90" >VL90</a>] usa este enfoque para reconstruir objetos guardados en disco. Unidraw define una clase <code>Creator</code> con un metodo de fabricacion <code>Create</code> que recibe como argumento un identificador de clase. Cuando Unidraw guarda un objeto en disco, primero escribe el identificador de la clase y luego sus variables de instancia. Cuando se reconstruye el objeto desde el disco, primero lee el identificador de la clase.</p>
<p>Una vez que ha leido el identificador de la clase, el framework llama a <code>Create</code>, pasandole el identificador como el parametro. <code>Create</code> busca el constructor de la clase correspondiente y lo usa para crear una instancia del objeto. Por ultimo, <code>Create</code> llama a la operacion <code>Read</code> del objeto, que lee la informacion restante del disco e inicializa las variables de instancia del objeto.</p>
<p>un metodo de fabricacion parametrizado tiene la siguiente forma general, donde <code>MiProducto</code> y <code>TuProducto</code> son subclases de <code>Producto</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Creador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="n">Producto</span><span class="o">*</span> <span class="n">Crear</span><span class="p">(</span><span class="n">IdProducto</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">Producto</span><span class="o">*</span> <span class="n">Creador</span><span class="o">::</span><span class="n">Crear</span> <span class="p">(</span><span class="n">IdProducto</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">MIO</span><span class="p">)</span>  <span class="k">return</span> <span class="k">new</span> <span class="n">MiProducto</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">TUYO</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">TuProducto</span><span class="p">;</span>
  <span class="c1">// repetir para los productos restantes...
</span><span class="c1"></span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Redefiniendo un metodo de fabricacion parametrizado se puede extender o cambiar facilmente y de manera selectiva los productos fabricados por un <code>Creador</code>. Se pueden introducir nuevos identificadores para nuevos tipos de productos, o asociar identificadores existentes con productos diferentes.</p>
<p>Por ejemplo, una subclase de <code>MiCreador</code> podria cambiar <code>MiProducto</code> por <code>TuProducto</code> y admitir una nueva subclase <code>SuProducto</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">Producto</span><span class="o">*</span> <span class="n">MiCreador</span><span class="o">::</span><span class="n">Crear</span> <span class="p">(</span><span class="n">IdProducto</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">TUYO</span><span class="p">)</span>  <span class="k">return</span> <span class="k">new</span> <span class="n">MiProducto</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">MIO</span><span class="p">)</span>   <span class="k">return</span> <span class="k">new</span> <span class="n">TuProducto</span><span class="p">;</span>
  <span class="c1">// Nota: intercambiados TUYO y MIO
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">SUYO</span><span class="p">)</span>  <span class="k">return</span> <span class="k">new</span> <span class="n">SuProducto</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">Creador</span><span class="o">::</span><span class="n">Crear</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">// llamado cuanda falla todo lo demas
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Notese que lo ultimo que hace esta operacion es llamar a <code>Crear</code> de la clase padre. Eso es debido a que <code>MiCreador::Crear</code> solo trata <code>TUYO</code>, <code>MIO</code> y <code>SUYO</code> de forma diferente a la clase padre. No esta interesada en otras clases. Por tanto <code>MiCreador</code> <em>extiende</em> los tipos de productos creados, y delega en su padre la responsabilidad de crear todos los productos excepto unos pocos.</p>
</li>
<li>
<p><em>Variantes y cuestiones especificas del lenguaje.</em> Lenguajes diferentes se prestan a otras interesantes variaciones.</p>
<p>Los programas en Smalltalk suelen usar un metodo que devuelve la clase del objeto a crear. Un metodo de fabricacion en <code>Creador</code> puede usar este valor para crear un producto, y un <code>CreadorConcreto</code> puede almacenar o procesar dicho valor. El resultado es un enlace todavia mas tardio al tipo de <code>ProductoConcreto</code> a crear.</p>
<p>Una version en Smalltalk del ejemplo del <code>Documento</code> puede definir un metodo <code>claseDocumento</code> en <code>Aplicacion</code>. El metodo <code>claseDocumento</code> devuelve la clase de <code>Documento</code> apropiada para crear instancias de documentos. La implementacion de <code>claseDocumento</code> en <code>MiAplicacion</code> devuelve la clase <code>MiDocumento</code>. Asi, en la clase <code>Aplicacion</code> tenemos</p>
<pre class="code" ><code class="chroma" ><span class="nf">metodoCliente</span>
    <span class="nv">documento</span> <span class="o">:=</span> <span class="bp">self</span> <span class="nf">claseDocumento</span> <span class="nb">new</span><span class="p">.</span>

<span class="nf">claseDocumento</span>
    <span class="bp">self</span> <span class="nf">subclaseResponsibility</span>
</code></pre>
<p>y en la clase <code>MiAplicacion</code> tenemos</p>
<pre class="code" ><code class="chroma" ><span class="nf">claseDocumento</span>
    <span class="o">^</span> <span class="nf">MiDocumento</span>
</code></pre>
<p>que devuelve la clase <code>MiDocumento</code> que debe ser instanciada por <code>Aplicacion</code>.</p>
<p>Un enfoque aun mas flexible que esta estrechamente relacionado con los metodos de fabricacion parametrizados es guardar la clase a crear como una variable de clase de <code>Aplicaciones</code>. De esa forma no tenemos que heredar de <code>Aplicaicon</code> para cambiar el producto.</p>
<p>Los metodos de fabricacion en C++ son siempre funciones virtuales y a menudo virtuales puras. Hay que tener cuidado de no llamar a los metodos de fabricacion en el constructor del <code>Creador</code> ––el metodo de fabricacion del <code>CreadorConcreto</code> todavia no estara disponible––.</p>
<p>Podemos evitar esto teniendo la precaucion de acceder a los productos solo a traves de operaciones de acceso que crean el producto cuando es necesario. En vez de crear el producto concreto en el constructor, este simplemente lo inicializa a 0. Es el metodo de acceso el que devuelve el producto, pero primero comprueba que exista, y si no es asi lo crea. A esta tecnica se le llama a veces <b>inicializacion perezosa</b>.<span class="note" ><sup><a href="#30" >30</a></sup></span> El siguiente codigo muestra una implementacion tipica:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Creador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Producto</span><span class="o">*</span> <span class="n">ObtenerProducto</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">Producto</span><span class="o">*</span> <span class="n">CrearProducto</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Producto</span><span class="o">*</span> <span class="n">_producto</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Producto</span><span class="o">*</span> <span class="n">Creador</span><span class="o">::</span><span class="n">ObtenerProducto</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_producto</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_producto</span> <span class="o">=</span> <span class="n">CrearProducto</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_producto</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</li>
<li>
<p><em>Usar plantillas para evitar la herencia.</em> Como ya hemos mencionado, otro potencial problema de los metodos de fabricacion es que pueden obligar a usar la herencia solo para crear los objetos <code>Producto</code> apropiados. Otra forma de hacer esto en C++ es proporcionar una subclase plantilla de <code>Creador</code> que esta parametrizada con la clase de <code>Producto</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Creador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">Producto</span><span class="o">*</span> <span class="n">CreadorProducto</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ElProducto</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">CreadorEstandar</span><span class="o">:</span> <span class="k">public</span> <span class="n">Creador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">Producto</span><span class="o">*</span> <span class="n">CrearProducto</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ElProducto</span><span class="o">&gt;</span>
<span class="n">Producto</span><span class="o">*</span> <span class="n">CreadorEstandar</span><span class="o">&lt;</span><span class="n">ElProducto</span><span class="o">&gt;::</span><span class="n">CrearProducto</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ElProducto</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Con esta plantilla el cliente unicamente proporciona la clase del producto ––no se necesita heredar de <code>Creador</code>––.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">MiProducto</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Producto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">MiProducto</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>

<span class="n">CreadorEstandar</span><span class="o">&lt;</span><span class="n">MiProducto</span><span class="o">&gt;</span> <span class="n">miCreador</span><span class="p">;</span>
</code></pre>
</li>
<li>
<p><em>Convenios de nominacion.</em> Es una buena practica usar convenios de nominacion que dejan claro que estamos usando metodos de fabricacion. Por ejemplo, el framework de aplicaciones para Macintosh MacApp [<a href="#app89" >App89</a>] siempre declara la operacion abstracta que define el metodo de fabricacion como <code>Class* DoMakeClass()</code>, donde <code>Class</code> es la clase <code>Producto</code>.</p>
</li>
</ol>
</div>
<h4 id="factory-method-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>La funcion <a href="#Capitulo-3" ><code>CrearLaberinto</code></a> construye y devuelve un laberinto. Un problema de esta funcion es que fija en el codigo la clase del laberinto y de las habitaciones, puertas y paredes. Introduciremos metodos de fabricacion para permitir que las subclases elijan estos componentes.</p>
<p>Primero definiremos metodos de fabricacion de <code>JuegoDelLaberinto</code> para crear los objetos laberinto, habitacion, pared y puerta:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">JuegoDelLaberinto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Laberinto</span><span class="o">*</span> <span class="n">CrearLaberinto</span><span class="p">();</span>

<span class="c1">// metodos de fabricacion
</span><span class="c1"></span>
    <span class="k">virtual</span> <span class="n">Laberinto</span><span class="o">*</span> <span class="nf">FabricarLaberinto</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Laberinto</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="nf">FabricarHabitacion</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Habitacion</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">Pared</span><span class="o">*</span> <span class="nf">FabricarPared</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">Puerta</span><span class="o">*</span> <span class="nf">FabricarPuerta</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span> <span class="n">h1</span><span class="p">,</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h2</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Habitacion</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre>
<p>Cada metodo de fabricacion devuelve un componente laberinto de un tipo dado. <code>JuegoDelLaberinto</code> proporciona implementaciones predetermindas que devuelven los tipos mas simples de laberintos, habitaciones, paredes y puertas.</p>
<p>Ahora podemos redefinir <code>CrearLaberinto</code> para que use estos metodos de fabricacion:</p>
<pre class="code" ><code class="chroma" ><span class="n">Laberinto</span><span class="o">*</span> <span class="n">JuegoDelLaberinto</span><span class="o">::</span><span class="n">CrearLaberinto</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">Laberinto</span><span class="o">*</span> <span class="n">unLaberinto</span> <span class="o">=</span> <span class="n">FabricarLaberinto</span><span class="p">();</span>

    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">FabricarHabitacion</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">FabricarHabitacion</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">Puerta</span><span class="o">*</span> <span class="n">laPuerta</span> <span class="o">=</span> <span class="n">FabricarPuerta</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">);</span>

    <span class="n">unLaberinto</span><span class="o">-&gt;</span><span class="n">AnadirHabitacion</span><span class="p">(</span><span class="n">h1</span><span class="p">);</span>
    <span class="n">unLaberinto</span><span class="o">-&gt;</span><span class="n">AnadirHabitacion</span><span class="p">(</span><span class="n">h2</span><span class="p">);</span>

    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Norte</span><span class="p">,</span> <span class="n">FabricarPared</span><span class="p">());</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Este</span><span class="p">,</span> <span class="n">laPuerta</span><span class="p">);</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Sur</span><span class="p">,</span> <span class="n">FabricarPared</span><span class="p">());</span>
    <span class="n">h1</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Oeste</span><span class="p">,</span> <span class="n">FabricarPared</span><span class="p">());</span>

    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Norte</span><span class="p">,</span> <span class="n">FabricarPared</span><span class="p">());</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Este</span><span class="p">,</span> <span class="n">FabricarPared</span><span class="p">);</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Sur</span><span class="p">,</span> <span class="n">FabricarPared</span><span class="p">());</span>
    <span class="n">h2</span><span class="o">-&gt;</span><span class="n">EstablecerLado</span><span class="p">(</span><span class="n">Oeste</span><span class="p">,</span> <span class="n">laPuerta</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">unLaberinto</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Juegos diferentes pueden heredar de <code>JuegoDelLaberinto</code> para especializar partes del laberinto. Las subclases de <code>JuegoDelLaberinto</code> pueden redefinir algunos de los metodos de fabricacion o todos para especificar variantes de los productos. Por ejemplo, un <code>JuegoDelLaberintoConBombas</code> puede redefinir los productos <code>Habitacion</code> y <code>Pared</code> para devolver sus variantes con bomba:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">JuegoDelLaberintoConBombas</span> <span class="o">:</span> <span class="k">public</span> <span class="n">JuegoDelLaberinto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">JuegoDelLaberintoConBombas</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">Pared</span><span class="o">*</span> <span class="nf">FabricarPared</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ParedExplosionada</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="nf">CrearHabitacion</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">HabitacionConBomba</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre>
<p>se podria definir una variante <code>JuegoDelLaberintoEncantado</code> como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">JuegoDelLaberintoEncantado</span> <span class="o">:</span> <span class="k">public</span> <span class="n">JuegoDelLaberinto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">JuegoDelLaberintoEncantado</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="nf">FabricarHabitacion</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">HabitacionEncantada</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">Hechizar</span><span class="p">());</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">Puerta</span><span class="o">*</span> <span class="nf">FabricarPuerta</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span> <span class="n">h1</span><span class="p">,</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h2</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">PuertaQueNecesitaHechizo</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">);</span> <span class="p">}</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Hechizo</span><span class="o">*</span> <span class="n">Hechizar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>
<h4 id="factory-method-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Los toolkits y frameworks estas plagados de metodos de fabricacion. El anterior ejemplo del documento es un tipico uso de MacApp y ET++ [<a href="#wgm88" >WGM88</a>]. El ejemplo del manipulador viene de Unidraw.</p>
<p>La clase <code>View</code> en el framework Modelo/Vista/Controlador de Smalltalk-80 tiene un metodo <code>defaultController</code> que crea un controlador, lo que puede parecer un metodo de fabricacion [<a href="#par90" >Par90</a>]. Pero las subclases de <code>View</code> especifican la clase de su controlador predeterminado definiendo <code>defaultControllerClass</code>, que devuelve la clase a partir de la cual <code>defaultController</code> crea las instancias. Por tanto es <code>defaultControllerClass</code> quien es realmente el metodo de fabricacion, es decir, el metodo que deberian redefinir las subclases.</p>
<p>Un ejemplo mas oculto en Smalltalk-80 es el metodo de fabricacion <code>paperClass</code> definido por <code>Behavior</code> (una superclase de todos los objetos que representan clases). Esto permite que una clase use un analizador personalizado para su codigo fuente. Por ejemplo, un cliente puede definir una clase SQLParser para analizar el codigo fuente de una clase con sentencias SQL insertadas. La clase <code>Behaviour</code> implementa <code>parserClass</code> para devolver la clase <code>Parser</code> estandar en Smalltalk. Una clase que incluya sentencias SQL insentadas redefine este metodo (como un metodo de clase) y devuelve la clase <code>SQLParser</code>.</p>
<p>El sistema ORB Orbix de IONA Technologies [<a href="#ion94" >ION94</a>] usa el patron Factory Method para generar un tipo adecuado de proxy (vease el patron <a href="#proxy" >Proxy</a>) cuando un objeto solicita una referencia a un objeto remoto. El patron Factory Method facilita reemplazar el proxy predeterminado con otro que use cache en el lado del cliente, por ejemplo.</p>
</div>
<h4 id="factory-method-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>El patron Abstract Factory suele implementarse con metodos de fabricacion. El ejemplo que aparece en la seccion <a href="#Abstract-Factory-Motivacion" >Motivacion</a> del patron Abstract Factory ilustra tambien un metodo de fabricacion.</p>
<p>Los metodos de fabricacion generalmente son llamados desde el interior de <a href="#Template-Method" >Metodos Plantilla</a>. En el ejemplo del documento, <code>NuevoDocumento</code> es un metodo plantilla.</p>
<p>El <a href="#prototype" >Prototype</a> no necesita heredar de <code>Creador</code>. Sin embargo, suelen requerir una operacion <code>Inicializar</code> en la clase <code>Producto</code>. El <code>Creador</code> usa <code>Inicializar</code> para inicializar el objeto. El patron Factory Method no requiere dicha operacion.</p>
</div>
<h3 id="prototype" >Prototype</h3>
<h4 id="prototype-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Especifica los tipos de objetos a crear por medio de una instancia prototipica, y crea nuevos objetos copiando dicho prototipo.</p>
</div>
<h4 id="prototype-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Podriamos construir un editor de partituras musicales adaptando un framework general para editores graficos y añadiendo nuevos objetos que representan notas, silencios y pentagramas. El framework puede tener una paleta de herramientas para añadir estos objetos musicales a la partitura. La paleta tambien incluira herramientas para seleccionar, mover y realizar otras manipulaciones de objetos musicales. Los usuarios haran clic en la herramienta de negras y la usaran para añadir negras a la partitura. O pueden usar la herramienta de movimiento para mover una nota arriba o abajo en el pentagrama cambiando asi su tono.</p>
<p>Supongamos que el framework proporciona una clase abstracta <code>Grafico</code> para componentes graficos, como notas y pentangramas. Ademas, proporcionara una clase abstracta <code>Herramienta</code> para definir herramientas como las de la paleta. El framework tambien predefine una subclase <code>HerramientaGrafica</code> para herramientas que crean instancias de objetos graficos y los añaden al documento.</p>
<p>Pero <code>HerramientaGrafica</code> representa un problema para el diseñador del framework. Las clases para notas y pentagramas son especificas de nuestra aplicacion, pero la clase <code>HerramientaGrafica</code> pertenece al framework, por lo que no sabe como crear instancias de nuestras clases musicales para añadirlas a la partitura. Podriamos crear una subclase de <code>HerramientaGrafica</code> para cada tipo de objeto musical, pero eso produciria muchas subclases que se diferenciarian solamente en el tipo de objeto musical que crean. Sabemos que la composicion de objetos es una alternativa flexible a la herencia. La cuestion es ¿como puede usarla el framework para parametrizar instancias de <code>HerramientaGrafica</code> con la <em>clase</em> de <code>Grafico</code> que deben crear?</p>
<p>La solucion consiste en hacer que <code>HerramientaGrafica</code> cree un nuevo <code>Grafico</code> copiando o <q>clonando</q> una instancia de una subclase <code>Grafico</code>. Llamaremos a esta instancia un <b>prototipo</b>. <code>HerramientaGrafica</code> esta paramentrizada con el prototipo que deberia clonar y añadir al documento. Si todas las subclases de <code>Grafico</code> admiten una operacion <code>Clonar</code>, la <code>HerramientaGrafica</code> puede clonar cualquier tipo de <code>Grafico</code>.</p>
<p>Por tanto, en nuestro editor musical, cada herramienta para crear un objeto musical es una instancia de <code>HerramientaGrafica</code> que esta inicializada con un prototipo diferente. Cada instancia de <code>HerramientaGrafica</code> producira un objeto musical clonando su prototipo y añadiendo el clon a la partitura.</p>
<p>Podemos usar el patron <b>Prototype</b> para reducir aun mas el numero de clases. Tenemos clases separadas para redondas y negras, pero eso probablemente no sea necesario. En vez de eso podrian ser instancias de la misma clase inicilizadas con diferentes mapas de bits y duraciones. Una herramienta para crear redondas pasa a ser simplemente una <code>HerramientaGrafica</code> cuyo prototipo es una <code>NotaMusical</code> inicialazada para que sea una redonda. Esto puede reducir drasticamente el numero de clases del sistema. Tambien hace que sea mas facil añadir un nuevo tipo de nota al editor.</p>
<figure>
<img src="img/041.png" />
</figure>
</div>
<h4 id="prototype-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Prototype cuando un sistema deba ser independiente de como se crean, se componen y se representan sus productos y</p>
<ul>
<li>
<p>cuando las clases a instanciar sean especificadas en tiempo de ejecucion (por ejemplo, mediante carga dinamica); o</p>
</li>
<li>
<p>para evitar construir una jerarquia de clases de fabricas paralela a la jerarquia de clases de los productos; o</p>
</li>
<li>
<p>cuando las instancias de una clase puedan tener uno de entre solo unos cuantos estados diferentes. Puede ser mas adecuado tener un numero equivalente de prototipos y clonarlos, en vez de crear manualmente instancias de la clase cada vez con el estado apropiado.</p>
</li>
</ul>
</div>
<h4 id="prototype-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/042.png" />
</figure>
</div>
<h4 id="prototype-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Prototipo</code> (<code>Grafico</code>)</p>
<ul>
<li>
<p>declara una interfaz para clonarse.</p>
</li>
</ul>
</li>
<li>
<p><code>PrototipoConcreto</code> (<code>Pentagrama</code>, <code>Redonda</code>, <code>Blanca</code>)</p>
<ul>
<li>
<p>implementa una operacion para clonarse.</p>
</li>
</ul>
</li>
<li>
<p><code>Cliente</code> (<code>HerramientaGrafica</code>)</p>
<ul>
<li>
<p>crea un nuevo objeto pidiendole a un prototipo que se clone.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="prototype-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p>Un cliente le pide a un prototipo que se clone.</p>
</div>
<h4 id="prototype-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>Muchas de las consecuencias del Prototype son las mismas que las de los patrones <a href="#abstract-fartory" >Abstract Fartory</a> y <a href="#builder" >Builder</a>: oculta al cliente las clases producto concretas, reduciendo asi el numero de nombres que conocen los clientes. Ademas, estos patrones permiten que el cliente use clases especificadas de la aplicacion sin cambios.</p>
<p>A continuacion se enumeran algunos beneficios adicionales del patron Prototype.</p>
<ol class="num" >
<li>
<p><em>Añadir y eliminar productos en tiempo de ejecucion.</em> Permite incorporar a un sistema una nueva clase concreta de producto simplemente registrando una instancia prototipica con el cliente. Esto es algo mas flexible que otros patrones de creacion, ya que un cliente puede instalar y eliminar prototipos en tiempo de ejecucion.</p>
</li>
<li>
<p><em>Especificar nuevos objetos modificando valores.</em> Los sistemas altamente dinamicos permiten definir comportamiento nuevo mediante la composicion de objetos ––por ejemplo, especificando valores para las variables de un objeto–– y no definiendo nuevas clases. Podemos definir nuevos tipos de objetos creando instancias de clases existentes y registrando esas instancias como prototipos de los objetos cliente. Un cliente puede exhibir comportamiento nuevo delegando responsabilidad en su prototipo.</p>
<p>Este tipo de diseño permite que los usuarios definan nuevas <q>clases</q> sin programacion. De hecho, clonar un prototipo es parecido a crear una instancia de una clase. El patron Prototipe puede reducir en gran medida el numero de clases necesarias en un sistema. En nuestro editor de musica, una clase <code>HerramientaGrafica</code> puede crear una gran variedad de objetos.</p>
</li>
<li>
<p><em>Especificar nuevos objetos variando la estructura.</em> Muchas aplicaciones construyen objetos a partir de partes y subpartes. Los editores de diseño de circuitos, por ejemplo, construyen circuitos a partir de subcircuitos. A menudo, por comodidad, dichas aplicaciones permiten crear instancias de estructuras complejas definidas por el usuario, por ejemplo, para usar un determinado subcircuito una y otra vez.</p>
<p>El patron Prototype tambien permite esto. Simplemente añadimos ese subcircuito como prototipo a la paleta de circuitos disponibles. Siempre y cuando el objeto circuito compuesto implemente <code>Clonar</code> como una copia profunda, los circuitos con varias estructuras tambien pueden ser prototipos.</p>
</li>
<li>
<p><em>Reduce la herencia.</em> El patron <a href="#factory-method" >Factory Method</a> suele producir una jerarquia de clases <code>Creador</code> que es paralela a la jerarquia de clases de productos. El patron Prototype permite clonar un prototipo en vez de decirle a un metodo de fabricacion que cree un nuevo objeto. Por tanto, no es en absoluto necesaria una jerarquia de clases <code>Creador</code>. Este beneficio es aplicable principalmente a lenguajes como C++, que no tratan a las clases como objetos en toda regla.</p>
<p>En los lenguajes que si lo hacen, como Smalltalk y Objetive C, resulta un beneficio menor, puesto que siempre podemos usar un objeto clase como creador. Los objetos clase ya funcionan en estos lenguajes como prototipos.</p>
</li>
<li>
<p><em>Configurar dinamicamente una aplicacion con clases.</em> Algunos entornos de tiempo de ejecucion permiten cargar clases en una aplicacion dinamicamente. El patron Prototype es la clave para explotar dichas facilidades en un lenguaje como C++.</p>
<p>Una aplicacion que quiere crear instancias de una clase cargada dinamicamente no podra hacer referencia al constructor de esta estaticamente. En vez de eso, el entorno en tiempo de ejecucion crea automaticamente una instancia de cada clase cada vez que es cargada, y la registra con un gestor de prototipos (vease la Seccion de <a href="#Prototype-Implementacion" >Implementacion</a>). Despues, la aplicacion puede solicitar al gestor de prototipos instancias de nuevas clases cargadas, es decir, clases que no fueron enlazadas con el programa originalmente. El framework de aplicacion ET++ [<a href="#wgm88" >WGM88</a>] tiene un sistema de tiempo de ejecucion que usa este esquema.</p>
</li>
</ol>
<p>El principal inconveniente del patron Prototype es que cada subclase de <code>Prototipo</code> debe implementar la operacion <code>Clonar</code>, lo cual puede ser dificil. Por ejemplo, añadir <code>Clonar</code> es dificil cuando las clases ya existen. Igualmente, puede ser dificil implementar <code>Clonar</code> cuando sus interioridades incluyen objetos que no pueden copiarse o que tienen referencias circulares.</p>
</div>
<h4 id="prototype-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>El Prototype es particularmente util con lenguajes estaticos como C++, donde las clases no son objetos, y en los que poca o ninguna informacion de tipos esta disponible en tiempo de ejecucion. Es menos importante en lenguajes como Smalltalk y Objetive C, que proporcionan lo que viene a ser un prototipo (es decir, un objeto clase) para crear instancias de cada clase.</p>
<p>Este patron lo incorporan los lenguajes basados en prototipos, como Self [<a href="#us87" >US87</a>], en los cuales toda creacion de objetos tiene lugar clonando un prototipo.</p>
<p>Hemos de tener en cuenta las siguientes cuestiones a la hora de implementar prototipos:</p>
<ol class="num" >
<li>
<p><em>Usar un gestor de prototipos.</em> Cuando el numero de prototipos de un sistema no es fijo (es decir, cuando pueden crearse y destruirse dinamicamente), mantiene un registro de los prototipos disponibles. Los clientes no gestionaran ellos mismos los prototipos, sino que los guardaran y recuperaran del registro. Un cliente le pedira al registro un prototipo antes de clonarlo. Llamaremos a este registro un gestor de prototipos.</p>
<p>Un gestor de prototipos es un almacen asociativo que devuelve el prototipo que concuerda con una determinada clave. Tiene operaciones para registrar un prototipo con una clave y para desregistrarlo. Los clientes pueden cambiar el registro o incluso navegar por el en tiempo de ejecucion. Esto permite que los clientes extiendan el sistema y lleven un inventario del mismo sin necesidad de escribir codigo.</p>
</li>
<li>
<p><em>Implementar la operacion <code>Clonar</code>.</em> La parte mas completa del patron Prototype es implementar correctamente la operacion <code>Clonar</code>. Es particularmente delicado cuando las estructuras de objetos contienen referencias circulares.</p>
<p>La mayoria de los lenguajes proporcionan algun tipo de ayuda para clonar objetos. Por ejemplo, Smalltalk proporciona una implementacion de <code>copy</code> que es heredada por todas las subclases de <code>Object</code>. C++ proporciona un constructor de copia. Pero estas facilidades no resuelven el problema de la <q>copia superficial frente a la copia profunda</q> [<a href="#gr83" >GR83</a>]. Es decir, ¿clonar un objeto clona a su vez sus variables de instancia, o el objeto clonado y el original simplemente comparten sus variables?</p>
<p>Una copia superficial es simple y a menudo suficiente, y es lo que Smalltalk proporciona de manera predeterminada. El constructor de copia por omision en C++ hace una copia de miembro, lo que significa que la copia y el original compartiran sus punteros. Pero clonar prototipos con estructuras complejas normalmente requiere una copia profunda, porque el clon y el original deben ser independientes. Por tanto debemos garantizar que los componentes del clon son clones de los componentes del prototipo. La clonacion nos obliga a decidir que sera compartido, si es que lo sera algo.</p>
<p>Si los objetos del sistema proporcionan operaciones <code>Guardar</code> y <code>Cargar</code>, entonces podemos usarlas para proporcionar una implementacion predeterminada de <code>Clonar</code>, simplemente guardando el objeto y cargandolo de nuevo a continuacion. La operacion <code>Guardar</code> guarda el objeto en un bufer en memoria, y <code>Cargar</code> crea un duplicado reconstruyendo el objeto a partir del bufer.</p>
</li>
<li>
<p><em>Inicializar los clones.</em> Mientras que a algunos clientes les sirve el clon tal cual, otros querran unicializar parte de su estado interno, o todo, con valores de su eleccion. Generalmente no pasamos dichos valores en la operacion <code>Clonar</code>, porque su numero variara de unas clases de prototipos a otras. Algunos prototipos pueden necesitar multiples parametros de inicializacion; otros no necesitan ninguno. Pasar parametros en la operacion <code>Clonar</code> impide tener una interfaz de clonacion uniforme.</p>
<p>Puede darse el caso de que nuestras clases prototipo ya definan operaciones para establecer las partes principales de su estado. Si es asi, los clientes pueden usar estas operaciones inmediatamente despues de la clonacion. Si no, quizas tengamos que introducir una operacion <code>Inicializar</code> (vease la Seccion <a href="#Prototype-Codigo-de-Ejemplo" >Codigo de Ejemplo</a>) que tome parametros de inicializacion como argumentos y establezca el estado interno del clon. Hemos de tener cuidado con las operaciones <code>Clonar</code> que hacen una copia profunda ––quiza tengamos que borrar las copias (ya sea explicitamente o desde dentro de <code>Inicializar</code>–– antes de reinicializarlas).</p>
</li>
</ol>
</div>
<h4 id="prototype-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Definiremos <code>FabricaDePrototiposLaberinto</code> como subclase de la clase <code>FabricaDeLaberintos</code>. <code>FabricaDePrototiposLaberinto</code> sera inicializada con prototipos de los objetos que creara, de manera que no habra que heredar de ella solo para cambiar las clases de paredes o habitaciones que crea.</p>
<p><code>FabricaDePrototiposLaberinto</code> aumenta la interfaz <code>FabricaDeLaberintos</code> con un constructor que toma como argumentos los prototipos:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">FabricaDePrototiposLaberinto</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FabricaDeLaberintos</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">FabricaDePrototiposLaberinto</span><span class="p">(</span><span class="n">Laberinto</span><span class="o">*</span><span class="p">,</span> <span class="n">Pared</span><span class="o">*</span><span class="p">,</span> <span class="n">Habitacion</span><span class="o">*</span><span class="p">,</span> <span class="n">Puerta</span><span class="o">*</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="n">Laberinto</span><span class="o">*</span> <span class="nf">HacerLaberinto</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="nf">HacerHabitacion</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Pared</span><span class="o">*</span> <span class="nf">HacerPared</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Puerta</span><span class="o">*</span> <span class="nf">HacerPuerta</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span><span class="p">,</span> <span class="n">Habitacion</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Laberinto</span><span class="o">*</span> <span class="n">_prototipoLaberinto</span><span class="p">;</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">_prototipoHabitacion</span><span class="p">;</span>
    <span class="n">Pared</span><span class="o">*</span> <span class="n">_protipoPared</span><span class="p">;</span>
    <span class="n">Puerta</span><span class="o">*</span> <span class="n">_prototipoPuerta</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>El nuevo constructor simplemente inicializa sus prototipos:</p>
<pre class="code" ><code class="chroma" ><span class="n">FabricaDePrototiposLaberinto</span><span class="o">::</span><span class="n">FabricaDePrototiposLaberinto</span> <span class="p">(</span>
    <span class="n">Laberinto</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">Pared</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="n">Puerta</span><span class="o">*</span> <span class="n">pu</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">_prototipoLaberinto</span>  <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
    <span class="n">_prototipoPared</span>      <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">_prototipoHabitacion</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">_prototipoPuerta</span>     <span class="o">=</span> <span class="n">pu</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Las funciones miembro para crear paredes, habitaciones y puertas son parecidas: cada una clona un prototipo y luego lo inicializa. A continuacion se presentan las definiciones de <code>HacerPared</code> y <code>HacerPuerta</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">Pared</span><span class="o">*</span> <span class="n">FabricaDePrototiposLaberinto</span><span class="o">::</span><span class="n">HacerPared</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_prototipoPared</span><span class="o">-&gt;</span><span class="n">Clonar</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Puerta</span><span class="o">*</span> <span class="n">FabricaDePrototiposLaberinto</span><span class="o">::</span><span class="n">HacerPuerta</span> <span class="p">(</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h1</span><span class="p">,</span> <span class="n">Habicacion</span><span class="o">*</span> <span class="n">h2</span>
<span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">Puerta</span><span class="o">*</span> <span class="n">puerta</span> <span class="o">=</span> <span class="n">_prototipoPuerta</span><span class="o">-&gt;</span><span class="n">Clonar</span><span class="p">();</span>
    <span class="n">puerta</span><span class="o">-&gt;</span><span class="n">Inicializar</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">puerta</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Podemos usar <code>FabricaDePrototiposLaberinto</code> para crear un <code>Laberinto</code> prototipico o predeterminado simplemente inicializandolo con prototipos de los componentes basicos de <code>Laberinto</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">JuegoDelLaberinto</span> <span class="n">juego</span><span class="p">;</span>
<span class="n">FabricaDePrototiposLaberinto</span> <span class="nf">FabricaDeLaberintosSimples</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">Laberinto</span><span class="p">,</span> <span class="k">new</span> <span class="n">Pared</span><span class="p">,</span> <span class="k">new</span> <span class="n">Habitacion</span><span class="p">,</span> <span class="k">new</span> <span class="n">Puerta</span>
<span class="p">);</span>

<span class="n">Laberinto</span><span class="o">*</span> <span class="n">Laberinto</span> <span class="o">=</span> <span class="n">juego</span><span class="p">.</span><span class="n">CrearLaberinto</span><span class="p">(</span><span class="n">FabricaDeLaberintosSimples</span><span class="p">);</span>
</code></pre>
<p>Para cambiar el tipo de laberinto, inicializamos <code>FabricaDePrototiposLaberinto</code> con un conjunto diferente de prototipos. La siguiente llamada crea un <code>Laberinto</code> con una puerta <code>PuertaExplosionada</code> y una <code>HabitacionConBomba</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">FabricaDePrototiposLaberinto</span> <span class="nf">FabricaDeLaberintosConBomba</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">Laberinto</span><span class="p">,</span> <span class="k">new</span> <span class="n">ParedExplosionada</span><span class="p">,</span>
    <span class="k">new</span> <span class="n">HabitacionConBomba</span><span class="p">,</span> <span class="k">new</span> <span class="n">Puerta</span>
<span class="p">);</span>
</code></pre>
<p>Un objeto que pueda ser usado como prototipo, como por ejemplo una instancia de <code>Pared</code>, debe admitir la operacion <code>Clonar</code>. Tambien tiene que tener un constructor de copia para la clonacion. Puede necesitar tambien otra operacion para reinicializar su estado interno. Añadiremos la operacion <code>Inicializar</code> a <code>Puerta</code> para que los clientes puedan inicializar los clones de <code>Habitacion</code>.</p>
<p>Comparese la siguiente definicion de <code>Puerta</code> con la del <a href="#capitulo-3" >Capitulo 3</a>;:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Puerta</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LugarDelMapa</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Puerta</span><span class="p">();</span>
    <span class="n">Puerta</span><span class="p">(</span><span class="k">const</span> <span class="n">Puerta</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Inicializar</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span><span class="p">,</span> <span class="n">Habitacion</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">Puerta</span><span class="o">*</span> <span class="nf">Clonar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Entrar</span><span class="p">();</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="nf">OtroLadoDe</span><span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">_habitacion1</span><span class="p">;</span>
    <span class="n">Habitacion</span><span class="o">*</span> <span class="n">_habitacion2</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Puerta</span><span class="o">::</span><span class="n">Puerta</span> <span class="p">(</span><span class="k">const</span> <span class="n">Puerta</span><span class="o">&amp;</span> <span class="n">otra</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_habitacion1</span> <span class="o">=</span> <span class="n">otra</span><span class="p">.</span><span class="n">_habitacion1</span><span class="p">;</span>
    <span class="n">_habitacion2</span> <span class="o">=</span> <span class="n">otra</span><span class="p">.</span><span class="n">_habitacion2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Puerta</span><span class="o">::</span><span class="n">Inicializar</span> <span class="p">(</span><span class="n">Habitacion</span><span class="o">*</span> <span class="n">h1</span><span class="p">,</span> <span class="n">Habitacion</span><span class="o">*</span> <span class="n">h2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_habitacion1</span> <span class="o">=</span> <span class="n">h1</span><span class="p">;</span>
    <span class="n">_habitacion2</span> <span class="o">=</span> <span class="n">h2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Puerta</span><span class="o">*</span> <span class="n">Puerta</span><span class="o">::</span><span class="n">Clonar</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Puerta</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>La subclase <code>ParedExplosionada</code> debe redefinir <code>Clonar</code> e implementar su correspondiente constructor de copia.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ParedExplosionada</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Pared</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ParedExplosionada</span><span class="p">();</span>
    <span class="n">ParedExplosionada</span><span class="p">(</span><span class="k">const</span> <span class="n">ParedExplosionada</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="n">Pared</span><span class="o">*</span> <span class="nf">Clonar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">TieneBomba</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">_bomba</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">ParedExplosionada</span> <span class="p">(</span><span class="k">const</span> <span class="n">ParedExplosionada</span><span class="o">&amp;</span> <span class="n">otra</span><span class="p">)</span> <span class="o">:</span> <span class="n">Pared</span><span class="p">(</span><span class="n">otra</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_bomba</span> <span class="o">=</span> <span class="n">otra</span><span class="p">.</span><span class="n">_bomba</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Pared</span><span class="o">*</span> <span class="n">ParedExplosionada</span><span class="o">::</span><span class="n">Clonar</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ParedExplosionada</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Aunque <code>ParderExplosionada::Clonar</code> devuelve <code>Pared*</code>, su implementacion devuelve un puntero a una nueva instancia de una subclase, es decir, <code>ParedExplosionada*</code>. Definimos <code>Clonar</code> de ese modo en la clase base para asegurar que los clientes que clonan el prototipo no tienen que conocer a sus subclases concretas. Los clientes nunca deberian necesitar convertir el valor devuelto por <code>Clonar</code> al tipo deseado.</p>
<p>En Smalltalk podemos reutilizar el metodo estandar <code>copy</code> heredado de <code>Object</code> para clonar cualquier <code>LugarDelMapa</code>. Podemos usar <code>FabricaDeLaberintos</code> para producir los prototipos necesarios; por ejemplo, podemos crear una <code>Habitacion</code> suministrando el nombre <code>#Habitacion</code>. <code>LaFabricaDeLaberintos</code> tiene un diccionario que hace corresponder nombres con prototipos. Su metodo <code>hacer:</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="nf">hacer:</span> <span class="nv">nombreParte</span>
    <span class="o">^</span> (<span class="nv">catalogoDePartes</span> <span class="nf">at:</span> <span class="nv">nombreParte</span>) <span class="nf">copy</span>
</code></pre>
<p>Dados los metodos apropiados para inicializar la <code>FabricaDeLaberintos</code> con prototipos, podremos crear un <code>Laberinto</code> simple con el codigo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="nf">CrearLaberinto</span>
    <span class="err">on:</span> (<span class="nc">FabricaDeLaberintos</span> <span class="nb">new</span>
        <span class="nf">with:</span> <span class="nc">Puerta</span> <span class="nb">new</span> <span class="nf">named:</span> <span class="ss">#puerta</span><span class="p">;</span>
        <span class="nf">with:</span> <span class="nc">Pared</span> <span class="nb">new</span> <span class="nf">named:</span> <span class="ss">#pared</span><span class="p">;</span>
        <span class="nf">with:</span> <span class="nc">Habitacion</span> <span class="nb">new</span> <span class="nf">named:</span> <span class="ss">#habitacion</span><span class="p">;</span>
        <span class="nf">yourself</span>)
</code></pre>
<p>donde la definicion del metodo de clase <code>on:</code> para <code>CrearLaberinto</code> seria</p>
<pre class="code" ><code class="chroma" ><span class="nf">on:</span> <span class="nv">unaFabrica</span>
    <span class="o">|</span><span class="nv"> Habitacion1 Habitacion2 </span><span class="o">|</span>
    <span class="nc">Habitacion1</span> <span class="o">:=</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#habitacion</span>)
                   <span class="nf">ubicacion:</span> <span class="m">1</span><span class="nf">@</span><span class="m">1</span><span class="p">.</span>
    <span class="nc">Habitacion2</span> <span class="o">:=</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#habitacion</span>)
                   <span class="nf">ubicacion:</span> <span class="m">2</span><span class="nf">@</span><span class="m">1</span><span class="p">.</span>
    <span class="nv">puerta</span> <span class="o">:=</span> (<span class="nv">unaFabrica</span> <span class="nf">hacer:</span> <span class="ss">#puerta</span>) <span class="nf">de:</span> <span class="nv">habitacion1</span> <span class="nf">a:</span> <span class="nv">habitacion2</span><span class="p">.</span>

    <span class="nf">Habitacion1</span>
        <span class="nv">lado</span><span class="p">;</span> <span class="err">#</span><span class="nf">norte</span>  <span class="nf">put:</span> (<span class="nv">unafabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">;</span>
        <span class="nf">lado</span><span class="p">;</span> <span class="err">#</span><span class="nf">este</span>   <span class="nf">put:</span> <span class="nv">puerta</span><span class="p">;</span>
        <span class="nf">lado</span><span class="p">;</span> <span class="err">#</span><span class="nf">sur</span>    <span class="nf">put:</span> (<span class="nv">unafabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">;</span>
        <span class="nf">lado</span><span class="p">;</span> <span class="err">#</span><span class="nf">oeste</span>  <span class="nf">put:</span> (<span class="nv">unafabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">;</span>
    <span class="nf">Habitacion2</span>
        <span class="nf">lado</span><span class="p">;</span> <span class="err">#</span><span class="nf">norte</span>  <span class="nf">put:</span> (<span class="nv">unafabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">;</span>
        <span class="nf">lado</span><span class="p">;</span> <span class="err">#</span><span class="nf">este</span>   <span class="nf">put:</span> (<span class="nv">unafabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">;</span>
        <span class="nf">lado</span><span class="p">;</span> <span class="err">#</span><span class="nf">sur</span>    <span class="nf">put:</span> (<span class="nv">unafabrica</span> <span class="nf">hacer:</span> <span class="ss">#pared</span>)<span class="p">;</span>
        <span class="nf">lado</span><span class="p">;</span> <span class="err">#</span><span class="nf">oeste</span>  <span class="nf">put:</span> <span class="nv">puerta</span><span class="p">;</span>
    <span class="err">^</span> <span class="nf">Laberinto</span> <span class="nb">new</span>
        <span class="nf">anadirHabitacion:</span> <span class="nv">habitacion1</span><span class="p">;</span>
        <span class="nf">anadirHabitacion:</span> <span class="nv">habitacion2</span><span class="p">;</span>
        <span class="nf">yourself</span>
</code></pre>
</div>
<h4 id="prototype-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Quizas el primer ejemplo del patron Prototipo fue en el sistema Sketchpad de Ivan Sutherland [<a href="#snt63" >Snt63</a>]. La primera aplicacion ampliamente conocida del patron en un lenguaje orientado a objetos fue en ThingLab, donde los usuarios podian formar un objeto compuesto y luego promocionarlo a un prototipo instalandolo en una biblioteca de objetos reutilizables [<a href="#bor81" >Bor81</a>]. Goldberg y Robson mencionan prototipos como patron [<a href="#gr83" >GR83</a>], pero Coplien [<a href="#cop92" >Cop92</a>] da una descripcion mucho mas completa, incluyendo idiomas para C++ relacionados con el patron Prototype, con muchos ejemplos y variaciones.</p>
<p>Etgdb es el <em>front-end</em> de un depurador basado en ET++ que proporciona una interfaz basada en raton para diferentes depuradores de lineas. Cada depurador tiene su correspondiente subclase <code>DebugerAdaptor</code>. Por ejemplo, <code>GdbAdaptor</code> adapta etgdb a la sintaxis de las ordenes de GNU gdb, mientras que SunDbxAdaptor adapta etgdb al depurador dbx de Sun. Etgdb no tiene una serie de clases <code>DebuggerAdaptor</code> incrustadas en el codigo, sino que lee el nombre del adaptador a usar de una variable de entorno, busca un prototipo con el nombre especificado en la tabla global y luego clona el prototipo. Se pueden añadir nuevos prototipos a etgdb enlazados con el <code>DebuggerAdaptor</code> que funcione con ese depurador.</p>
<p>La <q>biblioteca de tecnicas de interaccion</q> en Mode Composer almacena prototipos de objetos que soportan varias tecnicas de interaccion [<a href="#sha90" >Sha90</a>]. Cualquier tecnica de interaccion creada por el Mode Composer puede usarse como prototipo poniendola en esta biblioteca. El patron Prototype permite que Mode Composer soporte un conjunto ilimitado de tecnicas de interaccion.</p>
<p>El ejemplo del editor musical examinado anteriormente esta basado en el framework de dibujo Unidraw [<a href="#vl90" >VL90</a>].</p>
</div>
<h4 id="prototype-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>Prototype y <a href="#abstract-factory" >Abstract Factory</a> son patrones rivales en algunos aspectos, como se analiza al final de este capitulo. No obstante, tambien pueden usarse juntos. Una fabrica abstracta puede almacenar un conjunto de prototipos a partir de los cuales clonar y devolver objetos producto.</p>
<p>Los diseños que hacen un uso intensivo de los patrones <a href="#composite" >Composite</a> y <a href="#decorator" >Decorator</a> suelen beneficiarse del Prototype.</p>
</div>
<h3 id="singleton" >Singleton</h3>
<h4 id="singleton-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Garantiza que una clase solo tenga una instancia, y proporciona un punto de acceso global a ella.</p>
</div>
<h4 id="singleton-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Es importante que algunas clases tengan exactamente una instancia. Aunque puede haber muchas impresoras en un sistema, solo deberia haber una cola de impresion. Igualmente, solo deberia haber un sistema de ficheros y un gestor de ventanas. Un filtro digital tendra un convertidor A/D. Un sistema de contabilidad estara dedicado a servir a una unica compañia.</p>
<p>¿Como podemos asegurar que una clase tenga una unica instancia y que esta sea facilmente accesible? Una varible global hace accesible a un objeto, pero no nos previene de crear multiples instancias de objetos.</p>
<p>Una solucion mejor es hacer que sea la propia clase la responsable de su unica instancia. La clase puede garantizar que no se puede crear ninguna otra instancia (interceptando las peticiones para crear nuevos objetos), y puede proporcionar un modo de acceder a la instancia. En eso consiste el patron Singleton.</p>
</div>
<h4 id="singleton-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usaremos el patron Singleton cuando</p>
<ul>
<li>
<p>debe haber exactamente una instancia de una clase, y esta debe ser accesible a los clientes desde un punto de acceso conocido.</p>
</li>
<li>
<p>la unica instancia deberia ser extensible mediante herencia, los clientes deberian ser capaces de usar una instancia extendida sin modificar su codigo.</p>
</li>
</ul>
</div>
<h4 id="singleton-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/043.png" />
</figure>
</div>
<h4 id="singleton-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Singleton</code></p>
<ul>
<li>
<p>define una operacion <code>Instancia</code> que permite que los clientes accedan a su unica instancia. <code>Instancia</code> es una operacion de clase (es decir, un metodo de clase en Smalltalk y una funcion miembro estatica en C++).</p>
</li>
<li>
<p>Puede ser responsable de crear su unica instancia.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="singleton-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p>Los clientes acceden a la instancia de un Singleton exclusivamente a traves de la operacion <code>Instancia</code> de este.</p>
</div>
<h4 id="singleton-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron Singleton proporciona varios beneficios:</p>
<ol class="num" >
<li>
<p><em>Acceso controlado a la unica instancia.</em> Puesto que la clase <code>Singleton</code> encapsula su unica instancia, puede tener un control estricto sobre como y cuando acceden a ella los clientes.</p>
</li>
<li>
<p><em>Espacio de nombres reducido.</em> El patron Singleton es una mejora sobre las variables globales. Evita contaminar el espacio de nombres con variables globales que almacenan las instancias.</p>
</li>
<li>
<p><em>Permite el refinamiento de operaciones y la representacion.</em> Se puede crear una subclase de la clase <code>Singleton</code>, y es facil configurar una aplicacion con una instancia de esta clase extendida. Podemos configurar la aplicacion con una instancia de la clase necesaria en tiempo de ejecucion.</p>
</li>
<li>
<p><em>Permite un numero variable de instancias.</em> El patron hace que sea facil cambiar de opinion y permitir mas de una instancia de la clase <code>Singleton</code>. Ademas, podemos usar el mismo enfoque para controlar el numero de instancias que usa la aplicacion, Solo se necesitara cambiar la operacion que otorga acceso a la instancia del Singleton.</p>
</li>
<li>
<p><em>Mas flexible que las operaciones de clase.</em> Otra forma de empaquetar la funcionalidad de un Singleton es usar operaciones de clase (es decir, funciones miembro estaticas en C++ o metodos de clase en Smalltalk). Pero ambas tecnicas de estos lenguajes dificultan cambiar un diseño para permitir mas de una instancia de una clase. Ademas, las funciones miembro estaticas en C++ nunca son virtuales, por lo que las subclases no las pueden redefinir polimorficamente.</p>
</li>
</ol>
</div>
<h4 id="singleton-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>A continuacion se presentan unas cuestiones de implementacion a tener en cuenta a la hora de usar el patron Singleton.</p>
<ol class="num" >
<li>
<p><em>Garantiza una unica instancia.</em> El patron Singleton hace que la unica instancia sea una instancia normal de la clase, pero dicha clase se escribe de forma que solo se pueda crear una instancia. Una forma usual de hacer esto es ocultar la operacion que crea la instancia tras una operacion de clase (es decir, una funcion miembro estatica o un metodo de clase) que garantice que solo se crea una unica instancia. Esta operacion tiene acceso a la variable que contiene la instancia, y se asegura de que la varible este inicializada con dicha instancia antes de devolver su valor. Este enfoque garantiza que un Singleton se cree e inicialice antes de su primer uso.</p>
<p>Podemos definir la operacion de clase en C++ mediante una funcion miembro estatica <code>Instancia</code> de la clase <code>Singleton</code>. <code>Singleton</code> tambien define una variable miembro estatica <code>_instancia</code> que contiene un puntero a su unica instancia.</p>
<p>La clase <code>Singleton</code> se declara como</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">Instancia</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Singleton</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">_instancia</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>La correspondiente implementacion es</p>
<pre class="code" ><code class="chroma" ><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">_instancia</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">Instancia</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_instancia</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_instancia</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_instancia</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Los clientes acceden al Singleton exclusivamente a traves de la funcion miembro <code>Instancia</code>. La variable <code>_instancia</code> se inicializa a 0, y la funcion miembro estatica <code>Instancia</code> devuelve su valor, inicializandola con la unica instancia en caso de que sea 0. <code>Instancia</code> usa unicializacion perezosa; el valor que develve no se crea y se almacena hasta que se acceda a el por primera vez.</p>
<p>Notese que el constructor se declara como protegido. Un cliente que trate de crear una instancia de <code>Singleton</code> directamente obtendra un error en tiempo de compilacion. Esto garantiza que solo se puede crear una instancia.</p>
<p>Ademas, puesto que <code>_instancia</code> es un puntero a un objeto <code>Singleton</code>, la funcion miembro <code>Instancia</code> puede asignar a esta variable un puentero a una subclase de <code>Singleton</code>. Daremos un ejemplo de esto en el Codigo de Ejemplo.</p>
<p>Hay otra cosa en que fijarse en la implementacion C++. No basta con definir el <code>Singleton</code> como un objeto global o estatico y luego confiar en la inicializacion automatica. Hay trez razones para ello:</p>
<ol class="alpha" >
<li>
<p>No podemos garantizar que solo se declarar una unica instancia de un objeto estatico.</p>
</li>
<li>
<p>Podriamos no tener la informacion necesaria para crear una instancia de cada Singleton en el momento de la inicialzacion estatica. Un Singleton puede necesitar valores que se calculan despues en la ejecucion del programa.</p>
</li>
<li>
<p>C++ no define el orden en que se llama a los constructores de objetos globales cuando hay varias unidades de traduccion [<a href="#es90" >ES90</a>]. Esto significa que no pueden existir dependencias entre objetos Singleton; si hay alguna, es inevitable que se produzcan errrores.</p>
</li>
</ol>
<p>Una desventaja (si bien es cierto que pequeña) añadida al enfoque de un objeto global o estatico es que obliga a que se creen todos los objetos Singleton, independientemente de que se usen o no. Usar una funcion miembro estatica evita estos problemas.</p>
<p>En Smalltalk, la funcion que devuelve la unica instancia se implementa como un metodo de clase de la clase <code>Singleton</code>. Para asegurar que solo se crea una instancia, redefine la operacion <code>new</code>. La clase <code>Singleton</code> resultante podria tener los siguientes dos metodos de clase, donde <code>UnicaInstancia</code> es una variable de clase que no se usa en ningun otro sitio.</p>
<pre class="code" ><code class="chroma" ><span class="nf">new</span>
    <span class="bp">self</span> <span class="nf">error:</span> <span class="s">&#39;no se puede crear un nuevo objeto&#39;</span>

<span class="nf">default</span>
    <span class="nf">UnicaInstancia</span> <span class="nf">isNill</span> <span class="nb">ifTrue:</span> [<span class="nc">UnicaInstancia</span> <span class="o">:=</span> <span class="bp">super</span> <span class="nb">new</span>]<span class="p">.</span>
    <span class="o">^</span> <span class="nf">UnicaInstancia</span>
</code></pre>
</li>
<li>
<p><em>Crear una subclase de <code>Singleton</code>.</em> El principal problema no es definir la subclase sino instalar su unica instancia de manera que los clientes la puedan usar. En esencia, la variable que hace referencia a la unica instancia debe ser inicializada con una instancia de la subclase. La tecnica mas sencilla es determinar que Singleton queremos usar en la operacion <code>Instancia</code> de Singleton. Uno de los ejemplos del Codigo de Ejemplo muestra como implementar esta tecnica con variables de entorno.</p>
<p>Otro modo de elegir la subclase de <code>Singleton</code> es sacar la implementacion de <code>Instancia</code> fuera de la clase padre (por ejemplo, <code>FabricaDeLaberintos</code>) y ponerla en la subclase. Eso permite que un programador de C++ decida la clase del Singleton durante el enlazado (por ejemplo, enlazandola con un fichero objeto que contenga una implementacion diferente) pero la oculta a los clientes del Singleton.</p>
<p>Este enfoque fija la eleccion de la clase del Singleton durante el enlazado, lo que dificulta elegir la clase del Singleton en tiempo de ejecucion. Usar instrucciones condicionales para determinar la subclase es mas flexible, pero fija el conjunto de posibles clases Singleton. Ninguno de los dos enfoques es lo suficientemente flexible para todos los casos.</p>
<p>Un enfoque mas flexible usa un <b>registro de objetos Singleton</b>. En vez de que sea <code>Instancia</code> quien defina el conjunto de posibles clases <code>Singleton</code>, las clases <code>Singleton</code> pueden registrar su unica instancia por su nombre en un registro que sea conocido por todos.</p>
<p>El registro establece una correspondencia entre nombres y objetos <code>Singleton</code>. Cuando <code>Instancia</code> necesita un <code>Singleton</code>, consulta el registro, pidiendo un <code>Singleton</code> por su nombre. El registro busca el Singleton correspondiente (si existe) y lo devuelve. Este enfoque libra a <code>Instancia</code> de tener que conocer todas las posiles clases o instancias de <code>Singleton</code>. Todo lo que necesita es una interfaz comun para todas las clases <code>Singleton</code> que incluya operaciones para el registro:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">Registrar</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombre</span><span class="p">,</span> <span class="n">Singleton</span><span class="o">*</span><span class="p">);</span>
    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="nf">Instancia</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">Buscar</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombre</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">_instancia</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ParNombreSingleton</span><span class="o">&gt;*</span> <span class="n">_registro</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>Registrar</code> registra la instancia del <code>Singleton</code> con el nombre especificado. Para mantener el registro simple, haremos que guarde una lista de objetos <code>ParNombreSingleton</code>. Cada <code>ParNombreSingleton</code> hace corresponder un nombre con un <code>Singleton</code>. La operacion <code>Buscar</code> busca un <code>Singleton</code> dado su <code>nombre</code>. Supondremos que una variable de entorno especifica el nombre del Singleton que desea.</p>
<pre class="code" ><code class="chroma" ><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">Instancia</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_instancia</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombreSingleton</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;SINGLETON&#34;</span><span class="p">);</span>
        <span class="c1">// proporcionada por el usuario o el entorno al principio
</span><span class="c1"></span>
        <span class="n">_instancia</span> <span class="o">=</span> <span class="n">Buscar</span><span class="p">(</span><span class="n">nombreSingleton</span><span class="p">);</span>
        <span class="c1">// Buscar devuelve 0 si no existe tal Singleton
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_instancia</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>¿Donde se registan las propias clases Singleton? Una posibilidad es en su constructor. Por ejemplo, una subclase <code>MiSingleton</code> podria hacer lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="n">MiSingleton</span><span class="o">::</span><span class="n">MiSingleton</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">Singleton</span><span class="o">::</span><span class="n">Registrar</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;MiSingleton&#34;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Por supuesto, el constructor no sera llamado al menos que alguien cree una instancia de la clase, ¡lo que reproduce el problema que el patron Singleton esta tratando de resolver! Podemos evitar este problema en C++ definiendo una instancia estatica de <code>MiSingleton</code>. Por ejemplo podemos definir</p>
<pre class="code" ><code class="chroma" ><span class="k">static</span> <span class="n">MiSingleton</span> <span class="n">elSingleton</span><span class="p">;</span>
</code></pre>
<p>en el fichero que contiene la implementacion de <code>MiSingleton</code>.</p>
<p>La clase <code>Singleton</code> ya no es la responsable de crear el <code>Singleton</code>. En vez de eso, su principal responsabilidad es hacer que en el sistema se pueda elegir el <code>Singleton</code> y acceder a el. El enfoque del objeto estatico todavia tiene un inconveniente potencial: hay que crear las instancias de todas las posibles subclases de <code>Singleton</code> o, si no, no se resgistran.</p>
</li>
</ol>
</div>
<h4 id="singleton-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Supongamos que definimos una clase <code>FabricaDeLaberintos</code> para construir laberintos, como se describio en la Seccion <a href="#Abstract-Factory-Codigo-de-Ejemplo" >Codigo De Ejemplo</a> del patron <a href="#abstract-factory" >Abstract Factory</a>. La clase <code>FabricaDeLaberintos</code> define una interfaz para construir las diferentes partes de un laberinto. Las subclases pueden redefinir sus operaciones para devolver instancias de clases producto especializadas, como objetos <code>ParedExplosionada</code> en vez de simples objetos <code>Pared</code>.</p>
<p>Lo relevante aqui es que la aplicacion <code>Laberinto</code> solo necesita una instancia de una fabrica de laberintos, y esa instancia deberia estar disponible para el codigo que construye cualquier parte del laberinto. Aqui es donde entra en juego el patron Singleton. Al hacer a la <code>FabricaDeLaberintos</code> un Singleton, hacemos que el objeto laberinto sea accesible globalmente sin depender de variables globales.</p>
<p>Para Simplificar, supondremos que nunca crearemos subclases de <code>FabricaDeLaberintos</code> (en seguida veremos como seria en ese caso). En C++ hacemos que sea una clase Singleton, añadiendo una operacion estatica <code>Instancia</code> y un miembro tambien estatico <code>_instancia</code>, la que guarde la unica instancia. Tambien debemos declarar al constructor como protegido para prevenir la creacion de instancias accidentalmente, lo que podria dar lugar a mas de una instancia.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">FabricaDeLaberintos</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">FabricaDeLaberintos</span><span class="o">*</span> <span class="n">Instancia</span><span class="p">();</span>

    <span class="c1">// aqui iria la interfaz existente
</span><span class="c1"></span><span class="k">protected</span><span class="o">:</span>
    <span class="n">FabricaDeLaberintos</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">FabricaDeLaberintos</span><span class="o">*</span> <span class="n">_instancia</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>La correspondiente implementacion es</p>
<pre class="code" ><code class="chroma" ><span class="n">FabricaDeLaberintos</span><span class="o">*</span> <span class="n">FabricaDeLaberintos</span><span class="o">::</span><span class="n">_instancia</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">FabricaDeLaberintos</span><span class="o">*</span> <span class="n">FabricaDeLaberintos</span><span class="o">::</span><span class="n">Instancia</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_instancia</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_instancia</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FabricaDeLaberintos</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_instancia</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Pensemos ahora que ocurre cuando hay subclases de <code>FabricaDeLaberintos</code> y la aplicacion tiene que decidir cual usar. Seleccionaremos el tipo de laberinto por medio de una variable de entorno y añadiremos codigo que cree una instancia de la subclase apropiada de <code>FabricaDeLaberintos</code>, basandose en el valor de la variable de entorno. La operacion <code>Instancia</code> es un buen lugar donde poner este codigo, dado que ya crea una instancia de <code>FabricaDeLaberintos</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">FabricaDeLaberintos</span><span class="o">*</span> <span class="n">FabricaDeLaberintos</span><span class="o">::</span><span class="n">Instancia</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_instancia</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">estiloLaberinto</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;ESTILOLABERINTO&#34;</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">estiloLaberinto</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;conBombas&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_instancia</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FabricaDeLaberintosConBombas</span><span class="p">;</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">estiloLaberinto</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;encantado&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_instancia</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FabricaDeLaberintosEncantados</span><span class="p">;</span>

        <span class="c1">// ... otras posibles subclases
</span><span class="c1"></span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>         <span class="c1">// por omision
</span><span class="c1"></span>            <span class="n">_instancia</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FabricaDeLaberintos</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_instancia</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Notese que debemos modificar <code>Instancia</code> cada vez que definimos una nueva subclase de <code>FabricaDeLaberintos</code>. Eso puede que no sea un problema en esta aplicacion, pero podria serlo para fabricas abstractas definidas en un framework.</p>
<p>Una posible solucion seria usar el enfoque del registro descrito en la seccion Implementacion. Tambien podria ser util el enlazado dinamico ––previene a la aplicacion de tener que cargar todas las subclases que no se usan––.</p>
</div>
<h4 id="singleton-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Un ejemplo del patron Singleton en Smalltalk-80 [<a href="#par90" >Par90</a>] es el conjunto de cambios al codigo, <code>ChangeSet current</code>. Un ejemplo mas util es la relacion entre las clases y sus metaclases. Una metaclase es la clase de una clase, y cada metaclase tiene una instancia. Las metaclases no tienen nombres (salvo indirectamente, a traves de su unica instancia), pero conocen a su unica instancia y normalmente no crearan otra.</p>
<p>El toolkit de interfaces de usuario InterViews [<a href="#lci+92" >LCI+92</a>] usa el patron Singleton para acceder a la unica instancia de sus interfaces <code>Session</code> y <code>WidgetKit</code>, entre otras. La clase <code>Session</code> define el bucle principal de despacho de eventos de la aplicacion, almacena la base de datos con las preferencias estilisticas del usuario y gestiona las conexiones a uno o mas dispositivos fisicos de visualizacion. La clase <code>WidgetKit</code> es una fabrica abstracta para definir el aspecto y el comportamiento de los elementos de la interfaz de usuario. La operacion <code>WidgetKit::instance()</code> determina la subclase concreta de <code>WidgetKit</code> de la que se va a crear una instancia basandose en una variable de entorno definida por la clase <code>Session</code>. Una operacion parecida en <code>Session</code> determina si se soportan monitores monocromo o en color, y configura segun eso la unica instancia de <code>Session</code>.</p>
</div>
<h4 id="singleton-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>Hay muchos patrones que pueden implementarse usando el patron Singleton. Vease el <a href="#abstract-factory" >Abstract Factory</a>, el <a href="#builder" >Builder</a> y el <a href="#prototype" >Prototype</a>.</p>
</div>
<h3 id="discusion-sobre-los-patrones-de-creacion" >Discusion sobre los patrones de creacion</h3>
<div class="hBody-3" >
<p>Hay dos formas habituales de parametrizar un sistema con las clases de objetos que crea. Una es heredar de la clase que crea los objetos; esto se corresponde con el uso del patron <a href="Factory-Method" >Factory Method</a>. El principal inconveniente de este enfoque es que puede requerir crear una nueva subclase simplemente para cambiar la clase del producto. Dichos cambios pueden tener lugar en cascada. Asi, por ejemplo, cuando el creador del producto es a su vez creado por un metodo de fabricacion, habra que redefinir tambien a su creador.</p>
<p>El otro modo de parametrizar un sistema se basa mas en la composicion de objetos: consiste en definir un objeto que sea responsable de conocer la clase de los objetos producto, y hacer que sea un parametro del sistema. Este es un aspecto clave de los patrones <a href="#abstract-factory" >Abstract Factory</a>, <a href="#builder" >Builder</a> y <a href="#prototype" >Prototype</a>. Los tres implican crear un nuevo <q>objeto fabrica</q> cuya responsabilidad es crear objetos producto. El objeto fabrica del Abstract Factory produce objetos de varias clases, mientras que en el caso del Builder costruye un producto complejo incrementalmente usando un protocolo de complejidad similar. El Prototype, por su parte, hace que su objeto fabrica construya un producto copiando un objeto prototipico. En este caso, el objeto fabrica y el prototipo son el mismo objeto, ya que el prototipo es el responsable de devolver el producto.</p>
<p>Pensemos en el framework de editores de dibujo descrito en el patron Prototype. Hay varias formas de parametrizar una <code>HerramientaGrafica</code> con la clase del producto:</p>
<ul>
<li>
<p>Si aplicamos el patron Factory Method, se creara en la paleta una subclase de <code>HerramientaGrafica</code> para cada subclase de <code>Grafico</code>. <code>HerramientaGrafica</code> tendra una operacion <code>NuevoGrafico</code> que sera redefinida por cada una de sus subclases.</p>
</li>
<li>
<p>Si aplicamos el patron <code>Abstract Factory</code>, habra una jerarquia de clases de <code>FabricacionDeGraficos</code>, una para cada subclase de <code>Grafico</code>. En este caso, cada fabrica crea un solo producto: <code>FabricaDeCirculos</code> creara <code>Circulos</code>, <code>FabricaDeLineas</code> creara <code>Lineas</code>, y asi sucesivamente. Una <code>HerramientaGrafica</code> estara parametrizada con una fabrica para crear el tipo apropiado de <code>Grafico</code>.</p>
</li>
<li>
<p>Si aplicamos el patron Prototype, cada subclase de <code>Grafico</code> implementara la operacion <code>Clonar</code>, y cada <code>HerramientaGrafica</code> estara parametrizada con un prototipo del <code>Grafico</code> que crea.</p>
</li>
</ul>
<p>Que patron es mejor depende de muchos factores. En nuestro farmework de editores de dibujo, el patron Factory Method es el mas facil de usar al principio. Resulta sencillo definir una nueva subclase de <code>HerramietaGrafica</code>, y las instancias de <code>HerramientaGrafica</code> se crean solo cuando se define la paleta. El principal inconveniente de esta opcion es que proliferan las subclases de <code>HerramientaGrafica</code>, y ninguna de ellas hara gran cosa.</p>
<p>El Abstract Factory no ofrece mucha mejora, ya que requiere una jerarquia de clases <code>FabriaDeGraficos</code> igualmente grande. El Abstract Factory seria preferible al Factory Method solo si ya hubiera una jerarquia de clases <code>FabricaDeGraficos</code>, ya sea porque la proporcione el compilador de una manera automatica (como en Smalltalk o en Objetive C) o porque sea necesaria en otra parte del sistema.</p>
<p>De todos ellos, el patron Prototype es probablemente el mejor para el framework de editores de dibujo, ya que solo requiere implementar una operacion <code>Clonar</code> en cada clase de <code>Grafico</code>. Esto reduce el numero de clases, y la operacion <code>Clonar</code> puede usarse para otros propositos ademas de la mera creacion de instancias (por ejemplo, para una operacion de menu Duplicar).</p>
<p>El Factory Method hace que un diseño sea mas adaptable a cambio de solo un poco mas de complejidad. Otros patrones de diseño requieren clases nuevas, mientras que el Factory Method solo necesita una nueva operacion. La gente suele usar el Factory Method como la forma estandar de creacion de objetos, pero no es necesario cuando la clase de la que se crean instancias no cambia nunca o cuando la creacion de instancias tiene lugar en una operacion que puede ser redefinida facilmente por las subclases, como en una operacion de inicializacion.</p>
<p>Los diseños que usan los patrones Abstract Factory, Prototype o Bulider son tadavia mas flexibles que aquellos que usar el Factory Method, pero tambien son mas complejos. Muchas veces, los diseños empiezan usando el Factory Method y luego evolucionan hacia los otros patrones de creacion a medida que el diseñador descubre donde es necesaria mas flexibilidad. Conocer muchos patrones de diseño nos da mas posibilidades de eleccion cuando estamos analizando los pros y los contras de un criterio de diseño frente a otro.</p>
</div>
<h2 id="capitulo-4" >Patrones Estructurales</h2>
<div class="hBody-2" >
<p>Los patrones estructurales se ocupan de como se combinan las clases y los objetos para formar estructuras mas grandes. Los patrones estructurales <em>de clases</em> hacen uso de la herencia para componer interfaces o implementaciones. A modo de ejemplo sencillo, pensemos en como la herencia multiple mezcla dos o mas clases en una sola. El resultado es una clase que combina las propiedades de sus clases padre. Este patron es particularmente util para lograr que funcionen juntas bibliotecas de clases desarrolladas de forma independiente. Otro ejemplo es la version de clases del patron <a href="#adapter" >Adapter</a>. En general, un adaptador hace que una interfaz (la de la clase adaptable) se ajuste a otra, proporcionando asi una abstraccion uniforme de interfaces diferentes. La forma de lograr esto en un adaptador de clases es heredando privadamente de una clase adaptable. A continuacion el adaptador expresa su interfaz en terminos de la clase adaptable.</p>
<p>En vez de combinar interfaces o implementaciones, los patrones estructurales <em>de objetos</em> describen formas de componer objetos para obtener nueva funcionalidad. La flexibilidad añadida de la composicion de objetos viene dada por la capacidad de cambiar la composicion en tiempo de ejecucion, lo que es imposible con la composicion de clases estatica.</p>
<p>El <a href="#composite" >Composite</a> es un ejemplo de patron estructural de objetos. describe como construir una jerarquia de clases formada por dos tipos de objetos: primitivos y compuestos. Los objetos compuestos permiten combinar objetos primitivos, asi como objetos compuestos, para formar estructuras todo lo complejas que se quiera. En el patron <a href="#proxy" >Proxy</a> un objeto proxy actua como sustituto o un representante de otro objeto. Se puede usar un proxy de muchas formas. Puede hacer de represtante local de un objeto que esta en un espacio de direcciones remoto. Puede representar un objeto mas grande que deberia ser cargado a peticion. Puede proteger el acceso a un objeto confidencial. Los <em>proxies</em> proporcionan un nivel de indireccion a determinadas propiedades de los objetos. Por tanto, pueden restringir, aumentar o alterar dichas propiedades.</p>
<p>El patron <a href="#flyweigh" >Flyweigh</a> define una estructura para compartir objetos. Los objetos se comparten por al menos dos razones: eficiencia y consistencia. Este patron se basa en el compartimiento como mecasinmo para lograr un uso mas eficiente del espacio. Las aplicaciones que usan muchos objetos deben prestar especial atencion a los costes de cada objeto. Se pueden lograr ahorros sustanciales compartiendo objetos en vez de duplicarlos. Pero los objetos pueden compartirse solo si no tienen un estado que dependa del contexto. Los objetos <em>flyweigh</em> (peso ligero) no tienen dicho estado. Cualquier informacion adicional que necesiten para llevar a cabo su tarea se les pasa en el momento que sea necesaria. Asi, sin estado dependiente del contexto, los objetos <q>peso ligero</q> pueden compartirse sin problemas.</p>
<p>Mientras que el patron Flyweight muestra como crear muchos objetos pequeños, el patron <a href="#facade" >Facade</a> (fachada) muestra como hacer que un unico objeto represente un subsistema completo. Una fachada es un representante de un conjunto de objetos. La fachada lleva a cabo sus reponsabilidades reenviando mensajes a los objetos que representa. El patron <a href="#bridge" >Bridge</a> separa la abstraccion de un objeto de su implementacion, de manera que ambas puedan ser modificadas por separado.</p>
<p>El patron <a href="#decorator" >Decorator</a> describe como añadir responsabilidades a objetos dinamicamente. Es un patron estructural que compone objetos recursivamente para permitir un numero ilimitado de responsabilidades adicionales. Por ejemplo, un objeto <code>Decorador</code> que contiene un componente de interfaz de usuario puede añadir un adorno, como un borde o un sombreado, al componente, o bien añadir funcionalidad, como capacidad de desplazamiento <em>zoom</em>. Podemos añadir dos adornos simplemente anidando un objeto <code>Decorador</code> dentro de otro, y asi sucesivamente para adornos adicionales. Para llevar a cabo esto, cada objeto decorador debe ajustarse a la interfaz de su componente y reenviarle los mensajes. El Decorador puede hacer su trabajo (como dibujar un borde alrededor del componente) antes o despues de reenviar un mensaje.</p>
<p>Muchos patrones estructurales estan de algna manera relacionados. Trataremos dichas relaciones al final del capitulo.</p>
</div>
<h3 id="adapter" >Adapter</h3>
<h4 id="adapter-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Convierte la interfaz de un clase en otra interfaz que es la que esperan los clientes. Permite que cooperen clases que de otra forma no podrian por tener interfaces incompatibles.</p>
</div>
<h4 id="adapter-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Wrapper (Envoltorio)</p>
</div>
<h4 id="adapter-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>A veces una clase de un toolkit que ha sido diseñada para reutilizarse, no puede hacerlo porque su interfaz no coincide con la interfaz especifica del dominio que requiere la aplicacion.</p>
<p>Pensemos, por ejemplo, en un editor de dibujo que permita que los usuarios dibujen y ubiquen elementos graficos (lineas, poligonos, texto, etc.) en dibujos y diagramas. La abstraccion fundamental del editor de dibujo es el objeto grafico, que tiene una forma modificable y que puede dibujarse asi mismo. La interfaz de los objetos graficos esta definida por una clase llamada <code>Forma</code>. El editor define una subclase de <code>Forma</code> para cada tipo de objeto grafico: una clase <code>FormaLinea</code> para las lineas, otra <code>FormaPoligono</code> para los poligonos, etcetera.</p>
<p>Las clases de formas geometricas elementales, como <code>FormaLinea</code> y <code>FormaPoligono</code> son bastante faciles de implementar, ya que sus capacidades de dibujado y edicion son intrinsecamente limitadas. Pero una subclase <code>Texto</code> que pueda mostrar y editar texto es considerablemente mas dificil de implementar, ya que incluso la edicion basica de texto implica actualizaciones de pantalla complicadas y gestion de buferes. A su vez, un toolkit comercial de interfaces de usuario podria proporcionar una clase <code>VistaTexto</code> sofisticada para mostrar y editar texto. Lo que nos gustaria seria poder reutilizar <code>VistaTexto</code> para implementar <code>FormaTexto</code>, pero el toolkit no se diseño con las clases <code>Forma</code> en mente. Por tanto, no podemos usar los objetos <code>VisualTexto</code> y <code>Forma</code> de manera intercambiable.</p>
<p>¿Como pueden funcionar clases existentes y no relacionadas, como <code>VistaTexto</code>, en una aplicacion que espera clases con una interfaz diferente e incompatible? Podriamos cambiar la clase <code>VistaTexto</code> para que se ajustase a la interfaz <code>Forma</code>, pero eso no es una opcion a menos que tengamos el codigo fuente del toolkit. Incluso aunque asi fuese, no tendria sentido cambiar <code>VistaTexto</code>; el tookit no deberia tener que adoptar interfaces especificas del dominio solo para que funcione una aplicacion.</p>
<p>En vez eso, podriamos definir <code>FormaTexto</code> para que <em>adapte</em> la interfaz <code>VistaTexto</code> a la de <code>Forma</code>. Podemos hacer esto de dos maneras: (1) heredando la interfaz de <code>Forma</code> y la implementacion de <code>VistaTexto</code>, o (2) componiendo una instancia <code>VistaTexto</code> dentro de una <code>FormaTexto</code> e implementando <code>FormaTexto</code> en terminos de la interfaz de <code>Vistatexto</code>. Ambos enfoques se corresponden con las versiones de clases y de objetos del patron <code>Adapter</code>. Decimos entonces que <code>FormaTexto</code> es un <b>adaptador</b>.</p>
<p>El siguiente diagrama ilustra el caso del adaptador de objetos. Muestra como las peticiones a <code>CajaLimitrofe</code>, declarada en una clase <code>Forma</code>, se convierten en peticiones a <code>ObtenerExtension</code>, definida en <code>VistaTexto</code>. Puesto que <code>FormaTexto</code> adapta <code>VistaTexto</code> a la interfaz <code>Forma</code>, el editor de dibujo puede reutilizar la clase <code>VistaTexto</code>, que de otro modo seria incompatible.</p>
<figure>
<img src="img/044.png" />
</figure>
<p>Muchas veces el adaptador es responsable de la funcionalidad que la clase adaptada no proporciona. El diagrama muestra como un adaptador puede llevar a cabo tales responsabilidades. El usuario deberia ser capaz de <q>arrastrar</q> interactivamente cada objeto <code>Forma</code> a una nueva posicion, pero <code>VistaTexto</code> no esta diseñada para ello. <code>FormaTexto</code> puede añadir esta funcionalidad ausente implementando la operacion de <code>Forma</code> <code>Crearmanipulador</code>, que devuelve una instancia de la subclase <code>Manipulador</code> apropiada.</p>
<p><code>Manipulador</code> es una clase abstracta para objetos que saben como hacer que una <code>Forma</code> reponda a la entrada del usuario, como arrastrar la forma a una nueva posicion. Hay subclases de <code>Manipulador</code> para diferentes formas; <code>ManipuladorDeTexto</code>, es la subclase correspondiente a <code>FormaText</code>. Devolviendo una instancia de <code>ManipuladorDeTexto</code>, <code>FormaTexto</code> añade la funcionalidad que <code>VistaTexto</code> no tiene y que es requerida por <code>Forma</code>.</p>
</div>
<h4 id="adapter-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Deberia usarse el patron Adapter cuando</p>
<ul>
<li>
<p>se quiere usar una clase existente y su interfaz no concuerda con la que necesita.</p>
</li>
<li>
<p>se quiere crear una clase reutilizable que coopere con clases no relacionadas o que no han sido previstas, es decir, clases que no tienen por que tener interfaces compatibles.</p>
</li>
<li>
<p>(<em>solamente en el caso de un adaptador de objetos</em>) es necesario usar varias subclases existentes, pero no resulta practico adaptar su interfaz heredando de cada una de ellas. Un adaptador de objetos puede adaptar la interfaz de su clase padre.</p>
</li>
</ul>
</div>
<h4 id="adapter-estructura" >Estructura</h4>
<div class="hBody-4" >
<p>Un adaptador de clases usa la herencia multiple para adaptar una interfaz a otra:</p>
<figure>
<img src="img/045.png" />
</figure>
<p>Un adaptador de objetos se basa en la composicion de objetos:</p>
<figure>
<img src="img/046.png" />
</figure>
</div>
<h4 id="adapter-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Objetivo</code> (<code>Forma</code>)</p>
<ul>
<li>
<p>define la interfaz especifica del dominio que usa el <code>Cliente</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>Cliente</code> (<code>EditorDeDibujo</code>)</p>
<ul>
<li>
<p>colabora con objetos que se ajustan a la interfaz <code>Objetivo</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>Adaptable</code> (<code>VistaTexto</code>)</p>
<ul>
<li>
<p>define una interfaz existente que necesita ser adaptada.</p>
</li>
</ul>
</li>
<li>
<p><code>Adaptador</code> (<code>FormaTexto</code>)</p>
<ul>
<li>
<p>adapta la interfaz de <code>Adaptable</code> a la interfaz <code>Objetivo</code></p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="adapter-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p>Los clientes llaman a operaciones de una instancia de <code>Adaptador</code>. A su vez, el adaptador llama a operaciones de <code>Adaptable</code>, que son las que satisfacen la peticion.</p>
</div>
<h4 id="adapter-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>Los Adaptadores de clases y de objetos tienen diferentes ventajas e inconvenientes. Un adaptador de clases</p>
<ul>
<li>
<p>adapta una clase <code>Adaptable</code> a <code>Objetivo</code>, pero se refiere unicamente a una clase <code>Adaptable</code> concreta. Por tanto, un adaptador de clases no nos servira cuando lo que queremos es adaptar una clase y todas sus subclases.</p>
</li>
<li>
<p>permite que <code>Adaptador</code> redefina parte del comportamiento de <code>Adaptable</code>, por ser <code>Adaptador</code> una subclase de <code>Adaptable</code>.</p>
</li>
<li>
<p>introduce un solo objeto, y no se necesita ningun puntero de indireccion adicional para obtener el objeto adaptado.</p>
</li>
</ul>
<p>Por su parte, un adaptador de objetos</p>
<ul>
<li>
<p>permite que un mismo <code>Adaptador</code> funcione con muchos <code>Adaptables</code> ––es decir, con el <code>Adaptable</code> en si y todas sus subclases, en caso de que las tenga––. El <code>Adaptador</code> tambien puede añadir funcionalidades a todos los <code>Adaptadores</code> a la vez.</p>
</li>
<li>
<p>hace que sea mas dificil redefinir el comportamiento de <code>Adaptable</code>. Se necesitara crear una subclase de <code>Adaptable</code> y hacer que el <code>Adaptador</code> se refiera a la subclase en vez de a la clase <code>Adaptable</code> en si.</p>
</li>
</ul>
<p>Estas son otras cuestiones a tener en cuenta al usar el patron Adaptador:</p>
<ol class="num" >
<li>
<p><em>¿Cuanta adaptacion hace el <code>Adaptador</code>?</em> Los adaptadores difieren en la cantidad de trabajo necesario para adaptar <code>Adaptable</code> a la interfaz <code>Objetivo</code>. Hay una amplia gama de tareas posibles, que van desde la simple conversion de interfaces ––por ejemplo, cambiar los nombres de las operaciones–– a permitir un conjunto completamente nuevo de operaciones. La cantidad de trabajo que hace el <code>Adaptador</code> depende de lo parecida que sea la interfaz de <code>Objetivo</code> a la de <code>Adaptable</code>.</p>
</li>
<li>
<p><em><code>Adaptadores</code> conectables.</em> Una clase es mas reutilizable cuando minimizamos las asunciones que deben hacer otras clase para usarla. Al hacer la adaptacion de interfaces en una clase estamos eliminando la asuncion de que otras clases ven la misma interfaz. Dicho de otro modo, la adaptacion de interfaces nos permite incorporar nuestra clase a sistemas existentes que podrian esperar interfaces diferentes a la de la clase. ObjectWorks\Smalltalk [<a href="#par90" >Par90</a>] usa el termino <b>adaptador conectable</b> para describir clases con adaptacion de interfaces incorporada.</p>
<p>Pensemos en un util<span class="note" ><sup><a href="#31" >31</a></sup></span> <code>VisualizadorDeArboles</code> que puede mostrar estructuras arboreas graficamente. Si este fuera un util de proposito especial para usar en una unica aplicacion podriamos obligar a los objetos que representa a que tuviesen una interfaz concreta; es decir, que todos descendiesen de una clase abstracta <code>Arbol</code>. Pero si quisieramos hacer a <code>VisualizadorDeArboles</code> mas reutilizable (supongamos que quisieramos hacerlo parte de un toolkit de utiles), entonces ese requisito seria poco razonable. Las aplicaciones definiran sus propias clases para estructuras de arbol. No deberian estar obligadas a utilizar nuestra clase abstracta <code>Arbol</code>. Estructuras arboreas diferentes tendran diferentes interfaces.</p>
<p>Por ejemplo, en una jerarquia de directorios podria accederse a los hijos con una operacion <code>ObtenerSubdirectorios</code>, mientras que en una jerarquia de clases la operacion correspondiente podria llamarse <code>ObtenerSubclases</code>. Un util <code>VisualizadorDeArboles</code> reutilizable debe ser capaz de representar ambos tipos de jerarquias, incluso aunque usen diferentes interfaces. En otras palabras, el <code>VisualizadorDeArboles</code> deberia tener la adaptacion de interfaces incorporada.</p>
<p>En la seccion de Implementacion veremos diferentes modos de incorporar la adaptacion de interfaces a las clases.</p>
</li>
<li>
<p><em>Usar adaptadores bidireccionales para proporcionar transparencia.</em> Un problema potencial de los adaptadores es que no son transparentes a todos los clientes. Un objeto adaptador ya no se ajusta a la interfaz <code>Adaptable</code>, por lo que no puede usarse tal cual en donde pudiera ir un objeto <code>Adaptable</code>. Los <em>adaptadores bidireccionales</em> pueden proporcionar esta transparencia. En concreto, resultan utiles cuando dos clientes distintos necesitan ver un objeto de distinta forma. Pensemos en el adaptador bidireccional que incorpora Unidraw, un framework para editores graficos [<a href="#vl90" >VL90</a>], y QOCA, un toolkit de resolucion de problemas [<a href="#hhmv92" >HHMV92</a>]. Ambos sistemas tienen clases que representan variables explicitamente: Unidraw tiene <code>StateVariable</code>, y QOCA tiene <code>ConstrainVariable</code>. Para hacer que Unidraw funcione con QOCA, hay que adaptar <code>ConstraintVariable</code> a <code>StateVariable</code>; para que QOCA propague soluciones a Unidraw, hay que adaptar <code>StateVariable</code> a <code>ConstraintVariable</code>.</p>
<p>La solucion consiste en un adaptador de clases bidireccional <code>ConstraintStateVariable</code>, una subclase de <code>StateVariable</code> y <code>ConstraintVariable</code>, que adapta cada una de las dos interfaces a la otra. La herencia multiple es una solucion viable en este caso porque las interfaces de las clases adaptadas son sustancialmente diferentes. El adaptador de clases bidireccional se ajusta a las dos clases adaptadas y puede trabajar en cualquiera de los dos sistemas.</p>
<figure>
<img src="img/047.png" />
</figure>
</li>
</ol>
</div>
<h4 id="adapter-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Aunque la implementacion del patron Adapter suele ser sencilla, estas son algunas cuestiones que hay que tener en cuenta:</p>
<ol class="num" >
<li>
<p><em>Implementacion de adaptadores de clases en C++.</em> En una implementacion C++ de un adaptador de clases, <code>Adaptador</code> deberia heredar publicamente de <code>Objeto</code> y privadamente de <code>Adaptable</code>. Asi, <code>Adaptador</code> seria un subtipo de <code>Objetivo</code>, pero no de <code>Adaptable</code>.</p>
</li>
<li>
<p><em>Adaptadores conectables.</em> Veamos tres formas de implementar adaptadores conectables para el util <code>VisualizadorDeArboles</code> descrito anteriormente, el cual puede mostrar una estructura jerarquica automaticamente.</p>
</li>
</ol>
<p>El primer paso, que es comun a las tres implementaciones estudiadas aqui, consiste en encontrar una interfaz <q>reducida</q> para <code>Adaptable</code>, es decir, el subconjunto mas pequeño de operaciones que nos permita hacer la adaptacion. Una interfaz reducida consistente en solo un par de operaciones es mas facil de adaptar que una interfaz con docenas de operaciones. Para <code>VisualizadorDeArboles</code>, el adaptable es cualquier estructura jerarquica. Una interfaz minimalista podria incluir dos operaciones, una que defina como presentar un nodo graficamente en la estructura, y otra que recupere los hijos del nodo.</p>
<p>La interfaz reducida nos lleva a tres enfoques de implementacion:</p>
<ol class="alpha" >
<li>
<p><em>Usar operaciones abstractas.</em> Definir las correspondientes operaciones abstractas para la interfaz reducida de <code>Adaptable</code> en la clase <code>VisualizadorDeArboles.</code> Las subclases deben implementar las operaciones abstractas y adaptar el objeto estructurado jerarquicamente. Por ejemplo, una subclase <code>VisualizadorDeArbolDeDirectorios</code> implementara estas operaciones accediendo a la estructura de directorios.</p>
<figure>
<img src="img/048.png" />
</figure>
<p><code>VisualizadorDeArbolDeDirectorios</code> especializa la interfaz reducida de manera que pueda representar y mostrar estructuras de directorio formadas por objetos <code>EntidadDelSistemaDeFicheros</code>.</p>
</li>
<li>
<p><em>Usar objetos delegados.</em> Con este enfoque, <code>VisualizadorDeArboles</code> reenvia las peticiones para acceder a la estructura jerarquica a un objeto <b>delegado</b>. <code>VisualizadorDeArboles</code> puede usar una estrategia de adaptacion diferente cambiando el objeto delegado.</p>
<p>Por ejemplo, supongamos que exinte un <code>ExploradorDeDirectorios</code> que usa un <code>VisualizadorDeArboles</code>. <code>ExploradorDeDirectorios</code> podria ser un buen delegado para adaptar <code>VisualizadorDeArboles</code> a la estructura jerarquica de directorios. En lenguajes dinamicamente tipados, como Smalltalk u Objetive C, este enfoque solo necesita una interfaz para registrar el delegado con el adaptador. A continuacion, <code>VisualizadorDeArboles</code> simplemente reenvia las peticiones al delegado. NEXTSTEP [<a href="#add94" >Add94</a>] usa este enfoque intensivamente para reducir el uso de subclases.</p>
<p>Los lenguajes estaticamente tipados, como C++, necesitan una definicion de interfaz explicita para el delegado. Podemos especificar dicha interfaz poniendo la interfaz reducida que necesita <code>VisualizadorDeArboles</code> en una clase abstracta <code>DelegadoDeAccesoAlArbol</code>. A continuacion podemos combinar esta interfaz con el delegado de nuestra eleccion ––<code>ExploradorDeDirectorios</code>, en este caso–– a traves de la herencia. Usaremos herencia simple si el <code>ExploradorDeDirectorios</code> no tiene ninguna clase padre, y herencia multiple en caso de que la tenga. Combinar clases de esta forma es mas facil que introducir una nueva subclase <code>VisualizadorDeDirectorios</code> e implementar sus operaciones individualmente.</p>
<figure>
<img src="img/049.png" />
</figure>
</li>
<li>
<p><em>Adaptadores parametrizados.</em> La forma mas comun de permitir adaptadores conectables en Smalltalk es parametrizar un adaptador con uno o mas bloques. La construccion <em>block</em> permite la adaptacion sin necesidad de subclases. Un bloque puede adaptar una peticion y el adaptador puede almacenar un bloque para cada peticion individual. En nuestro ejemplo, esto quiere decir que <code>VisualizadorDeArboles</code> guarda un bloque para convertir un nodo en un <code>NodoGrafico</code> y otro bloque para acceder a los hijos de un nodo.</p>
<p>Por ejemplo, para crear <code>VisualizadorDeArboles</code> en una jerarquia de directorios, escribimos</p>
<pre class="code" ><code class="chroma" ><span class="nc">VisualizadorDeDirectorios</span> <span class="o">:=</span>
    (<span class="nc">VisualizadorDeArboles</span> <span class="nf">on:</span> <span class="nv">raiz</span>)
        <span class="nf">obtenerBloquesHijos:</span>
            [<span class="o">:</span><span class="nv">nodo</span> <span class="o">|</span> <span class="nv">nodo</span> <span class="nf">obtenerSubdirectorios</span>]
        <span class="nf">crearBloqueNodoGrafico:</span>
            [<span class="o">:</span><span class="nv">nodo</span> <span class="o">|</span> <span class="nv">nodo</span> <span class="nf">crearNodoGrafico</span>]<span class="p">.</span>
</code></pre>
<p>si estamos adaptando una interfaz a una clase, este enfoque ofrece una buena alternativa a la herencia.</p>
</li>
</ol>
</div>
<h4 id="adapter-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Daremos un breve esbozo de la implementacion de adaptadores de clases y de objetos para el ejemplo de la seccion de Motivacion, comenzando con las clases <code>Forma</code> y <code>VistaTexto</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Forma</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Forma</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">CajaLimitrofe</span><span class="p">(</span>
        <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">inferiorIzquierdo</span><span class="p">,</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">superiorDerecho</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Manipulador</span><span class="o">*</span> <span class="nf">CrearManipulador</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">VistaTexto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">VistaTexto</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">ObtenerOrigen</span><span class="p">(</span><span class="n">Coord</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">Coord</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">ObtenerArea</span><span class="p">(</span><span class="n">Coord</span><span class="o">&amp;</span> <span class="n">ancho</span><span class="p">,</span> <span class="n">Coord</span><span class="o">&amp;</span> <span class="n">alto</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">EstaVacia</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>Forma</code> determina sus limites mediante una caja definida por sus esquinas opuestas. <code>VistaTexto</code>, por el contrario, esta definida por un <code>origen</code>, un <code>alto</code> y un <code>ancho</code>. <code>Forma</code> tambien define una operacion <code>CrearManipulador</code> para crear un <code>Manipulador</code>,<span class="note" ><sup><a href="#32" >32</a></sup></span> el cual sabe como mover una forma cuando esta es manipulada por el usuario. <code>VistaTexto</code> no tiene una operacion equivalente. La clase <code>FormaTexto</code> es un adaptador entre estas interfaces diferentes.</p>
<p>Un adaptador de clases usa la herencia multiple para adaptar interfaces. La clave de los adaptadores de clases es usar una rama de la herencia para heredar la interfaz y otra para heredar la implementacion. La forma normal de hacer esta distincion en C++ es heredar publicamente la interfaz y privadamente la implementacion. Usaremos este convenio para definir el adaptador <code>FormaTexto</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">FormaTexto</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Forma</span><span class="p">,</span> <span class="k">private</span> <span class="n">VistaTexto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">FormaTexto</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">CajaLimitrofe</span><span class="p">(</span>
        <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">inferiorIzquierdo</span><span class="p">,</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">superiorDerecho</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">EstaVacia</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Manipulador</span><span class="o">*</span> <span class="nf">CrearManipulador</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>La operacion <code>CajaLimitrofe</code> convierte la interfaz de <code>VistaTexto</code> para que se ajuste a la de <code>Forma</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">FormaTexto</span><span class="o">::</span><span class="n">CajaLimitrofe</span> <span class="p">(</span>
    <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">inferiorIzquierdo</span><span class="p">,</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">superiorDerecho</span>
<span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">Coord</span> <span class="n">inferior</span><span class="p">,</span> <span class="n">izquierda</span><span class="p">,</span> <span class="n">ancho</span><span class="p">,</span> <span class="n">alto</span><span class="p">;</span>

    <span class="n">ObtenerOrigen</span><span class="p">(</span><span class="n">inferior</span><span class="p">,</span> <span class="n">izquierda</span><span class="p">);</span>
    <span class="n">ObtenerArea</span><span class="p">(</span><span class="n">ancho</span><span class="p">,</span> <span class="n">alto</span><span class="p">);</span>

    <span class="n">inferiorIzquierdo</span> <span class="o">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">inferior</span><span class="p">,</span> <span class="n">izquierda</span><span class="p">);</span>
    <span class="n">superiorDerecho</span>   <span class="o">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">inferior</span> <span class="o">+</span> <span class="n">alto</span><span class="p">,</span> <span class="n">izquierda</span> <span class="o">+</span> <span class="n">ancho</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>La operacion <code>EstaVacia</code> ilustra el reenvio directo de peticiones que es comun en las implementaciones de adaptadores:</p>
<pre class="code" ><code class="chroma" ><span class="kt">bool</span> <span class="n">FormaTexto</span><span class="o">::</span><span class="n">EstaVacia</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">VistaTexto</span><span class="o">::</span><span class="n">EstaVacia</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Por ultimo, definiremos <code>CrearManipulador</code> (que no es admitida por <code>VistaTexto</code>) desde cero. Suponemos que ya hemos implementado una clase <code>ManipuladorDeTexto</code> que permite la manipulacion de una <code>FormaTexto</code>.</p>
<pre class="code" ><code class="chroma" ><span class="n">Manipulador</span><span class="o">*</span> <span class="n">FormaTexto</span><span class="o">::</span><span class="n">CrearManipulador</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ManipuladorDeTexto</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>El objeto adaptador usa composicion de objetos para combinar clases con diferentes interfaces. Con este enfoque, el adaptador <code>FormatoTexto</code> mantiene un puntero a <code>VistaTexto</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">FormaTexto</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Forma</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">FormaTexto</span><span class="p">(</span><span class="n">VisitaTexto</span><span class="o">*</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">CajaLimitrofe</span><span class="p">(</span>
        <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">inferiorIzquierdo</span><span class="p">,</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">superiorDerecho</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">EstaVacia</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Manipulador</span><span class="o">*</span> <span class="nf">CrearManipulador</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">VistaTexto</span><span class="o">*</span> <span class="n">_texto</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>FormaTexto</code> debe inicializar el puntero a la instancia de <code>VistaTexto</code>, y lo hace en el constructor. Tambien tiene que llamar a las operaciones de su objeto <code>VistaTexto</code> cada vez que se llama a las suyas propias. En este ejemplo suponemos que el cliente crea el objetivo <code>VistaTexto</code> y lo pasa al constructor de <code>FormaTexto</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">FormaTexto</span><span class="o">::</span><span class="n">FormaTexto</span> <span class="p">(</span><span class="n">VisitaTexto</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_texto</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FormaTexto</span><span class="o">::</span><span class="n">CajaLimitrofe</span> <span class="p">(</span>
    <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">inferiorIzquierdo</span><span class="p">,</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">superiorDerecho</span>
<span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">Coord</span> <span class="n">inferior</span><span class="p">,</span> <span class="n">izquierda</span><span class="p">,</span> <span class="n">ancho</span><span class="p">,</span> <span class="n">alto</span><span class="p">;</span>

    <span class="n">_texto</span><span class="o">-&gt;</span><span class="n">ObtenerOrigen</span><span class="p">(</span><span class="n">inferior</span><span class="p">,</span> <span class="n">izquierda</span><span class="p">);</span>
    <span class="n">_texto</span><span class="o">-&gt;</span><span class="n">ObtenerArea</span><span class="p">(</span><span class="n">ancho</span><span class="p">,</span> <span class="n">alto</span><span class="p">);</span>

    <span class="n">inferiorIzquierdo</span> <span class="o">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">inferior</span><span class="p">,</span> <span class="n">izquierda</span><span class="p">);</span>
    <span class="n">superiorDerecho</span> <span class="o">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">inferior</span> <span class="o">+</span> <span class="n">alto</span><span class="p">,</span> <span class="n">izquierda</span> <span class="o">+</span> <span class="n">ancho</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">FormaTexto</span><span class="o">::</span><span class="n">EstaVacia</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_texto</span><span class="o">-&gt;</span><span class="n">EstaVacia</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>La implementacion de <code>CrearManipulador</code> no cambia respecto de la version del adaptador de clases, ya que esta implementado desde cero y no reutiliza nada de la funcionalidad existente de <code>VistaTexto</code>.</p>
<pre class="code" ><code class="chroma" ><span class="n">Manipulador</span><span class="o">*</span> <span class="n">FormaTexto</span><span class="o">::</span><span class="n">CrearManipulador</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ManipuladorDeTexto</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Comparese este codigo con el caso del adaptador de clases. El adaptador de objetos requiere un poco mas de esfuerzo a la hora de escribirlo, pero tambien es mas flexible. Por ejemplo, la version del adaptador de objetos de <code>FormaTexto</code> funcionara igualmente bien con subclases de <code>VisitaTexto</code> ––el cliente simplemente pasa una instancia de una subclase de <code>VisitaTexto</code> al constructor de <code>FormatoTexto</code>––.</p>
</div>
<h4 id="adapter-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>El ejemplo de la seccion Motivacion viene de ET++Draw, una aplicacion de dibujo basada en ET++ [<a href="#wgm88" >WGM88</a>]. ET++Draw reutiliza las clases de ET++ para editar texto mediante una clase adaptadora <code>TextShape</code>.</p>
<p>InterViews 2.6 define una clase abstracta <code>Interactor</code> para elementos de la interfaz de usuario como barras de desplazamiento, botones y menus [<a href="#vl88" >VL88</a>]. Tambien define una clase abstracta <code>Graphic</code> para objetos graficos estructurados, tales como lineas, circulos, poligonos y <em>splines</em>. Tanto <code>Interactor</code> como <code>Graphic</code> tienen representacion visual, pero ambos tienen diferentes interfaces e implementaciones (no comparten una clase padre comun) y son por tanto incompatibles ––no podemos insertar directamente un objeto grafico estructurado en, pongamos por caso, un cuadro de dialogo––.</p>
<p>En vez de eso, InterViews 2.6 define un adaptador de objetos llamado <code>GraphicBlock</code>, una subclase de <code>Iteractor</code> que contiene una instancia de <code>Graphic</code>. El <code>GraphicBlock</code> adapta la interfaz de la clase <code>Graphic</code> a la de <code>Interactor</code>. El <code>GraphicBlock</code> permite que se pueda mostrar, desplazar y hacer <em>zoom</em> sobre una instancia de <code>Graphic</code> dentro de una estructura <code>Interactor</code>.</p>
<p>Los adaptadores conectables son frecuentes en ObjectWorks\Smalltalk [<a href="#par90" >Par90</a>]. El Smalltalk estandar define una clase <code>ValueModel</code> para las vistas que muestran un valor unico. <code>ValueModel</code> define una interfaz <code>value</code>, <code>value:</code> para acceder al valor. Estos son metodos abstractos. Los implementadores de la aplicacion acceden al valor con nombres mas especificos del dominio, como <code>ancho</code> y <code>ancho:</code>, pero no deberian tener que crear una subclase de <code>ValueModel</code> para adaptar dichos nombres especificos del dominio a la interfaz <code>ValueModel</code>.</p>
<p>En lugar de eso, ObjectWorks\Smalltalk incluye una subclase de <code>ValueModel</code> llamada <code>PluggableAdaptor</code>. Un objeto <code>PluggableAdaptor</code> adapta otros objetos a la interfaz de <code>ValueModel</code> (<code>value</code>, <code>value:</code>). Puede ser parametrizado con bloques para obtener y establecer el valor deseado. <code>PluggableAdaptor</code> utiliza internamente estos bloques para implementar la interfaz <code>value</code>, <code>value:</code>. <code>PluggableAdaptor</code> tambien permite pasar nombres directamente en el selector (por ejemplo, <code>ancho</code>, <code>ancho:</code>) por conveniencia sintactica, convirtiendo estos selectores en los bloques correspondientes de forma automaticamente.</p>
<figure>
<img src="img/050.png" />
</figure>
<p>Otro ejemplo de ObjectWorks\Smalltalk es la clase <code>TableAdaptor</code>. Un <code>TableAdaptor</code> puede adaptar una secuencia de objetos a una representacion tabular. La tabla muestra un objeto por fila. El cliente parametriza <code>TablaAdaptor</code> con el conjunto de mensajes que puede usar una tabla para obtener de un objeto los valores de las columnas.</p>
<p>Algunas clases del AppKit de NeXT [<a href="#add94" >Add94</a>] usan delegacion de objetos para llevar a cabo adaptacion de interfaces. Un ejemplo es la clase <code>NXBrowser</code> que puede mostrar listas jerarquicas de datos. <code>NXBrowser</code> usa un objeto delegado para acceder a los datos y adaptarlos.</p>
<p>El <q>Matrimonio de Conveniencia</q> de Meyer [<a href="#mey88" >Mey88</a>] es una forma de adaptador de clases. Meyer describe como una clase <code>PilaFija</code> adapta la implementacion de una clase <code>Array</code> a la interfaz de una clase <code>Pila</code>. El resultado es una pila que contiene un numero fijo de entradas.</p>
</div>
<h4 id="adapter-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>El patron <a href="#bridge" >Bridge</a> tiene una estructura similar a un adaptador de objetos, pero con un proposito diferente: esta pensado para separar una interfaz de su implementacion, de manera que ambos puedan cambiar facilmente y de forma independiente uno del otro, mientras que un adaptador esta pensado para cambiar la interfaz de un objeto existente</p>
<p>El patron <a href="#decorator" >Decorator</a> decora otro objeto sin cambiar su interfaz. Un decorador es por tanto mas transparente a la aplicacion que un adaptador. Como resultado, el patron <code>Decorador</code> permite la composicion recursiva, lo que no es posible con adaptadores puros.</p>
<p>El patron <a href="#proxy" >Proxy</a> define una representacion o sustituto de otro objeto sin cambiar su interfaz.</p>
</div>
<h3 id="bridge" >Bridge</h3>
<h4 id="bridge-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Desacopla una abstraccion de su implementacion, de modo que ambas puedan variar de forma independiente.</p>
</div>
<h4 id="bridge-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Handle/Body (Manejador/Cuerpo)</p>
</div>
<h4 id="bridge-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Cuando una abstraccion puede tener varias implementaciones posibles, la forma mas habitual de darles cabida es mediante la herencia. Una clase abstracta define la interfaz de la abstraccion, y las subclases concretas la implementan de distintas formas. Pero este enfoque no simpre es lo bastante flexible. La herencia liga una implementacion a la abstraccion de forma permanente, lo que dificulta modificar, extender y reutilizar abstracciones e implementaciones de forma independiente.</p>
<p>Pensemos en la implementacion de una abstraccion portable <code>Ventana</code> en un toolkit de interfaces de usuario. Esta abstraccion deberia permitirnos escribir aplicaciones que funcionen, por ejemplo, tanto en el Sistema de Ventanas X como en Presentation Manager de IBM (PM). Mediante la herencia podriamos definir una clase abstracta <code>Ventana</code> y subclases <code>VentanaX</code> y <code>VentanaPM</code> que implementen la interfaz <code>Ventana</code> para las distintas plataformas. Pero este enfoque tiene dos inconvenientes:</p>
<ol class="num" >
<li>
<p>No es conveniente extender la abstraccion <code>Ventana</code> para cubrir diferentes tipos de ventanas o nuevas plataformas. Imaginemos una subclase <code>VentanaIcono</code>, que especializa la abstraccion Ventana para representar iconos. Para admitir este tipo de ventanas en ambas plataformas debemos implementar <em>dos</em> nuevas clases, <code>VentanaIconoX</code> y <code>VentanaIconoIP</code>. Y lo que es peor, tendremos que definir dos clases para <em>cada</em> tipo de ventana. Dar cabida a una tercera plataforma requeriria otra nueva subclase de <code>Ventana</code> para cada tipo de ventana.</p>
<figure>
<img src="img/051.png" />
</figure>
</li>
<li>
<p>Hace que el codigo sea dependiente de la plataforma. Cada vez que un cliente crea una ventana, se crea una clase concreta que tiene una determinada implementacion. Por ejemplo, crear un objeto <code>VentanaX</code> liga la abstraccion <code>Ventana</code> a la implementacion para X Window, lo que vuelve al codigo del cliente dependiente de dicha implementacion. A su vez esto hace que sea mas dificil portar el codigo cliente a otras plataformas.</p>
<p>Los clientes deberian ser capaces de crear una ventana sin someterse a una implementacion concreta. Lo unico que tendria que depender de la plataforma en la que se ejecuta la aplicacion es la implementacion de la ventana. Por tanto, el codigo cliente deberia crear ventanas sin hacer mencion a plataformas concretas.</p>
</li>
</ol>
<p>El patron Bridge resuelve estos problemas situando la abstraccion <code>Ventana</code> y su implementacion en jerarquias de clases separadas. Hay una jerarquia de clases para las interfaces de las ventanas (<code>Ventana</code>, <code>Ventanaicono</code>, <code>VentanaFlotante</code>) y otra jerarquia aparte para las implementaciones especificas de cada plataforma, teniendo a <code>VentanaImp</code><span class="note" ><sup><a href="#33" >33</a></sup></span> como su raiz. Por ejemplo, la subclase <code>VentanaImpX</code> proporciona una implementacion basada en el sistema de ventanas X Window.</p>
<figure>
<img src="img/052.png" />
</figure>
<p>Todas las operaciones de las subclases de <code>Ventana</code> se implementan en terminos de operaciones abstractas de la interfaz <code>VentanaImp</code>. Esto desacopla las abstracciones ventana de las diferentes implementaciones especificas de cada plataforma. Nos referiremos a la relacion entre <code>Ventana</code> y <code>VentanaImp</code> como un <b>puente</b> (<em>bridge</em>), porque une a la abstraccion con su implementacion, permitiendo que ambas varien de forma independiente.</p>
</div>
<h4 id="bridge-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Use el patron Bridge cuando</p>
<ul>
<li>
<p>quiera evitar un enlace permanente entre una abstraccion y su implementacion. Por ejemplo, cuando debe seleccionarse o cambiarse la implementacion en tiempo de ejecucion.</p>
</li>
<li>
<p>tanto las abstracciones como sus implementaciones deberian ser extensibles mediante subclases. En este caso, el patron Bridge permite combinar las diferentes abstracciones y sus implementaciones, y extenderlas independientemente.</p>
</li>
<li>
<p>los cambios en la implementacion de una abstraccion no deberian tener impacto en los clientes; es decir, su codigo no tendria que ser recompilado.</p>
</li>
<li>
<p>(C++) quiera ocultar completamente a los clientes la implementacion de una abstraccion. En C++ la representacion de una clase es visible en la interfaz de la misma.</p>
</li>
<li>
<p>tenga una proliferacion de clases como la mostrada en el primer diagrama de la seccion Motivacion. Una jerarquia de clases tal pone de manifiesto la necesidad de dividir un objeto en dos partes. Rumbaugh usa el termino <q>generalizaciones anidadas</q> [<a href="#rbp+91" >RBP+91</a>] para referirse a dichas jerarquias de clases.</p>
</li>
<li>
<p>quiera compartir una implementacion entre varios objetos (tal vez usando un contador de referencias) y este hecho deba permanecer oculto al cliente. Un ejemplo sencillo es la clase <code>String</code> de Coplien [<a href="#cop92" >Cop92</a>], donde varios objetos pueden compartir la misma representacion de una cadena (<code>StringRep</code>).</p>
</li>
</ul>
</div>
<h4 id="bridge-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/053.png" />
</figure>
</div>
<h4 id="bridge-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Abstraccion</code> (<code>Ventana</code>)</p>
<ul>
<li>
<p>define la interfaz de la abstraccion.</p>
</li>
<li>
<p>mantiene una referencia a un objeto de tipo <code>Implementador</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>AbstraccionRefinada</code> (<code>VentanaIcono</code>)</p>
<ul>
<li>
<p>extiende la interfaz definida por <code>Abstraccion</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>Implementador</code> (<code>VentanaImp</code>)</p>
<ul>
<li>
<p>define la interfaz de las clases de implementacion. Esta interfaz no tiene por que corresponderse exactamente con la de <code>Abstraccion</code>; de hecho, ambas interfaces pueden ser muy distintas. normalmente la interfaz <code>Implementador</code> solo proporciona operaciones primitivas, y <code>Abstraccion</code> define operaciones de mas alto nivel basadas en dichas primitivas.</p>
</li>
</ul>
</li>
<li>
<p><code>ImplementadorConcreto</code> (<code>VentanaImpX</code>, <code>VentanaImpPM</code>)</p>
<ul>
<li>
<p>implementa la interfaz <code>Implementador</code> y define su implementacion concreta.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="bridge-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p>Abstraccion redirige las peticiones del cliente a su objeto <code>Implementador</code>.</p>
</div>
<h4 id="bridge-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron Bridge tiene las siguientes consecuencias:</p>
<ol class="num" >
<li>
<p><em>Desacopla la interfaz y la implementacion.</em> No une permanentemente una implementacion a una interfaz, sino que la implementacion puede configurarse en tiempo de ejecucion. Incluso es posible que un objeto cambie su implementacion en tiempo de ejecucion.</p>
<p>Desacoplar <code>Abstraccion</code> e <code>Implementador</code> tambien elimina de la implementacion dependencias de tiempo de compilacion. Ahora, cambiar una clase ya no requiere recompilar la clase abstraccion y sus clientes. Esta propiedad es esencial cuando debemos asegurar la compatibilidad binaria entre distintas versiones de una biblioteca de clases.</p>
<p>Ademas, este desacoplamiento potencia una division en capas que puede dar lugar a sistemas mejor estructurados. La parte de alto nivel de un sistema solo tiene que conocer a <code>Abstraccion</code> y a <code>Implementador</code>.</p>
</li>
<li>
<p><em>Mejora la extensibilidad.</em> Podemos extender las jerarquias de <code>Abstraccion</code> y de <code>Implementador</code> de forma independiente.</p>
</li>
<li>
<p><em>Oculta detalles de implementacion a los clientes.</em> Podemos aislar a los clientes de los detalles de implementacion, como el compartimiento de objetos implementadores y el correspondiente mecanismo de conteo de referencias (si es que hay alguno).</p>
</li>
</ol>
</div>
<h4 id="bridge-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Al aplicar el patron Bridge hemos de tener en cuenta las siguientes cuestiones de implementacion:</p>
<ol class="num" >
<li>
<p><em>Un unico implementador.</em> En situaciones en las que solo hay una implementacion, no es necesario crear un clase abstracta <code>Implementador</code>. Este es un caso degenerado del patron Bridge, cuando hay una relacion uno-a-uno entre <code>Abstraccion</code> e <code>Implementador</code>. Sin embargo, esta separacion sigue siendo util cuando un cambio en la implementacion de una clase no debe afectar a sus clientes existentes, es decir, que estos no deberian tener que ser recompilados, sino solo vueltos a enlazar.</p>
<p>Carolan [<a href="#car89" >Car89</a>] usa la expresion <q>Gato de Cheshire</q> para describir dicha separacion. En C++ se puede definir la interfaz de la clase <code>Implementador</code> en un fichero de cabecera privado que no se proporciona a los clientes.</p>
</li>
<li>
<p><em>Crear el objeto <code>Implementador</code> apropiado.</em> ¿Como, cuando y donde se decide de que clase <code>Implementador</code> se van a crear las instancias cuando hay mas de una? Si <code>Abstraccion</code> conoce a todas las clases <code>ImplementadorConcreto</code>, puede crear una instancia de una de ellas en su constructor; puede decidir de cual basandose en los parametros pasados a su constructor. Por ejemplo, si la clase de una coleccion admite varias implementaciones, la desicion puede estar basada en el tamaño de la coleccion. Se puede usar una lista enlazada para colecciones pequeñas y una tabla de dispersion (<em>hash</em>) para colecciones grandes.</p>
<p>Otro enfoque consiste en elegir inicialmente una implementacion predeterminada y cambiarla despues en funcion de su uso, Si, por ejemplo, la coleccion crece mas alla de cierto limite, puede cambiar su implementacion por otra que resulte mas apropiada para un gran numero de elementos.</p>
<p>Tambien es posible delegar totalmente la desicion en otro objeto. En el ejercicio de la <code>Ventana</code>/<code>VentanaImp</code> se puede introducir un objeto fabrica (vease el patron <a href="#abstract-factory" >Abstract Factory</a>) cuya unica mision sea encapsular detalles de implementacion. La fabrica sabe que tipo de objeto <code>VentanaImp</code> crear para la plataforma en uso; una <code>Ventana</code> simplemente solicita una <code>VentanaImp</code>, y devuelve el tipo adecuado de esta. Una ventaja de este enfoque es que <code>Abstraccion</code> no esta acoplada directamente a ninguna de las clases <code>Implementador</code>.</p>
</li>
<li>
<p><em>Compartimiento de Implementadores.</em> Coplien ilustra como se puede usar el modismo de C++ Handle/Body (<em>Manjador/Cuerpo</em>) para compartir implementaciones entre varios objetos [<a href="#cop92" >Cop92</a>]. El <code>Cuerpo</code> tiene un contador de referencias que es incrementado y disminuido por la clase <code>Manejador</code>. El codigo para asignar manejadores con cuerpos compartidos tiene la siguiente forma general:</p>
<pre class="code" ><code class="chroma" ><span class="n">Manejador</span><span class="o">&amp;</span> <span class="n">Manejador</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Manejador</span><span class="o">&amp;</span> <span class="n">otro</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">otro</span><span class="p">.</span><span class="n">_cuerpo</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>
    <span class="n">_cuerpo</span><span class="o">-&gt;</span><span class="n">QuitarRef</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_cuerpo</span><span class="o">-&gt;</span><span class="n">ContadorReferencias</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="n">_cuerpo</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_cuerpo</span> <span class="o">=</span> <span class="n">otro</span><span class="p">.</span><span class="n">_cuerpo</span><span class="p">;</span>

    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</li>
<li>
<p><em>Uso de la herencia multiple.</em> Se puede utilizar herencia multiple en C++ para combinar una interafaz con su implementacion [<a href="#mar91" >Mar91</a>]. Por ejemplo, una clase puede heredar publicamente de <code>Abstraccion</code> y privadamente de <code>ImplementadorConcreto</code>. Pero dado que este enfoque se basa en la herencia estatica, esta asociando permanentemente una implementacion a su interfaz. Por tanto, no se puede implementar un verdadero Bridge usando herencia estatica, al menos no en C++.</p>
</li>
</ol>
</div>
<h4 id="bridge-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>El siguiente codigo C++ implementa el ejemplo <code>Ventana</code>/<code>VentanaImp</code> de la seccion de <code>Motivacion</code>. La clase <code>Ventana</code> define la abstraccion de ventana para las aplicaciones clientes:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Ventana</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Ventana</span><span class="p">(</span><span class="n">Vista</span><span class="o">*</span> <span class="n">contenido</span><span class="p">);</span>

    <span class="c1">// peticiones manejadas por la ventana
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DibujarContenido</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Abrir</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Cerrar</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Minimizar</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Maximizar</span><span class="p">();</span>

    <span class="c1">// peticiones reenviadas a su implementacion
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EstablecerOrigen</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">en</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EstablecerArea</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">area</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">TraerAlFrente</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EnviarAlFondo</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DibujarLinea</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DibujarRect</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DibujarPoligono</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DibujarTexto</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="n">VentanaImp</span><span class="o">*</span> <span class="n">ObtenerVentanaImp</span><span class="p">();</span>
    <span class="n">Vista</span><span class="o">*</span> <span class="nf">ObtenerVista</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">VentanaImp</span><span class="o">*</span> <span class="n">_imp</span><span class="p">;</span>
    <span class="n">Vista</span><span class="o">*</span> <span class="n">_contenido</span><span class="p">;</span> <span class="c1">// el contenido de la ventana
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p><code>Ventana</code> mantiene una referencia a <code>VentanaImp</code>, la clase abstracta que declara una interfaz para el sistema de ventanas subyacente.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">VentanaImp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ImpSuperior</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ImpInferior</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ImpEstablecerArea</span> <span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ImpEstablecerOrigen</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DispositivoRect</span><span class="p">(</span><span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DispositivoTexto</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DispositivoMapaDeBits</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// muchas mas funciones para dibujar en las ventanas...
</span><span class="c1"></span><span class="k">protected</span><span class="o">:</span>
    <span class="n">VentanaImp</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>Las subclases de <code>Ventana</code> definen los diferentes tipos de ventanas que puede usar la aplicacion, como ventanas de aplicacion, iconos, ventanas flotantes para los dialogos, paletas de herramientas flotantes, etcetera.</p>
<p>Por ejemplo, <code>VentanaAplicacion</code> implementa <code>DibujarContenido</code> para que dibuje su instancia de <code>Vista</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">VentanaAplicacion</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Ventana</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">DibujarContenido</span><span class="p">();</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">VentanaAplicacion</span><span class="o">::</span><span class="n">DibujarContenido</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">ObtenerVista</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">DibujarEn</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p><code>VentanaIcono</code> almacena el nombre de un mapa de bits con el icono que muestra...</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">VentanaIcono</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Ventana</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">DibujarContenido</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">_nombreMapaDeBits</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>...e implementa <code>DibujarContenido</code> para que dibuje el mapa de bits en la ventana:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">VentanaIcono</span><span class="o">::</span><span class="n">DibujarContenido</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">VentanaImp</span><span class="o">*</span> <span class="n">imp</span> <span class="o">=</span> <span class="n">ObtenerVentanaImp</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">imp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">imp</span><span class="o">-&gt;</span><span class="n">DispositivoMapaDeBits</span><span class="p">(</span><span class="n">_nombreMapaDeBits</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Hay muchas otras posibles variantes de <code>Ventana</code>. Una <code>VentanaFlotante</code> puede necesitar comunicarse con la ventana principal que la creo; de hay que contenga una referencia a dicha ventana. Una <code>VentanaPaleta</code> siempre flota sobre otras ventanas. Una <code>VentanaDeIconos</code> contiene objetos <code>VentanaIcono</code> y los coloca como es debido.</p>
<p>Las operaciones de <code>Ventana</code> se definen en terminos de la interfaz <code>VentanaImp</code>. Por ejemplo, <code>DibujarRect</code> extrae cuatro coordenadas a partir de sus dos parametros <code>Punto</code> antes de llamar a la operacion de <code>VentanaImp</code> que dibuja el rectangulo en la ventana:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Ventana</span><span class="o">::</span><span class="n">DibujarRect</span> <span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VentanaImp</span><span class="o">*</span> <span class="n">imp</span> <span class="o">=</span> <span class="n">ObtenerVentanaImp</span><span class="p">();</span>
    <span class="n">imp</span><span class="o">-&gt;</span><span class="n">DispositivoRect</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">X</span><span class="p">(),</span> <span class="n">p1</span><span class="p">.</span><span class="n">Y</span><span class="p">(),</span> <span class="n">p2</span><span class="p">.</span><span class="n">X</span><span class="p">(),</span> <span class="n">p2</span><span class="p">.</span><span class="n">Y</span><span class="p">());</span>
<span class="p">}</span>
</code></pre>
<p>Las subclases concretas de <code>VentanaImp</code> admiten diferentes sistemas de ventanas. La subclase <code>VentanaImpX</code> admite el sistema de ventanas X:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">VentanaImpX</span> <span class="o">:</span> <span class="k">public</span> <span class="n">VentanaImp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">VentanaImpX</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DispositivoRect</span><span class="p">(</span><span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">);</span>
    <span class="c1">// el resto de la interfaz publica...
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="c1">// estado especifico del sistema de ventanas X, incluyendo:
</span><span class="c1"></span>    <span class="n">Display</span><span class="o">*</span> <span class="n">_pantalla</span><span class="p">;</span>
    <span class="n">Drawable</span> <span class="n">_idVentana</span><span class="p">;</span>  <span class="c1">// identificador de ventana
</span><span class="c1"></span>    <span class="n">GC</span> <span class="n">_cg</span><span class="p">;</span>               <span class="c1">// contexto grafico de la ventana
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>Para Presentation Manager (PM) definimos la clase <code>VentanaImpPM</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">VentanaImpPM</span> <span class="o">:</span> <span class="k">public</span> <span class="n">VentanaImp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">VentanaImpPM</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DispositivoRect</span><span class="p">(</span><span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">);</span>

    <span class="c1">// el resto de la interfaz publica...
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="c1">// estado especifico del sistema de ventanas PM, incluyendo:
</span><span class="c1"></span>    <span class="n">HPS</span> <span class="n">_hps</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>Estas subclases implementan las operaciones de <code>VentanaImp</code> en terminos de las primitivas del sistema de ventanas. Por ejemplo, <code>DispositivoRect</code> se implementa para X como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">VentanaImpX</span><span class="o">::</span><span class="n">DispositivoRect</span> <span class="p">(</span>
    <span class="n">Coord</span> <span class="n">x0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y1</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">ancho</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">alto</span>  <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">y1</span><span class="p">));</span>
    <span class="n">XDrawRectangle</span><span class="p">(</span><span class="n">_pantalla</span><span class="p">,</span> <span class="n">_idVentana</span><span class="p">,</span> <span class="n">_cg</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ancho</span><span class="p">,</span> <span class="n">alto</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>La implemantacion para PM podria parecerse a:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">VentanaImpPM</span><span class="o">::</span><span class="n">DispositivoRect</span> <span class="p">(</span>
    <span class="n">Coord</span> <span class="n">x0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y1</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">Cord</span> <span class="n">izquierda</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
    <span class="n">Cord</span> <span class="n">derecha</span>   <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
    <span class="n">Cord</span> <span class="n">abajo</span>     <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">);</span>
    <span class="n">Cord</span> <span class="n">arriba</span>    <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">);</span>

    <span class="n">PPOINTL</span> <span class="n">punto</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="n">punto</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">izquierda</span><span class="p">;</span> <span class="n">punto</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">arriba</span><span class="p">;</span>
    <span class="n">punto</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span>   <span class="n">derecha</span><span class="p">;</span> <span class="n">punto</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">arriba</span><span class="p">;</span>
    <span class="n">punto</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span>   <span class="n">derecha</span><span class="p">;</span> <span class="n">punto</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span>  <span class="n">abajo</span><span class="p">;</span>
    <span class="n">punto</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">izquierda</span><span class="p">;</span> <span class="n">punto</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span>  <span class="n">abajo</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">GpiBeginPath</span><span class="p">(</span><span class="n">_hps</span><span class="p">,</span> <span class="mi">1L</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">GpiSetCurrentPosition</span><span class="p">(</span><span class="n">_hps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">punto</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">GpiPolyLine</span><span class="p">(</span><span class="n">_hps</span><span class="p">,</span> <span class="mi">4L</span><span class="p">,</span> <span class="n">punto</span><span class="p">)</span> <span class="o">==</span> <span class="n">GPI_ERROR</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">GpiEndPath</span><span class="p">(</span><span class="n">_hps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// notificar error
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">GpiStroquePath</span><span class="p">(</span><span class="n">_hps</span><span class="p">,</span> <span class="mi">1L</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>¿Como obtiene una ventana una instancia de la subclase correcta de <code>VentanaImp</code>? En este ejemplo, supondremos que es <code>Ventana</code> quien tiene esa responsabilidad. Su operacion <code>ObtenerVentanaImp</code> obtiene la instancia correcta de una fabrica abstracta (vease el patron <a href="Abstract-Factory" >Abstract Factory</a>) que encapsula todos los detalles del sistema de ventanas.</p>
<pre class="code" ><code class="chroma" ><span class="n">VentanaImp</span><span class="o">*</span> <span class="n">Ventana</span><span class="o">::</span><span class="n">ObtenerVentanaImp</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_imp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_imp</span> <span class="o">=</span> <span class="n">FabricaSistemaDeVentanas</span><span class="o">::</span><span class="n">Instancia</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">HacerWindowImp</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_imp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p><code>FabricaSistemaDeVentanas::Instancia()</code> devuelve una fabrica abstracta que produce todos los objetos especificos del sistema de ventanas. Por simplicidad hemos hecho que sea un <a href="#singleton" >Singleton</a> y  hemos dejado que la clase <code>Ventana</code> acceda directamente a la fabrica.</p>
</div>
<h4 id="bridge-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>El ejemplo de <code>Ventana</code> que acabamos de ver proviene de ET++ [<a href="#wgm88" >WGM88</a>]. En ET++ una <code>VentanaImp</code> se denomina <q>WindowPort</q> y tiene subclases tales como <code>XWindowPort</code> y <code>SunWindowPort</code>. El objeto <code>Window</code> crea su correspondiente objeto <code>Implementador</code> pidiendoselo a una factoria abstracta llamada <q><code>WindowSystem</code></q>. <code>WindowSystem</code> proporciona una interfaz para crear objetos dependientes de la plataforma, como fuentes, cursores, mapas de bits, etcetera.</p>
<p>El diseño <code>Window</code>/<code>WindowPort</code> de ET++ extiende el patron Bridge en el sentido de que <code>WindowPort</code> usa dicha referencia para notificar a <code>Window</code> eventos especificos de <code>WindowPort</code>: la llegada de eventos de entrada, cambios del tamaño de pantalla, etc.</p>
<p>Both Coplien [<a href="#cop92" >Cop92</a>] y Stroustrup [<a href="#str91" >Str91</a>] mencionan las clases <code>Manejador</code> (<em>Handler</em>) y dan algunos ejemplos de ellas. Sus ejemplos hacen hincapie en aspectos de la gestion de memoria, como compartir representaciones de cadenas y permitir objetos de tamaño variable. Nuestra atencion se centra mas en permitir que se puedan extender la abstraccion y la implemenatacion independientemente una de la otra.</p>
<p>libg++ [<a href="#lea88" >Lea88</a>] define clases que implementan estructuras de datos comunes, tales como <code>Set</code>, <code>LinkedSet</code>, <code>HashSet</code>, <code>LinketList</code> y <code>HashTable</code>. <code>Set</code> es una clase abstracta que define una abstraccion de un conjunto, mientras que <code>LinketList</code> y <code>HashTable</code> sos implementadores concretos de una lista enlazada y una tabla de dispersion, respectivamente. <code>LinkedSet</code> y <code>HashSet</code> son implementadores de <code>Set</code> que unen a <code>Set</code> con sus equivalentes concretos <code>LinkedList</code> y <code>HashTable</code>. Este es un ejemplo de un puente degenerado, porque no hay una clase abstracta <code>Implementador</code>.</p>
<p>El AppKit de NeXT [<a href="#add94" >Add94</a>] usa el patron Bridge en la implementacion y visualizacion de imagenes graficas. Una imagen se puede representar de varias formas diferentes. La representacion optima de una imagen depende de las caracteristicas de un dispositivo de visualizacion, concretamente de su capacidad de color y de su resolucion. Sin la ayuda de AppKit los desarrolladores tendrian que determinar que implementacion usar bajo varias circunstancias en cada aplicacion.</p>
<p>Para aliviar a los desarrolladores de esta responsabilidad, AppKit proporciona un puente para <code>NXImage</code>/<code>NXImageRep</code>. <code>NXImage</code> define la interfaz para manipular imagenes. La implementacion de las imagenes se define en una jerarquia de clases separada <code>NXImageRep</code> que tiene subclases como <code>NXEPSImageRep</code>, <code>NXCachedImageRep</code> y <code>NXBitMapImageRep</code>. <code>NXImage</code> mantiene una referencia a uno o mas objetos <code>NXImageRep</code>. Si hay mas de una implementacion de una imagen, <code>NXImage</code> selecciona la mas apropiada para el dispositivo de visualizacion actual. <code>NXImage</code> es incluso capaz de convertir una implementacion en otra si es necesario. El aspecto interesante de esta variante de Bridge es que <code>NXImage</code> puede almacenar mas de una implementacion de <code>NXImageRep</code> al mismo tiempo.</p>
</div>
<h4 id="bridge-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>El patron <a href="#abstract-factory" >Abstract Factory</a> puede crear y configurar un Bridge.</p>
<p>El patron <a href="#adapter" >Adapter</a> esta orientado a conseguir que trabajen juntas clases que no estan relacionadas. Normalmente se aplica a sistemas que ya han sido diseñados. El patron Bridge, por otro lado, se usa al comenzar un diseño para permitir que abstracciones varien independientemente unas de otras.</p>
</div>
<h3 id="composite" >Composite</h3>
<h4 id="composite-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Compone objetos en estructuras de arbol para representar jerarquias de parte-todo. Permite que los clientes traten de manera unforme a los objetos individuales y a los compuestos.</p>
</div>
<h4 id="composite-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Las aplicacions graficas como los editores de dibujo y los sistemas de diseño de circuitos permiten a los usuarios construir diagramas complejos a partir de componentes simples. El usuario puede agrupar componentes para formar componentes mas grandes, que a su vez pueden agruparse para formar componentes aun mayores. Una implementacion simple podria definir clases para primitivas graficas como <code>Texto</code> y <code>Linea</code>, mas otras clases que actuen como contenedoras de estas primitivas.</p>
<p>Pero hay un problema con este enfoque: el codigo que usa estas clases debe tratar de forma diferente a los objetos primitivos y a los contenedores, incluso aunque la mayor parte del tiempo el usuario los trate de forma identica. Tener que distinguir entre estos objetos hace que la aplicacion sea mas compleja. El patron Composite describe como usar la composicion recursiva para que los clientes no tengan que hacer esta distincion.</p>
<p>La clave del patron Composite es una clase abstracta que representa <em>tanto</em> a primitivas <em>como</em> a sus contenedores. Para el sistema grafico, esta clase es <code>Grafico</code>. <code>Grafico</code> declara operaciones como <code>Dibujar</code> que son especificas de objetos graficos. Tambien declara operaciones que comparten todos los objetos compuestos, tales como operaciones para acceder a sus hijos y para gestionarlos.</p>
<p>Las subclases <code>Linea</code>, <code>Rectangulo</code> y <code>Texto</code> (vease el diagrama de clases siguiente) definen objetos graficos primitivos. Estas clases implementan <code>Dibujar</code> para dibujar lineas, rectangulos y texto, respectivamente. Como los graficos primitivos no tienen graficos hijos, ninguna de estas clases implementa operaciones relacionadas con los hijos.</p>
<figure>
<img src="img/054.png" />
</figure>
<p>La clase <code>Dibujo</code> define una agregacion de objetos <code>Grafico</code>. <code>Dibujo</code> implementa <code>Dibujar</code> para que llame al <code>Dibujar</code> de sus hijos, y añade operaciones relacionadas con los hijos. Como la interfaz de dibujo se ajusta a la interfaz de <code>Grafico</code>, los objetos <code>Dibujo</code> pueden componer recursivamente otros <code>Dibujos</code>.</p>
<p>El siguiente diagrama muestra una tipica estructura de objetos compuestos recursivamente por otros objetos <code>Grafico</code> compuestos:</p>
<figure>
<img src="img/055.png" />
</figure>
</div>
<h4 id="composite-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Use el patron <code>Composite</code> cuando</p>
<ul>
<li>
<p>quiera representar jerarquias de objetos parte-todo.</p>
</li>
<li>
<p>quiera que los clientes sean capaces de obviar las diferencias entre composicion de objetos y los objetos individuales. Los clientes trataran a todos los objetos de la estructura compuesta de manera uniforme.</p>
</li>
</ul>
</div>
<h4 id="composite-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/056.png" />
</figure>
<p>Una estructura de objetos Compuestos tipica puede parecerse a esto:</p>
<figure>
<img src="img/057.png" />
</figure>
</div>
<h4 id="composite-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Componente</code> (<code>Grafico</code>)</p>
<ul>
<li>
<p>declara la interfaz de los objetos de la composicion.</p>
</li>
<li>
<p>implementa el comportamiento predeterminado de la interfaz que es comun a todas las clases.</p>
</li>
<li>
<p>declara una interfaz para acceder a sus componentes hijos y gestionarlos.</p>
</li>
<li>
<p>(opcional) define una interfaz para acceder al padre de un componente en la estructura recursiva y, si es necesario, la implementa.</p>
</li>
</ul>
</li>
<li>
<p><code>Hoja</code> (<code>Rectangulo</code>, <code>Linea</code>, <code>Texto</code>, etc.)</p>
<ul>
<li>
<p>representa objetos hoja en la composicion. Una hoja no tiene hijos.</p>
</li>
<li>
<p>define el comportamiento de los objetos primitivos de la composicion.</p>
</li>
</ul>
</li>
<li>
<p><code>Compuesto</code> (<code>Dibujo</code>)</p>
<ul>
<li>
<p>define el comportamineto de los componentes que tinen hijos.</p>
</li>
<li>
<p>almacena componentes hijos.</p>
</li>
<li>
<p>implementa las operaciones de la interfaz <code>Componente</code> relacionadas con los hijos.</p>
</li>
</ul>
</li>
<li>
<p><code>Cliente</code></p>
<ul>
<li>
<p>manipula objetos en la composicion a traves de la interfaz <code>Componente</code></p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="composite-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p>Los <code>Clientes</code> usan la interfaz de la clase <code>Componente</code> para interactuar con los objetos de la estructura compuesta. Si el recipiente es una <code>Hoja</code>, la peticion se trata correctamente. Si es un <code>Compuesto</code>, normalmente redirige las peticiones a sus componentes hijos, posiblemente realizando operaciones adicionales antes o despues.</p>
</div>
<h4 id="composite-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron <code>Composite</code></p>
<ul>
<li>
<p>define jerarquias de clases formadas por objetos primitivos y compuestos. Los objetos primitivos pueden componerse en otros objetos mas complejos, que a su vez pueden ser compuestos, y asi de manera recurrente. Alli donde el codigo espere un objeto primitivo, tambien podra recibir un objeto compuesto.</p>
</li>
<li>
<p>simplifica el cliente. Los clientes pueden tratar uniformemente a las estructuras compuestas y a los objetos individuales. Los clientes normalmente no conocen (y no les deberia importar) si estan tratando con una hoja o con un componente compuesto. Esto simplifica el codigo del cliente, puesto que evita tener que escribir funciones con instrucciones <code>if</code> anidadas en las clases que definen la composicion.</p>
</li>
<li>
<p>facilita añadir nuevos tipos de componentes. Si se definen nuevas subclases <code>Compuesto</code> u <code>Hoja</code>, estas funcionaran automaticamente con las estructuras y el codigo cliente existentes. No hay que cambiar los clientes para las nuevas clases <code>Componentes</code>.</p>
</li>
<li>
<p>puede hacer que un diseño sea demasiado general. La desventaja de facilitar añadir nuevos componentes es que hace mas dificil restringir los componentes de un compuesto. A veces queremos que un compuesto solo tenga ciertos componentes. Con el patron Composite, no podemos confiar en el sistema de tipos para que haga cumplir estas restricciones por nosotros. En vez de eso, tendremos que usar comprobaciones en tiempo de ejecucion.</p>
</li>
</ul>
</div>
<h4 id="composite-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Hay muchas cuestiones a tener en cuenta al implementar el patron Composite:</p>
<ol class="num" >
<li>
<p><em>Referencias explicitas al padre.</em> Mantener referencias de los componentes hijos a sus padres puede simplificar el recorrido y la gestion de una estructura compuesta. La referencia al padre facilita ascender por la estructura y borrar un componente. Las referencias al padre tambien ayudan a implementar el patron <a href="#chain-of-responsibility" >Chain of Responsibility</a>.</p>
<p>El lugar habitual donde definir la referencia al padre es en la clase <code>Componente</code>. Las clases <code>Hoja</code> y <code>Compuesto</code> pueden heredar la referencia y las operaciones que la gestionan.</p>
<p>Con referencias al padre, es esencial mantener el invariante de que todos los hijos de un compuesto tienen como padre al compuesto que a su vez los tiene a ellos como hijos. El modo mas facil de garantizar esto es cambiar el padre de un componente <em>solo</em> cuando se añade o se elimina a este de un compuesto. Si se puede implementar una vez en las operaciones <code>Añadir</code> y <code>Elimina</code> de la clase <code>Compuesto</code> entonces puede ser heredado por todas las subclases, conservando automaticamente el invariante.</p>
</li>
<li>
<p><em>Compartir componentes.</em> Muchas veces es util compartir componentes, por ejemplo para reducir los requisitos de almacenamiento. Pero cuando un componente no puede tener mas de un padre, compartir componentes se hace mas dificil.</p>
<p>Una posible solucion es que los hijos almacenen multiples padres. Pero eso puede llevarnos a ambiguedades cuando se propoga una peticion hacia arriba en la estructura. El patron <a href="#flyweight" >Flyweight</a> muestra como adaptar un diseño para evitar guardar los padres. Funciona en casos en los que los hijos pueden evitar enviar peticiones al padre externalizando parte de su estado, o todo.</p>
</li>
<li>
<p><em>Maximizar la interfaz <code>Componente</code>.</em> Uno de los objetivos del patron Composite es hacer que los clientes se despreocupen de las clases <code>Hoja</code> o <code>Compuesto</code> que estan usando. Para conseguirlo, la clase <code>Componente</code> deberia definir tantas operaciones comunes a las clases <code>Compuesto</code> y <code>Hoja</code> como sea posible. La clase <code>Componente</code> normalmente proporciona implementaciones predeterminadas para estas operaciones, que seran redefinidas por las subclases <code>Hoja</code> y <code>Compuesto</code>.</p>
<p>No obstante, este objetivo a veces entra en conflicto con el principio de diseño de jerarquias de clases que dice que una clase solo deberia definir operaciones que tienen sentido en sus subclases. Hay muchas operaciones permitidas por <code>Componente</code> que no parecen tener sentido en las clases <code>Hoja</code>. ¿Como puede <code>Componente</code> proporcionar una implementacion predeterminada para ellas?</p>
<p>A veces un poco de creatividad muestra como una operacion que podria parecer que solo tiene sentido en el caso de los <code>Compuestos</code> puede implementarse para todos los <code>Componentes</code>, moviendola a la clase <code>Componente</code>. Por ejemplo, la interfaz para acceder a los hijos es una parte fundamental de la clase <code>Compuesto</code>, pero no de las clases <code>Hoja</code>. Pero si vemos a una <code>Hoja</code> como un <code>Componente</code> que <em>nunca</em> tiene hijos, podemos definir una operacion predeterminada en la clase <code>Componente</code> para acceder a los hijos que nunca <em>devuelve</em> ningun hijo. Las clases <code>Hoja</code> pueden usar esa implementacion predeterminada, pero las clases <code>Compuesto</code> la reimplementaran para que devuelva sus hijos.</p>
<p>Las operaciones de gestion de los hijos son mas problematicas, y se tratan en el siguiente punto.</p>
</li>
<li>
<p><em>Declarar las operaciones de gestion de los hijos.</em> Aunque la clase <code>Compuesto</code> <em>implementa</em> las operaciones <code>Añadir</code> y <em>Eliminar</em> para controlar los hijos, un aspecto importante del patron <code>Compuesto</code> es que clases declaran estas operaciones en la jerarquia de clases <code>Compuesto</code>. ¿Deberiamos declarar estas operaciones en el <code>Componente</code> y hacer que tuvieran sentido en las clases <code>Hoja</code>, o deberiamos declararlas y definirlas solo en <code>Compuesto</code> y sus subclases?</p>
<p>La decision implica un equilibrio entre seguridad y transparencia:</p>
<ul>
<li>
<p>Definir la interfaz de gestion de los hijos en la raiz de la jerarquia de clases nos da trasparencia, puesto que podemos tratar a todos los componentes de manera uniforme. Sin embargo, sacrifica la seguridad, ya que los clientes pueden intentar hacer cosas sin sentido, como añadir y eliminar objetos de las hojas.</p>
</li>
<li>
<p>Definir la gestion de los hijos en la clase <code>Compuesto</code> nos proporciona seguridad, ya que cualquier intento de añadir o eliminar objetos de las hojas sera detectado en tiempo de compilacion en un lenguaje estaticamente tipado, como C++. Pero perderemos transparencia, porque las hojas y los compuestos tienen interfaces diferentes.</p>
</li>
</ul>
<p>En este patron hemos dado mas importancia a la transparencia que a la seguridad. Si se opta por la seguridad, habra ocaciones en las que perderemos informacion sobre el tipo y tendremos que convertir un componente en un compuesto. ¿Como podemos hacerlo sin recurrir a una conversion que no sea segura con respecto al tipo?</p>
<p>Una posibilidad es declarar una operacion <code>Compuesto* ObtenerCompuesto()</code> en la clase <code>Componente</code>. El <code>Componente</code> proporciona una operacion por omision que devuelve un puntero nulo. La clase <code>Compuesto</code> redefine esta operacion para devolverse a si misma a traves de su puntero <code>this</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Compuesto</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Componente</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="n">Compuesto</span><span class="o">*</span> <span class="n">ObtenerCompuesto</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Compuesto</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Componente</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Anadir</span><span class="p">(</span><span class="n">Componente</span><span class="o">*</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="n">Compuesto</span><span class="o">*</span> <span class="nf">ObtenerCompuesto</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Hoja</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Componente</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p><code>ObtenerCompuesto</code> nos permite consultar a un componente para ver si es un compuesto. Podemos ejecutar <code>Anadir</code> y <code>Eliminar</code> con seguridad sobre el compuesto que devuelve.</p>
<pre class="code" ><code class="chroma" ><span class="n">Compuesto</span><span class="o">*</span> <span class="n">unCompuesto</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Compuesto</span><span class="p">;</span>
<span class="n">Hoja</span><span class="o">*</span> <span class="n">unaHoja</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hoja</span><span class="p">;</span>

<span class="n">Componente</span><span class="o">*</span> <span class="n">unComponente</span><span class="p">;</span>
<span class="n">Compuesto</span><span class="o">*</span>  <span class="n">prueba</span><span class="p">;</span>

<span class="n">unComponente</span> <span class="o">=</span> <span class="n">unCompuesto</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">prueba</span> <span class="o">=</span> <span class="n">unComponente</span><span class="o">-&gt;</span><span class="n">ObtenerCompuesto</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">prueba</span><span class="o">-&gt;</span><span class="n">Anadir</span><span class="p">(</span><span class="k">new</span> <span class="n">Hoja</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">unComponente</span> <span class="o">=</span> <span class="n">unaHoja</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">prueba</span> <span class="o">=</span> <span class="n">unComponente</span><span class="o">-&gt;</span><span class="n">ObtenerCompuesto</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">pruba</span><span class="o">-&gt;</span><span class="n">Anadir</span><span class="p">(</span><span class="k">new</span> <span class="n">Hoja</span><span class="p">);</span> <span class="c1">// no añadira a una hoja
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Se pueden hacer comprobaciones similares para un <code>Compuesto</code> usando la costruccion de C++ <code>dynamic_cast</code>.</p>
<p>Por supuesto, el problema aqui es que no tratamos a todos los componentes de manera uniforme. Tenemos que volver a realizar comprobaciones para diferentes tipos antes de empreder la accion apropiada.</p>
<p>La unica forma de proporcionar transparencia es definir operaciones predeterminadas <code>Anadir</code> y <code>Eliminar</code> en <code>Componente</code>. Eso creara un nuevo problema: no hay modo de implementar <code>Componente::Anadir</code> sin introducir asi mismo la posibilidad de que falle. Podriamos no hacer nada, pero eso omite una consideracion importante, es decir, un intento de añadir algo a una hoja probablemente este indicando un error. En ese caso, la operacion <code>Anadir</code> produce basura. Podriamos hacer que borrara su argumento, pero eso no es lo que los clientes esperan.</p>
<p>Normalmente es mejor hacer que <code>Anadir</code> y <code>Eliminar</code> fallen de manera predeterminada (tal vez lanzando una excepcion) si el componente no puede tener hijos o si el argumento de <code>Eliminar</code> no es un hijo del componente.</p>
<p>Otra posibilidad es cambiar ligeramente el significado de <q>eliminar</q>. Si el componente mantiene una referencia al padre podriamos redefinir <code>Componente::Eliminar</code> para eliminarse asi mismo de su padre. No obstante, sigue sin haber una interpretacion con sentido para <code>Anadir</code>.</p>
</li>
<li>
<p><em>¿Deberia implementar el <code>Componente</code> una lista de <code>Componentes</code>?</em> Podriamos estar tentados de definir el conjunto de hijos como una variable de instancia de la clase <code>Componente</code> en la que se declaren las operaciones de acceso y gestion de los hijos. Pero poner el puntero al hijo en la clase base incurre en una penalizacion de espacio para cada hoja, incluso aunque una hoja nunca tenga hijos. Esto solo merece la pena si hay relativamente pocos hijos en la estructura.</p>
</li>
<li>
<p><em>Ordenacion de los hijos.</em> Muchos diseños especifican una ordenacion de los hijos de <code>Compuesto</code>. En el ejemplo del <code>Grafico</code>, la ordenacion puede reflejar el orden desde el frente hasta el fondo. Si los objetos <code>Compuesto</code> representan arboles de analisis, entonces las instrucciones compuestas pueden ser instancias de un <code>Compuesto</code> cuyos hijos deben estar ordenados de manera que reflejen el programa.</p>
<p>Cuando la ordenacion de los hijos es una cuestion a tener en cuenta, debemos diseñar las interfaces de acceso y gestion de hijos cuidadosamente para controlar la secuencia de hijos. El patron <a href="#Iterator" >Iterador</a> puede servirnos de guia.</p>
</li>
<li>
<p><em>Cache para mejorar el rendimiento.</em> Si necesitamos recorrer composiciones o buscar en ellas con frecuencia, la clase <code>Compuesto</code> puede almacenar informacion sobre sus hijos que facilite el recorrido o la busqueda. El <code>Compuesto</code> puede guardar resultados o simplemente informacion que le permita evitar parte del recorrido o de la busqueda. Por ejemplo, la clase <code>Dibujo</code> del ejemplo de la seccion de Motivacion podria guardar la caja limitrofe de su hijos. Mientras se dibuja o es seleccionado, esta caja previamente guardada permite que <code>Dibujo</code> no tenga que dibujar o realizar busquedas cuando sus hijos no son visibles en la ventana actual.</p>
<p>Los cambios en un componente requeriran invalidar la cache de sus padres. Esto funciona mejor cuando los componentes conocen a sus padres. Por tanto, si se va a usar almacenamiento cache se necesita definir una interfaz para decirle a los compuestos que su cache ya no es valida.</p>
</li>
<li>
<p><em>¿Quien deberia borrar los componentes?</em> En lenguajes sin recolector de basura, normalmente es mejor hacer que un <code>Compuesto</code> sea el responsable de borra sus hijos cuando es destruido. Una excepcion a esta regla es cuando los objetos <code>Hoja</code> son inmutables y pueden por tanto ser compartidos.</p>
</li>
<li>
<p><em>¿Cual es la mejor estructura de datos para almacenar los componentes?</em> Los objetos <code>Compuesto</code> pueden usar muchas estructuras de datos diferentes para almacenar sus hijos, incluyendo listas enlazadas, arboles, arrays y tablas de dispersion. La eleccion de la estructura de datos depende (como siempre) de la eficiencia. De hecho, ni siquiera es necesario usar una estructura de datos de proposito general. A veces los compuestos tienen una variable para cada hijo, aunque esto requiere que cada subclase de <code>Compuesto</code> implemente su propia interfaz de gestion. Vease el patron <a href="#interpreter" >Interpreter</a> para un ejemplo.</p>
</li>
</ol>
</div>
<h4 id="composite-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Determinados equipos, como computadores y componentes estereo, suelen estar organizados en jerarquias de parte-todo o de pertenencia. Por ejemplo, un chasis puede contener unidades y placas base, un bus puede contener tarjetas y un armario puede contener chasis, buses, etcetera. Dichas estructuras pueden modelarse de manera natural con el patron Composite.</p>
<p>La clase <code>Equipo</code> define una interfaz para todos los equipos de la jerarquia de pante-todo.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Equipo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Equipo</span><span class="p">();</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">Nombre</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_nombre</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">Vatio</span> <span class="nf">Potencia</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Moneda</span> <span class="nf">PrecioNeto</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Moneda</span> <span class="nf">PrecioConDescuento</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Anadir</span><span class="p">(</span><span class="n">Equipo</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Eliminar</span><span class="p">(</span><span class="n">Equipo</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Equipo</span><span class="o">*&gt;*</span> <span class="n">CrearIterador</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Equipo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">_nombre</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>Equipo</code> declara operaciones que devuelven los atributos de un equipo, como su consumo y coste. Las subclases implementan estas operaciones para determinados tipos de equipos. <code>Equipo</code> tambien declara una operacion <code>CrearIterador</code> que devuelve un <code>Iterador</code> (vease el <a href="#apendice-c" >Apendice C</a>) para acceder a sus partes. La implementacion predeterminada de estas operaciones devuelve un <code>IteradorNulo</code>, que itera sobre el conjunto vacio.</p>
<p>Las subclases de <code>Equipo</code> podrian incluir clases <code>Hoja</code> que representen unidades de disco, circuitos intergrados e interruptores:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Disquetera</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Equipo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Disquetera</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Disquetera</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">Vatio</span> <span class="nf">Potencia</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Moneda</span> <span class="nf">PrecioNeto</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Moneda</span> <span class="nf">PrecioConDescuento</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p><code>EquipoCompuesto</code> es la clase base de los equipos que contienen otros equipos. Es tambien una subclase de <code>Equipo</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">EquipoCompuesto</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Equipo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">EquipoCompuesto</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">Vatio</span> <span class="nf">Potencia</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Moneda</span> <span class="nf">ProcioNeto</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Moneda</span> <span class="nf">PrecioConDescuento</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Anadir</span><span class="p">(</span><span class="n">Equipo</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Eliminar</span><span class="p">(</span><span class="n">Equipo</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Equipo</span><span class="o">*&gt;*</span> <span class="n">CrearIterador</span><span class="p">();</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="n">EquipoCompuesto</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Lista</span><span class="o">&lt;</span><span class="n">Equipo</span><span class="o">*&gt;</span> <span class="n">_equipo</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>EquipoCompuesto</code> define las operaciones para acceder a sus componentes y recorrerlos. Las operaciones <code>Anadir</code> y <code>Eliminar</code> insertan y borran equipos en la lista de equipos almacenados en el miembro <code>_equipo</code>. La operacion <code>CrearIterador</code> devuelve un iterador (concretamente, una instancia de <code>IteradorLista</code>) para recorrer la lista.</p>
<p>Una implementacion predeterminada de <code>PrecioNeto</code> podria usar <code>CrearIterador</code> para sumar los precios netos de los equipos que lo componen:<span class="note" ><sup><a href="#34" >34</a></sup></span></p>
<pre class="code" ><code class="chroma" ><span class="n">Moneda</span> <span class="n">EquipoCompuesto</span><span class="o">::</span><span class="n">PrecioNeto</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Equipo</span><span class="o">*&gt;*</span> <span class="n">i</span> <span class="o">=</span> <span class="n">CrearIterador</span><span class="p">();</span>
    <span class="n">Moneda</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">Primero</span><span class="p">();</span> <span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">Haterminado</span><span class="p">();</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">Siguiente</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">ElementoActual</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">PrecioNeto</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">delete</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Ahora podemos representar un chasis de computadora como una subclase de <code>EquipoCompuesto</code> llamada <code>Chasis</code>. <code>Chasis</code> hereda las operaciones relativas a los hijos de <code>EquipoCompuesto</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Chasis</span> <span class="o">:</span> <span class="k">public</span> <span class="n">EquipoCompuesto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Chasis</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Chasis</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">Vatio</span> <span class="nf">Potencia</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Moneda</span> <span class="nf">PrecioNeto</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Moneda</span> <span class="nf">PrecioConDescuento</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>Podemos definir otros contenedores de equipos tales como <code>Armario</code> y <code>Bus</code> de forma similar. Eso nos da todo lo necesario para ensamblar componentes en una computadora personal (bastante sencillo):</p>
<pre class="code" ><code class="chroma" ><span class="n">Armario</span><span class="o">*</span> <span class="n">armario</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Armario</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Armario de PC&#34;</span><span class="p">);</span>
<span class="n">Chasis</span><span class="o">*</span> <span class="n">chasis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Chasis</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Chasis de PC&#34;</span><span class="p">);</span>

<span class="n">armario</span><span class="o">-&gt;</span><span class="n">Anadir</span><span class="p">(</span><span class="n">chasis</span><span class="p">);</span>

<span class="n">Bus</span><span class="o">*</span> <span class="n">bus</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bus</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Bus MCA&#34;</span><span class="p">);</span>
<span class="n">bus</span><span class="o">-&gt;</span><span class="n">Anadir</span><span class="p">(</span><span class="k">new</span> <span class="n">Tarjeta</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Token Ring de 16 Mbs&#34;</span><span class="p">));</span>

<span class="n">chasis</span><span class="o">-&gt;</span><span class="n">Anadir</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
<span class="n">chasis</span><span class="o">-&gt;</span><span class="n">Anadir</span><span class="p">(</span><span class="k">new</span> <span class="n">Disquetera</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Disquetera de 3,5 pulgadas&#34;</span><span class="p">));</span>

<span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="sa"></span><span class="s">&#34;El precio neto es &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">chasis</span><span class="o">-&gt;</span><span class="n">PrecioNeto</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre>
</div>
<h4 id="composite-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Se pueden encontrar ejemplos del patron Composite en casi todos los sistemas orientados a objetos. La clase <code>Vista</code> del Modelo/Vista/Controlador de Smalltalk [<a href="#kp88" >KP88</a>] era un Compuseto, y practiamente todos los toolkits o frameworks de interfaces de usuario han seguido sus pasos, incluyendo ET++ (con VObjects [<a href="#wgm88" >WGM88</a>]) e InterViews (Styles [<a href="#lci+92" >LCI+92</a>], Graphics [<a href="#vl88" >VL88</a>] y Glyphs [<a href="#cl90" >CL90</a>]). Merece la pena destacar que la Vista original del Modelo/Vista/Controlador tenia un conjunto de subvistas; en otras palabras, la clase <code>View</code> era tanto la clase Componente como la Compuesto. La version 4.0 de Smalltalk-80 reviso el Modela/Vista/Controlador con una clase <code>VisualComponent</code> que tenia como subclases <code>View</code> y <code>CompositeView</code>.</p>
<p>El framework para compiladores de Smalltalk RTL [<a href="#jml92" >JML92</a>] hace un uso intensivo del patron Composite. <code>RTLExpression</code> es una clase Componente para arboles de analisis. Tiene subclases, tales como <code>BinaryExpression</code>, que contienen objetos <code>RTLExpression</code> como hijos. Dichas clases definen una estructura compuesta para arboles de analisis. <code>RegisterTransfer</code> es la clase <code>Componente</code> para un programa en la forma intermedia de Single Static Assignment (SSA). Las subclases <code>Hoja</code> de <code>RegisterTransfer</code> definen diferentes asignaciones estaticas, como</p>
<ul>
<li>
<p>asignaciones primitivas que realizan una operacion en dos registros y asignan el resultado a un tercero;</p>
</li>
<li>
<p>una asignacion con un registro fuente pero sin registro destino, que indica que el registro se usa despues del retorno de una rutina; y</p>
</li>
<li>
<p>una asignacion con un registro destino pero sin origen, lo que indica que al registro se le asigna un valor antes de que empiece la rutina.</p>
</li>
</ul>
<p>Otra subclase, <code>RegisterTransferSet</code>, es una clase <code>Compuesto</code> que representa asignaciones que modifican varios registros a la vez.</p>
<p>Otro ejemplo de este patron tiene lugar en el dominio de las finanzas, donde una cartera de acciones agrupa valores individuales. Se pueden permitir agregaciones complejas de valores implementando una cartera como un <code>Compuesto</code> que se ajusta a la interfaz de un valor individual [<a href="#be93" >BE93</a>].</p>
<p>El patron <a href="#command" >Command</a> describe como se pueden componer y secuenciar objetos <code>Orden</code> con una clase Compuesto <code>OrdenMacro</code>.</p>
</div>
<h4 id="composite-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>Muchas veces se usa el enlace al componente pardre para implementar el patron <a href="#chain-of-responsibility" >Chain of Responsibility</a></p>
<p>El patron <a href="#decorator" >Decorator</a> suele usarse junto con el Composite. Cuando se usan juntos decoradores y compuestos, normalmente ambos tendran una clase padre comun. Por tanto, los decoradores tendran que admitir la intrefaz <code>Componente</code> con operaciones como <code>Anadir</code>, <code>Eliminar</code> y <code>ObtenerHijo</code>.</p>
<p>El patron <a href="#flyweight" >Flyweight</a> permite compartir componentes, si bien en ese caso estos ya no pueden referirse a sus padres.</p>
<p>Se suele usar el patron <a href="#iterator" >Iterator</a> para recorrer las estructuras definidas por el patron Composite.</p>
<p>El patron <a href="#visitor" >Visitor</a> localiza operaciones y comportamientos que de otro modo estaria distribuida en varias clases <code>Compuesto</code> y <code>Hoja</code>.</p>
</div>
<h3 id="decorator" >Decorator</h3>
<h4 id="decorator-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Asigna responsabilidades adicionales a un objeto dinamicamente, proporcionando una alternativa flexible a la herencia para extender la funcionalidad.</p>
</div>
<h4 id="decorator-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Wrapper (Envoltorio)</p>
</div>
<h4 id="decorator-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>A veces queremos añadir responsabilidades a objetos individuales en vez de a toda una clase. Por ejemplo, un toolkit de interfaces de usuario deberia permitir añadir propiedades (como bordes) o comportamientos (como capacidad de desplazamiento) a cualquier componente de la interfaz de usuario.</p>
<p>Un modo de añadir responsabilidades es a traves de la herencia. Heredar un borde de otra clase pondria un borde alrededor de todas las instancias de la subclase. Sin embargo, esto es inflexible, ya que la eleccion del borde se hace estaticamente. Un cliente no puede controlar como y cuando decorar el componente con un borde.</p>
<p>Un enfoque mas flexible es encerrar el componente en otro objeto que añada el borde. Al objeto confinante se le donomina <b>decorador</b>. El decorador se ajusta a la interfaz del componente que decora de manera que su presencia es transparente a sus clientes. El decorador reenvia las peticiones al componente y puede realizar acciones adicionales (tales como dibujar un borde) antes o despues del reevio. Dicha transparencia permite anidar decoradores recursivamente, permitiendo asi un numero ilimitado de responsabilidades añadidas.</p>
<figure>
<img src="img/058.png" />
</figure>
<p>Por ejemplo, supongamos un objeto <code>VistaTexto</code> que muestra texto en una ventana. <code>VistaTexto</code> no tiene barras de desplazamiento de manera predeterminada, ya que puede que no sean siempre necesarias. Cuando las necesitemos, podemos usar un <code>DecoradorDesplazamiento</code> para añadirlas. Supongamos que queremos añadir un borde negro, grueso, alrededor de <code>VistaTexto</code>. Podemos usar un <code>DecoradorBorde</code> para añadir tambien un borde. Basta con componer los decoradores con <code>VistaTexto</code> para producir el resultado deseado.</p>
<p>El siguiente diagrama de objetos muestra como componer un objeto <code>VistaTexto</code> con objetos <code>DecoradorBorde</code> y <code>DecoradorDeplazamiento</code> para producir una vista de texto con borde y desplazamiento:</p>
<figure>
<img src="img/059.png" />
</figure>
<p>Las clases <code>DecoradorDesplazamiento</code> y <code>DecoradorBorde</code> son subclases de <code>Decorador</code>, una clase abstracta para componentes visuales que decoran otros componentes visuales.</p>
<figure>
<img src="img/060.png" />
</figure>
<p><code>ComponenteVisual</code> es la clase abstracta de los objetos visuales. Define su interfaz para dibujarse y para el manejo de eventos. Notese como la clase <code>Decorador</code> simplemente redirige las peticiones para que se dibuje su componente, y como las subclases de <code>Decorador</code> pueden extender dicha operacion.</p>
<p>Las subclases de <code>Decorador</code> son libres de añadir operaciones para determinadas funcionalidades. Por ejemplo, la operacion @c(DesplazarA) de <code>DecoradorDesplazamiento</code> permite que otros objetos deplacen la interfaz <em>si</em> saben que la interfaz incluye un objeto <code>DecoradorDesplazamiento</code>. Lo imporante de este patron es que permite que los decoradores aparezcan en cualquier lugar en el que pueda ir un <code>ComponenteVisual</code>. De esa forma los clientes generalmente no pueden distinguir entre un componente decorado y otro que no lo esta, por lo que no dependen en absoluto de la decoracion.</p>
</div>
<h4 id="decorator-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Use el Decorador</p>
<ul>
<li>
<p>para añadir objetos individuales de forma dinamica y transparente, es decir, sin afectar a otros objetos.</p>
</li>
<li>
<p>para responsabilidades que pueden ser retiradas.</p>
</li>
<li>
<p>cuando la extension mediante la herencia no es viable. A veces es posible tener un gran numero de extensiones independientes, produciendose una explosion de subclases para permitir todas las combinaciones. O puede ser que una definicion de una clase este oculta o que no este disponible para ser heredada.</p>
</li>
</ul>
</div>
<h4 id="decorator-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/061.png" />
</figure>
</div>
<h4 id="decorator-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Componente</code> (<code>ComponenteVisual</code>)</p>
<ul>
<li>
<p>define la interfaz para objetos a los que se puede añadir responsabilidades dinamicamente.</p>
</li>
</ul>
</li>
<li>
<p><code>ComponenteConcreto</code> (<code>VistaTexto</code>)</p>
<ul>
<li>
<p>define un objeto al que se pueden añadir responsabilidades adicionales.</p>
</li>
</ul>
</li>
<li>
<p><code>Decorador</code></p>
<ul>
<li>
<p>mantiene una referencia a un objeto <code>Componente</code> y define una interfaz que se ajusta a la interfaz del <code>Componente</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>DecoradorConcreto</code> (<code>DecoradorBorde</code>, <code>DecoradorDesplazamiento</code>)</p>
<ul>
<li>
<p>añade responsabilidades al componente.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="decorator-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p>El Decorador redirige peticiones a su objeto <code>Componente</code>. Opcionalmente puede realizar operaciones adicionales antes y despues de reenviar la peticion.</p>
</div>
<h4 id="decorator-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron Decorador tiene al menos dos ventajas y dos inconvenientes fundamentales:</p>
<ol class="num" >
<li>
<p><em>Mas flexibilidad que la herencia estatica.</em> El patron Decorador proporciona una manera mas flexible de añadir responsabilidades a los objetos que la que podia obtenerse a traves de la herencia (multiple) estatica. Con los decoradores se pueden añadir y eliminar responsabilidades en tiempo de ejecucion simplemente poniendolas y quitandolas. Por el contrario, la herencia requiere crear una nueva clase para cada responsabilidad adicional (como <code>VistaTextoDesplazableConBorde</code> o <code>VistaTextoConBorde</code>). Esto da lugar a muchas clases diferentes e incrementa la complejidad de un sistema. Por otro lado, proporcionar diferentes clases <code>Decorador</code> para una detereminada clase <code>Componente</code> permite mezclar responsabilidades.</p>
<p>Los decoradores tambien facilitan añadir una propiedad dos veces. Por ejemplo, para dar un borde doble a <code>VistaTexto</code>, basta con añadir dos objetos <code>DecoradorBorde</code>. Heredar dos veces de una clase <code>Borde</code> resulta, cuado menos, propenso a errores.</p>
</li>
<li>
<p><em>Evita clases cargadas de funciones en la parte de arriba de la jerarquia.</em> El Decorador ofrece un enfoque para añadir responsabilidades que consiste en pagar solo por aquello que se necesita. En vez de tratar de permitir todas las funcionalidades inimaginables en una clase compleja y adaptable, podemos definir primero una clase simple y añadir luego funcionalidad incrementalmente con objetos <code>Decorador</code>. La funcionalidad puede obtenerse componiendo partes simples. Como resultado, una aplicacion no necesita pagar por caracteristicas que no usa. Tambien resulta facil definir nuevos tipos de Decoradores independientemente de las clases de objetos de las que hereden, incluso para extensiones que no hubieran sido previstas. Extender una clase compleja tiende a exponer detalles no relacionados con las responsabilidades que estamos añadiendo.</p>
</li>
<li>
<p><em>Un decorador y su componente no son identicos.</em> Un decorador se comporta como un revestimiento transparente. Pero desde el punto de vista de la identidad de un objeto, un componente decorado no es identico al componente en si. Por tanto, no deberiamos apoyarnos en la identidad de objetos cuando estamos usando decoradores.</p>
</li>
<li>
<p><em>Muchos objetos pequeños.</em> Un diseño que usa el patron Decorador suele dar como resultado sistemas formados por muchos objetos pequeños muy parecidos. Los objetos solo se diferencian en la forma en que estan interconectados, y no en su clase o en el valor de sus variables. Aunque dichos sistemas son faciles de adaptar por parte de quienes los comprenden bien, pueden ser dificiles de aprender y depurar.</p>
</li>
</ol>
</div>
<h4 id="decorator-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Hay que tener en cuenta varias cuestiones al aplicar el patron Decorador:</p>
<ol class="num" >
<li>
<p><em>Concordancia de interfaces.</em> La interfaz de un objeto decorador debe ajustarse a la interfaz del componente que decora. Las clases <em>DecoradorConcreto</em> deben  por tanto heredar de una clase comun (al menos en C++).</p>
</li>
<li>
<p><em>Omision de la clase abstracta Decorador.</em> No hay necesidad de definir una clase abstracta <code>Decorador</code> cuando solo necesitamos añadir una responsabilidad. Eso es lo que suele ocurrir cuando estamos tratando con una jerarquia de clases existente y no diseñando una nueva. En ese caso, podemos obtener la responsabilidad del Decorador reenviando peticiones al componente en el <code>DecoradorConcreto</code>.</p>
</li>
<li>
<p><em>Mantener ligeras las clases <code>Componente</code>.</em> Para garantizar una interfaz compatible, los componentes y los decoradores deben descender de una clase <code>Componente</code> comun. Es importante que esta clase comun se mantenga ligera; es decir, deberia centrarse en definir una interfaz, no en guardar datos. La definicion de como se representan los datos deberia delegarse en las subclases; de no ser asi, la complejidad de la clase <code>Componente</code> puede hacer que los decoradores sean demasiado pesados como para usar un gran numero de ellos. Poner mucha funcionalidad en el <code>Componente</code> tambien incrementa la probabilidad de que las subclases concretas esten pagando por caracteristicas que no necesitan.</p>
</li>
<li>
<p><em>Cambiar la piel de un objeto en vez de sus tripas.</em> Podemos pensar en un decorador como un revestimiento de un objeto que cambia su comportamiento. Una alternativa es cambiar las interioridades del objeto. El patron <a href="#strategy" >Strategy</a> es un buen ejemplo de patron para cambiar las tripas. Las estrategias son una mejor eleccion en aquellas situaciones en las que la clase <code>Componente</code> es intrinsecamente pesada, lo que hace que el patron Decorator sea demasiado costoso de aplicar. En el patron Strategy, el componente delega parte de su responsabilidad en un objeto estrategia aparte. El patron Strategy nos permite alterar o extender la funcionalidad del componente cambiando el objeto estrategia.</p>
<p>Por ejemplo, podemos permitir diferentes estilos de bordes haciendo que el componente delegue el dibujado del borde en un objeto <code>Borde</code> aparte. El objeto <code>Borde</code> es un objeto <code>Estrategia</code> que encapsula un algoritmo para dibujar bordes. Al ampliar el numero de estrategias de una a una lista ilimitada conseguimos el mismo efecto que anidando recursivamente decoradores.</p>
<p>Por ejemplo, en MacApp 3.0 [<a href="#app89" >App89</a>] y Bedrock [<a href="#sym93a" >Sym93a</a>] los componentes graficos (denominados <q>vistas</q>) mantienen una lista de objetos <q>adorno</q> que pueden añadir adornos adicionales, como bordes a un componente vista. Si una vista tiene algunos adornos, les da una posibilidad de dibujar adornos adicionales. MacApp y Bedrock deben usar este enfoque debido a que la clase <code>View</code> es pesada, por lo que seria demasiado costoso usarla solo para añadir un borde.</p>
<p>Puesto que el patron Decorator solo cambia la parte exterior de un objeto, el componente no tiene que saber nada de sus decoradores; es decir, los decoradores son transparentes para el componente:</p>
<figure>
<img src="img/062.png" />
</figure>
<p>Con estrategias, el componente conoce sus posibles extensiones. Por tanto tiene que referenciar y mantener las estrategias correspondientes:</p>
<figure>
<img src="img/063.png" />
</figure>
<p>El enfoque basado en estrategias puede requerir modificar el componetne para permitir nuevas extensiones. Por otro lado, una estrategia puede tener su propia interfaz especializada, mientras que la interfaz de un decorador debe ajustarse a la del componente. Una estrategia para dibujar un borde, por ejemplo, solo necesita definir la interfaz para dibujar el borde (<code>DibujarBorde</code>, <code>ObtenerAncho</code>, etc.), lo que significa que la estrategia puede ser ligera incluso aunque la clase componente sea pesada.</p>
<p>MacApp y Bedrock usan este enfoque para algo mas que simplemente adornar vistas. Tambien la usan para aumentar el comportamiento de manejo de eventos de los objetos. En ambos sistemas, una vista mantiene una lista de objetos de <q>comportamiento</q> que pueden modificar e interceptar eventos. La vista da la posibilidad de manejar el evento a cada uno de los objetos de comportamiento registrados antes que a los no registrados. Podemos decorar una vista para que admita el manejo de eventos, por ejemplo, registrando un objeto comportamiento que intercepte y maneje los eventos de teclado.</p>
</li>
</ol>
</div>
<h4 id="decorator-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>El codigo siguiente muestra como implementar decoradores de interfaz de usuario en C++. Supondremos que hay una clase <code>Componente</code> llamada <code>ComponenteVisual</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ComponenteVisual</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ComponenteVisual</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Dibujar</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">CambiarTamano</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>definiremos una subclase de <code>ComponenteVisual</code> llamada <code>Decorador</code>, de la cual heredaremos para obtener diferentes decoraciones.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Decorador</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ComponenteVisual</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Decorator</span><span class="p">(</span><span class="n">ComponenteVisual</span><span class="o">*</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Dibujar</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">CambiarTamano</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">ComponenteVisual</span><span class="o">*</span> <span class="n">_componente</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>Decorador</code> decora el <code>ComponenteVisual</code> referenciado por la variable de instancia <code>_componente</code>, la cual es inicializada en el constructor. Para cada operacion de la interfaz <code>ComponenteVisual</code>, <code>Decorador</code> define una implementacion predeterminada que pasa la peticion a <code>_componente</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Decorador</span><span class="o">::</span><span class="n">Dibujar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_componente</span><span class="o">-&gt;</span><span class="n">Dibujar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Decorador</span><span class="o">::</span><span class="n">CambiarTamano</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_componente</span><span class="o">-&gt;</span><span class="n">CambiarTamano</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Las subclases de <code>Decorador</code> definen decoraciones concretas. Por ejemplo, la clase <code>DecoradorBorde</code> añade un borde a su componente. <code>DecoradorBorde</code> es una subclase de <code>Decorador</code> que redefine la operacion <code>Dibujar</code> para dibujar el borde. <code>DecoradorBorde</code> tambien define una operacion privada auxiliar <code>DibujarBorde</code> que se encarga de dibujarlo. La subclase hereda de <code>Decorador</code> la implementacion de todas las otras operaciones.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">DecoradorBorde</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Decorator</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">DecoradorBorde</span><span class="p">(</span><span class="n">ComponenteVisual</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">anchoBorde</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Dibujar</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">DibujarBorde</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_ancho</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">DecoradorBorde</span><span class="o">::</span><span class="n">Dibujar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">Decorator</span><span class="o">::</span><span class="n">Dibujar</span><span class="p">();</span>
    <span class="n">DibujarBorde</span><span class="p">(</span><span class="n">_ancho</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Aqui vendria una implementacion parecida para <code>DecoradorDesplazamiento</code> y <code>DecoradorSombra</code>, que añadirian capacidades de desplazamiento y sombra a un componente visual.</p>
<p>Ahora podemos combinar instancias de estas clases para proporcionar diferentes decoraciones. El codigo siguiente ilustra como podemos usar decoradores para crear una <code>VistaTexto</code> desplazable y con borde.</p>
<p>En primer lugar, necesitamos un modo de poner un objeto visual en un objeto ventana. Supondremos que nuestra clase ventana proporciona una operacion <code>EstablecerContenido</code> para este proposito:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Ventana</span><span class="o">::</span><span class="n">EstablecerContenido</span> <span class="p">(</span><span class="n">ComponenteVisual</span><span class="o">*</span> <span class="n">contenido</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Ahora podemos crear la vista de texto y una ventana donde ponerla:</p>
<pre class="code" ><code class="chroma" ><span class="n">Ventana</span><span class="o">*</span> <span class="n">ventana</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ventana</span><span class="p">;</span>
<span class="n">VistaTexto</span><span class="o">*</span> <span class="n">vistaTexto</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VistaTexto</span><span class="p">;</span>
</code></pre>
<p><code>VistaTexto</code> es un <code>ComponenteVisual</code>, lo que nos permite ponerla en la ventana:</p>
<pre class="code" ><code class="chroma" ><span class="n">ventana</span><span class="o">-&gt;</span><span class="n">EstablecerContenido</span><span class="p">(</span><span class="n">vistaTexto</span><span class="p">);</span>
</code></pre>
<p>Pero queremos una <code>VistaTexto</code> con borde y que se pueda desplazar, por lo que hemos de decorarla de manera apropiada antes de ponerla en la ventana.</p>
<pre class="code" ><code class="chroma" ><span class="n">ventana</span><span class="o">-&gt;</span><span class="n">EstablecerContenido</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">DecoradorBorde</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">DecoradorDesplazamiento</span><span class="p">(</span><span class="n">vistaTexto</span><span class="p">),</span> <span class="mi">1</span>
    <span class="p">)</span>
<span class="p">);</span>
</code></pre>
<p>Dado que <code>Ventana</code> accede a su contenido a traves de la interfaz <code>ComponenteVisual</code>, no se percata de la presencia del decorador. Nosotros como clientes, todavia podemos utilizar la vista de texto si tenemos que interactuar con ella directamente, por ejemplo cuando necesitamos invocar operaciones que no son parte de la interfaz de <code>ComponenteVisual</code>. Los clientes que se basan en la identidad del componente tambien deberian referirse a ella directamente.</p>
</div>
<h4 id="decorator-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Muchos toolkits de interfaces de usuario orientados a objetos usan decoradores para añadir adornos graficos a los utiles.<span class="note" ><sup><a href="#28" >28</a></sup></span> Algunos ejemplos son InterViews [<a href="#lvc98" >LVC98</a>, <a href="#lci+92" >LCI+92</a>], ET++ [<a href="#wgm88" >WGM88</a>] y la biblioteca de clases ObjectWorks\Smalltalk [<a href="#par90" >Par90</a>]. Aplicaciones mas exoticas del patron Decorator son el DebuggingGlyph de InterViews y el PassivityWrapper de ParcPlace Smalltalk. Un DebuggingGlyph muestra informacion de depuracion antes y despues de reenviar una peticion a su componente para que se ubique en pantalla. Esta informacion de traza puede usarse para analizar y depurar el comportamiento de como se disponen los objetos en una composicion compleja. El PassivityWrapper puede activar o desactivar las interacciones del usuario con el componente.</p>
<p>Pero el patron Decorator no se limita en absoluto a las interfaces graficas de usuario, como demuestra el siguiente ejemplo (basado en las clases de flujos de ET++ [<a href="#wgm88" >WGM88</a>]).</p>
<p>Los flujos son una abstraccion fundamental en la mayoria de mecanismos de E/S. Un flujo puede proporcionar una interfaz para convertir objetos en una secuencia de bytes o caracteres. Eso nos permite transcribir un objeto a un fichero o a una cadena en memoria para recuperarlo posteriormente. Un modo sencillo de llevar esto a cabo es definiendo una clase abstracta <code>Flujo</code> con subclases como <code>FlujoMemoria</code> y <code>FlujoFichero</code>. Pero supongamos que tambien queremos poder hacer lo siguiente:</p>
<ul>
<li>
<p>Comprimir el flujo de datos usando diferentes algoritmos de compresion (run-length encoding, Lempel-Ziv, etc.).</p>
</li>
<li>
<p>Reducir el flujo de datos a caracteres ASCII de 7 bits, de manera que puedan transmitirse sobre un canal de comunicacion ASCII.</p>
</li>
</ul>
<p>El patron decorador nos ofrece un modo elegante de añadir estas responsabilidades a los flujos. El siguiente diagrama muestra una solucion al problema:</p>
<figure>
<img src="img/064.png" />
</figure>
<p>La clase abstracta <code>Flujo</code> mantiene un bufer interno y proporciona operaciones para almacenar datos en el flujo (<code>MeterEntero</code>, <code>MeterCadena</code>). Cuando se llene el bufer, <code>Flujo</code> llamara a la operacion <code>ManejarBuferLleno</code>, que lleva a cabo la transferencia real de datos. La version <code>FlujoFichero</code> de esta operacion la redefine para transferir el bufer a un fichero.</p>
<p>La clase fundamental aqui es <code>DecoradorFlujo</code>, que mantiene una referencia a un componente flujo y le reenvia peticiones. Las subclases de <code>DecoradorFlujo</code> redefinen <code>ManejarBuferLleno</code> y llevan a cabo acciones adicionales llamando a la operacion <code>ManejarBuferLleno</code> de <code>DecoradorFlujo</code>.</p>
<p>Por ejemplo, la subclase <code>FlujoDeCompresion</code> comprime los datos, y <code>FlujoASCII7</code> convierte los datos en ASCII de 7 bits. Ahora, para crear un <code>FlujoFichero</code> que comprima sus datos y convierta los datos binarios comprimidos en ASCII de 7 bits, decoramos un <code>FlujoFichero</code> con un <code>FlujoDeCompresion</code> y un <code>FlujoASCII7</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">Flujo</span><span class="o">*</span> <span class="n">unFlujo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FlujoCompresion</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">FlujoASCII7</span><span class="p">(</span>
        <span class="n">newFlujoFichero</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;unNombreDeFichero&#34;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">};</span>
<span class="n">unFlujo</span><span class="o">-&gt;</span><span class="n">MeterEntero</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
<span class="n">unFlujo</span><span class="o">-&gt;</span><span class="n">MeterCadena</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;unaCadena&#34;</span><span class="p">);</span>
</code></pre>
</div>
<h4 id="decorator-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p><a href="#adapter" >Adapter</a>: un decorador se diferencia de un adaptador en que el decorador solo cambia las responsabilidades de un objeto, no su interfaz, mientras que un adaptador le da a un objeto una interfaz completamente nueva.</p>
<p><a href="#composite" >Composite</a>: podemos ver a un decorador como un compuesto degenerado que solo tiene un componente. No obstante, un decorador añade responsabilidades adicionales ––no esta pensado para la agregacion de objetos––.</p>
<p><a href="#strategy" >Strategy</a>: un decorador permite cambiar el exterior de un objeto; una estrategia permite cambiar sus tripas. Son dos formas alternativas de modificar un objeto.</p>
</div>
<h3 id="facade" >Facade</h3>
<h4 id="facade-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Proporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema sea mas facil de usar.</p>
</div>
<h4 id="facade-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Estructurar un sistema en subsistemas ayuda a reducir la complejidad. Un tipico objetivo de diseño es minimizar la comunicacion y dependencias entre subsistemas. Un modo de lograr esto es introduciendo un objeto <b>fachada</b> que proporcione una interfaz unica y simplificada para los servicios mas generales del subsistema.</p>
<figure>
<img src="img/065.png" />
</figure>
<p>Pensemos, por ejemplo, en un entorno de programacion que permita a las aplicaciones acceder a su subsistema de compilacion. Este subsistema contendra clases tales como <code>Lexico</code>, <code>Sintactico</code>, <code>NodoPrograma</code>, <b>FlujoDeCodigoBinario</b> y <code>ConstructorNodoPrograma</code> que implementan el compilador. Algunas aplicaciones especializadas podrian encesitar acceder a estas clases directamente, pero la mayoria de los clientes de un compilador no suelen preocuparse de detalles como el analisis sintactico y la generacion de codigo, sino que simplemente quieren compilar un codigo determinado. Para estas aplicaciones, las potentes interfaces de bajo nivel del subsistema de compilacion solo complicarian su labor.</p>
<p>Para proporcionar una interfaz de mas alto nivel que aisle a estas clases de los clientes el subsistema de compilacion tambien incluye una clase <code>Compilador</code>. Esta clase define una interfaz uniforme para la funcionalidad del compilador. La clase <code>compilador</code> funciona como una fachada: ofrece a los clientes una interfaz unica y simple para el subsistema de compilacion. Esta clase aglutina las clases que implementan la funcionalidad del compilador sin ocultarlas por completo. La fachada del compilador facilita la vida a la mayoria de los programadores, sin ocultar la funcionalidad de mas bajo nivel para aquellos pocos que la necesiten.</p>
<figure>
<img src="img/066.png" />
</figure>
</div>
<h4 id="facade-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usaremos el patron Facade cuando</p>
<ul>
<li>
<p>queramos proporcionar una interfaz simple para un subsistema complejo. Los subsistemas suelen volverse mas complicados a medida que van evolucionando. La mayoria de los patrones, cuando se aplican, dan como resultado mas clases y mas pequeñas. Esto hace que el subsistema sea mas reutilizable y facil de personalizar, pero eso tambien lo hace mas dificil de usar para aquellos clientes que no necesitan personalizarlo. Una fachada puede proporcionar, por omision, una vista simple del subsistema que resulta adecuada para la mayoria de clientes. Solo aquelllos clientes que necesitan mas personalizacion necesitaran ir mas alla de la fachada.</p>
</li>
<li>
<p>hay muchas dependencias entre los clientes y las clases que implementan una abstraccion. Se introduce una fachada para desacoplar el subsistema de sus clientes y de otros subsistemas, promoviendo asi la independencia entre subsistemas y la portabilidad.</p>
</li>
<li>
<p>queramos dividir en capas nuestros subsistemas. Se usa una fachada para definir un punto de entrada en cada nivel del subsistema. Si estos son dependientes, se pueden simplificar las dependencias entre ellos haciendo que se comuniquen entre si unicamente a traves de sus fachadas.</p>
</li>
</ul>
</div>
<h4 id="facade-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/067.png" />
</figure>
</div>
<h4 id="facade-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Fachada</code> (<code>Compilador</code>)</p>
<ul>
<li>
<p>sabe que clases del subsistema son las responsables ante una peticion.</p>
</li>
<li>
<p>delega las peticiones de los clientes en los objetos apropiados del subsistema.</p>
</li>
</ul>
</li>
<li>
<p><b>clases del subsistema</b> (<code>Lexico</code>, <code>Sintactico</code>, <code>NodoPrograma</code>, etc.)</p>
<ul>
<li>
<p>implementan la funcionalidad del subsistema.</p>
</li>
<li>
<p>realizan las labores encomendadas por el objeto <code>Fachada</code>.</p>
</li>
<li>
<p>no conocen a la fachada; es decir, no tienen referencias a ella.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="facade-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p>Los clientes se comunican con el subsistema enviando peticiones al objeto <code>Fachada</code>, el cual las reenvia a los objetos apropiados del subsistema. Aunque son los objetos del subsistema los que realizan el trabajo real, la fachada puede tener que hacer algo de trabajo para pasar de su interfaz a las del subsistema.</p>
</li>
<li>
<p>Los clientes que usan la fachada no tienen que acceder directamente a los objetos del subsistema.</p>
</li>
</ul>
</div>
<h4 id="facade-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron Facade proporciona las siguientes ventajas:</p>
<ol class="num" >
<li>
<p>Oculta a los clientes los componentes del subsistema, reduciendo asi el numero de objetos con los que tratan los clientes y haciendo que el subsistema sea mas facil de usar.</p>
</li>
<li>
<p>Promueve un debil acoplamiento entre el subsistema y sus clientes. Muchas veces los componentes de un subsistema estan fuertemente acoplados. Un acoplamiento debil nos permite modificar los componentes del subsistema sin que sus clientes se vean afectados. Las fachadas ayudan a estructurar en capas un sistema y las dependencias entre los objetos. Tambien pueden eliminar dependencias complejas o circulares. Esto puede ser una consecuencia importante cuando el cliente y el subsistema se implementan por separado.</p>
<p>En los grande sistemas software es vital reducir las dependencias de compilacion. Queremos ahorrar tiempo minimizando la recompilacion cuando cambien las clases del subsistema. Reducir las dependencias de compilacion con fachadas puede limitar la recompilacion necesaria para un pequeno cambio en un subsistema importante. Una fachada tambien puede simplificar portar sistemas a otras plataformas, ya que es menos probable que construir un subsistema requiera volver a construir todos los otros.</p>
</li>
<li>
<p>No impide que las aplicaciones usen las clases del subsistema en caso de que sea necesario. De este modo se puede elegir entre facilidad de uso y generalidad.</p>
</li>
</ol>
</div>
<h4 id="facade-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>A la hora de implementar una fachada deben tenerse en cuenta los siguientes aspectos:</p>
<ol class="num" >
<li>
<p><em>Reduccion del acoplamiento cliente-subsistema.</em> El acoplamiento entre clientes y el subsistema puede verse reducido todavia mas haciendo que <code>Fachada</code> sea una clase abstracta con subclases concretas para las diferentes implementaciones de un subsistema. De esa manera los clientes pueden comunicarse con el subsistema a traves de la interfaz de una clase abstracta <code>Fachada</code>. Este acoplamiento abstracto evita que los clientes tengan que saber que implementacion de un subsistema estan usando.</p>
<p>Una alternativa a la herencia es configurar un objeto <code>Fachada</code> con diferentes objetos del subsistema. Para personalizar la fachada basta con reemplazar uno o varios de tales objetos.</p>
</li>
<li>
<p><em>Clases del subsistema publicas o privadas.</em> Un subsistema se parece a una clase en que ambos tienen interfaces y los dos encapsulan algo ––una clase encapsula estado y operaciones, mientras que un subsistema encapsula clases––. Y del mismo modo que resulta util pensar en la interfaz publica y privada de una clase, tambien podemos pensar en la interfaz publica y privada de un subsistema.</p>
<p>La interfaz publica de un subsistema consiste en una serie de clases a las que acceden todos los clientes; la interfaz privada es solo para quienes vayan a ampliar el subsistema. La clase <code>Fachada</code> es parte de la interfaz publica, por supuesto, pero no es la unica. Otras clases del subsistema tambien suelen ser publicas. Por ejemplo, las clases <code>Lexico</code> y <code>Sintactico</code> del subsistema de compilacion son parte de la interfaz publica.</p>
<p>Seria interesante poder hacer privadas a las clases de un subsistema, pero hay pocos lenguajes orientados a objetos que lo permitan. Tanto C++ como Smalltalk han tenido tradicionalmente un espacio de nombre global para las clases. No obstante, recientemente, el comite de estandarizacion de C++ añadio espacios de nombres al lenguaje [<a href="#str94" >Str94</a>], lo que nos permitira hacer visibles solo las clases publicas del subsistema.</p>
</li>
</ol>
</div>
<h4 id="facade-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Veamos mas en detalle como introducir una fachada en un subsistema de compilacion.</p>
<p>El subsistema de compilacion define una clase <code>FlujoDeCodigoBinario</code> que implementa un flujo de objetos <code>InstruccionBinaria</code>. Un objeto <code>InstruccionBinaria</code> encapsula un codigo binario, que puede especificar las instrucciones en lenguaje maquina. El subsistema tambien define una clase <code>Token</code> para los objetos que encapsula tokens del lenugaje de programacion.</p>
<p>La clase <code>Lexico</code> toma un flujo de caracteres y produce un flujo de tokens, un token cada vez.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Lexico</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Lexico</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Lexico</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">Tokens</span><span class="o">&amp;</span> <span class="n">Analizar</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">istream</span><span class="o">&amp;</span> <span class="n">_flujoDeEntrada</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>La clase <code>Sintactico</code> usa un <code>ConstructorNodoPrograma</code> para construir un arbol de analisis sintactico a partir de los tokens del <code>Lexico</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Sintactico</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Sintactico</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Sintactico</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Analizar</span><span class="p">(</span><span class="n">Lexico</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ConstructorNodoPrograma</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
<p><code>Sintactico</code> realiza llamadas a <code>ConstructorNodoPrograma</code> para crear incrementalmente el arbol de analisis sintactico. Estas clases interactuan segun el patron <a href="#builder" >Builder</a>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ConstructorNodoPrograma</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ConstructorNodoPrograma</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">NodoPrograma</span><span class="o">*</span> <span class="nf">NuevaVariable</span><span class="p">(</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombreVariable</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="n">NodoPrograma</span><span class="o">*</span> <span class="nf">NuevaAsignacion</span><span class="p">(</span>
        <span class="n">NodoPrograma</span><span class="o">*</span> <span class="n">variable</span><span class="p">,</span> <span class="n">NodoPrograma</span><span class="o">*</span> <span class="n">expresion</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="n">NodoPrograma</span><span class="o">*</span> <span class="nf">NuevaExpresionReturn</span> <span class="p">(</span>
        <span class="n">NodoPrograma</span><span class="o">*</span> <span class="n">valor</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="n">NodoPrograma</span><span class="o">*</span> <span class="nf">NuevaCondicion</span><span class="p">(</span>
        <span class="n">NodoPrograma</span><span class="o">*</span> <span class="n">condicion</span><span class="p">,</span>
        <span class="n">NodoPrograma</span><span class="o">*</span> <span class="n">parteTrue</span><span class="p">,</span> <span class="n">NodoPrograma</span><span class="o">*</span> <span class="n">parteFalse</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="c1"></span>
    <span class="n">NodoPrograma</span><span class="o">*</span> <span class="nf">ObtenerNodoRaiz</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">NodoPrograma</span><span class="o">*</span> <span class="n">_nodo</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>El arbol de analisis se compone de instancias de subclases de <code>NodoPrograma</code> tales como <code>NodoInstruccion</code>, <code>NodoExpresion</code> y asi sucesivamente. La jerarquia de <code>NodoPrograma</code> es un ejemplo de patron <a href="#composite" >Composite</a>. <code>NodoPrograma</code> define una interfaz para manipular un nodo de programa y sus hijos, en caso de que existan.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">NodoPrograma</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// manipulacion del nodo de programa
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ObtenerPosicionFuente</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">linea</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">indice</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span>
    <span class="c1">// manipulacion de los hijos
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Insertar</span><span class="p">(</span><span class="n">NodoPrograma</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Borrar</span><span class="p">(</span><span class="n">NodoPrograma</span><span class="o">*</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Recorrer</span><span class="p">(</span><span class="n">GeneradorDeCodigo</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">NodoPrograma</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>La operacion <code>Recorrer</code> toma un objeto <code>GenerardorDeCodigo</code>. Las subclases de <code>NodoPrograma</code> usan este objeto para generar codigo maquina, empleando para ello objetos <code>InstruccionBinaria</code> sobre un <code>FlujoDeCodigoBinario</code>. La clase <code>GeneradorDeCodigo</code> es un visitante (vease el patron <a href="#visitor" >Visitor</a>).</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">GeneradorDeCodigo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Visitar</span><span class="p">(</span><span class="n">NodoInstrucccion</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Visitar</span><span class="p">(</span><span class="n">NodoExpresion</span><span class="o">*</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="k">protected</span><span class="o">:</span>
    <span class="n">GeneradorDeCodigo</span><span class="p">(</span><span class="n">flujoDeCodigoBinario</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">FlujoDeCodigoBinario</span><span class="o">&amp;</span> <span class="n">_salida</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>GeneradorDeCodigo</code> tiene subclases como <code>GeneradorDeCodigoMaquinaDePila</code> y <code>GeneradorDeCodigoRISC</code>, que generan codigo maquina para distintas arquitecturas hardware.</p>
<p>Cada subclase de <code>NodoPrograma</code> implementa <code>Recorrer</code> como una llamada a <code>Recorrer</code> sobre sus objetos hijo <code>NodoPrograma</code>. A su vez, cada hijo hace lo mismo para sus hijos, y asi sucesivamente, de forma recursiva. Por ejemplo, <code>NodoExpresion</code> define <code>Recorrer</code> de la siguiente manera:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">NodoExpresion</span><span class="o">::</span><span class="n">Recorrer</span> <span class="p">(</span><span class="n">GeneradorDeCodigo</span><span class="o">&amp;</span> <span class="n">gc</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gc</span><span class="p">.</span><span class="n">Visitar</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

    <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">NodoPrograma</span><span class="o">*&gt;</span> <span class="n">i</span><span class="p">(</span><span class="n">_hijos</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">Primero</span><span class="p">();</span> <span class="o">!</span><span class="n">i</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">i</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Recorrer</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Las clases descritas hasta ahora forman el subsistema de compilacion. Ahora introduciremos una clase <code>Compilador</code>, una fachada que junta todas estas piezas. <code>Compilador</code> proporciona una interfaz simple para compilar codigo fuente y generar codigo para una determinada maquina.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Compilador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Compilador</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Compilar</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">FlujoDeCodigoBinario</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Compilar</span><span class="o">::</span><span class="n">Compilar</span> <span class="p">(</span>
    <span class="n">istream</span><span class="o">&amp;</span> <span class="n">entrada</span><span class="p">,</span> <span class="n">FlujoDeCodigoBinario</span><span class="o">&amp;</span> <span class="n">salida</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">Lexico</span> <span class="n">lexico</span><span class="p">(</span><span class="n">entrada</span><span class="p">);</span>
    <span class="n">ConstructorNodoPrograma</span> <span class="n">constructor</span><span class="p">;</span>
    <span class="n">Sintactico</span> <span class="n">sintactico</span><span class="p">;</span>

    <span class="n">sintactico</span><span class="p">.</span><span class="n">Analizar</span><span class="p">(</span><span class="n">lexico</span><span class="p">,</span> <span class="n">constructor</span><span class="p">);</span>
    <span class="n">GeneradorDeCodigoRISC</span> <span class="nf">generador</span><span class="p">(</span><span class="n">salida</span><span class="p">);</span>
    <span class="n">NodoPrograma</span><span class="o">*</span> <span class="n">arbolDeAnalisis</span> <span class="o">=</span> <span class="n">constructor</span><span class="p">.</span><span class="n">ObtenerNodoRaiz</span><span class="p">();</span>
    <span class="n">arbolDeAnalisis</span><span class="o">-&gt;</span><span class="n">Recorrer</span><span class="p">(</span><span class="n">generador</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Esta implementacion liga al codigo el tipo de generador de codigo a utilizar, de manera que los programadores no necesitan especificar la arquitectura de destino. Eso podria ser razonable si siempre fuera a haber una unica arquitectura. Si ese no es el caso, tal vez queremos cambiar el constructor de <code>Compilador</code> para que tome un parametro <code>GeneradorDeCodigo</code>. De ese modo los programadores pueden especificar el generador a usar cuando crean una instancia de <code>Compilador</code>. La fachada del compilador puede parametrizar otros participantes, como <code>Lexico</code> y <code>ConstructorNodoPrograma</code>, lo que añade flexibilidad, pero tambien se aparta de la mision del patron <code>Facade</code>, que es simplificar la interfaz para el caso general.</p>
</div>
<h4 id="facade-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>El ejemplo del compilador de la seccion Codigo de Ejemplo esta inspirado en el sistema de compilacion ObjectWorks\Smalltalk [<a href="#par90" >Par90</a>].</p>
<p>En el framework de aplicaciones ET++ [<a href="#wgm88" >WGM88</a>], una aplicacion puede tener incorporadas herramientas de inspeccion de objetos en tiempo de ejecucion. Estas herramientas estan implementadas en un subsistema aparte que incluye una clase <code>Fachada</code> denominada <q><code>ProgrammingEnvironment</code></q>. Esta fachada define operaciones tales como <code>InspectObject</code> e <code>InspectClass</code> para acceder a las herramientas de inspeccion.</p>
<p>Una aplicacion ET++ tambien puede prescindir de las capacidades de inspeccion proporcionadas. En ese caso, <code>ProgrammingEnvironment</code> implementa estas peticiones como operaciones nulas; es decir, no hacen nada. Solo la subclase <code>ETProgrammingEnvironment</code> implementa estas peticiones con operaciones que muestran los correspondientes inspectores. La aplicacion no sabe si esta o no disponible un entorno de inspeccion; hay un acoplamiento abstracto entre la aplicacion y el subsistema de inspeccion de objetos.</p>
<p>El sistema operativo Choices [<a href="#cirm93" >CIRM93</a>] usa fachadas para combinar varios frameworks en uno solo. Las abstracciones clave en Choices son los procesos, el almacenamiento y los espacios de direcciones. Para cada una de estas abstracciones existe su correspondiente subsistema, implementado como un framework, lo que permite portar Choises a diversas paltaformas hardware. Dos de estos subsistemas tienen un <q>representante</q> (es decir, una fachada). Estos representantes son <code>FileSystemInterface</code> (para el almacenamiento) y <code>Domain</code> (para los espacios de direcciones).</p>
<p>Por ejemplo, el framework de memoria virtual tiene como fachada a la clase <code>Domain</code> (dominio). Un dominio representa un espacio de direcciones, y proporciona una correspondencia entre las direcciones virtuales y los desplazamientos, por un lado, y los objetos en la memoria, ficheros y copias de seguridad, por otro. Las operaciones principales de <code>Domain</code> permiten añadir un objeto en la memoria a una determinada direccion, eliminar un objeto de la memoria y procesar los fallos de pagina.</p>
<p>Como se muestra en el siguiente diagrama, el subsistema de memoria virtual usa internamente los siguientes componentes:</p>
<ul>
<li>
<p><code>MemoryObject</code> representa un almacenamiento de datos.</p>
</li>
<li>
<p><code>MemoryObjectCache</code> guarda en la memoria fisica los datos de varios <code>MemoryObject</code>. <code>MemoryObjectCache</code> es realmente una <a href="#Strategy" >Estrategia</a> que localiza la politica de cache.</p>
</li>
<li>
<p><code>AddressTranslation</code> encapsula el hardware de traduccion de direcciones.</p>
</li>
</ul>
<p>Cada vez que tiene lugar una interrupcion por fallo de pagina se llama a la operacion <code>RepairFault</code>. el objeto <code>Domain</code> busca el objeto de memoria de la direccion causante del fallo de pagina y delega la operacion <code>RepairFault</code> en la cache asociada a ese objeto de memoria. Los dominios pueden personalizarse cambiando sus componentes.</p>
<figure>
<img src="img/068.png" />
</figure>
</div>
<h4 id="facade-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>El patron <a href="#abstract-factory" >Abstract Factory</a> puede usarse para proporcionar una interfaz para crear el subsistema de objetos de forma independiente a otros subsistemas. Las fabricas abstractas tambien pueden ser una alternativa a las fachadas para ocultar clases especificas de la plataforma.</p>
<p>El patron <a href="#mediator" >Mediator</a> es parecido al Facade en el sentido de que abstrae funcionalidad a partir de unas clases existentes. Sin embargo, el proposito del Mediador es abstraer cualquier comunicacion entre objetos similares, a menudo centralizando la funcionalidad que no pertenece a niguno de ellos. Los colegas de un mediador solo se preocupan de comunicarse con el y no entre ellos directamente. Por el contrario, una fachada simplemente abstrae una interfaz para los objetos del subsistema, haciendolos mas facil de usar; no define una nueva funcionalidad, y las clases del subsistema no saben de su existencia.</p>
<p>Normalmente solo necesita un objeto Fachada. Por tanto, suelen implementarse como <a href="#Singleton" >Sigletons</a>.</p>
</div>
<h3 id="flyweight" >Flyweight</h3>
<h4 id="flyweight-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Usa compartamiento para permitir un gran numero de objetos de grano fino de forma eficiente.</p>
</div>
<h4 id="flyweight-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Si bien algunas aplicaciones podrian beneficiarse de un diseño en el que se empleasen objetos para todo, una implementacion simplista haria que este fuese prohibitivamente caro.</p>
<p>Por ejemplo, la mayoria de las implementaciones de editores de documentos tienen funciones de formateado y edicion de texto que son hasta cierto punto modulares. Los editores de documentos orientados a objetos normalmente emplean objetos para representar los elementos insertados, como tablas y figuras. Sin embargo, no suelen hacer uso de un objeto para cada uno de los caracteres del documento, a pesar de que de esa manera se lograria una gran flexibilidad en la aplicacion. En ese caso se podria tratar de manera uniforme a los caracteres y a los elementos insertados con respecto a como se dibujan y formatean estos. La aplicacion podria ampliarse para permitir nuevos juegos de caracteres sin afectar al resto de su funcionalidad. La estructura de objetos de la aplicacion podria mimetizar la estructura fisica del documento. El siguiente diagrama muestra como puede usar objetos un editor de documentos para representar los caracteres.</p>
<figure>
<img src="img/069.png" />
</figure>
<p>El inconveniente de este diseño es su coste. Incluso documentos de un tamaño moderado podrian necesitar cientos o miles de objetos de caracteres, los cuales consumirian mucha memoria y podrian sufrir un coste en tiempo de ejecucion inaceptable. El patron Flyweight describe como compartir objetos para permitir su uso con granularidades muy finas sin un coste prohibitivo.</p>
<p>Un <b>peso ligero</b> es un objeto compartido que puede usarse a la vez en varios contextos. El peso ligero es un objeto independiente en cada contexto ––no se puede distinguir de una instancia del objeto que no este compartida––. Los pesos ligeros no pueden hacer suposiciones sobre el contexto en el cual operan. Lo fundamental aqui es la distincion entre estado <b>intrinseco</b> y <b>extrinseco</b>. El estado intrinseco se guarda con el propio objeto; consiste en informacion que es independiente de su contexto y que puede ser, por tanto, compartida. El estado extrinseco depende del contexto y cambia con el, por lo que no puede ser compartido. Los objetos cliente son responsables de pasar al peso ligero su estado extrinseco cuando lo necesite.</p>
<p>Los pesos ligeros modelan conceptos o entidades que normalmente son demasiado numerosos como para ser representados como objetos. Por ejemplo, un editor de documentos puede crean un peso ligero para cada letra del alfabeto. Cada peso ligero guarda un codigo de caracter, mientras que las coordenadas con su posicion en el documento y su estilo tipografico pueden obtenerse a partir de los algoritmos de maquetacion del texto y las ordenes de formateado activas alli donde aparezca dicho caracter. El codigo del caracter es su estado intrinseco, mientras que el resto de la informacion es extrinseca.</p>
<p>Desde un punto de vista logico, hay un objeto por cada aparicion en el documento de un determinado caracter:</p>
<figure>
<img src="img/070.png" />
</figure>
<p>Fisicamente, no obstante, hay un solo objeto peso ligero compartido por cada caracter, el cual aparece en diferentes contextos de la estructura del documento. Cada aparicion de un caracter concreto se refiere a la misma instancia del almacen<span class="note" ><sup><a href="#35" >35</a></sup></span> compartido de objetos peso ligero:</p>
<figure>
<img src="img/071.png" />
</figure>
<p>A continuacion se muestra la estructura de clases de estos objetos. <code>Glifo</code> es la clase abstracta para los objetos graficos, algunos de los cuales pueden ser pesos ligeros. Las operaciones que pueden depender del estado extrinseco reciben este como parametro. Por ejemplo, <code>Dibujar</code> e <code>Interseca</code> deben saber en que contexto esta el glifo antes de que puedan hacer su trabajo.</p>
<figure>
<img src="img/072.png" />
</figure>
<p>Un peso ligero que represente la letra <q>a</q> unicamente guarda el codigo de caracter correspondiente; no necesita guardar su posicion ni tipo de fuente. Los clientes proporcionan la informacion dependiente del contexto que el peso ligero necesita para dibujarse a si mismo. Por ejemplo, una <code>Fila</code> sabe donde deberian dibujarse sus hijos para que se dispongan horizontalmente. Por tanto, puede pasar a cada hijo su posicion cuando les pida que se dibujen.</p>
<p>Puesto que el numero de objetos de caracter diferentes es bastante menor que el numero de caracteres del documento, el numero total de objetos es notablemente menor que los que usaria una implementacion simplista. Un documento en el que todos los caracteres aparezcan con la misma fuente y color tendria del orden de 100 objetos caracter (aproximadamente el tamaño del juego de caracteres ASCII), independientemente de cual sea su longitud. Por otro lado, dado que la mayoria de los documentos no usan mas de 10 combinaciones diferentes de fuentes y colores, este numero no crecera demasiado en la practica. Emplear un objeto como abstraccion para los caracteres individuales es, por tanto, practico.</p>
</div>
<h4 id="flyweight-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>La efectividad del patron Flyweight depende enormemente de como y donde se use. Deberia aplicarse el patron cuando se cumpla <em>todo</em> lo siguiente:</p>
<ul>
<li>
<p>Una  aplicacion utiliza un gran numero de objetos.</p>
</li>
<li>
<p>Los costes de almacenamiento son elevados debido a la gran cantidad de objetos.</p>
</li>
<li>
<p>La mayor parte del estado del objeto puede hacerse extrinseco.</p>
</li>
<li>
<p>Muchos grupos de objetos pueden reemplazarse por relativamente pocos objetos compartidos, una vez que se ha eliminado el estado extrinseco.</p>
</li>
<li>
<p>La aplicacion no depende de la identidad de un objeto. Puesto que los objetos peso ligero pueden ser compartidos, las comprobaciones de identidad devolveran verdadero para objetos conceptualmente distintos.</p>
</li>
</ul>
</div>
<h4 id="flyweight-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/073.png" />
</figure>
<p>El siguiente diagrama de objetos muestra como se comparten los pesos ligeros:</p>
<figure>
<img src="img/074.png" />
</figure>
</div>
<h4 id="flyweight-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>PesoLigero</code> (<code>Glifo</code>)</p>
<ul>
<li>
<p>declara una interfaz a travez de la cual los pesos ligeros pueden recibir un estado extrinseco y actual sobre el.</p>
</li>
</ul>
</li>
<li>
<p><code>PesoLigeroConcreto</code> (<code>Caracter</code>)</p>
<ul>
<li>
<p>Implementa la interfaz <code>PesoLigero</code> y permite almacenar el estado intrinseco, en caso de que lo haya. Un objeto <code>PesoLigeroConcreto</code> debe poder ser compartido, por lo que cualquier estado que almacene debe ser intrinseco, esto es, debe ser independiente del contexto del objeto <code>PesoLigeroConcreto</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>PesoLigeroConcretoNoCompartido</code> (<code>Fila</code>, <code>Columna</code>)</p>
<ul>
<li>
<p>no todas las subclases de <code>PesoLigero</code> necesitan ser compartidas. La interfaz <code>PesoLigero</code> <em>permite</em> el compartimiento, no fuerza a el. Los objetos <code>PesoLigeroConcretoNoCompartido</code> suelen tener objetos <code>PesoLigeroConcreto</code> como hijos en algun nivel de la estructura de objetos (como es el caso de <code>Fila</code> y <code>Columna</code>).</p>
</li>
</ul>
</li>
<li>
<p><code>FabricaDePesosLigeros</code></p>
<ul>
<li>
<p>crea y controla objetos pesos ligeros.</p>
</li>
<li>
<p>garantiza que los pesos ligeros se compartan de manera adecuada. Cuando un cliente solicita un peso ligero, el objeto <code>FabricaDePesosLigeros</code> proporciona una instancia concreta o crea uno nuevo, en caso de que no exista ninguno.</p>
</li>
</ul>
</li>
<li>
<p><code>Cliente</code></p>
<ul>
<li>
<p>mantiene una referencia a los pesos ligeros.</p>
</li>
<li>
<p>calcula o guarda el estado extrinseco de los pesos ligeros.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="flyweight-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p>El estado que un peso ligero necesita para funcionar debe ser caracterizado como intrinseco o extrinseco. El estado intrinseco se guarda en el objeto <code>PesoLigeroConcreto</code>, mientras que el estado extrinseco lo guardan o lo calculan los objetos <code>Cliente</code>. Los clientes pasan este estado al peso ligero cuando invocan sus operaciones.</p>
</li>
<li>
<p>Los clientes no deberian crear instancias de <code>PesoLigeroConcreto</code> directamente, sino que deben obtener los objetos <code>PesoLigeroConcreto</code> solo a partir del objeto <code>FabricaDePesosLigeros</code> para garantizar que se puedan compartir adecuadamente.</p>
</li>
</ul>
</div>
<h4 id="flyweight-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>Los pesos ligeros pueden introducir costes en tiempo de ejecucion asociados con la transferencia, busqueda y calculo del estado extrinseco, especialmente si este se almaceno en primer lugar como estado intrinseco. En cualquier caso, dichos costes se ven compensados por el ahorro de espacio de almacenamiento, que se incrementa a medida que se comparten mas objetos.</p>
<p>El ahorro de almacenamiento esta en funcion de varios factores:</p>
<ul>
<li>
<p>La reduccion en el numero total de instancias lograda mediante el compartimiento</p>
</li>
<li>
<p>la cantidad de estado intrinseco por objeto</p>
</li>
<li>
<p>si el estado extrinseco se calcula o se almacena.</p>
</li>
</ul>
<p>Cuantos mas objetos peso ligero se compartan, mayor sera el ahorro de almacenamiento. Este ahorro aumentara a medida que se comparta mas cantidad de estado. El mayor ahorro tendra lugar cuando los objetos tengan gran cantidad de estado, tanto intrinseco como extrinseco, y cuando el estado extrinseco pueda calcularse en vez de tener que ser guardado. De esa manera se ahorra espacio de almacenamiento de dos formas: el compartimiento reduce el coste del estado intrinseco, y se cambia estado extrinseco por tiempo de calculo.</p>
<p>El patron Flyweight suele combinarse con el patron Composite para representar una estructura jerarquica como un grafo con nodos hojas compartidos. Una consecuencia del compartimiento es que los nodos hojas pesos ligeros no pueden tener un puntero a su padre. En vez de eso, el puntero al padre se le pasa al peso ligero como parte de su estado extriseco. Esto tiene un impacto desicivo en la forma en que se comunican los objetos de la jerarquia.</p>
</div>
<h4 id="flyweight-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>A la hora de implementar el patron Peso Ligero han de tenerse presentes las siguientes cuestiones:</p>
<ol class="num" >
<li>
<p><em>Eliminar el estado extrinseco.</em> La aplicabilidad del patron viene dada en gran medida por lo facil que sea identificar el estado extrinseco y eliminarlo de los objetos compartidos. Eliminar el estado extrinseco no ayudara a reducir los costes de almacenamiento en caso de que haya tantos tipos diferentes de estados extrinsecos como objetos hubiera antes del compartimiento. Lo ideal seria que el estado extrinseco pudiera ser calculado a partir de una estructura de objetos separada que tuviera requisitos de almacenamiento mucho menores.</p>
<p>En nuestro editor de documentos, por ejemplo, podemos almacenar un diccionario con informacion tipografica en una estructura aparte en vez de almacenar la fuente y el estilo con cada objeto caracter. Dicha estructura de datos almacena series de caracteres con los mismos atributos tipograficos. Cuando un caracter se dibuja a si mismo recibe sus atributos tipograficos como un efecto lateral de la operacion de dibujado. Como los documentos normalmente solo hacen uso de unas pocas fuentes y estilos diferentes, almacenar esta informacion fuera de cada objeto de caracter es mucho mas eficiente que si se almacenace internamente.</p>
</li>
<li>
<p><em>Gestionar los objetos compartidos.</em> Dado que los objetos estan compartidos, los clientes no deberian crear instancias de ellos directamente. La <code>FabricaDePesosLigeros</code> permite que los clientes obtengan un peso ligero concreto. Para ello, suelen utilizar un almacen asociativo donde los clientes pueden buscar los objetos pesos ligeros de su interes. Por ejemplo, la fabrica de pesos ligeros del ejemplo del editor de documentos podria mantener una tabla con objetos pesos ligeros indexados por codigos de caracter. El administrador devuelve el objeto peso ligero apropiado para un codigo dado, creando el objeto peso ligero en caso de que este no existiese.</p>
<p>El compartimiento tambien implica alguna forma de conteo de referencias o de recoleccion de basura para recuperar el espacio de almacenamiento de un peso ligero cuando este ya no sea necesario. Sin embargo, ninguna de estas cosas es necesaria si hay un numero fijo y pequeño de tales objetos (por ejemplo, los pesos ligeros para el juego de caracteres ASCII). En ese caso, vale la pena mantener los pesos ligeros de forma permatente.</p>
</li>
</ol>
</div>
<h4 id="flyweight-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Volviendo a nuestro codigo de ejemplo del formateador de documentos, podemos definir una clase base <code>Glifo</code> base para los objetos graficos. Como es logico, los glifos son Compuestos (vease el patron <a href="#composite" >Composite</a>) que tienen atributos graficos y que pueden dibujarse a si mismos. Aqui nos centraremos simplemente en el atributo para la fuente, pero podria seguirse el mismo enfoque para cualquiera de los otros atributos graficos que pudiera tener un glifo.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Glifo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Glifo</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Dibujar</span><span class="p">(</span><span class="n">Ventana</span><span class="o">*</span><span class="p">,</span> <span class="n">ContextoGlifo</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EstablecerFuente</span><span class="p">(</span><span class="n">Fuente</span><span class="o">*</span><span class="p">,</span> <span class="n">ContextoGlifo</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">Fuente</span><span class="o">*</span> <span class="nf">ObtenerFuente</span><span class="p">(</span><span class="n">ContextoGlifo</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Primero</span><span class="p">(</span><span class="n">ContextoGlifo</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Siguiente</span><span class="p">(</span><span class="n">ContextoGlifo</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">HaTerminado</span><span class="p">(</span><span class="n">ContextoGlifo</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">Glifo</span><span class="o">*</span> <span class="nf">Actual</span><span class="p">(</span><span class="n">ContextoGlifo</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Insertar</span><span class="p">(</span><span class="n">Glifo</span><span class="o">*</span><span class="p">,</span> <span class="n">ContextoGlifo</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Borrar</span><span class="p">(</span><span class="n">ContextoGlifo</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Glifo</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>La subclase <code>Caracter</code> simplemente almacena un codigo de caracter:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Caracter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Glifo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Caracter</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Dibujar</span><span class="p">(</span><span class="n">Ventana</span><span class="o">*</span><span class="p">,</span> <span class="n">ContextoGlifo</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">char</span> <span class="n">_codigocaracter</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>Para evitar reservar espacio en cada glifo para el atributo de la fuente, almacenaremos dicho atributo extrinsicamente en un objeto <code>ContextoGlifo</code>, el cual sirve de repositorio para el estado extrinseco, manteniendo una correspondencia entre un glifo y su fuente (y otros atributos graficos cualesquiera que pudiera tener) en diferentes contextos. Cualquier operacion que necesite saber la fuente del glifo en un contexto dado recibira como parametro una instancia de un objeto <code>ContextoGlifo</code>. La operacion puede entonces pedirle a <code>ContextoGlifo</code> cual es la fuente en ese contexto. El contexto depende de la posicion del glifo en la estructura. Por tanto, las operaciones de iteracion y manipulacion sobre los hijos del <code>Glifo</code> deben actualizar el <code>ContextoGlifo</code> cada vez que se usan.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ContextoGlifo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ContextoGlifo</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ContextoGlifo</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Siguiente</span><span class="p">(</span><span class="kt">int</span> <span class="n">incremento</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Insertar</span><span class="p">(</span><span class="kt">int</span> <span class="n">cantidad</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="n">Fuente</span><span class="o">*</span> <span class="nf">ObtenerFuente</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EstablecerFuente</span><span class="p">(</span><span class="n">Fuente</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">span</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_indice</span><span class="p">;</span>
    <span class="n">ArbolB</span><span class="o">*</span> <span class="n">_fuentes</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>El <code>ContextoGlifo</code> debe permanecer informado de la posicion actual en la estructura de glifos durante el recorrido. <code>ContextoGlifo::Siguiente</code> incrementa <code>_indice</code> a medida que se avanza en el recorrido. Las subclases de <code>Glifo</code> que tienen hijos (como <code>Fila</code> y <code>Columna</code>) deben implementar <code>Siguiente</code> para que llame a <code>ContextoGlifo::Siguiente</code> en cada punto del recorrido.</p>
<p><code>ContextoGlifo::ObtenerFuente</code> usa el indice como clave de una estructura <code>ArbolB</code> que guarda la correspondencia entre glifos y fuentes. Cada nodo del arbol se etiqueta con la longitud de la cadena para la que se proporciona informacion sobre la fuente. Las hojas del arbol apuntan a una fuente, mientras que los nodos interiores separan la cadena en subcadenas, una para cada hijo.</p>
<p>Sea el siguiente extracto de una composicion de glifos:</p>
<figure>
<img src="img/075.png" />
</figure>
<p>La estructura <code>ArbolB</code> para la informacion sobre la fuente podria parecer a esto:</p>
<figure>
<img src="img/076.png" />
</figure>
<p>Los nodos interiores definen intervalos de indices de glifos. El <code>ArbolB</code> se actualiza en respuesta a los cambios de fuentes y cada vez que se añaden o se eliminan glifos de la estructura. Por ejemplo, suponiendo que nos encontramos en el indice 102 durante un recorrido, el siguiente codigo establece la fuente de cada caracter de la palabra <q>expect</q> como la misma que la del contexto adyacente (es decir, <code>times12</code>, una instania de <code>Fuente</code> para Times Roman de 12 puntos):</p>
<pre class="code" ><code class="chroma" ><span class="n">ContextoGlifo</span> <span class="n">contexto</span><span class="p">;</span>
<span class="n">Fuente</span><span class="o">*</span> <span class="n">times12</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Fuente</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Times-Roman-12&#34;</span><span class="p">);</span>
<span class="n">Fuente</span><span class="o">*</span> <span class="n">timesItalic12</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Fuente</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Times-Italic-12&#34;</span><span class="p">);</span>
<span class="c1">// ...
</span><span class="c1"></span>
<span class="n">gc</span><span class="p">.</span><span class="n">EstablecerFuente</span><span class="p">(</span><span class="n">times12</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</code></pre>
<p>La nueva estructura <code>ArbolB</code> (con los cambios resaltados en negro) se pareceria a</p>
<figure>
<img src="img/077.png" />
</figure>
<p>Supongamos que añadimos la palabra <q>don&#39;t </q> (incluyendo el espacio en blanco) en Times Italic de 12 puntos antes de <q>expect</q>. El codigo siguiente informa al <code>contexto</code> de este evento, suponiendo que todavia se encuentre en el indice 102:</p>
<pre class="code" ><code class="chroma" ><span class="n">contexto</span><span class="p">.</span><span class="n">Insertar</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="n">contexto</span><span class="p">.</span><span class="n">EstablecerFuente</span><span class="p">(</span><span class="n">timesItalic12</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</code></pre>
<p>La estructura <code>ArbolB</code> se convierte en</p>
<figure>
<img src="img/078.png" />
</figure>
<p>Cuando se le pide a <code>ContextoGlifo</code> la fuente del glifo actual, este desciende por el <code>ArbolB</code>, añadiendo indices hasta que encuentra la fuente para el indice actual. Dado que la frecuencia de los cambios de fuente es relativamente baja, el arbol se mantiene pequeño en comparacion con el tamaño de la estructura de glifos. Esto mantiene bajos los costes de almacenamiento sin un aumento desorbitado de tiempo de busqueda.<span class="note" ><sup><a href="#36" >36</a></sup></span></p>
<p>El ultimo objeto que necesitamos es una <code>FabricaDePesosLigeros</code> que cree glifos y garantice que se comparten de manera adecuada. La clase <code>FabricaDeGlifos</code> crea instancias de <code>Caracter</code> y otros tipos de glifos. Nosotros solo compartimos objetos <code>Caracter</code>; los glifos compuestos son mas raros y, en cualquier caso, su estado importante (es decir, sus hijos) es intrinseco.</p>
<pre class="code" ><code class="chroma" ><span class="k">const</span> <span class="kt">int</span> <span class="n">NCODIGOSCARACTER</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">FabricaDeGlifos</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">FabricaDeGlifos</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">FabricaDeGlifos</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">Caracter</span><span class="o">*</span> <span class="nf">CrearCaracter</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">Fila</span><span class="o">*</span> <span class="nf">CrearFila</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Columna</span><span class="o">*</span> <span class="nf">CrearColumna</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">Caracter</span><span class="o">*</span> <span class="n">_caracter</span><span class="p">[</span><span class="n">NCODIGOSCARACTER</span><span class="p">];</span>
<span class="p">};</span>
</code></pre>
<p>El array <code>_caracter</code> contiene punteros a glifos <code>Caracter</code> indexados por el codigo de caracter. Este array es inicializado a cero en el constructor.</p>
<pre class="code" ><code class="chroma" ><span class="n">FabricaDeGlifos</span><span class="o">::</span><span class="n">FabricaDeGlifos</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCODIGOSCARACTER</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_caracter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><code>CrearCaracter</code> busca un caracter en los glifos de caracter del array, y devuelve el glifo correspondiente, si existe. entonces <code>CrearCaracter</code> crea el glifo, lo mete en el array y lo devuelve:</p>
<pre class="code" ><code class="chroma" ><span class="n">Caracter</span><span class="o">*</span> <span class="n">FabricaDeGlifos</span><span class="o">::</span><span class="n">CrearCaracter</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_caracter</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">_caracter</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Caracter</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">_caracter</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
<p>El resto de operaciones simplemente crean un nuevo objeto cada vez que son llamadas, dado que los glifos que no sean caracteres no seran compartidos:</p>
<pre class="code" ><code class="chroma" ><span class="n">Fila</span><span class="o">*</span> <span class="n">FabricaDeGlifos</span><span class="o">::</span><span class="n">CrearFila</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Fila</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Columna</span><span class="o">*</span> <span class="n">FabricaDeGlifos</span><span class="o">::</span><span class="n">CrearColumna</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Columna</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Podriamos omitir estas operaciones y dejar que los clientes crearan instancias de glifos no compartidos directamente. Sin embargo, en caso de que mas tarde decidiesemos hacer dichos glifos compartidos, tendriamos que cambiar el codigo cliente que los crea.</p>
</div>
<h4 id="flyweight-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>El concepto de objetos pesos ligeros se describio e investigo por primera vez como una tecnica de diseño en InterViews 3.0 [<a href="#cl90" >CL90</a>]. Sus desarrolladores construyeron un potente editor de documentos llamado Doc para demostrar el concepto [<a href="#cl92" >CL92</a>]. Doc usa objetos glifo para representar cada caracter del documento. El editor crea una instancia de Glifo para cada caracter que tenga un determinado estilo (el cual define sus atributos graficos); por tanto el estado intrinseco de un caracter consiste en el codigo del caracter y su informacion de estilo (un indice en la tabla de estilos).<span class="note" ><sup><a href="#37" >37</a></sup></span> Eso significa que unicamente la posicion es extrinseca, lo que hace que Doc sea rapido. Los documentos se representan por una clase <code>Document</code>, que tambien hace las veces de <code>FabricaDePesosLigeros</code>. Las mediciones hechas sobre Doc muestran que el compartimiento de caracteres resulta efectivo. Un documento tipico de 180.00 caracteres requirio solamente 480 objetos caracter.</p>
<p>ET++ [<a href="#wgm88" >WGM88</a>] usa pesos ligeros para permitir la independencia de la interfaz de usuario.<span class="note" ><sup><a href="#9" >9</a></sup></span><span class="note" ><sup><a href="#38" >38</a></sup></span> El estandar de interfaz de usuario afecta a la disposicion de los elementos de la interfaz de usuario (por ejemplo, barras de desplazamiento, botones y menus ––lo que se conoce con el nombre colectivo de <q>utiles</q>––)<span class="note" ><sup><a href="#28" >28</a></sup></span> y sus adornos (sombras, borde, etc.). Un util delega todo su comportamiento de posicionamiento y dibujado en otro objeto <code>Layout</code>. Cambiar el objeto <code>Layout</code> cambia el aspecto de la interfaz incluso en tiempo de ejecucion.</p>
<p>Para cada clase de util hay su correspondiente clase <code>Layout</code> (por ejemplo, <code>ScrollbarLayout</code>, <code>MenubarLayout</code>, etc.). Un problema evidente con este enfoque es que usar diferentes objetos layout duplica el numero de objetos de interfaz de usuario: para cada objeto de interfaz de usuario hay un objeto <code>Layout</code> adicional. Para evitar esta penalizacion, los objetos <code>Layout</code> se implementan como pesos ligeros. Dichos objetos son buenos pesos ligeros porque su principal mision es definir comportamiento, y es facil pasarles el poco estado extrinseco que necesitan para colocar o dibujar un objeto.</p>
<p>Los objetos <code>Layout</code> son creados y gestionados por objetos <code>Look</code>. La clase <code>Look</code> es una <a href="#Abstract-Factory" >Fabrica Abstracta</a> que recupera un determinado objeto <code>Layout</code> con operaciones como <code>GetButtonLayout</code>, <code>GetMenuBarLayout</code> y otras. Para cada estandar de interfaz de usuario existe la correspondiente subclase de <code>Look</code> (como <code>MotifLook</code> u <code>OpenLook</code>) que proporciona los objetos <code>Layout</code> apropiados.</p>
<p>Por cierto, los objetos <code>Layout</code> son, en esencia, estrategias, (vease el patron <a href="#strategy" >Strategy</a>). Son un ejemplo de objeto estrategia implementado como un peso ligero.</p>
</div>
<h4 id="flyweight-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>El patron Flyweight suele combinarse con el patron <a href="#composite" >Composite</a> para implementar una estructura logica jerarquica en terminos de un grafo dirigido aciclico con nodos hojas compartidos.</p>
<p>Suele ser mejor implementar los objetos <a href="#state" >State</a> y <a href="#strategy" >Strategy</a> como pesos ligeros.</p>
</div>
<h3 id="proxy" >Proxy</h3>
<h4 id="proxy-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Proporciona un representante o sustituto de otro objeto para controlar el acceso a este.</p>
</div>
<h4 id="proxy-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Surrogate (Sustituto)</p>
</div>
<h4 id="proxy-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Una razon para controlar el acceso a un objeto es retrasar todo el coste de su creacion e inicializacion hasta que sea realmente necesario usarlo. Pensemos en un editor de documentos que puede insertar objetos graficos en un documento. Algunos de estos objetos graficos, como las grandes imagenes <em>raster</em>, pueden ser costosos de crear. Sin embargo, abrir un documento deberia ser una operacion que se efectue rapidamente, por lo que se deberia evitar crear todos los objetos costosos a la vez en cuanto se abre el documento. Por otro lado, tampoco es necesario, ya que no todos esos objetos seran visibles en el documento al mismo tiempo.</p>
<p>Estas restricciones sugieren que cada objeto concreto se cree a <em>peticion</em>, lo que en este caso tendra lugar cuando la imagen se hace visible. Pero, ¿que ponemos en el documento en lugar de la imagen? ¿Y como puede ocultarse el hecho de que la imagen se crea a peticion sin que se complique la implementacion del editor? Esta optimizacion no deberia influir, por ejemplo, en el codigo de visualizacion y formateado.</p>
<p>La solucion es utilizar otro objeto, un <b>proxy</b> de la imagen, que actue como un sustituto de la imagen real. El proxy se comporta igual que la imagen y se encarga de crearla cuando sea necesario.</p>
<figure>
<img src="img/079.png" />
</figure>
<p>El proxy de la imagen crea la imagen real solo cuando el editor de documentos le pide que se dibuje, invocando a su operacion <code>Dibujar</code>. El proxy redirige las siguientes peticiones directamente a la imagen. Debe guardar, por tanto, una referencia a la imagen despues de crear esta.</p>
<p>Supongamos que las imagenes se guardan en ficheros aparte. En este caso podemos usar el nombre del fichero como la referencia al objeto real. El proxy tambien almacena su extension, esto es, su ancho y su alto. La extension permite que el proxy pueda responder a las preguntas sobre su tamaño que le haga el formateador sin crear realmente la imagen.</p>
<p>El siguiente diagrama de clases ilustra este ejemplo mas en detalle.</p>
<figure>
<img src="img/080.png" />
</figure>
<p>El editor de documentos accede a las imagenes insertadas a traves de la interfaz definida por la clase abstracta <code>Grafico</code>. <code>ProxyImagen</code> es una clase para las imagenes que se crean a peticion. <code>ProxyImagen</code> tiene como referencia a la imagen en el disco el nombre del fichero, el cual recibe como parametro el constructor de la clase.</p>
<p><code>ProxyImagen</code> tambien guarda la caja que circunscribe la imagen y una referencia a la instancia de la <code>Imagen</code> real, la cual no sera valida hasta que el proxy cree dicha imagen real. La operacion <code>Dibujar</code> se asegura de que la imagen ha sido creada antes de enviarle la peticion. <code>ObtenerExtension</code> redirige la peticion a la imagen solo si esta ha sido creada; en caso contrario, es <code>ProxyImagen</code> quien devuelve su extension.</p>
</div>
<h4 id="proxy-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Este patron es aplicable cada vez que hay necesidad de una referencia a un objeto mas versatil o sofisticado que un simple puntero. Estas son varias situaciones comunes en las que es aplicable el patron Proxy:</p>
<ol class="num" >
<li>
<p>Un <b>proxy remoto</b> proporciona un representante local de un objeto situado en otro espacio de direcciones. NEXTSTEP [<a href="#add94" >Add94</a>] usa la clase <code>NXProxy</code> con este proposito. Coplien [<a href="#cop92" >Cop92</a>] llama <q>Embajador</q> a este tipo de proxy.</p>
</li>
<li>
<p>Un <b>proxy virtual</b> crea objetos costosos por encargo. El <code>ProxyImagen</code> descrito en la seccion de Motivacion es un ejemplo de este tipo de proxy.</p>
</li>
<li>
<p>Un <b>proxy de proteccion</b> controla el acceso al objeto original. Los proxies de proteccion son utiles cuando los objetos debieran tener diferentes permisos de acceso. Por ejemplo, los <code>KernelProxy</code> del sistema operativo Choices [<a href="#cirm93" >CIRM93</a>] proporcionan un acceso protegido a los objetos del sistema operativo.</p>
</li>
<li>
<p>Una <b>referencia inteligente</b> es un sustituto de un simple puntero que lleva a cabo operaciones adicionales cuando se accede a un objeto. Algunos ejemplos de usos tipicos son:</p>
<ul>
<li>
<p>contar el numero de referencias al objeto real, de manera que este puede liberarse automaticamente cuando no haya ninguna referencia apuntandole (tambien se conocen con el nombre de <b>punteros inteligentes</b> [<a href="#ede92" >Ede92</a>]).</p>
</li>
<li>
<p>cargar un objeto persistente en la memoria cuando es referenciado por primera vez.</p>
</li>
<li>
<p>comprobar que se bloquea el objeto real antes de acceder a el para garantizar que no pueda ser modificado por ningun otro objeto.</p>
</li>
</ul>
</li>
</ol>
</div>
<h4 id="proxy-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/081.png" />
</figure>
<p>Este es un posble diagrama de objetos de una estructura de proxies en tiempo de ejecucion:</p>
<figure>
<img src="img/082.png" />
</figure>
</div>
<h4 id="proxy-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Proxy</code> (<code>ProxyImagen</code>)</p>
<ul>
<li>
<p>mantiene una referencia que permite al proxy acceder al objeto real. El proxy puede referirse a un <code>Sujeto</code> en caso de que las interfaces de <code>SujetoReal</code> y <code>Sujeto</code> sean la misma.</p>
</li>
<li>
<p>porporciona una interfaz identica a la de <code>Sujeto</code>, de manera que un proxy pueda ser sustituido por el sujeto real.</p>
</li>
<li>
<p>controlar el acceso al sujeto real, y puede ser responsable de su creacion y borrado.</p>
</li>
<li>
<p>otras responsabilidades dependen del tipo de proxy:</p>
<ul>
<li>
<p>los <em>proxies remotos</em> son reponsables de codificar una peticion y sus argumento para enviar la peticion codificada al sujeto que se encuentra en un espacio de direcciones diferente.</p>
</li>
<li>
<p>los <em>proxies virtuales</em> pueden guardar informacion adicional sobre el sujeto real, por lo que pueden retardar el acceso al mismo. Por ejemplo, el <code>ProxyImagen</code> de la seccion de <code>Motivacion</code> guarda la extension de la imagen real.</p>
</li>
<li>
<p>los <em>proxies de proteccion</em> comprueban que el llamador tenga los permisos de acceso necesarios para realizar una peticion.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Sujeto</code> (<code>Grafico</code>)</p>
<ul>
<li>
<p>define la interfaz comun para el <code>SujetoReal</code> y el <code>Proxy</code>, de modo que pueda usarse un Proxy en cualquier sitio en el que se espere un <code>SujetoReal</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>SujetoReal</code> (<code>Imagen</code>)</p>
<ul>
<li>
<p>define el objeto real representado.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="proxy-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p>El proxy redirige peticiones al <code>SujetoReal</code> cuando sea necesario, dependiendo del tipo de proxy.</p>
</div>
<h4 id="proxy-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron <code>Proxy</code> introduce un nivel de indireccion al acceder a un objeto. Esta indireccion adicional tiene muchos posibles usos, dependiendo del tipo de proxy:</p>
<ol class="num" >
<li>
<p>Un proxy remoto puede ocultar el hecho de que un objeto reside en un espacio de direcciones diferente.</p>
</li>
<li>
<p>Un proxy virtual puede llevar a cabo optimizaciones tales como crear un objeto por encargo.</p>
</li>
<li>
<p>Tanto los proxies de proteccion, como las referencias inteligentes, permiten realizar tareas de mantenimiento adicionales cuando se accede a un objeto.</p>
</li>
</ol>
<p>Hay otra optimizacion que el patron Proxy puede ocultar al cliente. Se denomina <b>copia-de-escritura</b>, y esta relacionada con la creacion por encargo. Copiar un objeto grande y complejo puede ser una operacion costosa. Si dicha copia no se modifica nunca, no hay necesidad de incurrir en ese gasto. Al utilizar un proxy para posponer el proceso de copia nos estamos asegurando de que solo pagamos el precio de copiar el objeto en caso de que este sea modificado.</p>
<p>Para realizar una copia-de-escritura el sujeto debe tener un contador de referencias. Copiar el proxy no sera mas que incrementar dicho contador. Solo cuando el cliente solicita una operacion que modifica el sujeto es cuando el proxy realmente lo copia. En este caso el proxy tambien tiene que disminuir el contador de referencias del sujeto. Cuando este llega a cero se borra el sujeto.</p>
<p>La copia-de-escritura puede reducir significativamente el coste de copiar sujetos pesados.</p>
</div>
<h4 id="proxy-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>El patron Proxy puede explotar las siguientes caracteristicas de los lenguajes:</p>
<ol class="num" >
<li>
<p><em>Sobrecargar el operador de acceso a miembros en C++.</em> C++ admite la sobrecarga de <code>operator-&gt;</code>, el operador de acceso a miembros. Sobrecargar este operador permite realizar tareas adicionales cada vez que se desreferencia un objeto, lo que puede resultar util para implementar algunos tipos de proxies; el proxy se comporta igual que un puntero.</p>
<p>El siguiente ejemplo ilustra como usar esta tecnica para implementar un proxy virtual llamado <code>PunteroImagen</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Imagen</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">Imagen</span><span class="o">*</span> <span class="nf">CargarUnFicheroDeImagen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
    <span class="c1">// funcion externa
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">PunteroImagen</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">PunteroImagen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">FicheroDeImagen</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">PunteroImagen</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="n">Imagen</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Imagen</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Imagen</span><span class="o">*</span> <span class="n">CargarImagen</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Imagen</span><span class="o">*</span> <span class="n">_imagen</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">_ficheroDeImagen</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">PunteroImagen</span><span class="o">::</span><span class="n">PunteroImagen</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">elFicheroDeImagen</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_ficheroDeImagen</span> <span class="o">=</span> <span class="n">elFicheroDeImagen</span><span class="p">;</span>
    <span class="n">_imagen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Imagen</span><span class="o">*</span> <span class="n">PunteroImagen</span><span class="o">::</span><span class="n">CargarImagen</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_imagen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_imagen</span> <span class="o">=</span> <span class="n">CargarUnFicheroDeImagen</span><span class="p">(</span><span class="n">_ficheroDeImagen</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_imagen</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Los operadores sobrecargados <code>-&gt;</code> y <code>*</code> usan <code>CargarImagen</code> para devolver <code>_imagen</code> a sus llamadores (cargando la imagen si es necesario).</p>
<pre class="code" ><code class="chroma" ><span class="n">Imagen</span><span class="o">*</span> <span class="n">PunteroImagen</span><span class="o">::</span><span class="k">operator</span><span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">CargarImagen</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Imagen</span><span class="o">&amp;</span> <span class="n">PunteroImagen</span><span class="o">::</span><span class="k">operator</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">CargarImagen</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Este enfoque permite llamar a las operaciones de <code>Imagen</code> a travez de objetos <code>PunteroImagen</code> sin el problema de hacer a esas operaciones parte de la interfaz de <code>PunteroImagen</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">PunteroImagen</span> <span class="n">imagen</span> <span class="o">=</span> <span class="n">PunteroImagen</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;nombreDeUnFicheroDeImagen&#34;</span><span class="p">);</span>
<span class="n">imagen</span><span class="o">-&gt;</span><span class="n">Dibujar</span><span class="p">(</span><span class="n">Punto</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">));</span>
    <span class="c1">// (Imagen.operator-&gt;())-&gt;Dibujar(Punto(50, 100))
</span><span class="c1"></span></code></pre>
<p>Notese como el proxy de <code>imagen</code> funciona como un puntero, pero no esta declarado como un puntero a <code>Imagen</code>. Eso significa que no se puede usar exactamente igual que un puntero real a <code>Imagen</code>. Por tanto, con este enfoque los clientes deben tratar de forma diferente a los objetos <code>Imagen</code> y <code>PunteroImagen</code>.</p>
<p>Sobrecargar el operador de acceso a miembros no es una buena solucion para todos los tipos de proxies. Algunos necesitan saber exactamente <em>que</em> operacion es llamada, y en esos casos no sirve sobrecargar el operador de acceso a miembros.</p>
<p>Piensese en el ejemplo del proxy virtual de la seccion de Motivacion. La imagen deberia cargarse en un determinado instante ––en concreto, cuando se llama a la operacion <code>Dibujar</code>––, y no cada vez que se hace referencia a la imagen. Sobrecargar el operador de accceso no permite realizar esta distincion. En ese caso debemos implementar manualmente cada operacion del proxy que redirige la peticion al sujeto.</p>
<p>Estas operaciones suelen ser muy parecidas unas a otras, como se demuestra en el Codigo de Ejemplo. Normalmente todas las operaciones verifican que la peticion es legal, que existe el objeto original, etc., antes de redirigir la peticion al sujeto. Escribir este codigo una y otra vez es una labor tediosa. Por ese motivo, es frecuente usar un preprocesador para generarlo automaticamente.</p>
</li>
<li>
<p><em>Usar <code>doesNotUnderstand</code> en Smalltalk.</em> Smalltalk proporciona un enganche que se puede usar para permitir el reenvio automatico de peticiones. Smalltalk llama a <code>doesNotUnderstand:unMensaje</code> cuando un cliente envia un mensaje a un receptor que no tiene el metodo correspondiente. La clase Proxy puede redefinir <code>doesNotUnderstand</code> para que el mensaje sea reenviado a su sujeto.</p>
<p>Para garantizar que una peticion se redirige al sujeto y no es absorbida en silencio por su proxy, puede definirse una clase Proxy que no entienda <em>ningun</em> mensaje. Smalltalk permite hacer esto definiendo Proxy como una clase sin superclase.<span class="note" ><sup><a href="#39" >39</a></sup></span></p>
<p>El principal inconveniente de <code>doesNotUnderstand:</code> es que la mayoria de sistemas Smalltalk tienen unos pocos mensajes especiales que no son manejados directamente por la maquina virtual, y para estos no se lleva a cabo la habitual busqueda de metodos. El unico que suele estar implementado en Object (y que puede por tanto afectar a los proxies) es la operacion de identidad, <code>==</code>.</p>
<p>Si se decide usar <code>doesNotUnderstand:</code> para implementar Proxy sera necesario hacer un diseño que tenga en cuenta este problema. No se debe suponer que la identidad entre proxies significa que sus sujetos reales son tambien identicos. Un inconveniente añadido es que <code>doesNotUnderstand:</code> fue desarrollado para el tratamiento de errores, no para crear proxies, por lo que no suele ser demasiado rapida.</p>
</li>
<li>
<p><em>Los proxies no siempre tienen que conocer el tipo del sujeto real.</em> Si una clase Proxy puede tratar con su sujeto solo a traves de una interfaz abstracta, entonces no hay necesidad de hacer una clase Proxy para cada clase de <code>SujetoReal</code>; el proxy puede tratar de manera uniforme a todas las clases <code>SujetoReal</code>. Pero si los objetos Proxy van a crear instancias de <code>SujetoReal</code> (como en los casos de los proxies virtuales), entonces tienen que conocer la clase concreta.</p>
</li>
</ol>
<p>Otra cuestion de implementacion tiene que ver como referirse al sujeto antes de que se cree una instancia de este. Algunos proxies tienen que referirse a su sujeto independientemente de que este en disco o en memoria. Eso significa que deben usar alguna forma de identificadores de objetos independientes del espacio de direcciones. En la seccion de Motivacion se uso un nombre de fichero para tal fin.</p>
</div>
<h4 id="proxy-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>El siguiente codigo implementa dos tipos de proxies: el proxy virtual descrito en la seccion de Motivacion y un proxy implementado con <code>doesNotUnderstand:</code>.<span class="note" ><sup><a href="#40" >40</a></sup></span></p>
<ol class="num" >
<li>
<p><em>Un proxy Virtual.</em> La clase <code>Grafico</code> define la interfaz de los objetos graficos:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Grafico</span> <span class="p">{</span>
<span class="nl">publico</span><span class="p">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Grafico</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Dibujar</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">en</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ManejarRaton</span><span class="p">(</span><span class="n">Evento</span><span class="o">&amp;</span> <span class="n">evento</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">ObtenerExtension</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Cargar</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">desde</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Guardar</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">en</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Grafico</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>La clase <code>Imagen</code> implementa la interfaz <code>Grafico</code> para mostrar ficheros de <code>Imagen</code>. <code>Imagen</code> redefine <code>ManejarRaton</code> para que los usuarios puedan cambiar interactivamente el tamaño de la <code>Imagen</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">imagen</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Grafico</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Imagen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fichero</span><span class="p">);</span>  <span class="c1">// carga una Imagen desde un fichero
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="o">~</span><span class="n">Imagen</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Dibujar</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">en</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ManejarRaton</span><span class="p">(</span><span class="n">Evento</span><span class="o">&amp;</span> <span class="n">evento</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">ObtenerExtension</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Cargar</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">desde</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Guardar</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">en</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p><code>ProxyImagen</code> tiene la misma interfaz que <code>Imagen</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ProxyImagen</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Grafico</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ProxyImagen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">FicheroDeImagen</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ProxyImagen</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Dibujar</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">en</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ManejarRaton</span><span class="p">(</span><span class="n">Evento</span><span class="o">&amp;</span> <span class="n">evento</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">ObetenerExtension</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Cargar</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">desde</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Guardar</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">en</span><span class="p">);</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Imagen</span><span class="o">*</span> <span class="n">ObtenerImagen</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Imagen</span><span class="o">*</span> <span class="n">_imagen</span><span class="p">;</span>
    <span class="n">Punto</span> <span class="n">_extension</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">_nombreDeFichero</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>El constructor guarda una copia local del nombre de fichero que contiene la <code>Imagen</code>, e inicializa <code>_extension</code> e <code>_imagen</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">ProxyImagen</span><span class="o">::</span><span class="n">ProxyImagen</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombreDeFichero</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_nombreDeFichero</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">nombreDeFichero</span><span class="p">);</span>
    <span class="n">_extension</span> <span class="o">=</span> <span class="n">Punto</span><span class="o">::</span><span class="n">Cero</span><span class="p">;</span> <span class="c1">// todavia no se conoce la extension
</span><span class="c1"></span>    <span class="n">_imagen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Imagen</span><span class="o">*</span> <span class="n">ProxyImagen</span><span class="o">::</span><span class="n">GetImagen</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_imagen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_imagen</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Imagen</span><span class="p">(</span><span class="n">_nombreDeFichero</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_imagen</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>La implementacion de <code>ObtenerExtension</code> devuelve, si es posible, la extension guardada por el proxy; en otro caso se carga la <code>Imagen</code> desde el fichero. <code>Dibujar</code> carga la <code>Imagen</code>, y <code>ManejarRaton</code> reenvia el evento a la <code>Imagen</code> real.</p>
<pre class="code" ><code class="chroma" ><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">ProxyImagen</span><span class="o">::</span><span class="n">ObtenerExtension</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_extension</span> <span class="o">==</span> <span class="n">Punto</span><span class="o">::</span><span class="n">Cero</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_extension</span> <span class="o">=</span> <span class="n">ObtenerImagen</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ObtenerExtension</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_extension</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ProxyImagen</span><span class="o">::</span><span class="n">Dibujar</span> <span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">en</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ObtenerImagen</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Dibujar</span><span class="p">(</span><span class="n">en</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ProxyImagen</span><span class="o">::</span><span class="n">ManejarRaton</span> <span class="p">(</span><span class="n">Evento</span><span class="o">&amp;</span> <span class="n">evento</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ObtenerImagen</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ManejarRaton</span><span class="p">(</span><span class="n">evento</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>La operacion <code>Guardar</code> graba en un flujo de salida la extension y el nombre del fichero de <code>Imagen</code> almacenados en el proxy. <code>Cargar</code> recupera esta informacion e inicializa los miembros correspondientes.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">ProxyImagen</span><span class="o">::</span><span class="n">Guardar</span> <span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">en</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">en</span> <span class="o">&lt;&lt;</span> <span class="n">_extension</span> <span class="o">&lt;&lt;</span> <span class="n">_nombreDeFichero</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ProxyImagen</span><span class="o">::</span><span class="n">Cargar</span> <span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">desde</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">desde</span> <span class="o">&gt;&gt;</span> <span class="n">_extension</span> <span class="o">&gt;&gt;</span> <span class="n">_nombreDeFichero</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Por ultimo, supongamos que tenemos una clase <code>DocumentoDeTexto</code> que puede contener objetos <code>Grafico</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">DocumentoDeTexto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">DocumentoDeTexto</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">Insertar</span><span class="p">(</span><span class="n">Grafico</span><span class="o">*</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>Podemos insertar un <code>ProxyImagen</code> en un documento de texto como se muestra a continuacion:</p>
<pre class="code" ><code class="chroma" ><span class="n">DocumentoDeTexto</span><span class="o">*</span> <span class="n">texto</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DocumentoDeTexto</span><span class="p">;</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="n">texto</span><span class="o">-&gt;</span><span class="n">Insertar</span><span class="p">(</span><span class="k">new</span> <span class="n">ProxyImagen</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;nombreDeUnFicheroDeImagen&#34;</span><span class="p">));</span>
</code></pre>
</li>
<li>
<p><em>Proxies que usan <code>doesNotUnderstand</code>.</em> Se pueden crear proxies genericos en Smalltalk definiendo clases cuya superclase sea <code>nil</code><span class="note" ><sup><a href="#41" >41</a></sup></span> y definiendo el metodo <code>doesNotUnderstand:</code> para manejar los mensajes.</p>
<p>El siguiente metodo presupone que el proxy tiene un metodo <code>sujetoReal</code> que devuelve su sujeto real. En el caso de <code>ProxyImagen</code>, este metodo comprobaria si se habia creado la <code>Imagen</code>, la crearia si fuese necesario y finalmente la devolveria. Hace uso de <code>perform:withArguments:</code> para responder al mensaje que ha sido atrapado en el sujeto real.</p>
<pre class="code" ><code class="chroma" ><span class="nf">doesNotUnderstand:</span> <span class="nv">unMensaje</span>
    <span class="o">^</span> <span class="bp">self</span> <span class="nf">sujetoReal</span>
        <span class="nf">perform:</span> <span class="nv">unMensaje</span> <span class="nf">selector</span>
        <span class="nf">withArguments:</span> <span class="nv">unMensaje</span> <span class="nf">arguments</span>
</code></pre>
<p>El argumento de <code>doesNotUnderstand:</code> es una instancia de <code>Message</code> que representa el mensaje que no entiende el proxy. Por tanto, el proxy responde a todos los mensajes asegurandose que existe el sujeto real antes de reenviarle el mensaje.</p>
<p>Una de las ventajas de <code>doesNotUnderstand:</code> es que puede realizar un procesamiento arbitrario. Por ejemplo, podriamos obtener un proxy de proteccion especificando un conjunto <code>mensajesLegales</code> con los mensajes que deben ser aceptados y dandole al proxy el metodo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="nf">doesNotUnderstand:</span> <span class="nv">unMensaje</span>
    <span class="o">^</span> (<span class="nv">mensajesLegales</span> <span class="nf">includes:</span> <span class="nv">unMensaje</span> <span class="nf">selector</span>)
        <span class="nb">ifTrue:</span> [<span class="bp">self</span> <span class="nf">sujetoReal</span>
            <span class="nf">perform:</span> <span class="nv">unMensaje</span> <span class="nf">selector</span>
            <span class="nf">withArguments:</span> <span class="nv">unMensaje</span> <span class="nf">arguments</span>]
        <span class="nb">ifFalse:</span> [<span class="bp">self</span> <span class="nf">error:</span> <span class="s">&#39;Operador ilegal&#39;</span>]
</code></pre>
<p>Este metodo comprueba que un mensaje sea legal antes de redirigirlo al sujeto real. En caso de que no lo sea, enviara error: al proxy, lo que daria como resultado un bucle infinito de errores a menos que el proxy defina <code>error:</code>. Por tanto, deberia copiarse la definicion de <code>error:</code> de la clase Object junto con cualquier metodo que use.</p>
</li>
</ol>
</div>
<h4 id="proxy-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>El proxy virtual de la seccion Motivacion esta tomado de las clases de ET++ para construccion de bloques de texto.</p>
<p>NEXTSTEP [<a href="#add94" >Add94</a>] usa proxies (instancias de clase NXProxy) como proxies locales de objetos que pueden ser distribuidos. Un servidor crea proxies de objetos remotos cuando los solucitan lo clientes . Al recibir un mensaje, el proxy lo codifica junto con sus argumentos y envia el mensaje codificado al sujeto remoto. De forma similar, el sujeto codifica los resultados a devolver y los envia devuelta al objeto NXProxy.</p>
<p>MeCullough [<a href="#mcc87" >McC87</a>] examina el uso de proxies en Smalltalk para acceder a objetos remotos. Pascoe [<a href="#pas86" >Pas86</a>] describe como proporcionar efectos laterales y control de acceso en las llamadas a metodos mediante <q>Encapsuladores</q>.</p>
</div>
<h4 id="proxy-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p><a href="#adapter" >Adapter</a>: un adaptador proporciona una interfaz diferente para el objeto que adapta. Por el contrario, un proxy tiene la misma interfaz que su sujeto. No obstante, un proxy utilizado para proteccion de acceso podria rechazar una operacion que el sujeto si realiza, de modo que su interfaz puede ser realmente un subconjunto de la del sujeto.</p>
<p><a href="#decorator" >Decorator</a>: si bien los decoradores pueden tener una implementacion parecida a los proxies, tienen un proposito diferente. Un decorador añade una o mas responsabilidades a un objeto, mientras que un proxy controla el acceso a un objeto.</p>
<p>Los proxies difieren en el grado de similitud entre su implementacion y la de un decorador. Un proxy de proteccion podria implementarse exactamente como un decorador. Por otro lado un proxy remoto no contendra una referencia directa a su sujeto real sino solo una referencia indirecta, como <q>un ID de maquina y la direccion local en dicha maquina</q>. Un proxy virtual empezara teniendo una referencia indirecta como un nombre de fichero, pero podra al final obtener y utilizar una referencia directa.</p>
</div>
<h3 id="discusion-sobre-los-patrones-estructurales" >Discusion sobre los patrones estructurales</h3>
<div class="hBody-3" >
<p>Tal vez haya notado similitudes entre los patrones estructurales, especialmente en sus participantes y colaboradores. Esto es debido a que los patrones estructurales se basan en un mismo pequeño conjunto de mecanismos del lenguaje para estructurar el codigo y los objetos: herencia simple y herencia multiple para los patrones basados en clases, y composicion de objetos para los patrones de objetos. Pero estas similitudes ocultan los diferentes propositos de estos patrones. En esta seccion se comparan y contrastan grupos de patrones estructurales para ofrecerle una vision de los meritos de cada uno de ellos.</p>
</div>
<h4 id="adapter-frente-a-bridge" >Adapter frente a Bridge</h4>
<div class="hBody-4" >
<p>Los patrones <a href="#adapter" >Adapter</a> y <a href="#bridge" >Bridge</a> tienen algunos atributos comunes. Ambos promueven la flexibilidad al proporcionar un nivel de indireccion a otro objeto. Ambos implican reenviar peticiones a este objeto desde una interfaz distinta de la suya propia.</p>
<p>La diferencia fundamental entre estos patrones radica en su proposito. El patron Adapter se centra en resolver incompatibilidades entre dos interfaces existentes. No presta atencion a como se implementan dichas interfaces, ni tiene en cuenta como podrian evolucionar de forma independiente. Es un modo de lograr que dos clases diseñadas independientemente trabajen sin tener que volver a implementar una u otra. Por otro lado, el patron Bridge une una implementacion con sus implementaciones (que pueden ser numerosas). Proporciona una interfaz estable a los clientes permitiendo, no obstante, que cambien las clases que la implementan. Tambien permite incorporar nuevas implementaciones a medida que evoluciona el sistema.</p>
<p>Como resultado de estas diferencias, los patrones Adapter y Bridge suelen usarse en diferentes puntos del ciclo de vida del software. Un adaptador suele hacerse necesario cuando se descubre que deberian trabajar juntas dos clases incompatibes, generalmente para evitar duplicar codigo, y este acoplamiento no habia sido provisto. Por el contrario, el usuario de un puente sabe de antemano que una abstraccion debe tener varias implementaciones, y que una y otras pueden variar independientemente. El patron Adapter hace que las cosas funcionen <em>despues</em> de que han sido diseñadas; el Bridge lo hace <em>antes</em>. Eso no significa que el Adapter sea en modo alguno inferior al <code>Bridge</code>; simplemente, cada patron resuelve un problema distinto.</p>
<p>Podemos ver una fachada (vease el patron <a href="#facade" >Facade</a>) como un adaptador para un conjunto de objetos. Pero esa implementacion obvia el hecho de que una fachada define una <em>nueva</em> interfaz, mientras que un adaptador reutiliza una interfaz existente. Recuerdese que un adaptador hace que trabajen juntas dos interfaces <em>existentes</em> en vez de tener que definir una completamente nueva.</p>
</div>
<h4 id="composite-frente-a-decorator-y-a-proxy" >Composite frente a Decorator y a Proxy</h4>
<div class="hBody-4" >
<p>Los patrones <a href="#composite" >Composite</a> y <a href="#decorator" >Decorator</a> tienen diagramas de estructura parecidos, lo que refleja el hecho de que ambos se basan en la composicion recursiva para organizar un numero identerminado de objetos. Esta caracteristica en comun puede tentar a pensar en un objeto decorador como un compuesto degenerado, pero eso no representa la esencia del patron Decorator. El parecido termina en la composicion recursiva, al tratarse de nuevo de propositos diferentes.</p>
<p>El patron Decorator esta diseñado para permitir añadir responsabilidades a objetos sin crear subclases. Esto evita la explosion de subclases a la que puede dar lugar al intentar cubrir cada combinacion de responsabilidades estaticamente. El patron Composite tiene un proposito diferente. Consiste en estructurar subclases para que se puedan tratar de manera uniforme muchos objetos relacionados, y que multiples objetos puedan ser tratados como uno solo. Es decir, no se centra en la decoracion sino en la representacion.</p>
<p>Estos propositos son distintos pero complementarios. Por tanto, los patrones Composite y Decorador suelen usarse conjuntamente. Ambos llevan a la clase de diseño en la que se pueden construir aplicaciones simplemente poniendo juntos objetos sin definir ninguna clase nueva. Habra una clase abstracta con algunas subclases que son compuestos, otras que son decoradores y otras que implementan los principales bloques de construccion del sistema. En este caso, tanto compuestos como decoradores tendran una interfaz comun. Desde el punto de vista del patron Decorador, un compuesto es un <code>ComponenteConcreto</code>. Desde el punto de vista del patron Composite, un decorador es una <code>Hoja</code>. Por supuesto, no tienen por que ser usados juntos, y, como hemos visto, sus propositos son bastante distintos.</p>
<p>Otro patron con una estructura similar al Decorador es el <a href="#proxy" >Proxy</a>. Ambos patrones describen como proporcionar un nivel de indireccion a un objeto, y las implementaciones de los objetos proxy y decorador mantienen una referecia a otro objeto, al cual reenvian peticiones. Una vez mas, no obstante, estan pensados para propositos diferentes.</p>
<p>Al igual que el Decorador, el patron Proxy compone un objeto y proporciona una interfaz identica a los clientes. A diferencia del Decorator, el patron Proxy no tiene que ver con asignar o quitar propiedades dinamicamente, y tampoco esta diseñado para la composicion recursiva. Su proposito es proporcionar un sustituto para un sujeto cuando no es conveniente o deseable acceder directamente a el, debido, por ejemplo, a residir en una maquina remota, tener acceso restringido o ser persintente.</p>
<p>En el patron Proxy, el sujeto define la principal funcionalidad, y el proxy proporciona (o rechaza) el acceso al mismo. En el Decorador, el componente proporciona solo parte de funcionalidad, y uno o mas decoradores hacen el resto. El patron Decorator se encarga de aquellas situaciones en las que no se puede determinar toda la funcionalidad de un objeto en tiempo de compilacion, o al menos no resulta conveniente hacerlo. Ese no es el caso del Proxy, ya que este se centra en una relacion ––entre el proxy y su sujeto–– y dicha relacion puede expresarse estaticamente.</p>
<p>Estas diferencias son significativas, ya que representan soluciones a problemas concretos y recurrentes en el diseño orientado a objetos. Pero eso no significa que estos patrones no puedan combinarse. Podriamos pensar en un proxy-decorador que añadiese funcionalidad a un proxy, o en un decorador-proxy que adornase un objeto remoto. Si bien tales hibridos <em>pueden</em> ser utiles (no tenemos ejemplos reales a mano), pueden dividirse en patrones que <em>realmente</em> son utiles.</p>
</div>
<h2 id="capitulo-5" >Patrones de Comportamiento</h2>
<div class="hBody-2" >
<p>Los patrones de comportamiento tienen que ver con algoritmos y con la asignacion de responsabilidades a objetos. Los patrones de comportamiento describen no solo patrones de clases y objetos, sino tambien patrones de comunicacion entre ellos. Estos patrones describen el flujo de control complejo que es dificil de seguir en tiempo de ejecucion, lo que nos permite olvidarnos del flujo de control para centrarnos simplemente en el modo en que se interconectan los objetos.</p>
<p>Los patrones de comportamiento basados en clases usan la herencia para distribuir el comporatamiento entre clase. Este capitulo incluye dos de estos patrones. El patron <a href="#template-method" >Template Method</a> es el mas simple y comun de los dos. Un metodo plantilla es una definicion abstracta a una operacion primitiva. Una subclase es la encargada de completar el algoritmo definiendo las operaciones abstractas. El patron de comportamiento basado en clases es el <a href="Interpreter" >Interpreter</a>, que representa una gramatica como una jerarquia de clases e implementa un interprete como una operacion sobre las instancias de dichas clases.</p>
<p>Los patrones de comportamiento basados en objetos usan la composicion de objetos en vez de la herencia. Algunos describen como cooperan un grupo de objetos parejos para realizar una tarea que ningun objeto individual puede llevar a cabo por si solo. Una cuestion importante es como los objetos saben unos de otros. Cada uno podria mantener referencias explicitas al resto, pero eso incrementaria su acoplamiento. Llevado al limite, cada objeto conoceria a todos los demas. El patron <a href="#mediator" >Mediator</a> evita esto introduciendo un objeto mediador entre todos los objetos parejos. El mediador proporciona la indireccion necesaria para un bajo acoplamiento.</p>
<p>El patron <a href="#chain-of-responsibility" >Chain of Responsibility</a> proporciona un acoplamiento aun mas bajo. Permite enviar peticiones a un objeto implicitamente, a traves de una cadena de objetos candidatos. Cualquier candidato puede satisfacer la peticion dependiendo de una serie de condiciones en tiempo de ejecucion. El numero de candidatos es indeterminado, y se puede seleccionar en tiempo de ejecucion que candidatos participan en la cadena.</p>
<p>El patron <a href="#observer" >Observer</a> define y mantiene una dependencia entre objetos. El ejemplo clasico de <a href="#observer" >Observer</a> tiene lugar en el Modelo/Vista/Controlador de Smalltalk, donde todas las vistas del modelo son avisadas cada vez que cambia el estado del mismo.</p>
<p>Otros patrones de comportamiento basados en objetos estan relacionados con la encapsulacion de comportamiento en un objeto, delegando las peticiones a dicho objeto. El patron <a href="#strategy" >Strategy</a> encapsula un algoritmo en un objeto, facilitando especificar y cambiar el algoritmo que usa un objeto. El patron <a href="#command" >Command</a> encapsula una peticion en un objeto de modo que pueda ser pasada como parametro, guardada en un historial o manipulada de alguna otra forma. El patron <a href="#state" >State</a> encapsula los estados de un objeto para que este pueda cambiar su comportamiento cuando cambia su estado. El <a href="#visitor" >Visitor</a> encapsula comportamiento que de otro modo estaria distribuido en varias clases, y el <a href="#iterator" >Iterator</a> abstrae el modo en que accede y se recorren los objetos de una agrecacion.</p>
</div>
<h3 id="chain-of-responsibility" >Chain of Responsibility</h3>
<h4 id="chain-of-responsibility-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Evita acoplar el emisor de una peticion a su receptor, dando a mas de un objeto la posibilidad de responder a la peticion. Encadena los objetos receptores y pasa la peticion a traves de la cadena hasta que es procesada por algun objeto.</p>
</div>
<h4 id="chain-of-responsibility-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Supongamos un servicio de ayuda sensible al contexto para una interfaz grafica de usuario. El usuaria puede obtener informacion de ayuda en cualquier parte de la interfaz simplemente pulsando con el raton sobre ella. La ayuda proporcionada depende de la parte de la interfaz que se haya seleccionado asi como de su contexto; por ejemplo, un boton de un cuadro de dialogo puede tener diferente informacion de ayuda que un boton similar de la ventana principal. Si no existe informacion de ayuda especifica para esa parte de la interfaz el sistema de ayuda deberia mostrar un mensaje de ayuda mas general sobre el contexto inmediato, por ejemplo, sobre el cuadro de dialogo en si.</p>
<p>De hay que sea natural organizar la informacion de ayuda de acuerdo con su generalidad ––de lo mas especifico a lo mas general––. Ademas, esta claro que una peticion de ayuda es manejada por un objeto entre varios de la interfaz de usuario; el objeto concreto depende del contexto y de la especificidad de la ayuda disponible.</p>
<p>El problema es que el objeto que en ultima instancia <em>proporciona</em> la ayuda no conoce explicitamente al objeto (por ejemplo, el boton) que <em>inicializa</em> la peticion de ayuda. Necesitamos un modo de desacoplar el boton que da lugar a la peticion de ayuda de los objetos que podrian proporcionar dicha informacion. El patron Chain of Responsibility define como hacer esto.</p>
<p>La idea de este patron es desacoplar a los emisores y a los receptores dandole a varios objetos la posibilidad de tratar una peticion. La peticion se pasa a travez de una cadena de objetos hasta que es procesada por uno de ellos.</p>
<figure>
<img src="img/083.png" />
</figure>
<p>El primer objeto de la cadena recibe la peticion y, o bien la procesa o bien la redirie al siguiente candidato en la cadena, el cual hace lo mismo. El objeto que hizo la peticion no tien un conocimiento explicito de quien la tratara ––decimos que la peticion tiene un <b>receptor implicito</b>––.</p>
<p>Supongamos que el usuario solicita ayuda sobre un boton denominado <q>Imprimir</q>. El boton se encuentra en una instancia de <code>DialogoDeImpresion</code>, que sabe a que objeto de aplicacion pertenece (vease el diagramade objetos precedente). El siguiente diagrama de interaccion ilustra como la peticion de ayuda se reenvia a travez de la cadena.</p>
<figure>
<img src="img/084.png" />
</figure>
<p>En este caso, la peticion no es procesada ni por <code>unBotonDeImpresion</code> ni por <code>unDialogoDeImpresion</code>; se detiene en <code>unaAplicacion</code>, quien puede procesarla u obviarla. El cliente que dio origen a la peticion no tiene niguna referencia directa al objeto que finalmente la satisface.</p>
<p>Para reenviar la peticion a lo largo de la cadena, y para garantizar que los receptores permanecen implicitos, cada objeto de la cadena comparte una interfaz comun para procesar peticiones y para acceder a su <b>sucesor</b> en la cadena. Por ejemplo, el sistema de ayuda podria definir una clase <code>ManejadorDeAyuda</code> con su correspondiente operacion <code>ManejarAyuda</code>. <code>ManejadorDeAyuda</code> puede ser la clase padre de las clases de objetos candidatos, o bien puede ser definida como una clase mezclable. Entonces las clases que quieran manejar peticiones de ayuda pueden hacer que <code>ManejadorDeAyuda</code> sea uno de sus padres:</p>
<figure>
<img src="img/085.png" />
</figure>
<p>Las clases <code>Boton</code>, <code>Dialogo</code> y <code>Aplicacion</code> usan las operaciones de <code>ManejadorDeAyuda</code> para tratar peticiones de ayuda. La operacion <code>ManejarAyuda</code> de <code>ManejadorDeAyuda</code> reenvia la peticion al sucesor de manera predeterminada. Las subclases pueden redefinir esta operacion para proporcionar ayuda en determinadas circunstancias; en caso contrario, pueden usar la implementacion predeterminada para reenviar la peticion.</p>
</div>
<h4 id="chain-of-responsibility-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Chain of Responsibility cuando</p>
<ul>
<li>
<p>hay mas de un objeto que pueden manejar una peticion, y el manejador no se conoce <em>a priori</em>, sino que deberia determinarse automaticamente</p>
</li>
<li>
<p>se quiere enviar una peticion a un objeto entre varios sin especificar explicitamente el receptor.</p>
</li>
<li>
<p>el conjunto de objetos que pueden tratar una peticion deberia ser especificado dinamicamente</p>
</li>
</ul>
</div>
<h4 id="chain-of-responsibility-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/086.png" />
</figure>
<p>Una estructura de objetos tipica podria parecerse a esta:</p>
<figure>
<img src="img/087.png" />
</figure>
</div>
<h4 id="chain-of-responsibility-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Manejador</code> (<code>ManejadorDeAyuda</code>)</p>
<ul>
<li>
<p>define una interfaz para tratar las peticiones.</p>
</li>
<li>
<p>(opcional) implementa el enlace al sucesor.</p>
</li>
</ul>
</li>
<li>
<p><code>ManejadorConcreto</code> (<code>BotonDeImpresion</code>, <code>DialogoDeImpresion</code>)</p>
<ul>
<li>
<p>trata las peticiones de las que es responsable.</p>
</li>
<li>
<p>puede acceder a su sucesor.</p>
</li>
<li>
<p>si el <code>ManejadorConcreto</code> puede manejar la peticion, lo hace; en caso contrario la reenvia a su sucesor.</p>
</li>
</ul>
</li>
<li>
<p><code>Cliente</code></p>
<ul>
<li>
<p>inicializa la peticion a un objeto <code>ManejadorConcreto</code> de la cadena.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="chain-of-responsibility-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p>Cuando un cliente envia una peticion, esta se propaga a traves de la cadena hasta que un objeto <code>ManejadorConcreto</code> se hace responsable de procesarla.</p>
</div>
<h4 id="chain-of-responsibility-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>Este patron tiene las siguientes ventajas e inconvenientes:</p>
<ol class="num" >
<li>
<p><em>Reduce el acoplamiento.</em> El patron libera a un objeto de tener que saber que otro objeto maneja una peticion. Un objeto solo tiene que saber que una peticion sera manejada <q>de forma apropiada</q>. Ni el receptor ni el emisor se conocen explicitamente entre ellos, y un objeto de la cadena tampoco tiene que conocer la estructura de esta.</p>
<p>Como resultado, la Cadena de Responsabilidad puede simplificar las interconecciones entre objetos. En vez de que los objetos mantengan referencias a todos los posibles receptores, solo tienen una unica referencia a su sucesor.</p>
</li>
<li>
<p><em>Añade flexibilidad para asignar responsabilidades a objetos.</em> La Cadena de Responsabilidad ofrece una flexibilidad añadida para repartir responsabilidades entre objetos. Se pueden añadir o cambiar responsabilidades para tratar una peticion modificando la cadena en tiempo de ejecucion. Esto se puede combinar con la herencia para especializar los manejadores estaticamente.</p>
</li>
<li>
<p><em>No se garantiza la recepcion.</em> Dado que las peticiones no tienen un receptor explicito, no hay garantia de que sean manejadas ––la peticion puede alcanzar el final de la cadena sin haber sido procesada––. Una peticion tambien puede quedar sin tratar cuardo la cadena no esta configurada correctamente.</p>
</li>
</ol>
</div>
<h4 id="chain-of-responsibility-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Estos son algnos detalles de implementacion a tener en cuenta sobre la Cadena de Responsabilidad:</p>
<ol class="num" >
<li>
<p><em>Implementacion de la cadena sucesora.</em> Hay dos formas posibles de implementar la cadena sucesora:</p>
<ol class="alpha" >
<li>
<p>Definir nuevos enlaces (normalmente en el <code>Manejador</code>, pero tambien podria ser en los objetos <code>ManejadorConcreto</code>).</p>
</li>
<li>
<p>Usar los enlaces existentes.</p>
</li>
</ol>
<p>Los ejemplos mostrados hasta ahora definen nuevos enlaces, pero muchas veces se pueden usar referencias a objetos existentes para formar la cadena sucesora. Por ejemplo, las referencias al padre en una jerarquia de parte-todo pueden definir el sucesor de una parte. Una estructura de utiles<span class="note" ><sup><a href="#28" >28</a></sup></span> puede que ya tenga dichos enlaces. El patron <a href="Composite" >Composite</a> describe las referencias al padre con mas detalle.</p>
<p>Usar enlaces existetes funciona bien cuando los enlaces permiter la cadena que necesitamos. Nos evita tener que definir explicitamente nuevos enlaces y ahorra espacio. Pero si la estructura no refleja la cadena de responsabilidad que necesita nuestra aplicacion habra que definir enlaces redundantes.</p>
</li>
<li>
<p><em>Conexion de los sucesores.</em> Si no hay referencias preexistentes para definir una cadena, entoces tendremos que introducirlas nosotros mismos. En ese caso, el <code>Manejador</code> no solo define la interfaz para las peticiones, sino que normalmente tambien se encarga de matener el sucesor. eso permite que el manejador proporcione una implementacion predeterminada de <code>ManejarPeticion</code> que reenvia la peticion al sucesor (si hay alguno). Si una subclase de <code>ManejadorConcreto</code> no esta interesada en dicha peticion, no tiene que redefinir la operacion de reenvio, puesto que la implementacion predeterminada la reenvia incondicionalmente.</p>
<p>A continuacion se muestra una clase base <code>ManejadorDeAyuda</code> que mantiene un enlace al sucesor:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ManejadorDeAyuda</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ManejadorDeAyuda</span><span class="p">(</span><span class="n">ManejadorDeAyuda</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">_sucesor</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ManjarAyuda</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">ManejadorDeAyuda</span><span class="o">*</span> <span class="n">_sucesor</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">ManjadorDeAyuda</span><span class="o">::</span><span class="n">ManejarAyuda</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_sucesor</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_sucesor</span><span class="o">-&gt;</span><span class="n">ManejarAyuda</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</li>
<li>
<p><em>Representacion de las peticiones.</em> Hay varias opciones para representar las peticiones. En su forma mas simple, una peticion es una invocacion a una operacion insertada en el codigo, como en el caso de <code>ManejarAyuda</code>. Esto resulta conveniente y seguro, pero entonces solo se pueden reenviar el conjunto prefijado de peticiones que define la clase <code>Manejador</code>.</p>
<p>Una alternativa es usar una unica funcion manejadora que reciba un codigo de peticion (por ejemplo, una constante entera o una cadena) como parametro. Esto permite un numero arbitrario de peticiones. El unico requisito es que el emisor y el receptor se pongan de acuerdo sobre como debe codificarse la peticion.</p>
<p>Este enfoque es mas flexible, pero requiere sentencias condicionales para despachar la peticion en funcion de su codigo. Y, lo que es peor, no hay un modo de pasar los parametros seguro con respecto al tipo, por lo que estos deben ser empaquetados y desempaquetados manualmente. Obviamente, esto es menos seguro que invocar una operacion directamente.</p>
<p>Para resolver el problema del paso de parametros, podemos usar para las peticiones <em>objetos</em> aparte que incluyan los parametros de la peticion. Una clase <code>Peticion</code> puede representar peticiones explicitamente, y se pueden definir nuevos tipos de peticiones mediante herencia. Las subclases pueden definir diferentes parametros. Los manejadores deben conocer el tipo de peticion (esto es, que subclase de <code>Peticion</code> estan usando) para acceder a estos parametros.</p>
<p>Para identificar la peticion, <code>Peticion</code> puede definir una funcion de acceso que devuelva un identificador para la clase. Por otro lado, el receptor puede usar informacion de tipos en tiempo de ejecucion en caso de que el lenguaje de implementacion lo permita.</p>
<p>A continuacion se muestra un esbozo de una funcion de despacho que usa objetos peticion para identificar las peticiones. Una operacion <code>ObtenerTipo</code> definida en la clase base <code>Peticion</code> identifica el tipo de peticion:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Manejador</span><span class="o">::</span><span class="n">ManejarPeticion</span> <span class="p">(</span><span class="n">Peticion</span><span class="o">*</span> <span class="n">laPeticion</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">laPeticion</span><span class="o">-&gt;</span><span class="n">ObjetoTipo</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">Ayuda</span><span class="p">:</span>
        <span class="c1">// convierte el argumento al tipo apropiado
</span><span class="c1"></span>        <span class="n">ManejarAyuda</span><span class="p">((</span><span class="n">PeticionDeAyuda</span><span class="o">*</span><span class="p">)</span> <span class="n">laPeticion</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">Impresion</span><span class="p">:</span>
        <span class="n">ManejarImpresion</span><span class="p">((</span><span class="n">PeticionDeImpresion</span><span class="o">*</span><span class="p">)</span> <span class="n">laPeticion</span><span class="p">);</span>
        <span class="c1">// ...
</span><span class="c1"></span>        <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="c1">// ...
</span><span class="c1"></span>        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Las subclases pueden extender el despacho redefiniendo <code>ManejarPeticion</code>. La subclase maneja solo aquellas peticiones en las que esta interesada; otras peticiones son reenviadas a la clase padre. De esta forma, las subclases efectivamente extienden (en vez de redefinir) la operacion <code>ManejarPeticion</code>. Por ejemplo, asi es como una subclase <code>ManejadorExtendido</code> extiende la version de <code>ManejarPeticion</code> de <code>Manejador</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ManejadorExtendido</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Manejador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ManejarPeticion</span><span class="p">(</span><span class="n">Peticion</span><span class="o">*</span> <span class="n">laPeticion</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>

<span class="kt">void</span> <span class="n">ManejadorExtendido</span><span class="o">::</span><span class="n">ManejarPeticion</span> <span class="p">(</span><span class="n">Peticion</span><span class="o">*</span> <span class="n">laPeticion</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">laPeticion</span><span class="o">-&gt;</span><span class="n">ObtenerTipo</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">VistaPreliminar</span><span class="p">:</span>
        <span class="c1">// trata la operacion VistaPreliminar
</span><span class="c1"></span>        <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="c1">// permite que Manejador trate otras peticiones
</span><span class="c1"></span>        <span class="n">Manejador</span><span class="o">::</span><span class="n">ManejarPeticion</span><span class="p">(</span><span class="n">laPeticion</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</li>
<li>
<p><em>Reenvio automatico en Smalltalk.</em> Podemos usar el mecanismo de Smalltalk <code>doesNotUnderstand</code> para reenviar peticiones. Los mensajes que no tienen su metodo correspondiente son atrapados en la implementacion de <code>doesNotUnderstand</code>, que puede ser redefinida para reenviar el mensaje a un sucesor del objeto. De esa manera no es necesario implementar manualmente el reenvio; la clase maneja solo la peticion en la que esta interesada, y deja a <code>doesNotUnderstand</code> el reenvio de todas las demas.</p>
</li>
</ol>
</div>
<h4 id="chain-of-responsibility-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>El siguiente ejemplo ilustra como una cadena de responsabilidad puede manejar peticiones para un sistema de ayuda en linea como el descrito anteriormente. La peticion de ayuda es una operacion explicita. Usaremos las referencias al padre existentes en la jerarquia de utiles para propagar peticiones extre utiles de la cadena, y definiremos una referencia en la clase <code>Manejador</code> para propagar las peticiones de ayuda entre los elementos de la cadena que no sean utiles.</p>
<p>La clase <code>ManejadorDeAyuda</code> define la interfaz para manejar peticiones de ayuda. Mantiene un tema de ayuda (que, de manera predeterminada, siempre esta vacio) y guarda una referencia a su sucesor en la cadena de manejadores de ayuda. La operacion principal es <code>ManejarAyuda</code>, la cual es redefinida por las subclase. <code>TieneAyuda</code> es una operacion de conveniencia para comprobar si existe un tema de ayuda asociado.</p>
<pre class="code" ><code class="chroma" ><span class="k">typedef</span> <span class="kt">int</span> <span class="n">Tema</span><span class="p">;</span>
<span class="k">const</span> <span class="n">Tema</span> <span class="n">SIN_TEMA_DE_AYUDA</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ManejadorDeAyuda</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ManejadorDeAyuda</span><span class="p">(</span><span class="n">ManejadorDeAyuda</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Tema</span> <span class="o">=</span> <span class="n">SIN_TEMA_DE_AYUDA</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">TieneAyuda</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EstablecerManejador</span><span class="p">(</span><span class="n">ManejadorDeAyuda</span><span class="o">*</span><span class="p">,</span> <span class="n">Tema</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ManejarAyuda</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">ManejadorDeAyuda</span><span class="o">*</span> <span class="n">_sucesor</span><span class="p">;</span>
    <span class="n">Tema</span> <span class="n">_tema</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">ManejadorDeAyuda</span><span class="o">::</span><span class="n">ManejadorDeAyuda</span> <span class="p">(</span>
    <span class="n">ManejadorDeAyuda</span><span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">Tema</span> <span class="n">t</span>
<span class="p">)</span> <span class="o">:</span> <span class="n">_sucesor</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">_tema</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">bool</span> <span class="n">ManejadorDeAyuda</span><span class="o">::</span><span class="n">TieneAyuda</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_tema</span> <span class="o">!=</span> <span class="n">SIN_TEMA_DE_AYUDA</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ManejadorDeAyuda</span><span class="o">::</span><span class="n">ManejarAyuda</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_sucesor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_sucesor</span><span class="o">-&gt;</span><span class="n">ManejarAyuda</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Todos los utiles son subclases de la clase abstracta <code>Util.Util</code> es una subclase de <code>ManejadorDeAyuda</code>, ya que todos los elementos de la interfaz de usuario pueden tener ayuda asociada a ellos (tambien podriamos haber usado una implementacion basada en una clase mezclable).</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Util</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ManejadorDeAyuda</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Util</span><span class="p">(</span><span class="n">Util</span><span class="o">*</span> <span class="n">padre</span><span class="p">,</span> <span class="n">Tema</span> <span class="n">t</span> <span class="o">=</span> <span class="n">SIN_TEMA_DE_AYUDA</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Util</span><span class="o">*</span> <span class="n">_padre</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Util</span><span class="o">::</span><span class="n">Util</span> <span class="p">(</span><span class="n">Util</span><span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="n">Tema</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">ManejadorDeAyuda</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_padre</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>En nuestro ejemplo de boton es el primer manejador de la cadena. La clase <code>Boton</code> es una subclase de <code>Util</code>. El constructor de <code>Boton</code> toma dos parametros: una referencia al util que lo contiene y el tema de ayuda.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Boton</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Util</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Boton</span><span class="p">(</span><span class="n">Util</span><span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">Tema</span> <span class="n">t</span> <span class="o">=</span> <span class="n">SIN_TEMA_DE_AYUDA</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ManejarAyuda</span><span class="p">();</span>
    <span class="c1">// Las operaciones de Util redefinidas por Boton...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>La version de <code>ManejarAyuda</code> de <code>Boton</code> en primer lugar comprueba si hay un tema de ayuda para los botones. Si el desarrollador no ha definido ninguno, entonces la peticion es reenviada al sucesor usando la operacion <code>ManejarAyuda</code> de <code>ManejadorDeAyuda</code>. Si <em>hay</em> un tema de ayuda el boton muestra y termina la busqueda.</p>
<pre class="code" ><code class="chroma" ><span class="n">Boton</span><span class="o">::</span><span class="n">Boton</span> <span class="p">(</span><span class="n">Util</span><span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="n">Tema</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">Util</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">Boton</span><span class="o">::</span><span class="n">ManejarAyuda</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TieneAyuda</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// ofrecer ayuda sobre el boton
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">ManejadorDeAyuda</span><span class="o">::</span><span class="n">ManejarAyuda</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><code>Dialogo</code> implementa un esquema similar, salvo que su sucesor no es un util, sino <em>cualquier</em> manejado de ayuda. En nuestra aplicacion este sucesor sera una instancia de <code>Aplicacion</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Dialogo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Util</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Dialogo</span><span class="p">(</span><span class="n">ManejadorDeAyuda</span><span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">Tema</span> <span class="n">t</span> <span class="o">=</span> <span class="n">SIN_TEMA_DE_AYUDA</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ManejarAyuda</span><span class="p">();</span>

    <span class="c1">// las operaciones de Util redefinidas por Dialogo...
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Dialogo</span><span class="o">::</span><span class="n">Dialogo</span> <span class="p">(</span><span class="n">ManejadorDeAyuda</span><span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">Tema</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">Util</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">EstablecerManejador</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Dialogo</span><span class="o">::</span><span class="n">ManejadorAyuda</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TieneAyuda</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// ofrecer ayuda sobre el dialogo
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">ManejadorDeAyuda</span><span class="o">::</span><span class="n">ManejarAyuda</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Al final de la cadena hay una instancia de <code>Aplicacion</code>. La aplicacion no es un util, por lo que <code>Aplicacion</code> hereda directamente de <code>ManejadorDeAyuda</code>. Cuando una peticion de ayuda se propaga hasta este nivel, la aplicacion puede proporcionar informacion sobre la aplicacion en general, o puede ofrecer una lista con los distintos temas de ayuda:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Aplicacion</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ManejadorDeAyuda</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Aplicacion</span><span class="p">(</span><span class="n">Tema</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">ManejadorDeAyuda</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ManejarAyuda</span><span class="p">();</span>
    <span class="c1">// operaciones especificas de la aplicacion...
</span><span class="c1"></span><span class="p">};</span>

<span class="kt">void</span> <span class="n">Aplicacion</span><span class="o">::</span><span class="n">ManejarAyuda</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// muestra una lista de temas de ayuda
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>El siguiente codigo crea estos objetos y los conecta. En este caso el dialogo es sobre la impresion, y por tanto los objetos tienen asignados temas relacionados con la impresion.</p>
<pre class="code" ><code class="chroma" ><span class="k">const</span> <span class="n">Tema</span> <span class="n">TEMA_IMPRESION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="n">Tema</span> <span class="n">TEMA_ORIENTACION_PAPEL</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="n">Tema</span> <span class="n">TEMA_APLICACION</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="n">Aplicacion</span><span class="o">*</span> <span class="n">aplicacion</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Aplicacion</span><span class="p">(</span><span class="n">TEMA_APLICACION</span><span class="p">);</span>
<span class="n">Dialogo</span><span class="o">*</span> <span class="n">dialogo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dialogo</span><span class="p">(</span><span class="n">aplicacion</span><span class="p">,</span> <span class="n">TEMA_IMPRESION</span><span class="p">);</span>
<span class="n">Boton</span><span class="o">*</span> <span class="n">boton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Boton</span><span class="p">(</span><span class="n">dialogo</span><span class="p">,</span> <span class="n">TEMA_ORIENTACION_PAPEL</span><span class="p">);</span>
</code></pre>
<p>Podemos invocar a la peticion de ayuda llamando a <code>ManejarAyuda</code> en cualquier objeto de la cadena. Para comenzar la busqueda en el objeto <code>boton</code> basta con llamar a <code>ManejarAyuda</code> sobre el:</p>
<pre class="code" ><code class="chroma" ><span class="n">boton</span><span class="o">-&gt;</span><span class="n">ManejarAyuda</span><span class="p">();</span>
</code></pre>
<p>En este caso, el boton manejara la peticion inmediatamente. Notese que cualquier clase <code>ManejadorDeAyuda</code> podria ser el sucesor de <code>Dialogo</code>. Mas aun, podria cambiarse dinamicamente su sucesor. De modo que no importa donde se use un dialogo, siempre se obtendra la informacion de ayuda dependiente del contexto apropiada para el.</p>
</div>
<h4 id="chain-of-responsibility-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Varias bibliotecas de clases usan el patron Chain of Responsibility para manejar los eventos de usuario. Aunque usan distintos nombres para la clase <code>Manejador</code>, la idea es la misma: cuando el usuario hace clic con el raton o pulsa una tecla, se genera un evento y se pasa a lo largo de la cadena. MacApp [<a href="#app89" >App89</a>] y ET++ [<a href="#wgm88" >WGM88</a>] lo llaman <q><code>EventHandler</code></q> (manejador de eventos) la biblioteca TCL de Symantec [<a href="#sym93b" >Sym93b</a>] lo llama <q><code>Bureaucrat</code></q> (burocrata) y AppKit de NeXT [<a href="#add94" >Add94</a>] usa el nombre <q><code>Responder</code></q> (respondedor).</p>
<p>El framework de editores graficos Unidraw define objetos <code>Command</code> que encapsulan peticiones a los objetos <code>Component</code> y <code>ComponentView</code> [<a href="#vl90" >VL90</a>]. Las ordenes son peticiones en el sentido de que un componente o una vista de un componente pueden interpretar una orden para realizar una operacion. Esto se corresponde con el enfoque de <q>peticiones como objetos</q> descrito en la seccion de Implementacion. Los componentes y las vistas de componentes se pueden estructurar jerarquicamente. Un componente o una vista de componente pueden reenviar interpretaciones de ordenes a su padre, quien a su vez puede reenviarlas a su padre y asi sucesivamente, formando asi una cadena de responsabilidad.</p>
<p>ET++ usa una Cadena de Responsabilidad para tratar la actualizacion de graficos. Un objeto <code>grafico</code> llama a la operacion <code>InvalidateRect</code> cada vez que debe actualizarse una parte de su represantacion. Un objeto grafico no puede manejar <code>InvalidateRect</code> el mismo, ya que no sabe lo suficiente sobre su contexto. Por ejemplo, un objeto grafico puede formar parte de objetos como barras de desplazamiento o <em>zooms</em> que transforman su sistema de coordenadas. Eso significa que podemos desplazarnos o hacer <em>zoom</em> sobre el objeto, de manera que este quede parcialmente oculto. Por tanto la implementacion predeterminada de <code>InvalidateRect</code> reenvia la peticion al objeto contenedor. El ultimo objeto de la cadena de reenvio es una instancia de <code>Window</code>. En el momento en que <code>Window</code> recibe la peticion, se garantiza que el rectangulo de invalidacion se transforma correctamente. El objeto <code>Window</code> trata <code>InvalidateRect</code> notificando a la interfaz del sistema de ventanas y solicitando actualizarse.</p>
</div>
<h4 id="chain-of-responsibility-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>Este patron se suele aplicar conjuntamente con el patron <a href="#composite" >Composite</a>. En el, los padres de los componentes pueden actuar como sucesores.</p>
</div>
<h3 id="command" >Command</h3>
<h4 id="command-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Encapsula una peticion en un objeto, permitiendo asi parametrizar a los clientes con diferentes peticiones, hacer cola o llevar un registro de las peticiones, y poder deshacer las operaciones.</p>
</div>
<h4 id="command-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Action (Accion), Transaction (Transaccion)</p>
</div>
<h4 id="command-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>A veces es necesario enviar peticiones a objetos sin saber nada acerca de la operacion solicitada o de quien es el receptor de la peticion. Por ejemplo, los toolkits de interfaces de usuario incluyen objetos como botones y menus que realizan una peticion en ruespuesta a una entrada de usuario. Pero el toolkit no puede implementar la peticion explicitamente en el boton o el menu, ya que solo las aplicaciones que usan el toolkit saben que deberia hacerse y sobre que objeto. Como diseñadores de toolkits no tenemos modo de conocer al receptor de la peticion ni de saber que operaciones se efectuaran.</p>
<p>El patron Command permite que los objetos del toolkit hagan peticiones a objetos de la aplicacion no especificados, convirtiendo a la propia peticion en un objeto, el cual se puede guardar y enviar exactamente igual que cualquier otro objeto. La clave de este patron es una clase abstracta <code>Orden</code>, que declara una interfaz para ejecutar operaciones. En su forma mas simple, esta interfaz incluye una operacion abstracta <code>Ejecutar</code>. Las subclases concretas de <code>Orden</code> especifican un par receptor-accion, guardando el receptor como una variable de instancia e implementando <code>Ejecutar</code> para que invoque a la peticion. El receptor posee el conocimiento necesario para llevar a cabo la peticion.</p>
<figure>
<img src="img/088.png" />
</figure>
<p>Los menus se pueden implementar facilmente con objetos <code>Orden</code>. Cada opcion de un <code>Menu</code> es una instancia de una clase <code>ElementoDeMenu</code>. La clase <code>Aplicacion</code> es la encargada de crea estos menus y sus elementos de menu junto con el resto de la interfaz de usuario. Tambien es esta clase quien sabe que objetos <code>Documento</code> han sido abiertos por un usuario.</p>
<p>La aplicacion configura cada <code>ElementoDeMenu</code> con una instancia de una subclase concreta de <code>Orden</code>. Cuando el usuario selecciona un <code>ElementoDeMenu</code>, este llama al metodo <code>Ejecutar</code> de su orden, quien lleva a cabo la operacion. Los objetos <code>ElementoDeMenu</code> no saben que subclase de <code>Orden</code> usan. Las subclases de <code>Orden</code> almacenan el receptor de la peticion e invocan sobre el una o mas operaciones.</p>
<p>Por ejemplo, <code>OrdenPegar</code> permite pegar texto del portapapeles en un <code>Documento</code>. El receptor de <code>OrdenPegar</code> es el objeto <code>Documento</code> proporcionado cuando se crea una instancia de aquella. La operacion <code>Ejecutar</code> llama a <code>Pegar</code> sobre el <code>Documento</code> receptor.</p>
<figure>
<img src="img/089.png" />
</figure>
<p>La operacion <code>Ejecutar</code> de <code>OrdenAbrir</code> es diferente: le pregunta al usuario el nombre de un documento, crea el correspondiente objeto <code>Documento</code>, lo añade a la aplicacion receptora y abre el documento.</p>
<figure>
<img src="img/090.png" />
</figure>
<p>A veces un <code>ElementoDeMenu</code> necesita ejecutar una <em>secuencia</em> de ordenes. Por ejemplo, podria construirse un <code>ElementoDeMenu</code> para centrar una pagina a tamaño normal a partir de un objeto <code>OrdenCentrarDocumento</code> y de otro objeto <code>OrdenTamanoNormal</code>. Dado que es habitual concatenar ordenes de este modo, podemos definir una clase <code>OrdenMacro</code> para permitir que un <code>ElementoDeMenu</code> ejecute un numero indefinido de ordenes. <code>OrdenMacro</code> es una subclase concreta de <code>Orden</code> que simplemente ejecuta una secuencia de ordenes. <code>OrdenMacro</code> no tiene ningun receptor explicito, sino que son las ordenes que contiene las que definen su propio receptor.</p>
<figure>
<img src="img/091.png" />
</figure>
<p>Notese como, en cada uno de los ejemplos anteriores, el patron <code>Orden</code> desacopla el objeto que invoca la operacion de aquel que posee el conocimiento para realizarla. Esto nos da mucha flexibilidad para diseñar nuestra interfaz de usuario. Una aplicacion puede proporcionar un menu y un boton como interfaces para una misma funcion simplemente haciendo que ambos compartan una instancia de la misma subclase concreta de <code>Orden</code>. Podemos reemplazar ordenes dinamicamente, lo que sera util para implementar menus sencibles al contexto. Tambien podemos permitir la creacion de ondenes mediante la composicion de unas ordenes en otras mas grandes. Todo esto es posible debido a que el objeto que emite la peticion solo necesita saber como enviarla; no necesita saber como se ejecutara la peticion.</p>
</div>
<h4 id="command-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Command cuando se quiera</p>
<ul>
<li>
<p>parametrizar objetos con una accion a realizar, como ocurriria con los objetos <code>ElementoDeMenu</code> anteriores. En un lenguaje de procedimiento se puede expresar dicha parametrizacion con una funcion <b>callback</b>, es decir, con una funcion que esta registrada en algun sitio para que sea llamada mas tarde. Los objetos <code>Orden</code> son un sustituto orentado a objetos para las funciones callback.</p>
</li>
<li>
<p>especificar, poner en cola y ejecutar peticiones en diferentes instantes de tiempo. Un objeto <code>Orden</code> puede tener un tiempo de vida independiente de la peticion original. Si se puede representar el receptor de una peticion en una forma independiente del espacio de direcciones, entonces se puede transferir un objeto <code>Orden</code> con la peticion a un proceso diferente y llevar a cabo la peticion alli.</p>
</li>
<li>
<p>permitir deshacer. La operacion <code>Ejecutar</code> de <code>Orden</code> puede guardar en la propia orden el estado que anule sus efectos. Debe añadirse a la interfaz <code>Orden</code> una operacion <code>Deshacer</code> que anule los efectos de una llamada anterior a <code>Ejecutar</code>. Las ordenes ejecutadas se guarda en una lista  que hace las veces de historial. Se pueden lograr niveles ilimitados de deshacer y repetir recorriendo dicha lista hacia atras y hacia delante llamando respectivamente a <code>Deshacer</code> y <code>Ejecutar</code>.</p>
</li>
<li>
<p>permitir registrar los cambios de manera que se puedan volver a aplicar en caso de una caida del sistema. Aumentando la interfaz de <code>Orden</code> con operaciones para cargar y guardar se puede mantener un registro persistente de los cambios. Recuperarse de una caida implica volver a cargar desde el disco las ordenes guardadas y volver a ejecutarlas con la operacion <code>Ejecutar</code>.</p>
</li>
<li>
<p>entructurar un sistema alrededor de operaciones de alto nivel construidas sobre operaciones basicas. Dicha estructura es comun en los sistemas de informacion que permiten <b>transacciones</b>. Una transaccion encapsula un conjunto de cambios sobre unos datos. El patron Command ofrece un modo de modelar transacciones. Las ordenes tienen una interfaz comun, permitiendo asi invocar a todas las transacciones del mismo modo. El patron tambien facilita extender el sistema con nuevas transacciones.</p>
</li>
</ul>
</div>
<h4 id="command-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/092.png" />
</figure>
</div>
<h4 id="command-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Orden</code></p>
<ul>
<li>
<p>declara una interfaz para ejecutar una operacion.</p>
</li>
</ul>
</li>
<li>
<p><code>OrdenConcreta</code> (<code>OrdenPegar</code>, <code>OrdenAbrir</code>)</p>
<ul>
<li>
<p>define un enlace entre un objeto <code>Receptor</code> y una accion</p>
</li>
<li>
<p>implementa <code>Ejecutar</code> invocando la correspondiente operacion u operaciones del <code>Receptor</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>Cliente</code> (<code>Aplicacion</code>)</p>
<ul>
<li>
<p>crea un objeto <code>OrdenConcreta</code> y establece su receptor.</p>
</li>
</ul>
</li>
<li>
<p><code>Invocador</code> (<code>ElementoDeMenu</code>)</p>
<ul>
<li>
<p>le pide a la orden que ejecute la peticion.</p>
</li>
</ul>
</li>
<li>
<p><code>Receptor</code> (<code>Documento</code>, <code>Aplicacion</code>)</p>
<ul>
<li>
<p>sabe como llevar a cabo las operaciones asociadas a una peticion. Cualquier clase puede hacer actuar como <code>Receptor</code>.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="command-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p>El cliente crea un objeto <code>OrdenConcreta</code> y especifica su receptor.</p>
</li>
<li>
<p>Un objeto <code>Invocador</code> almacena el objeto <code>OrdenConcreta</code>.</p>
</li>
<li>
<p>El invocador envia una peticion llamando a <code>Ejecutar</code> sobre la orden. Cuando las ordenes se puede deshacer, <code>OrdenConcreta</code> guarda el estado para deshacer la orden antes de llamar a <code>Ejecutar</code>.</p>
</li>
<li>
<p>El objeto <code>OrdenConcreta</code> invoca operaciones de su receptor para llevara a cabo la peticion.</p>
</li>
</ul>
<p>El siguiente diagrama muestra las interacciones entre estos objetos, ilustrando como <code>Orden</code> desacopla el invocador del receptor (y de la peticion que esta lleve a cabo).</p>
<figure>
<img src="img/093.png" />
</figure>
</div>
<h4 id="command-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron Command tiene las siguientes consecuencias:</p>
<ol class="num" >
<li>
<p>Orden desacopla el objeto que invoca la operacion de aquel que sabe como realizarla.</p>
</li>
<li>
<p>Las ordenes son objetos de primera clase. Pueden ser manipulados y extendidos como cualquier otro objeto.</p>
</li>
<li>
<p>Se pueden esamblar ordenes en una orden compuesta. Un ejemplo lo constituye la clase <code>OrdenMacro</code> que se describio antes. En general, las ordenes compuestas son una instacia del patron <a href="Composite" >Composite</a>.</p>
</li>
<li>
<p>Es facil añadir nuevas ordenes, ya que no hay que cambiar las clases existentes.</p>
</li>
</ol>
</div>
<h4 id="command-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>A la hora de implementar el patron Command deben tenerse en cuenta las siguientes condiciones:</p>
<ol class="num" >
<li>
<p><em>¿Como deberia ser de inteligente una orden?</em> Una orden puede tener un amplio conjunto de habilidades. Por un lado, simplemente define un enlace entre un receptor y las acciones que lleva a cabo la peticion. Por el otro, lo implementa todo ella misma sin delegar para nada en el receptor. Este ultimo extremo resulta util cuando queremos definir ordenes que sean idenpendientes de las clases existentes, cuando no existe ningun receptor adecuado o cuando una orden conoce implicitamente a su receptor. Por ejemplo, una orden que crea otra ventana de aplicacion puede ser tan capaz de crear la ventana como cualquier otro objeto. En algun punto entre estos dos extremo se encuentran las ordenes que tienen el conocimiento suficiente para encontrar dinamicamente sus receptores.</p>
</li>
<li>
<p><em>Permitir deshacer y repetir.</em> Las ordenes pueden permitir capacidades de deshacer y repetir si proveen un modo de revertir su ejecucion (por ejemplo, mediante una operacion <code>Deshacer</code>). Una clase <code>OrdenConcreta</code> podria necesitar almacenar informacion de estado adicional para hacer esto. Este estado puede incluir</p>
<ul>
<li>
<p>el objeto <code>Receptor</code>, el cual es quien realmente realiza las operaciones en respuesta a la peticion;</p>
</li>
<li>
<p>los argumentos de la operacion llevada a cabo por el receptor; y</p>
</li>
<li>
<p>cualquier valor original del receptor que pueda cambiar como resultado de manejar la peticion. El receptor debe proporcionar operaciones que permitan a la orden devolver el receptor a su estado anterior.</p>
</li>
</ul>
<p>Para permitir un nivel de deshacer, una aplicacion solo necesita guardar la ultima orden que se ejecuto. Para multiples niveles de deshacer y repetir, la aplicacion necesita un historial de las ordenes que han sido ejecutadas, donde la maxima longitud de la lista determina el numero de niveles de deshacer/repetir. El historial guarda secuencias de ordenes que han sido ejecutadas. Recorrer la lista hacia atras deshaciendo las ordenes cancela sus efectos, recorrerla hacia delante ejecutando las ordenes los repite.</p>
<p>Una orden anulable puede que deba ser copiada antes de que se guarde en el historial. Eso es debido a que el objeto orden que llevo a cabo la peticion original desde, supongamos, un <code>ElementoDeMenu</code>, mas tarde ejecutara otras peticiones. La copia es necesaria para distinguir entre diferentes invocaciones de la misma orden si su estado puede variar entre invocaciones sucesivas.</p>
<p>Por ejemplo, una <code>OrdenBorrar</code> que borra los objetos seleccionados debe guardar diferentes conjuntos de objetos cada vez que se ejecuta. Por tanto el objeto <code>OrdenBorrar</code> debera ser copiado despues de su ejecucion y esta copia almacenada en el historial. En caso de que el estado de la orden no cambie tras su ejecucion y esta copia almacenada en el historial. En caso de que el estado de la orden no cambie tras su ejecucion no es necesario realizar la copia, basta con guardar en el historial una referencia a la orden. Las ordenes que deben ser copiadas antes de ser guardadas en el historial funcionan como prototipos (vease el patron <a href="#prototype" >Prototype</a>).</p>
</li>
<li>
<p><em>Evitar la acumulacion de errores en el proceso de deshacer.</em> La histeresis puede ser un problema a la hora de garantizar un mecanismo de deshacer/repetir fiable, que preserve la semantica. Los errores se pueden acumular a medida que se ejecutan y deshacen las ordenes repetidamente, de marera que el estado de una aplicacion finalmente difiera de sus valores originales. Por tanto, puede ser necesario guardar mas informacion con la orden para asegurar que los objetos son devueltos a su estado original. Puede aplicarse el patron <a href="#memento" >Memento</a> para dar a la orden acceso a esta informacion sin exponer las interioridades de otros objetos.</p>
</li>
<li>
<p><em>Uso de plantillas de C++.</em> Para aquellas ordenes que (1) no se pueden deshacer y (2) no necesitan argumentos, podemos usar plantillas de C++ para evitar crear una subclase de <code>Orden</code> para cada clase de accion y receptor. Mostraremos como hacer esto en la seccion de Codigo de Ejemplo.</p>
</li>
</ol>
</div>
<h4 id="command-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>El codigo de C++ que se muestra aqui es un esbozo de las clases <code>Orden</code> que se comentaron en la seccion de Motivacion. Definiremos las clases <code>OrdenAbrir</code>, <code>OrdenPegar</code> y <code>OrdenMacro</code>. Veamos en primer lugar la clase abstracta <code>Orden</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Orden</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Orden</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Ejecutar</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Orden</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p><code>OrdenAbrir</code> abre un documento cuyo nombre es proporcionado por el usuario. Es necesario pasarle un objeto <code>Aplicacion</code> en su constructor. <code>PreguntarAlUsuario</code> es una rutina de implementacion que le pide al usuario el nombre del documento a abrir.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">OrdenAbrir</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Orden</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">OrdenAbrir</span><span class="p">(</span><span class="n">Aplicacion</span><span class="o">*</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Ejecutar</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">PreguntarAlUsuario</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Aplicacion</span><span class="o">*</span> <span class="n">_aplicacion</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">_respuenta</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">OrdenAbrir</span><span class="o">::</span><span class="n">OrdenAbrir</span> <span class="p">(</span><span class="n">Aplicacion</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_aplicacion</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">OrdenAbrir</span><span class="o">::</span><span class="n">Ejecutar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombre</span> <span class="o">=</span> <span class="n">PreguntarAlUsuario</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nombre</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Documento</span><span class="o">*</span> <span class="n">documento</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Documento</span><span class="p">(</span><span class="n">nombre</span><span class="p">);</span>
        <span class="n">_aplicacion</span><span class="o">-&gt;</span><span class="n">Añadir</span><span class="p">(</span><span class="n">documento</span><span class="p">);</span>
        <span class="n">documento</span><span class="o">-&gt;</span><span class="n">Abrir</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>A <code>OrdenPegar</code> es necesario pasarle un objeto <code>Documento</code> como su receptor. El receptor se pasa como parametro en el constructor de <code>OnderPegar</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">OrdenPegar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Orden</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">OrdenPegar</span><span class="p">(</span><span class="n">Documento</span><span class="o">*</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Ejecutar</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Documento</span><span class="o">*</span> <span class="n">_documento</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">OrdenPegar</span><span class="o">::</span><span class="n">OrdenPegar</span> <span class="p">(</span><span class="n">Documento</span><span class="o">*</span> <span class="n">doc</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_documento</span> <span class="o">=</span> <span class="n">doc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">OrdenPegar</span><span class="o">::</span><span class="n">Ejecutar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_documento</span><span class="o">-&gt;</span><span class="n">Pegar</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Para ordenes simples que no se pueden deshacer y que no necesitan argumentos podemos usar una clase plantilla para parametrizar el receptor de la orden. Definiremos una subclase plantilla <code>OrdenSimple</code> para dichas ordenes. <code>ordenSimple</code> es parametrizada con el tipo del <code>Receptor</code> y mantiene un enlace entre un objeto receptor y una accion almacenada como un puntero a una funcion miembro.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Receptor</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OrdenSimple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Orden</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">Receptor</span><span class="o">::*</span> <span class="n">Accion</span><span class="p">)();</span>

    <span class="n">OrdenSimple</span><span class="p">(</span><span class="n">Receptor</span><span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="n">Accion</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span>
      <span class="n">_receptor</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">_accion</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Ejecutar</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Accion</span> <span class="n">_accion</span><span class="p">;</span>
    <span class="n">Receptor</span><span class="o">*</span> <span class="n">_receptor</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>El constructor almacena el receptor y la accion las correspondientes variables de instancia. <code>Ejecutar</code> simplemente aplica la accion al receptor.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Receptor</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">OrdenSimple</span><span class="o">&lt;</span><span class="n">Receptor</span><span class="o">&gt;::</span><span class="n">Ejecutar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">_receptor</span><span class="o">-&gt;*</span><span class="n">_accion</span><span class="p">)();</span>
<span class="p">}</span>
</code></pre>
<p>Para crear una orden que llame a <code>Accion</code> sobre una instancia de la clase <code>MiClase</code>, basta con que el cliente escriba</p>
<pre class="code" ><code class="chroma" ><span class="n">MiClase</span><span class="o">*</span> <span class="n">receptor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MiClase</span><span class="p">;</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="n">Orden</span><span class="o">*</span> <span class="n">unaOrden</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">OrdenSimple</span><span class="o">&lt;</span><span class="n">MiClase</span><span class="o">&gt;</span><span class="p">(</span><span class="n">receptor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MiClase</span><span class="o">::</span><span class="n">Accion</span><span class="p">);</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="n">unaOrden</span><span class="o">-&gt;</span><span class="n">Ejecutar</span><span class="p">();</span>
</code></pre>
<p>Hay que tener en cuenta que esta solucion solo sirve para ordenes simples. Otras ordenes mas complejas que no solo deban tratar con sus receptores sino tambien con argumentos y con informacion de estado para deshacer, necesitan una subclase de <code>Orden</code>.</p>
<p>Una <code>OrdenMacro</code> gestiona una secuencia de ordenes y proporciona operaciones para añadir y eliminar subordenes. No se necesita un receptor explicito, ya que las subordenes ya definen su receptor.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">OrdenMacro</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Orden</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">OrdenMacro</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">OrdenMacro</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Anadir</span><span class="p">(</span><span class="n">Orden</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Eliminar</span><span class="p">(</span><span class="n">Orden</span><span class="o">*</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Ejecutar</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Lista</span><span class="o">&lt;</span><span class="n">Orden</span><span class="o">*&gt;*</span> <span class="n">_ordenes</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>Lo fundamental de <code>OrdenMacro</code> es su funcion miembro <code>Ejecutar</code>. Esta recorre todas las subordenes y llama a <code>Ejecutar</code> sobre cada una de ellas.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">OrdenMacro</span><span class="o">::</span><span class="n">Ejecutar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">IteratorLista</span><span class="o">&lt;</span><span class="n">Orden</span><span class="o">*&gt;</span> <span class="n">i</span><span class="p">(</span><span class="n">_ordenes</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">Primero</span><span class="p">();</span> <span class="o">!</span><span class="n">i</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">Orden</span><span class="o">*</span> <span class="n">o</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">();</span>
        <span class="n">o</span><span class="o">-&gt;</span><span class="n">Ejecutar</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Notese que si <code>OrdenMacro</code> debe implementar una operacion <code>Deshacer</code>, entoces sus subordenes deben deshacerse en orden <em>inverso</em> con respecto a la implementacion de <code>Ejecutar.</code></p>
<p>Por ultimo, <code>OrdenMacro</code> debe proporcionar operaciones para gestionar sus subordenes. <code>OrdenMacro</code> es tambien responsable de borrar sus subordenes.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">OrdenMacro</span><span class="o">::</span><span class="n">Anadir</span> <span class="p">(</span><span class="n">Orden</span><span class="o">*</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_ordenes</span><span class="o">-&gt;</span><span class="n">Insertar</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">OrdenMacro</span><span class="o">::</span><span class="n">Eliminar</span> <span class="p">(</span><span class="n">Orden</span><span class="o">*</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_ordenes</span><span class="o">-&gt;</span><span class="n">Eliminar</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<h4 id="command-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Tal vez el primer ejemplo de patron Command sea el que aparecio en un articulo de Lieberman [<a href="#lie85" >Lie85</a>]. MacApp [<a href="#app89" >App89</a>] popularizo la nocion de ordenes para implementar operaciones que podian deshacerse. ET++ [<a href="#wgm88" >WGM88</a>], IterViews [<a href="#lci+92" >LCI+92</a>] y Unidraw [<a href="#vl90" >VL90</a>] tambien definen clases que siguen el patron Command. InwerViews define una clase abstracta <code>Action</code> que proporciona la funcionalidad de una orden. Tambien define una plantilla <code>ActionCallback</code>, parametrizada con un metodo de accion, que puede crear instancias de subclases de ordenes automaticamente.</p>
<p>La biblioteca de clases THINK [<a href="#sym93b" >Sym93b</a>] tambien usa ordenes para permitir acciones que se pueden deshacer. Las ordenes en THINK se denominan <q>Tasks</q> (tareas). Los objetos tarea se pasan a una <a href="#Chain-of-Responsibility" >Cadena de Responsabilidad</a>, donde son consumidos.</p>
<p>Los objetos de ordenes de Unidraw son unicos en el sentido de que pueden comportarse como mensajes. Una orden de Unidraw puede enviarse a otro objeto para su interpretacion, y el resultado de la interpretacion varia con el objeto receptor. Mas aun, el receptor puede delegar la interpretacion a otro objeto, normalmente al padre en una estructura mas grande, como en una Cadena de Responsabilidad. Asi pues, el receptor de una orden de Unidraw se calcula, no se almacena. El mecanismo de interpretacion de Unidraw depende de la informacion de tipos en tiempo de ejecution.</p>
<p>Coplien discribe como implementar <em>funtors</em>, objetos que son funciones, en C++ [<a href="#cop92" >Cop92</a>]. Logra un grado de transparencia en su utilizacion sobrecargando el operador de llamada a funcion (<code>operator()</code>). El patron Command es diferente; se centra en mantener un <em>enlace entre</em> un receptor y una funcion (es decir, una accion), no en mantener una funcion.</p>
</div>
<h4 id="command-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>Se puede usar el patron <a href="#composite" >Composite</a> para implementar <code>OrdenMacro</code>.</p>
<p>Un <a href="#memento" >Memento</a> puede mantener el estado que necesitan las ordenes para anular sus efectos.</p>
<p>Una orden que debe ser copiada antes de ser guardada en el historial funciona como un <a href="#Prototype" >Prototipo</a>.</p>
</div>
<h3 id="interpreter" >Interpreter</h3>
<h4 id="interpreter-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Dado un lenguaje, define una representacion de su gramatica junto con un interprete que usa dicha representacion para interpretar sentencias del lenguaje.</p>
</div>
<h4 id="interpreter-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Si hay un tipo de problemas que ocurren con cierta frecuencia, puede valer la pena expresar las apariciones de ese problema como instrucciones de un lenguaje simple. A continuacion puede construirse un interprete que resuelva el problema interpretando dichas instrucciones.</p>
<p>Por ejemplo, buscar cadenas que concuerden con un patron es uno de estos problemas recurrentes. Las expresiones regulares son un lenguaje estandar para especificar patrones de cadenas. En vez de construir algoritmos personalizados que comparen cada patron con diferentes cadenas, podriamos tener algoritmos de busqueda que interpretasen una expresion regular que especifica el conjunto de cadenas a buscar.</p>
<p>El patron Interpreter describe como definir una gramitaca para lenguajes simples, como representar instrucciones de ese lenguaje y como interpretar esas instrucciones. En nuestro ejemplo, el patron describe como definir una gramatica para expresiones regulares, como representar una expresion regular concreta y como interpretar dicha expresion regular.</p>
<p>Supongamos que las expresiones regulares se definen mediante la siguiente gramatica:</p>
<div class="example-block" >
<pre class="example" >expresion ::= literal | alternativa | secuencia | repeticion | &#39;(&#39; expresion &#39;)&#39;
alternativa ::= expresion &#39;|&#39; expresion
secuencia ::= expresion &#39;&amp;&#39; expresion
repeticion ::= expresion &#39;*&#39;
literal ::= &#39;a&#39; | &#39;b&#39; | &#39;c&#39; | ... { &#39;a&#39; | &#39;b&#39; | &#39;c&#39; | ... }*
</pre>
</div>
<p>El simbolo inicial es <code>expresion</code>, y <code>literal</code> es un simbolo terminal que define palabras.</p>
<figure>
<img src="img/094.png" />
</figure>
<p>El patron <code>Interpreter</code> usa una clase para representar cada regla de la gramatica. Los simbolos del lado derecho de la regla son variables de instancia de dichas clases. La gramatica de mas arriba se representa por cinco clases: una clase abstracta <code>ExpresionRegular</code> y sus cuatro subclases <code>ExpresionLiteral</code>, <code>ExpresionAlternativa</code>, <code>ExpresionSecuencia</code> y <code>ExpresionRepeticion</code>. Las ultimas tres clases definen variables que contienen subexpresiones.</p>
<p>Cada expresion regular definida por esta gramatica se representa por un arbol sintactico abstracto formado por instancias de estas clases. Por ejemplo, el arbol sintactico abstracto</p>
<figure>
<img src="img/095.png" />
</figure>
<p>representa la expresion regular</p>
<div class="example-block" >
<pre class="example" >lloviendo &amp; (perros | gatos) *
</pre>
</div>
<p>Podemos crear un interprete para estas expresiones regulares definiendo la operacion <code>Interpretar</code> en cada subclase de <code>ExpresionRegular</code>. <code>Interpretar</code> toma como argumento el contexto en el cual se interpreta la expresion. El contexto contiene la cadena de entrada e informacion acerca de que parte de ella se ha reconocido hasta el momento. Cada subclase de <code>ExpresionRegular</code> implementa <code>Interpretar</code> para reconocer la siguiente parte de la cadena de entrada en funcion del contexto actual. Por ejemplo,</p>
<ul>
<li>
<p><code>ExpresionLiteral</code> comprobara si la entrada coincide con el literal que ella define,</p>
</li>
<li>
<p><code>ExpresionAlternativa</code> comprobara si la entrada coincide con alguna de sus alternativas,</p>
</li>
<li>
<p><code>ExpresionRepeticion</code> comprobara si la entrada tiene multiples copias de la expresion repetida,</p>
</li>
</ul>
<p>y asi sucesivamente.</p>
</div>
<h4 id="interpreter-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Interpreter cuando hay un lenguaje que interpretar y se pueden representar las sentacias del lenguaje como arboles de sintactico y abstractos. El patron Interpreter funciona mejor cuando</p>
<ul>
<li>
<p>la gramatica es simple. Para gramaticas complejas, la jerarquia de clases de la gramatica se vuelve grande e inmanejable. Herramientas como los generadores de analizadores sintacticos constituyen una alternativa mejor en estos casos. Estas pueden interpretar expresiones sin necesidad de construir arboles sintacticos abstractos, lo que puede ahorrar espacio y, posiblemente, tiempo.</p>
</li>
<li>
<p>la eficiencia no es una preocupacion critica. Los interpretes mas eficientes normalmente <em>no</em> se implementan interpretando arboles de analisis sintactico directamente, sino que primero los traducen a algun formato. Por ejemplo, las expresiones regulares suelen transformarse en maquinas de estados. Pero incluso en ese caso, el <em>traductor</em> puede implementarse con el patron <code>Interpreter</code>, de modo que este sigue siendo aplicable.</p>
</li>
</ul>
</div>
<h4 id="interpreter-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/096.png" />
</figure>
</div>
<h4 id="interpreter-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>ExpresionAbstracta</code> (<code>ExpresionRegular</code>)</p>
<ul>
<li>
<p>declara una operacion abstracta Interpretar que es comun a todos los nodos del arbol de sintaxis abstracto.</p>
</li>
</ul>
</li>
<li>
<p><code>ExpresionTerminal</code> (<code>ExpresionLiteral</code>)</p>
<ul>
<li>
<p>implementa una operacion <code>Interpretar</code> asociada con los simbolos terminales de la gramatica.</p>
</li>
<li>
<p>se necesita una instancia de esta clase para cada simbolo terminal de una sentencia.</p>
</li>
</ul>
</li>
<li>
<p><code>ExpresionNoTerminal</code> (<code>ExpresionAlternativa</code>, <code>ExpresionRepeticion</code>, <code>ExpresionSecuencia</code>)</p>
<ul>
<li>
<p>por cada regla de la gramatica <span class="math" >R::= R₁ R₂ … Rₙ</span> debe haber una de estas clases.</p>
</li>
<li>
<p>mantiene variables de instancia de tipo <code>ExpresionAbstracta</code> para cada uno de los simbolos de <span class="math" >Rₜ</span> a <span class="math" >Rₙ</span>.</p>
</li>
<li>
<p>implementa una operacion <code>Interpretar</code> para los simbolos no terminales de la gramatica. <code>Interpretar</code> nolmalmente se llama a si misma recursivamente sobre las variables que representan de <span class="math" >Rₜ</span> a <span class="math" >Rₙ</span>.</p>
</li>
</ul>
</li>
<li>
<p><code>Contexto</code></p>
<ul>
<li>
<p>contiene informacion que es global al interprete.</p>
</li>
</ul>
</li>
<li>
<p><code>Cliente</code></p>
<ul>
<li>
<p>construye (o recibe) un arbol sintactico abstracto que representa una determinada sentencia del lenguaje definido por la gramatica. Este arbol sintactico abstracto esta formado por instancias de las clases <code>ExpresionNoTerminal</code> y <code>ExpresionTerminal</code>.</p>
</li>
<li>
<p>invoca a la operacion <code>Interpretar</code>.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="interpreter-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p>El cliente construye (o recibe) la sentencia como un arbol sintactico abstracto formado por instancias de <code>ExpresionNoTerminal</code> y <code>ExpresionTerminal</code>. A continuacion el cliente inicializa el contexto e invoca a la operacion <code>Interpretar</code>.</p>
</li>
<li>
<p>Cada nodo <code>ExpresionNoTerminal</code> define <code>Interpretar</code> en terminos de <code>Interpretar</code> de cada subexpresion. La operacion <code>Interpretar</code> de cada <code>ExpresionTerminal</code> define el caso base de la recurcion.</p>
</li>
<li>
<p>Las operaciones <code>Interpretar</code> de cada nodo usa el contexto para almacenar y acceder al estado del interprete.</p>
</li>
</ul>
</div>
<h4 id="interpreter-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron <code>Interprete</code> tiene las siguientes ventajas e inconvenientes:</p>
<ol class="num" >
<li>
<p><em>Es facil cambiar y ampliar la gramatica.</em> Puesto que el patron usa clases para representar las reglas de la gramatica, se puede usar la herencia para cambiar o extender esta. Se puede modificar incrementalmente las expresiones existentese, y se pueden definir otras nuevas como variaciones de las antiguas.</p>
</li>
<li>
<p><em>Tambien resulta facil implementar la gramatica.</em> Las clases que definen los nodos del arbol sintactico abstracto tiene implementaciones similares. Estas clases son faciles de escribir, y muchas veces se pueden generar automaticamete con un compilador o un generador de analizadores sintacticos.</p>
</li>
<li>
<p><em>Las gramaticas complejas son difiles de mantener.</em> El patron Interpreter define al menos una clase para cada regla de la gramatica (las reglas que se hayan definido usando BNF pueden necesitar varias clases). De hay que las gramaticas que contienen muchas reglas pueden ser dificiles de controlar y mantener. Se pueden aplicar otros patrones de diseño para mitigar el problema (vease la seccion de Implementacion). Pero cuando la gramatica es muy compleja son mas adecuadas otras tecnicas como los generadoles de analizadores sintacticos o de compiladores.</p>
</li>
<li>
<p><em>Añadir nuevos modos de interpretar expresiones.</em> El patron Interpreter facilita evaluar una expresion de una manera distinta. Por ejemplo, podriamos permitir imprimir con formato una expresion o realizar una comprobacion de tipos en ella definiendo una nueva operacion en las clases de las expresiones. Si vamos a seguir añadiendo nuevos modos de interpretar una expresion, deberiamos considerar la utilizacion del patron <a href="#visitor" >Visitor</a> para evitar cambiar las clases de la gramatica.</p>
</li>
</ol>
</div>
<h4 id="interpreter-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Los patrones Interpreter y <a href="#composite" >Composite</a> comparten muchos detalles de implementacion. Las siguientes cuestiones son especificas del Interpreter:</p>
<ol class="num" >
<li>
<p><em>Crear un arbol sintactico abstracto.</em> El patron Interpreter no explica como <em>crear</em> un arbol sintactico abstracto. En otras palabras, no se encarga del analisis sintactico. El arbol sintactico abstracto puede ser creado mediante un analizador sintactico dirigido por una tabla, mediante un analizador sintactico (normalmente recursivo descendente) hecho a mano, o directamente por el cliente.</p>
</li>
<li>
<p><em>Definir la operacion <code>Interpretar</code></em>. No tenemos por que definir la operacion <code>Interpretar</code> en las clases de la expresion. Si se van a crear nuevos interpretes es mejor usar el patron <a href="#visitor" >Visitor</a> para poner <code>Interpretar</code> en un objeto <q>visitante</q> aparte. Por ejemplo, una gramatica de un lenguaje de programacion tendra muchas operaciones sobre los arboles sintacticos abstractos, tales como la comprobacion de tipos, la optimizacion, la generacion de codigo, etcetera. Sera mejor usar un visitante para evitar definir estas operaciones en cada clase de la gramatica.</p>
</li>
<li>
<p><em>Compartir simbolos terminales mediante el patron Flyweight.</em> Para las gramaticas cuyas sentencias contienen muchas repeticiones de un mismo simbolo terminal puede ser beneficioso compartir una unica copia de dicho simbolo. Las gramaticas para programas de computadora son buenos ejemplos ––cada variable de un programa aparecera en muchos sitios a lo largo del codigo––. En el ejemplo de la seccion Motivacion, una sentencia puede tener el simbolo terminal <code>perro</code> (modelado mediante la clase <code>ExpresionLiteral</code>) repetido muchas veces.</p>
<p>Los nodos terminales generalmente no guardan informacion sobre su posicion en el arbol sintactico abstracto. Los nodos padre les pasan cualquier contexto que pudieran necesitar durante la interpretacion. Por tanto aqui se da una distincion entre estado compartido (intrinseco) y estado recibido (extrinseco), por lo que es aplicable el patron <a href="#flyweight" >Flyweight</a>.</p>
<p>Por ejemplo, cada instancia de <code>ExpresionLiteral</code> para <code>perro</code> recibe un contexto que contiene la subcadena reconocida hasta ese instante. Y cada una de estas instancias de <code>ExpresionLiteral</code> hace lo mismo en su operacion <code>Interpretar</code> ––comprueba si la parte que sigue de la entrada contiene un <code>perro</code>––, sin importar en que posicion del arbol aparezca la instancia.</p>
</li>
</ol>
</div>
<h4 id="interpreter-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>A continuacion se mostraran dos ejemplos. El primero de ellos es un codigo completo en Smalltalk para comprobar si una secuencia satisface una expresion regular. El segundo es un programa en C++ para evaluar expresiones booleanas.</p>
<p>El reconocedor de expresiones regulares comprueba si una cadena pertenece al lenguaje definido por la expresion regular. La expresion regular esta definida por la siguiente gramatica:</p>
<div class="example-block" >
<pre class="example" >expresion ::= literal | alternativa | secuencia | repeticion | &#39;(&#39; expresion &#39;)&#39;
alternativa ::= expresion &#39;|&#39; expresion
secuencia ::= expresion &#39;&amp;&#39; expresion
repeticion ::= expresion &#39;repetir&#39;
literal ::= &#39;a&#39; | &#39;b&#39; | &#39;c&#39; | ... { &#39;a&#39; | &#39;b&#39; | &#39;c&#39; | ... }*
</pre>
</div>
<p>Esta gramatica es una ligera modificacion de la del ejemplo de la seccion de Motivacion. Hemos cambiando un poco la sintaxis concreta de las expresiones regulares, ya que el simbolo <samp><code>*</code></samp> no puede ser una operacion postfija en Smalltalk. Por este motivo usaremos <code>repetir</code> en su lugar. Por ejemplo, la expresion regular</p>
<div class="example-block" >
<pre class="example" >((&#39;perro &#39; | &#39;gato &#39;) repetir &amp; &#39;tiempo&#39;)
</pre>
</div>
<p>reconocera la cadena de entrada <q><code>perro perro gato tiempo</code></q>.</p>
<p>Para implementar el reconocedor, definimos las cinco clases descritas en la seccion <a href="#Interpreter-Motivacion" >Motivacion</a>. La clase <code>ExpresionSecuencia</code> tiene las variables de instancia <code>expresion1</code> y <code>expresion2</code> para sus hijos en el arbol sintactico abstracto. <code>ExpresionAlternativa</code> guarda sus alternativas en las variables de instancia <code>alternativa1</code> y <code>alternativa2</code>, mientras que <code>ExpresionRepeticion</code> guarda en su variable de instancia <code>repeticion</code> la expresion que se repite. <code>ExpresionLiteral</code> tiene la variable de instancia <code>componentes</code> que contiene una lista de objetos (probablemente caracteres). Estos representan la cadena literal con la que debe coincidir la secuencia de entrada .</p>
<p>La operacion <code>reconocer:</code> implementa un interprete de expresiones regulares. Cada una de las clases que define el arbol sintactico implementa esta operacion, que recibe en el parametro <code>estadoEntrada</code> el estado actual del proceso de analisis, tras haber leido parte de la cadena de entrada.</p>
<p>Dicho estado actual viene dado por una serie de flujos de entrada que representan todas las entradas que podria haber aceptado hasta el momento la expresion regular. (Esto equivale mas o menos a guardar todos los estado en los que estaria el automata de estados finitos equivalente tras haber reconocido la cadena de entrada hasta este punto.)</p>
<p>El estado actual es de vital importancia para la operacion <code>repetir</code>. Por ejemplo, si la expresion regular fuera</p>
<div class="example-block" >
<pre class="example" >&#39;a&#39; repetir
</pre>
</div>
<p>entonces el interprete podria reconocer <q><code>a</code></q>, <q><code>aa</code></q>, <q><code>aaa</code></q> y asi sucesivamente. Si fuera</p>
<div class="example-block" >
<pre class="example" >&#39;a&#39; repetir &amp; &#39;bc&#39;
</pre>
</div>
<p>entonces podria reconocer  <q><code>abc</code></q>,  <q><code>aabc</code></q>,  <q><code>aaabc</code></q>, etcetera. Pero si la expresion regular fuese</p>
<div class="example-block" >
<pre class="example" >&#39;a&#39; repetir &amp; &#39;abc&#39;
</pre>
</div>
<p>entonces comparar la entrada <q><code>aabc</code></q> con la expresion <q><code>&#39;a&#39; repetir</code></q> daria lugar a dos flujos de entrada, uno en el que se reconoceria un caracter de la entrada y otro en el que se reconocerian dos caracteres. Solo el flujo que ha aceptado un caracter reconocera el <q><code>abc</code></q> restante.</p>
<p>Pensemos ahora en las definiciones de <code>reconecer:</code> para cada clase que define una expresion regular. La definicion de esta operacion para <code>ExpresionSecuencia</code> reconoce cada una de sus subexpresiones secuencialmente. Normalmente eliminara flujos de entrada de su <code>estadoEntrada</code>.</p>
<pre class="code" ><code class="chroma" ><span class="nf">reconocer:</span> <span class="nv">estadoEntrada</span>
    <span class="o">^</span> <span class="nv">expresion2</span> <span class="nf">reconocer:</span> (<span class="nv">expresion1</span> <span class="nf">reconocer:</span> <span class="nv">estadoEntrada</span>)<span class="p">.</span>
</code></pre>
<p>Una <code>ExpresionAlternativa</code> devolvera un estado que consiste en la union de estados de cada alternativa. La definicion de <code>reconocer:</code> para <code>ExpresionAlternativa</code> es</p>
<pre class="code" ><code class="chroma" ><span class="nf">reconocer:</span> <span class="nv">estadoEntrada</span>
    <span class="o">|</span><span class="nv"> estadoFinal </span><span class="o">|</span>
    <span class="nv">estadoFinal</span> <span class="o">:=</span> <span class="nv">alternativa1</span> <span class="nf">reconocer:</span> <span class="nv">estadoEntrada</span><span class="p">.</span>
    <span class="nv">estadoFinal</span> <span class="nf">addAll:</span> (<span class="nv">alternativa2</span> <span class="nf">reconocer:</span> <span class="nv">estadoEntrada</span>)<span class="p">.</span>
    <span class="o">^</span> <span class="nf">estadoFinal</span>
</code></pre>
<p>La operacion <code>reconocer:</code> de <code>ExpresionRepeticion</code> trata de encontrar tantos estados que pueda reconocer como sea posible:</p>
<pre class="code" ><code class="chroma" ><span class="nf">reconocer:</span> <span class="nv">estadoEntrada</span>
    <span class="o">|</span><span class="nv"> unEstado estadoFinal </span><span class="o">|</span>
    <span class="nv">unEstado</span> <span class="o">:=</span> <span class="nv">estadoEntrada</span><span class="p">.</span>
    <span class="nv">estadoFinal</span> <span class="o">:=</span> <span class="nv">estadoEntrada</span> <span class="nf">copy</span><span class="p">.</span>
    [<span class="nv">unEstado</span> <span class="nf">isEmpty</span>]
        <span class="nb">whileFalse:</span>
            [<span class="nv">unEstado</span> <span class="o">:=</span> <span class="nv">repeticion</span> <span class="nf">reconoter:</span> <span class="nv">unEstado</span><span class="p">.</span>
             <span class="nv">estadoFinal</span> <span class="nf">addAll:</span> <span class="nv">unEstado</span>]
        <span class="err">^</span> <span class="nf">estadoFinal</span>
</code></pre>
<p>Su estado de salida normalmente consiste en mas estados que su estado de entrada, ya que <code>ExpresionRepeticion</code> puede reconocer uno, dos o muchas apariciones de <code>repeticion</code> en el estado de entrada. Los estados de salida representan todas estas posibilidades, permitiendo a los siguientes elementos de la expresion regular decidir que estado es el correcto.</p>
<p>Por ultimo, la definicion de <code>reconocer:</code> para <code>ExpresionLiteral</code> trata de reconocer sus componentes para cada posible flujo de entrada. Solo mantiene aquellos flujos de entrada que concuerdan con la expresion:</p>
<pre class="code" ><code class="chroma" ><span class="nf">reconocer:</span> <span class="nv">estadoEntrada</span>
    <span class="err">|</span> <span class="nv">estadoFinal</span> <span class="o">:=</span> <span class="nv">tStream</span> <span class="nf">|</span>
    <span class="nv">estadoFinal</span> <span class="o">:=</span> <span class="nc">Set</span> <span class="nb">new</span><span class="p">.</span>
    <span class="nf">estadoEntrada</span>
        <span class="err">do:</span>
            [<span class="o">:</span><span class="nv">stream</span> <span class="o">|</span> <span class="nv">tStream</span> <span class="o">:=</span> <span class="nv">stream</span> <span class="nf">copy</span><span class="p">.</span>
                 (<span class="nv">tStream</span> <span class="nf">nextAvailable:</span>
                      <span class="nv">components</span> <span class="nf">size</span>
                 ) <span class="nf">=</span> <span class="nf">components</span>
                     <span class="err">ifTrue:</span> [<span class="nv">estadoFinal</span> <span class="nf">add:</span> <span class="nv">tStream</span>]
            ]<span class="p">.</span>
        <span class="o">^</span> <span class="nf">estadoFinal</span>
</code></pre>
<p>El mensaje <code>siguienteDisponible:</code> hace que avance el flujo de entrada. Esta es la unica operacion <code>reconocer:</code> que hace avanzar al flujo. Notese como el estado que devuelve contiene una copia del flujo de entrada, garantizando asi que reconocer un literal nunca cambie el flujo de entrada. Esto es importante porque todas las alternativas de una <code>ExpresionAlternativa</code> deberian ver copias identicas del flujo de entrada.</p>
<p>Ahora que hemos definido las clases de las que se compone un arbol sintactico abstracto, estamos en condicines de describir como construirlo. En vez de escribir un analizador sintactico de expresiones regulares, definiremos algunas operaciones en las clases <code>ExpresionRegular</code> de forma que evaluar una expresion en Smalltalk produzca un arbol sintactico abstracto para la correspondiente expresion regular. Eso nos permite usar el compilador incorporado de Smalltalk como si fuese un analizador sintactico de expresiones regulares.</p>
<p>Para construir el arbol sintactico abstracto necesitaremos definir <q><code>|</code></q>, <q><code>repetir</code></q> y <q><code>&amp;</code></q> como operacienos de <code>ExpresionRegular</code>. Estas operaciones se definen en la clase <code>ExpresionRegular</code> como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="nf">&amp;</span> <span class="nv">unNodo</span>
    <span class="o">^</span> <span class="nc">ExpresionSecuencia</span> <span class="nb">new</span>
        <span class="nf">expresion1:</span> <span class="bp">self</span> <span class="nf">expresion2:</span> <span class="nv">unNodo</span> <span class="nf">comoExpReg</span>

<span class="nf">repetir</span>
    <span class="err">^</span> <span class="nf">ExpresionRepeticion</span> <span class="nb">new</span> <span class="nf">repeticion:</span> <span class="nf">self</span>

<span class="nf">|</span> <span class="nv">unNodo</span>
    <span class="o">^</span> <span class="nc">ExpresionAlternativa</span> <span class="nb">new</span>
    <span class="nf">alternativa1:</span> <span class="bp">self</span> <span class="nf">alternativa2:</span> <span class="nv">unNodo</span> <span class="nf">comoExpReg</span>

<span class="nf">comoExpReg</span>
    <span class="err">^</span> <span class="nf">self</span>
</code></pre>
<p>La operacion <code>comoExpReg</code> convertira literales en objetos <code>ExpresionRegular</code>. Estas operaciones se definen en la clase <code>String:</code></p>
<pre class="code" ><code class="chroma" ><span class="nf">&amp;</span> <span class="nv">unNodo</span>
    <span class="o">^</span> <span class="nc">ExpresionSecuencia</span> <span class="nb">new</span>
        <span class="nf">expresion1:</span> <span class="bp">self</span> <span class="nf">comoExpReg</span> <span class="nf">expresion2:</span> <span class="nv">unNodo</span> <span class="nf">comoExpReg</span>

<span class="nf">repetir</span>
    <span class="err">^</span> <span class="nf">ExpresionRepeticion</span> <span class="nb">new</span> <span class="nf">repeticion:</span> <span class="nf">self</span>

<span class="nf">|</span> <span class="nv">unNodo</span>
    <span class="o">^</span> <span class="nc">ExpresionAlternativa</span> <span class="nb">new</span>
    <span class="nf">alternativa1:</span> <span class="bp">self</span> <span class="nf">comoExpReg</span> <span class="nf">alternativa2:</span> <span class="nv">unNodo</span> <span class="nf">comoExpReg</span>

<span class="nf">comoExpReg</span>
    <span class="err">^</span> <span class="nf">ExpresionLiteral</span> <span class="nb">new</span> <span class="nf">componentes:</span> <span class="nf">self</span>
</code></pre>
<p>Si definieramos estas operaciones mas arriba en la jerarquia de clases (<code>SequenceableCollection</code> en Smalltalk-80, <code>IndexedCollection</code> en Smalltalk/V), entonces tambien estarian definidas para clases como <code>Array</code> y <code>OrderedCollection</code>. Esta haria que las expresiones regulares reconociesen secuencias de objetos de cualquier tipo.</p>
<p>El segundo ejemplo es un sistema para manipular y evaluar expresiones booleanas, implementado en C++. Los simbolos terminales del lenguaje son variables de tipo Boolean, es decir, las constantes <code>true</code> y <code>false</code>. Los simbolos no terminales representan expresiones que contienen los operadores <code>and</code>, <code>or</code>, y <code>not</code>. La gramatica se define como sigue:<span class="note" ><sup><a href="#42" >42</a></sup></span></p>
<div class="example-block" >
<pre class="example" >ExpBooleana ::= ExpVariable | Constante | ExpOr | ExpAnd | ExpNot | &#39;(&#39; ExpBooleana &#39;)&#39;
ExpAnd ::= ExpBooleana &#39;and&#39; ExpBooleana
ExpOr ::= ExpBooleana &#39;or&#39; ExpBooleana
ExpNot ::= &#39;not&#39; ExpBooleana
Constante ::= &#39;true&#39; | &#39;false&#39;
ExpVariable := &#39;A&#39; | &#39;B&#39; | ... | &#39;X&#39; | &#39;Y&#39; | &#39;Z&#39;
</pre>
</div>
<p>Definiremos dos operaciones para las expresiones booleanas. La primera, <code>Evaluar</code>, evaluaria una expresion Booleana en un contexto que asigna un valor verdadero o falso a cada variable. La segunda operacion, <code>Sustituir</code>, produce una nueva expresion booleana al sustituir una variable por una expresion. <code>Sustituir</code> muestra como se puede usar el patron Interpreter para algo mas que simplemente evaluar expresiones. En este caso, para manipular la propia expresion.</p>
<p>A continuacion se detallaran las clases <code>ExpBooleana</code>, <code>ExpVariable</code> y <code>ExpAnd</code>. Las clases <code>ExpOr</code> y <code>ExpNot</code> son parecidas a <code>ExpAnd</code>. La clase <code>Constante</code> representa las constantes logicas.</p>
<p><code>ExpBooleana</code> define la interfaz para todas las clases que definen una expresion booleana:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ExpBooleana</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ExpBooleana</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ExpBooleana</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Evaluar</span><span class="p">(</span><span class="n">Contexto</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">ExpBooleana</span><span class="o">*</span> <span class="nf">Sustituir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">ExpBooleana</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">ExpBooleana</span><span class="o">*</span> <span class="nf">Copiar</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>La clase <code>Contexto</code> define una correspondencia entre variables y valores booleanos, los cuales se representan mediante las constantes de C++ <code>true</code> y <code>false</code>. <code>Contexto</code> tiene la siguiente interfaz:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Contexto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">Buscar</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">Asignar</span><span class="p">(</span><span class="n">ExpVariable</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
<p>Una <code>ExpVariable</code> representa una variable con nombre:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ExpVariable</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExpBooleana</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ExpVariable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ExpVariable</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Evaluar</span><span class="p">(</span><span class="n">Contexto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">ExpBooleana</span><span class="o">*</span> <span class="nf">Sustituir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">ExpBooleana</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">ExpBooleana</span><span class="o">*</span> <span class="nf">Copiar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">_nombre</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>El constructor recibe como parametro el nombre de la variable:</p>
<pre class="code" ><code class="chroma" ><span class="n">ExpVariable</span><span class="o">::</span><span class="n">ExpVariable</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombre</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_nombre</span> <span class="o">=</span> <span class="n">strdop</span><span class="p">(</span><span class="n">nombre</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Evaluar una variable devuelve su valor en el contexto actual.</p>
<pre class="code" ><code class="chroma" ><span class="kt">bool</span> <span class="n">ExpVariable</span><span class="o">::</span><span class="n">Evaluar</span> <span class="p">(</span><span class="n">Contexto</span><span class="o">&amp;</span> <span class="n">unContexto</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">unContexto</span><span class="p">.</span><span class="n">Buscar</span><span class="p">(</span><span class="n">_nombre</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Copiar una variable devuelve una nueva <code>ExpVariable</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">ExpBooleana</span><span class="o">*</span> <span class="n">ExpVariable</span><span class="o">::</span><span class="n">Copiar</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ExpVariable</span><span class="p">(</span><span class="n">_nombre</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Para sustituir una variable por una expresion hemos de compobar si la variable tiene el mismo nombre que la que se recibe como parametro:</p>
<pre class="code" ><code class="chroma" ><span class="n">ExpBooleana</span><span class="o">*</span> <span class="n">ExpVariable</span><span class="o">::</span><span class="n">Sustituir</span> <span class="p">(</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombre</span><span class="p">,</span> <span class="n">ExpBooleana</span><span class="o">&amp;</span> <span class="n">exp</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">nombre</span><span class="p">,</span> <span class="n">_nombre</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">.</span><span class="n">Copiar</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ExpVariable</span><span class="p">(</span><span class="n">_nombre</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Por otro lado, <code>ExpAnd</code> representa una expresion resultado de unir dos expresiones booleanas por ala operacion <q>y</q> logica.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ExpAnd</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExpBooleana</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ExpAnd</span><span class="p">(</span><span class="n">ExpBooleana</span><span class="o">*</span><span class="p">,</span> <span class="n">ExpBooleana</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ExpAnd</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Evaluar</span><span class="p">(</span><span class="n">Contexto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">ExpBooleana</span><span class="o">*</span> <span class="nf">Sustituir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">ExpBooleana</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">ExpBooleana</span><span class="o">*</span> <span class="nf">Copiar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">ExpBooleana</span><span class="o">*</span> <span class="n">_operando1</span><span class="p">;</span>
    <span class="n">ExpBooleana</span><span class="o">*</span> <span class="n">_operando2</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">ExpAnd</span><span class="o">::</span><span class="n">ExpAnd</span> <span class="p">(</span><span class="n">ExpBooleana</span><span class="o">*</span> <span class="n">op1</span><span class="p">,</span> <span class="n">ExpBooleana</span><span class="o">*</span> <span class="n">op2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_operando1</span> <span class="o">=</span> <span class="n">op1</span><span class="p">;</span>
    <span class="n">_operando2</span> <span class="o">=</span> <span class="n">op2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Evaluar una <code>ExpAnd</code> consiste en evaluar sus operandos y devolver el <q>y</q> logico de los resultados.</p>
<pre class="code" ><code class="chroma" ><span class="kt">bool</span> <span class="n">ExpAnd</span><span class="o">::</span><span class="n">Evaluar</span> <span class="p">(</span><span class="n">Contexto</span><span class="o">&amp;</span> <span class="n">unContexto</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span>
        <span class="n">operando1</span><span class="o">-&gt;</span><span class="n">Evaluar</span><span class="p">(</span><span class="n">unContexto</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">operando2</span><span class="o">-&gt;</span><span class="n">Evaluar</span><span class="p">(</span><span class="n">unContexto</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Una <code>ExpAnd</code> implementa <code>Copiar</code> y <code>Sustituir</code> haciendo llamadas recursivas sobre sus operandos:</p>
<pre class="code" ><code class="chroma" ><span class="n">ExpBooleana</span><span class="o">*</span> <span class="n">ExpAnd</span><span class="o">::</span><span class="n">Copiar</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span>
        <span class="k">new</span> <span class="n">ExpAnd</span><span class="p">(</span><span class="n">_operando1</span><span class="o">-&gt;</span><span class="n">Copiar</span><span class="p">(),</span> <span class="n">_operando2</span><span class="o">-&gt;</span><span class="n">Copiar</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">ExpBooleana</span><span class="o">*</span> <span class="n">ExpAnd</span><span class="o">::</span><span class="n">Sustituir</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombre</span><span class="p">,</span> <span class="n">ExpBooleana</span><span class="o">&amp;</span> <span class="n">exp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span>
        <span class="k">new</span> <span class="n">ExpAnd</span><span class="p">(</span>
            <span class="n">_operando1</span><span class="o">-&gt;</span><span class="n">Sustituir</span><span class="p">(</span><span class="n">nombre</span><span class="p">,</span> <span class="n">exp</span><span class="p">),</span>
            <span class="n">_operando2</span><span class="o">-&gt;</span><span class="n">Sustituir</span><span class="p">(</span><span class="n">nombre</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
        <span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Ahora podemos definir la expresion booleana</p>
<div class="example-block" >
<pre class="example" >(true and x) or (y and (not x))
</pre>
</div>
<p>y evaluarla asignando <code>true</code> o <code>false</code> a las variables <code>x</code> e <code>y</code>:</p>
<pre class="code" ><code class="chroma" ><span class="n">ExpBooleana</span><span class="o">*</span> <span class="n">expresion</span><span class="p">;</span>
<span class="n">Contexto</span> <span class="n">contexto</span><span class="p">;</span>

<span class="n">ExpVariable</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExpVariable</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;X&#34;</span><span class="p">);</span>
<span class="n">ExpVariable</span><span class="o">*</span> <span class="n">y</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExpVariable</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Y&#34;</span><span class="p">);</span>

<span class="n">expresion</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExpOr</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">ExpAnd</span><span class="p">(</span><span class="k">new</span> <span class="n">Constante</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span>
    <span class="k">new</span> <span class="n">ExpAnd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="k">new</span> <span class="n">ExpNot</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">);</span>

<span class="n">contexto</span><span class="p">.</span><span class="n">Asignar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="n">contexto</span><span class="p">.</span><span class="n">Asignar</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">resultado</span> <span class="o">=</span> <span class="n">expresion</span><span class="o">-&gt;</span><span class="n">Evaluar</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</code></pre>
<p>La expresion se evalua a <code>true</code> para estos valores de <code>x</code> e <code>y</code>. Podemos evaluar la expresion dandoles diferentes valores a las variables simplemente cambiando el contexto.</p>
<p>Por ultimo, podemos sustituir la variable <code>y</code> con una nueva expresion y luego volver a evaluarla:</p>
<pre class="code" ><code class="chroma" ><span class="n">ExpVariable</span><span class="o">*</span> <span class="n">z</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExpVariable</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Z&#34;</span><span class="p">);</span>
<span class="n">ExpNot</span> <span class="nf">not_z</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

<span class="n">ExpBooleana</span><span class="o">*</span> <span class="n">sustitucion</span> <span class="o">=</span> <span class="n">expresion</span><span class="o">-&gt;</span><span class="n">Sustituir</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Y&#34;</span><span class="p">,</span> <span class="n">not_z</span><span class="p">);</span>

<span class="n">contexto</span><span class="p">.</span><span class="n">Asignar</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

<span class="n">resultado</span> <span class="o">=</span> <span class="n">sustitucion</span><span class="o">-&gt;</span><span class="n">Evaluar</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</code></pre>
<p>Este ejemplo ilustra un aspecto importante del patron Interpreter: hay muchos tipos de operaciones que pueden <q>interpretar</q> una sentencia. De las tres operaciones definidas para <code>ExpBooleana</code>, <code>Evaluar</code> es la que mas se ajusta a nuestra idea de lo que deberia hacer un interprete ––interpretar un programa o expresion y devolver un resultado simple––.</p>
<p>No obstante, <code>Sustituir</code> tambien puede verse como un interprete. Es un interprete cuyo contexto es el nombre de la variable que esta siendo sustituida junto con la expresion que la sustituye, y cuyo resultado es una nueva expresion. Incluso podria pensarse en <code>Copiar</code> como un interprete con un contexto vacio. Puede parecer un poco extraño considerar a <code>Sustituir</code> y <code>Copiar</code> como interpretes, dado que estas son operaciones basicas sobre arboles. Los ejemplos del patron <a href="#visitor" >Visitor</a> muestran como estas tres operaciones pueden refectarizarse en un <q>interprete</q> visitante aparte, revelando asi una profunda similitud.</p>
<p>El patron interpreter es mas que una simple operacion distribuida sobre una jerarquia de clases que usa el patron <a href="#composite" >Composite</a>. Si consideramos a <code>Evaluar</code> como un interprete es porque pensamos en la jerarquia de clases de <code>ExpBooleana</code> como la representacion de un lenguaje. Supuesta una jerarquia de clases similar para representar el ensablaje de partes de automoviles, no es probable que hubieramos considerado interpretes a operaciones como <code>Peso</code> y <code>Copiar</code>, aunque esten distribuidas sobre una jerarquia de clases que usa el patron Composite ––no pensamos en las partes de un automovil como un lenguaje––. Es una cuestion de perspectiva; si empezasemos a publicar gramaticas de partes de automoviles, entoces se podria considerar a las operaciones sobre esas partes como formas de interpretar el lenguaje.</p>
</div>
<h4 id="interpreter-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>El patron Interpreter esta muy extendido en los compiladores implementados con lenguajes orientados a objetos, como los compiladores de Smalltalk. SPECTalk usa este patron para interpretar descripciones de formatos de ficheros de entrada [<a href="#sza92" >Sza92</a>]. El toolkit de resolucion de problemas QOCA lo usa para evaluar los problemas [<a href="#hhmv92" >HHMV92</a>].</p>
<p>Concebido en su forma mas general (es decir, como una operacion distribuida sobre una jeraquia de clases basada en el patron Composite), casi cualquier uso del patron Composite tambien contendra el patron Interpreter. Pero este patron deberia reservarse para aquellos casos en los que tiene sentido pensar en la jerarquia de clases como la definicion de un lenguaje.</p>
</div>
<h4 id="interpreter-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p><a href="#composite" >Composite</a>: el arbol sintactico abstracto es una instancia del patron Composite.</p>
<p>El patron <a href="#flyweight" >Flyweight</a> muestra como compartir simbolos terminales dentro del arbol sintactico abstracto.</p>
<p><a href="Iterator" >Iterator</a>: el interprete puede usar un Iterator para recorrer la estructura.</p>
<p>Puede usarse el patron <a href="Visitor" >Visitor</a> para mantener el comportamiento de cada nodo del arbol sintactico abstracto en una clase.</p>
</div>
<h3 id="iterator" >Iterator</h3>
<h4 id="iterator-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Proporciona un modo de acceder secuencialmente a los elementos de un objeto agredado sin exponer su representacion interna.</p>
</div>
<h4 id="iterator-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Cursor</p>
</div>
<h4 id="iterator-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Un objeto agregado, como por ejemplo una lista, deberia darnos una forma de acceder a sus elementos sin exponer su estructura interna. Mas aun, tal vez queramos recorrer la lista de diferentes formas, dependiendo de lo que queramos realizar. Pero probablemente no queremos plagar la interfaz de <code>Lista</code> con operaciones para diferentes recorridos, incluso en el caso de que pudiramos prever cuales se van a necesitar. Por otro lado, tambien puede necesitarse hacer mas de un recorrido simultaneamente sobre la misma lista.</p>
<p>El patron Iterator nos permite hacer todo esto. La idea clave de este patron es tomar la responsabilidad de acceder y recorrer el objeto lista y poner dicha responsabilidad en un objeto <b>iterador</b>. La clase <code>Iterador</code> define una interfaz para acceder a los elementos de la lista. Un objeto iterador es el responsable de saber cual es el elemento actual; es decir, sabe que elementos ya han sido recorridos.</p>
<p>Por ejemplo, una clase <code>Lista</code> pediria un <code>IteradorLista</code> con la siguiente relacion entre ambos:</p>
<figure>
<img src="img/097.png" />
</figure>
<p>Antes de que pueda crearse una instancia de <code>IteradorLista</code> debemos proporcionarle la <code>Lista</code> a recorrer. Una vez que tenemos la instancia de <code>IteradorLista</code>, podemos acceder secuencialmente a los elementos de la lista. La operacion <code>ElementoActual</code> devuelve el elemento actual de la lista; Primero inicializa el elemento actual al primer elemento; <code>Siguiente</code> hace avanzar el elemento actual al siguiente elemento; y <code>HaTerminado</code> comprueba si se ha avanzado mas alla del ultimo elemento, es decir, si se ha finalizado el recorrido.</p>
<p>Separar el mecanismo de recorrido del objeto <code>Lista</code> nos permite definir iteradores con diferentes politicas de recorrido sin necesidad de enumerarlos en la interfaz de <code>Lista</code>. Por ejemplo, <code>IteradorListaConFiltro</code> podria proporcionar acceso solo a aquellos elementos que satisfagan a las normas de filtrado.</p>
<p>Notese que el iterador y la lista estan acoplados, y que el cliente debe saber que lo que esta recorriendo es una <em>lista</em> y no otra estructura agregada. Por tanto, el cliente se ajusta a una determinada estructura agregada. Seria mejor que pudiesemos cambiar la clase agregada sin cambiar el codigo cliente. Podemos hacer esto por generalizacion del concepto de iterador para permitir la <b>iteracion polimorfica</b>.</p>
<p>Como ejemplo, supongamos que ya tenemos una implementacion de una lista <code>ListaConSaltos</code>. Una lista con saltos (<em>skiplis</em>) [<a href="#pug90" >Pug90</a>] es una estructura de datos con caracteristicas similares a los arboles equilibrados. Nos gustaria poder escribir codigo que funsionase tanto para objetos <code>Lista</code> como para objetos <code>ListaConSaltos</code>.</p>
<p>Definimos una clase <code>ListaAbstracta</code> que proporciona una interfaz comun para manipular listas. Igualmente, necesitamos una clase abstracta <code>Iterador</code> que defina una interfaz de iteracion comun. Entonces podemos definir las subclases concretas de <code>Iterador</code> para las diferentes implementaciones de listas. Como resultado, el mecanismo de iteracion se vuelve independiente de las clases concretas.</p>
<figure>
<img src="img/098.png" />
</figure>
<p>Nos queda el problema de como crear el iterador. Puesto que queremos escribir codigo que sea independiente de las subclases concretas de <code>Lista</code>, no podemos crear simplemente una instancia de una clase determinada. En vez de eso, haremos que los objetos lista sean responsables de crear sus correspondientes iteradores. Esto requiere una operacion como <code>CrearIterador</code>, mediante la cual los clientes soliciten un objeto iterador.</p>
<p><code>CrearIterador</code> es un ejemplo de metodo de fabricacion (vease el patron <a href="#factory-method" >Factory Method</a>). Aqui lo usamos para permitir que un cliente le pida a un objeto lista el iterador apropiado. El enfoque seguido con el patron Factory Method da lugar a dos jerarquias de clases, una para las listas y otra para los iteradores. El metodo de fabricacion <code>CrearIterador</code> <q>conecta</q> las dos jeraquias.</p>
</div>
<h4 id="iterator-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Iterador</p>
<ul>
<li>
<p>para acceder al contenido de un objeto agregado sin exponer su representacion interna.</p>
</li>
<li>
<p>para permitir varios recorridos sobre objetos agregados.</p>
</li>
<li>
<p>para proporcionar una interfaz uniforme para recorrer diferentes estructuras agregadas (es decir, para permitir la iteracion polimorfica).</p>
</li>
</ul>
</div>
<h4 id="iterator-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/099.png" />
</figure>
</div>
<h4 id="iterator-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Iterador</code></p>
<ul>
<li>
<p>define una interfaz para recorrer los elementos y acceder a ellos.</p>
</li>
</ul>
</li>
<li>
<p><code>IteradorConcreto</code></p>
<ul>
<li>
<p>implementa la interfaz <code>Iterador</code>.</p>
</li>
<li>
<p>mantiene la posicion actual en el recorrido del agregado.</p>
</li>
</ul>
</li>
<li>
<p><code>Agregado</code></p>
<ul>
<li>
<p>define una interfaz para crear un objeto <code>Iterador</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>AgregadorConcreto</code></p>
<ul>
<li>
<p>implementa la interfaz de creacion de <code>Iterador</code> para devolver una instancia del <code>IteradorConcreto</code> apropiado.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="iterator-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p>Un <code>IteradorConcreto</code> sabe cual es el objeto actual del agregado y puede calcular el objeto siguiente en el recorrido.</p>
</li>
</ul>
</div>
<h4 id="iterator-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron Iterator tiene tres consecuencias importantes:</p>
<ol class="num" >
<li>
<p><em>Permite variaciones en el recorrido de un agregado.</em> Los agregados complejos pueden recorrerse de muchas formas. Por ejemplo, la generacion de codigo y la comprobacion de tipos implican recorrer arboles de analisis sintactico. La generacion de codigo puede recorrer dicho arbol de analisis sintactico en-orden o en pre-orden. Los iteradores facilitan cambiar el algoritmo de recorrido: basta con sustituir la instancia de iterador por otra diferente. Tambien se pueden definir subclases de <code>Iterador</code> para permitir nuevos recorridos.</p>
</li>
<li>
<p><em>Los iteradores simplifican la interfaz <code>Agregado</code>.</em> La interfaz de recorrido de <code>Iterador</code> elimina la necesidad de una interfaz parecida en <code>Agregado</code>, simplificando asi la interfaz del agregado.</p>
</li>
<li>
<p><em>Se puede hacer mas de un recorrido a la vez sobre un agregado.</em> Un iterador mantiene su propio estado del recorrido. Por tanto, es posible estar realizando mas de un recorrido al mismo tiempo.</p>
</li>
</ol>
</div>
<h4 id="iterator-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>El patron Iterator tiene muchas variantes y alternativas de implementacion. A continuacion se muestran algunas de las mas importantes. Los pros y los contras muchas veces dependen de las estructuras de control proporcionadas por el lenguaje. Algunos lenguajes (CLU [<a href="#lg86" >LG86</a>], por ejemplo) llegan a incluir este patron directamente.</p>
<ol class="num" >
<li>
<p><em>¿Quien controla la iteracion?</em> Una cuestion fundamental es decidir que participante controla la iteracion, si el iterador o el cliente que lo usa. Cuando es el cliente quien controla la iteracion, el iterador se denomina iterador externo, y cuando es el iterador quien la controla, se dice que el iterador es un iterador interno.<span class="note" ><sup><a href="#43" >43</a></sup></span> Los clientes que usan un iterador externo deben avanzar en el recorrido y pedirle explicitamente al iterador el siguiente elemento. En el caso contrario, el cliente maneja un iterador intero y este aplica esa operacion a cada elemento del agregado.</p>
<p>Los iteradores externos son mas flexibles que los internos. Por ejemplo, resulta facil comparar dos colecciones para ver si son iguales usando un iterador externo, pero esto misma es practicamente imposible con iteradores internos. Los iteradores internos son especialmente debiles en un lenguaje como C++, que no proporciona funciones anonimas, cierres o reanudaciones como si hacen Smalltalk y CLOS. Pero, por otro lado, los iteradores internos son mas faciles de usar, ya que definen la logica de iteracion por nosotros.</p>
</li>
<li>
<p><em>¿Quien define el algoritmo de recorrido?</em> El iterador no es el unico lugar donde se puede definir el algoritmo de recorrido. El agregado podria definir el algoritmo de recorrido y usar el iterador para almacenar solo el estado de la iteracion. A este tipo de iterador lo denominamos <b>cursor</b>, ya que se limita a apuntar a la posicion actual del agregado. Un cliente invocara a la operacion <code>Siguiente</code> sobre el agregado con el cursor como parametro, y la operacion <code>Siguiente</code> cambiara el estado del cursor.<span class="note" ><sup><a href="#44" >44</a></sup></span></p>
<p>Si el iterador es el responsable del algoritmo de recorrido, entonces es facil usar diferentes algoritmos de iteracion sobre el mismo agregado, y tambien puede ser mas facil reutilizar el mismo algoritmo sobre diferentes agregados. Por otro lado, el algoritmo de recorrido puede necesitar acceder a las variables privadas del agregado. Si es asi, poner el algoritmo de recorrido en el iterador violaria la encapsulacion del agregado.</p>
</li>
<li>
<p><em>¿Como es de robusto el iterador?</em> Puede ser peligroso modificar un agregado mientras lo estamos recorriendo. Si se añaden o borran elementos del iterador podriamos acabar accediendo dos veces a un elemento o a uno que ya no existe. Uno solucion sencilla es copiar el agregado y recorrer la copia, pero eso es demasiado costoso como para hecerlo siempre.</p>
<p>Un <b>iterador robusto</b> garantiza que las inserciones y borrados no interfieran con el recorrido, y lo hace sin copiar el agregado. Hay muchas formas de implementar iteradores robustos. La mayoria se basan en registrar el iterador con el agregado. Al insertar o borrar, el agregado ajusta el estado interno de los iteradores que han producido, o mantiene informacion internamente para garantizar un recorrido apropiado.</p>
<p>Kofler proporciona una buena discusion acerca de como estan implementados los iteradores robustos en ET++ [<a href="#kof93" >Kof93</a>]. Murray examina la implemantacion de iteradores robustos para la clase <code>List</code> de USL StandardComponents [<a href="#mur93" >Mur93</a>].</p>
</li>
<li>
<p><em>Operaciones adicionales de <code>Iterador</code>.</em> La interfaz minima de <code>Iterador</code> consiste en las operaciones <code>Primero</code>, <code>Siguiente</code>, <code>HaTerminado</code> y <code>ElementoActual</code>.<span class="note" ><sup><a href="#45" >45</a></sup></span> Podrian ser utiles algunas operaciones adicionales. Por ejemplo, los ageregados ordenados pueden tener una operacion <code>Anterior</code> que posicione el iterador en el elemento anterior. Una operacion <code>IrA</code> es util para ordenar o indexar colecciones. <code>IrA</code> posiciona el iterador en un objeto que cumpla el criterio especificado.</p>
</li>
<li>
<p><em>Usar iteradores polimorficos en C++.</em> Los iteradores polimorficos tienen un coste. Necesitan que el objeto iterador sea creado dinamicamente por un metodo de fabricacion. Por tanto deberian usarse solo cuando hay necesidad de polimorfismo. En caso contrario, es mejor usar iteradores concretos, que pueden crearse en la pila.</p>
<p>Los iterador polimorficos tienen otro inconveniente: el cliente es el responsable de borrarlos. Esto es propenso a errores, ya que es facil olvidarse de liberar la memoria asignada a un iterador cuando se ha terminado de usarlo. Eso es especialmente probable cuando en una operacion hay multiples puntos de salida. Y si se lanza una excepcion, el objeto iterador nunca se liberara.</p>
<p>El patron <a href="#proxy" >Proxy</a> proporciona un remedio para esto. Podemos usar un proxy en la memoria de pila como sustituto del iterador real. El proxy elimina el iterador en su destructor. Asi, cuando el proxy garantiza una limpieza adecuada, incluso en el caso de que se produzcan excepciones. esta es una aplicacion de la conocida tecnica de C++ <q>asignacion de recursos en inializacion</q> [<a href="#es90" >ES90</a>]. El Codigo de Ejemplo ofrece un ejemplo de esto.</p>
</li>
<li>
<p><em>Los iteradores pueden tener un acceso restringido.</em> Podemos ver a un iterador como una extension del agregado que lo crea. El iterador y el agregado estan fuertemento acoplados. En C++ se puede expresar esta estrecha relacion haciendo que el iterador sea un clase <code>friend</code> de su agregado. En ese caso ya no es necesario definir operaciones en el agregado cuyo unico proposito es permitir a los iteradores implementar el recorrido de manera eficiente.</p>
<p>Sin embargo, este acceso restringido puede dificultar la definicion de nuevos recorridos, ya que requerira cambiar la interfaz del agregado para añadir otra clase de amiga. Para evitar este problema, la clase <code>Iterador</code> puede incluir operaciones de tipo <code>protected</code> para acceder a los miembros importantes, pero no estan disponibles publicamente, del agregado. Las subclases de <code>Iterador</code> (y <em>solo</em> ellas) pueden usar estas operaciones protegidas para obtener un acceso restringido al agregado.</p>
</li>
<li>
<p><em>Iteradores en lugar de compuestos.</em> Los iteradores externos pueden ser dificiles de implementar sobre estructuras agregadas recursivas, como las del patron <a href="#composite" >Composite</a>, ya que una posicion de la estructura puede abarcar muchos niveles de agregados anidados. Por tanto, un iterador externo tiene que guardar una ruta a traves del <code>Compuesto</code> para saber cual es el objeto actual. A veces es mas facil usar un iterador interno. Este puede guardar la posicion actual simplemente llamandose a si mismo de forma recursiva, por lo que la ruta estara guardada implicitamente en la pila de llamadas.</p>
<p>Si los nodos de un <code>Compuesto</code> tienen interfaz para ir de un nodo a sus hermanos, padres e hijos, entonces un iterador basado en un cursor puede ofrecer una alternativa mejor. El cursor solo necesita conocer al nodo actual; puede apoyarse en la interfaz del nodo para recorrer el compuesto.</p>
<p>Los compuestos muchas veces tienen que ser recorridos de mas de una manera. Son frecuentes los recorridos en preorden, postorden, enorden y primero-en-anchura. Se puede permitir cada tipo de recorrido con una clase diferente de iterador.</p>
</li>
<li>
<p><em>Iteradores nulos.</em> Un <code>IteradorNulo</code> es un iterador degenerado que ayuda a manejar las condiciones limite. Por definicion, un <code>IteradorNulo</code> <em>simpre</em> acaba el recorido; esto es, su operacion <code>HaTerminado</code> siempre se evalua a verdadero.</p>
<p><code>IteradorNulo</code> puede facilitar el recorrido de agregados de estructuras de arbol (como los compuestos). En cada punto del recorrido podemos pedirle al elemento actual un iterador para sus hijos. Los elementos agregados devuelven, como norma general, un iterador concreto. Pero los elementos hoja devuelven una instancia de <code>IteradorNulo</code>. Esto nos permite implementar el recorrido sobre la estructura completa de un modo uniforme.</p>
</li>
</ol>
</div>
<h4 id="iterator-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Examinaremos la implementacion de una clase <code>Lista</code> simple, la cual forma parte de nuestra biblioteca basica (<a href="#apendice-c" >Apendice C</a>). se mostraran dos implementaciones de <code>Iterador</code>, una  para recorrer la <code>Lista</code> de principio a fin y otra para recorrerla hacia atras (la biblioteca solo permite el primero de estos recorridos). A continuacion se muestra como usar estos iteradores y como evitar atarse a una determinada implementacion. Tras todo eso, se cambia el diseño para asegurar que los iteradores se borran correctamente. El ultimo ejemplo muestra un iterador interno y lo compara con su equivalente externo.</p>
<ol class="num" >
<li>
<p><em>Interfaces <code>Lista</code> e <code>Iterador</code>.</em> Veamos en primer lugar la parte de la interfaz de <code>Lista</code> que tiene que ver con la implementacion de los iteradores. En el <a href="Apendice-C" ><span class="path" >Apendice C</span></a> puede verse la interfaz completa.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Lista</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Lista</span><span class="p">(</span><span class="kt">long</span> <span class="n">tamano</span> <span class="o">=</span> <span class="n">CAPACIDAD_PREDETERMINADA_LISTA</span><span class="p">);</span>

    <span class="kt">long</span> <span class="nf">Contar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">Elemento</span><span class="o">&amp;</span> <span class="n">Obtener</span><span class="p">(</span><span class="kt">long</span> <span class="n">indice</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>La clase <code>Lista</code> proporciona, mediante su interfaz publica, un modo razonablemente eficiente de permitir la iteracion. Basta con implementar ambos recorridos. De modo que no hay necesidad de dar a los iteradores un acceso restringido a la estructura de datos subyacente; es decir, las clases de los iteradores no son amigas de <code>Lista</code>. Para permitir el uso transparente de diferentes recorridos definimos una clase abstracta <code>Iterador</code>, que define la interfaz del iterador.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Iterador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Primero</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Siguiente</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">HaTerminado</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Elemento</span> <span class="nf">ElementoActual</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Iterador</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
</li>
<li>
<p><em>Implementaciones de las subclases de <code>Iterador</code>.</em> <code>IteradorLista</code> es una subclase de <code>Iterador</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IteradorLista</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">IteradorLista</span><span class="p">(</span><span class="k">const</span> <span class="n">Lista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">unaLista</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Primero</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Siguiente</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">HaTerminado</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Elemento</span> <span class="nf">ElementoActual</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">const</span> <span class="n">Lista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">_lista</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">_actual</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>La implementacion de <code>IteradorLista</code> es sencilla. Esta guarda la <code>Lista</code> junto con el indice <code>_actual</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;::</span><span class="n">IteradorLista</span> <span class="p">(</span>
    <span class="k">const</span> <span class="n">Lista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">unaLista</span>
<span class="p">)</span> <span class="o">:</span> <span class="n">_lista</span><span class="p">(</span><span class="n">unaLista</span><span class="p">),</span> <span class="n">_actual</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre>
<p><code>Primero</code> posiciona el iterador en el primer elemento:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;::</span><span class="n">Primero</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_actual</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p><code>Siguiente</code> avanza hasta el siguiente elemento:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;::</span><span class="n">Siguiente</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_actual</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p><code>HaTerminado</code> comprueba si el indice se refiere a un elemento de la <code>Lista</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;::</span><span class="n">HaTerminado</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_actual</span> <span class="o">&gt;=</span> <span class="n">_lista</span><span class="o">-&gt;</span><span class="n">Contar</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Por ultimo, <code>ElementoActual</code> devuelve el elemento situado en la posicion dada por el indice actual. Si la iteracion ya ha termindo se lanza una excepcion <code>IteradoFueraDeLimites</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="n">Elemento</span> <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;::</span><span class="n">ElementoActual</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">HaTerminado</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="n">IteradorFueraDeLimites</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_lista</span><span class="o">-&gt;</span><span class="n">Obtener</span><span class="p">(</span><span class="n">_actual</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>La implementacion de <code>IteradorListaHaciaAtras</code> es identica, salvo que su operacion <code>Primero</code> posiciona <code>_actual</code> en el final de la lista, y <code>Siguiente</code> va disminuyendo <code>_actual</code> hasta llegar al primer elemento.</p>
</li>
<li>
<p><em>Usar los iteradores.</em> Supongamos que tenemos una <code>Lista</code> de objetos <code>Empleado</code> y queremos imprimir todos los empleados que contiene. La clase <code>Empleado</code> permite esto con una operacion <code>Imprimir</code>. Para imprimir la lista, definimos una operacion <code>ImprimirEmpleados</code> que toma como parametros un iterador, al cual usa para recorrer e imprimir la lista.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="nf">ImprimirEmpleados</span> <span class="p">(</span><span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">Primero</span><span class="p">();</span> <span class="o">!</span><span class="n">i</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">i</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Imprimir</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Puesto que tenemos iteradores para los recorridos hacia atras y ahacia delante, podemos reutilizar esta operacion para que muestre los empleados en ambos sentidos.</p>
<pre class="code" ><code class="chroma" ><span class="n">Lista</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;*</span> <span class="n">empleados</span><span class="p">;</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;</span> <span class="n">haciaDelante</span><span class="p">(</span><span class="n">empleados</span><span class="p">);</span>
<span class="n">IteradorListaHaciaAtras</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;</span> <span class="n">haciaAtras</span><span class="p">(</span><span class="n">empleados</span><span class="p">);</span>

<span class="n">ImprimirEmpleados</span><span class="p">(</span><span class="n">haciaDelante</span><span class="p">);</span>
<span class="n">ImprimirEmpleados</span><span class="p">(</span><span class="n">haciaAtras</span><span class="p">);</span>
</code></pre>
</li>
<li>
<p><em>Evitar ajustarse a una implementacion de lista en concreto.</em> Pensemos en como una variante lista con saltos de <code>Lista</code> afectaria a nuestro codigo de iteracion. Una subclase de <code>Lista</code>, <code>ListaConSaltos</code>, debe proporcionar un <code>IteradorListaConSaltos</code> que implemente la interfaz <code>Iterator</code>. Internamente, el <code>iteradorListaConSaltos</code> tiene que mantener algo mas que un indice para hacer la iteracion eficientemente. Pero, dado que <code>IteradorListaConSaltos</code> se ajusta a la interfaz de <code>Iterator</code>, la operacion <code>ImprimirEmpleados</code> tambien puede usarse cuando los empleados se guardan en un objeto <code>ListaConSaltos</code>.</p>
<pre class="code" ><code class="chroma" ><span class="n">ListaConSaltos</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;*</span> <span class="n">empleados</span><span class="p">;</span>
<span class="c1">// ...
</span><span class="c1"></span>
<span class="n">IteradorListaConSaltos</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;</span> <span class="n">iterador</span><span class="p">(</span><span class="n">empleados</span><span class="p">);</span>
<span class="n">ImprimirEmpleados</span><span class="p">(</span><span class="n">iterador</span><span class="p">);</span>
</code></pre>
<p>Si bien este enfoque funciona, seria mejor si no tuvieramos que atarnos a una determinada implementacion de <code>Lista</code>, como por ejemplo <code>ListaConSaltos</code>. Podemos introducir una clase <code>ListaAbstracta</code> para estandarizar la interfaz de lista para diferentes implementaciones de listas, convirtiendose <code>Lista</code> y <code>ListaConSaltos</code> en subclases de <code>ListaAbstracta</code>.</p>
<p>Para permitir la iteracion polimorfica, <code>ListaAbstracta</code> define un metodo de fabricacion <code>CrearIterador</code>, el cual es redefinido por las subclases para devolver su correspondiente iterador:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ListaAbstracta</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">CrearIterador</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>Una alternativa seria definir una clase mezclable (<em>mixin</em>) general, <code>Recorrible</code>, que define la interfaz para crear un iterador. Las clases agregadas puden combinarse con <code>Recorrible</code> para permitir la iteracion polimorfica.</p>
<p><code>Lista</code> redefine <code>CrearIterador</code> para devolver un objeto <code>IteradorLista</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">Lista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;::</span><span class="n">CrearIterador</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Ahora nos encontramos en posicion de escribir el codigo para imprimir los empleados independientemente de una representacion concreta.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// solo sabemos que tenemos una ListaAbstracta
</span><span class="c1"></span><span class="n">ListaAbstracta</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;*</span> <span class="n">empleados</span><span class="p">;</span>
<span class="c1">// ...
</span><span class="c1"></span>
<span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;*</span> <span class="n">iterador</span> <span class="o">=</span> <span class="n">empleados</span><span class="o">-&gt;</span><span class="n">CrearIterador</span><span class="p">();</span>
<span class="n">ImprimirEmpleados</span><span class="p">(</span><span class="o">*</span><span class="n">iterador</span><span class="p">);</span>
<span class="k">delete</span> <span class="n">iterador</span><span class="p">;</span>
</code></pre>
</li>
<li>
<p><em>Asegurarse de que los iteradores son eleminados.</em> Notese que <code>CrearIterador</code> devuelve un objeto iterador recien creado. Somos responsables de borrar dicho objeto. Si nos olvidamos habremos creado un agujero de memoria. Para facilitar la vida a los clientes, proporcionaremos un <code>PunteroIterador</code> que hace de proxy de un iterador. Se ocupa de limpiar el objeto <code>Iterador</code> cuando este se sale de ambito.</p>
<p><code>PunteroIterador</code> siempre se crea en la pila.<span class="note" ><sup><a href="#46" >46</a></sup></span> C++ se encarga de llamar automaticamente a su constructor cuando se borra el iterador real. <code>PunteroIterador</code> sobrecarga tanto <code>operator-&gt;</code> como <code>operator*</code> de modo que un <code>PunteroIterador</code> puede ser tratado exactamente igual que un puntero a un iterador. Los miembros de <code>PunteroIterador</code> se implementan todos en linea; de ese modo no disminuyen el rendimiento.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">PunteroIterador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">PunteroIterador</span><span class="p">(</span><span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">i</span><span class="p">)</span><span class="o">:</span> <span class="n">_i</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">PuenteroIterador</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">_i</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_i</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">_i</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// deshabilita la copia y la asignacion para evitar
</span><span class="c1"></span>    <span class="c1">// borrados multiples de _i:
</span><span class="c1"></span>
    <span class="n">PunteroIterador</span><span class="p">(</span><span class="k">const</span> <span class="n">PunteroIterador</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">PunteroIterador</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">PunteroIterador</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">_i</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>PunteroIterador</code> nos permite simplificar nuestro codigo de impresion:</p>
<pre class="code" ><code class="chroma" ><span class="n">ListaAbstracta</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;*</span> <span class="n">empleados</span><span class="p">;</span>
<span class="c1">// ...
</span><span class="c1"></span>
<span class="n">PunteroIterador</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;</span> <span class="n">iterador</span><span class="p">(</span><span class="n">empleados</span><span class="o">-&gt;</span><span class="n">CrearIterador</span><span class="p">());</span>
<span class="n">ImprimirEmpleados</span><span class="p">(</span><span class="o">*</span><span class="n">iterador</span><span class="p">);</span>
</code></pre>
</li>
<li>
<p><em>Un <code>IteradorLista</code> interno.</em> Como ejemplo final, echemos un vistazo a una posible implementacion de una clase <code>IteradorLista</code>. En este ejemplo es el iterador quien controla la iteracion, y quien aplica una iteracion a cada elemento.</p>
<p>El problema en este caso es como parametrizar el iterador con la operacion que queremos realizar sobre cada elemento. C++ no proporciona funciones anonimas o cierres que otros lenguajes si proveen para este tipo de tareas. Hay al menos dos opciones: (1) pasar un puntero a una funcion (global o estatica), o (2) apoyarse en la herencia. En el primer caso, el iterador llama a una operacion que una subclase redefine para representar el comportamiento especifico.</p>
<p>Ninguna opcion es perfecta. A menudo queremos acumular el estado durante la iteracion, y las funciones no estan pensadas para eso; tendriamos que usar variables estaticas para recordar el estado. Una subclase de <code>Iterador</code> nos porporciona un lugar apropiado para guardar el estado acumulado, por ejemplo en una variable de instancia. Pero crear una subclase para cada recorrido diferente significa mas trabajo.</p>
<p>Este es un esbozo de la segunda opcion, usando la herencia. Llamaremos al iterador interno un <code>RecorredorLista</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">RecorredorLista</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">RecorredorLista</span><span class="p">(</span><span class="n">Lista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">unaLista</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">Recorrer</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">ProcesarElemento</span><span class="p">(</span><span class="k">const</span> <span class="n">Elemento</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;</span> <span class="n">_iterador</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>RecorredorLista</code> toma una instancia de <code>Lista</code> como parametro. Interamente usa un <code>IteradorLista</code> externo para hacer el recorrido. <code>Recorrer</code> comienza el recorrido y llama a <code>ProcesarElemento</code> para cada elemento. El iterador interno puede decidir terminar un recorrido devolviendo <code>false</code> en <code>ProcesarElemento</code>. En caso de que el recorrido haya terminad de forma prematura, <code>Recorrer</code> acaba.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="n">RecorredorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;::</span><span class="n">RecorredorLista</span> <span class="p">(</span>
    <span class="n">Lista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">unaLista</span>
<span class="p">)</span> <span class="o">:</span> <span class="n">_iterador</span><span class="p">(</span><span class="n">unaLista</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">RecorredorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;::</span><span class="n">Recorrer</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">resultado</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span>
         <span class="n">_iterador</span><span class="p">.</span><span class="n">Primero</span><span class="p">();</span>
         <span class="o">!</span><span class="n">_iterador</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">();</span>
         <span class="n">_iterador</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">();</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">resultado</span> <span class="o">=</span> <span class="n">ProcesarElemento</span><span class="p">(</span><span class="n">_iterador</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">());</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">resultado</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">resultado</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Usemos ahora un <code>RecorredorLista</code> para imprimir los primeros 10 empleados de nuestra lista de empleados. Para hacer esto tenemos que heredar de <code>RecorredorLista</code> y redefinir <code>ProcesarElemento</code>. Contamos el numero de empleados mostrados en una variable de instancia <code>_contador</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ImprimirNEmpleados</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RecorredorLista</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ImprimirNEmpleados</span><span class="p">(</span><span class="n">Lista</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;*</span> <span class="n">unaLista</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">RecorredorLista</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">unaLista</span><span class="p">),</span>
        <span class="n">_total</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">_contador</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">ProcesarElemento</span><span class="p">(</span><span class="n">Empleado</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_total</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_contador</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="n">ImprimirNEmpleados</span><span class="o">::</span><span class="n">ProcesarElemento</span> <span class="p">(</span><span class="n">Empleado</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_contador</span><span class="o">++</span><span class="p">;</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">Imprimir</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">_contador</span> <span class="o">&lt;</span> <span class="n">_total</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Asi es como <code>ImprimirNEmpleados</code> imprime los primeros 10 empleados de la lista:</p>
<pre class="code" ><code class="chroma" ><span class="n">Lista</span> <span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;*</span> <span class="n">empleados</span><span class="p">;</span>
<span class="c1">// ...
</span><span class="c1"></span>
<span class="n">ImprimirNEmpleados</span> <span class="nf">pa</span><span class="p">(</span><span class="n">empleados</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">pa</span><span class="p">.</span><span class="n">Recorrer</span><span class="p">();</span>
</code></pre>
<p>Notese como el cliente no especifica el bucle de iteracion. Toda la logica de iteracion puede ser reutilizada. Esta es la principal ventaja de un operador interno. Es algo mas de trabajo que con un iterador externo, ya que tenemos que definir una nueva clase. Comparese esto con el uso de un iterador externo:</p>
<pre class="code" ><code class="chroma" ><span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Empleado</span><span class="o">*&gt;</span> <span class="n">i</span><span class="p">(</span><span class="n">empleados</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">contador</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">Primero</span><span class="p">();</span> <span class="o">!</span><span class="n">i</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">contador</span><span class="o">++</span><span class="p">;</span>
    <span class="n">i</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">imprimir</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">contador</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Los iteradores internos pueden encapsular diferentes tipos de iteracion. Por ejemplo, <code>RecorredorListaConFiltro</code> encapsula una iteracion que procesa solo aquellos elementos que verifican una comprobacion:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">RecorredorListaConFiltro</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">RecorredorListaConFiltro</span><span class="p">(</span><span class="n">lista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">unaLista</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">Recorrer</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">ProcesarElemento</span><span class="p">(</span><span class="k">const</span> <span class="n">Elemento</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">ComprobarElemento</span><span class="p">(</span><span class="k">const</span> <span class="n">Elemento</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;</span> <span class="n">_iterador</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>Esta interfaz es la misma que la de <code>RecorredorLista</code> salvo por una funcion miembro añadida, <code>ComprobarElemento</code>, que define la comprobacion. Las subclases redefinen <code>ComprobarElemento</code> para especificar la comprobacion.</p>
<p><code>Recorrer</code> decide continuar el recorrido basandose en el resultado de la comprobacion:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">RecorredorListaConFiltro</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;::</span><span class="n">Recorrer</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">resultado</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span>
         <span class="n">_iterador</span><span class="p">.</span><span class="n">Primero</span><span class="p">();</span>
         <span class="o">!</span><span class="n">_iterador</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">();</span>
         <span class="n">_iterador</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">();</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ComprobarElemento</span><span class="p">(</span><span class="n">_iterador</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">()))</span> <span class="p">{</span>
            <span class="n">resultado</span> <span class="o">=</span> <span class="n">ProcesarElemento</span><span class="p">(</span><span class="n">_iterador</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">());</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">resultado</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">resultado</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Una variante de esta clase podria definir <code>Recorrer</code> para que terminase si al menos un elemento satisface la comprobacion.<span class="note" ><sup><a href="#47" >47</a></sup></span></p>
</li>
</ol>
</div>
<h4 id="iterator-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Los iteradores son frecuentes en los sistemas orientados a objetos. La mayoria de las bibliotecas de clases ofrecen iteradores de una forma u otra.</p>
<p>El siguiente es un ejemplo de los componentes de Booch [<a href="#boo94" >Boo94</a>], una popular biblioteca de clases de colecciones. Proporciona dos implementaciones de una cola, una para un tamaño fijo y otra que puede crecer dinamicamente. La interfaz de la cola la define una clase abstracta <code>Queue</code>. Para permitir iterar polimorficamente sobre las diferentes implementaciones de colas, el iterador de la cola se implementa en terminos de la interfaz de la clase abstracta <code>Queue</code>. Esta variacion tiene la ventaja de que no se necesita un metodo de fabricacion para pedirle a las implementaciones de colas su iterador apropiado. No obstante, es necesario que la interfaz de la clase abstracta <code>Queue</code> sea lo bastante potente como para implementar de manera eficiente el iterador.</p>
<p>En Smalltalk no hay que definir explicitamente los iteradores. Las clases de colecciones estandar (<code>Bag</code>, <code>Set</code>, <code>Dictionary</code>, <code>OrderedCollection</code>, <code>String</code>, etc.) definen un metedo <code>do:</code> como un iterador interno, el cual toma un bloque (es decir, un cierre) como parametro. Cada parametro  de la coleccion se liga a la variable local del bloque; a continuacion se ejecuta el bloque. Smalltalk tambien incluye un conjunto de clases <code>Stream</code> que permiten una interfaz similar a un iterador. <code>ReadStream</code> es basicamente un iterador, y puede actuar como un iterador externo para todas las colecciones secuenciales. No hay iteradores externos estandar para las colecciones no secuenciales como <code>Set</code> y <code>Dictionary</code>.</p>
<p>Las clases contenedoras de ET++ proporcionan los iteradores polimorficos y el Proxy de limpieza descritos anteriormente [<a href="#wgm88" >WGM88</a>]. Las clases del framework de editores graficos usan iteradores basados en cursores [<a href="#vl90" >VL90</a>].</p>
<p>ObjectWindows 2.0 [<a href="#bor94" >Bor94</a>] provee una jerarquia de clases de iteradores para conectores. Se puede iterar sobre diferentes tipos de conectores del mismo modo. La sintaxis de iteracion de ObjectWindow se basa en sobrecargar el operader de incremento postfijo, <code>++</code>, para avanzar en la iteracion.</p>
</div>
<h4 id="iterator-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p><a href="#composite" >Composite</a>: los iteradores suelen aplicarse a estructuras recursivas como los compuestos.</p>
<p><a href="Factory-Method" >Factory Method</a>: los iteradores polimorficos se basan en metodos de fabricacion para crear instancias de las subclases apropiadas de Iterator.</p>
<p>El patron <a href="#memento" >Memento</a> suele usarse conjuntamente con el patron Iterator. Un iterador puede usar un memento para representar el estado de una iteracion. El iterador almacena el memento internamente.</p>
</div>
<h3 id="mediator" >Mediator</h3>
<h4 id="mediator-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Define un objeto que encapsula como interactuan una serie de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros explicitamente, y permite variar la interaccion entre ellos de forma independiente.</p>
</div>
<h4 id="mediator-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>los diseñadores orientados a objetos promueven la distribucion de comportamientos entre objetos. Dicha distribucion puede dar lugar a una estructura de objetos con muchas conexiones entre ellos; en el peor de los casos, cada objeto acaba por conocer a todos los demas.</p>
<p>Aunque dividir un sistema en muchos objetos suele mejorar la reutilizacion, la proliferacion de interconexiones tiende a reducir esta de nuevo. Tener muchas interconexiones hace que sea menos probable que un objeto pueda funcionar sin la ayuda de otros ––el sistema se comporta como si fuera monolitico––. Mas aun, puede ser dificil cambiar el comportamiento del sistema de manera significativa, ya que el comportamiento se encuentra distribuido en muchos objetos. Como resultado, podemos vernos forzados a definir muchas subclases para personalizar el comportamiento del sistema.</p>
<p>Sea, por ejemplo, la implementacion de cuadros de dialogo en una interfaz grafica de usuario. Un cuadro de dialgo usa una ventana para presentar una coleccion de utiles<span class="note" ><sup><a href="#28" >28</a></sup></span> tales como botones, menus y campos de entrada, como se muestra a acontinuacion:</p>
<figure>
<img src="img/100.png" />
</figure>
<p>Muchas veces hay dependencias entre los utiles del dialogo. Por ejemplo, un boton esta desactivado cuando esta vacio un capo de entrada determinado. Seleccionar una entrada de una lista de opciones, llamada <b>lista desplegable</b> (<em>list box</em>), puede cambiar el contenido de un campo de entrada. A la inversa, teclear texto en el campo de entrada puede seleccionar automaticamente una o mas entradas de la lista desplegable. En cuanto haya texto en el campo de entrada pueden activarse otros botones para permitir al usuario hacer algo con dicho texto, como cambiar o borrar aquello a lo que se refiere.</p>
<p>Distintos cuadros de dialogo tendran distintas dependencias entre utiles. Asi, aunque los dialoges muestran los mismo tipos de utiles, no pueden reutilizar directamente las clases de utiles de las que se dispone; se ven obligados a personalizarlas para que reflejen las dependencias especificas de cada dialogo. Personalizarlas una a una mediante la herencia seria tedioso, ya que hay muchas clases involucradas.</p>
<p>Estos problemas pueden ser evitados encapsulando el comportamiento colectivo en un objeto aparte llamado <b>mediador</b>. Un mediador es responsable de controlar y coordinar las interaciones entre un grupo de objetos. El mediador hace las veces de un intermediario que evita que los objetos del grupo se refieran unos a otros explicitamente. Los objetos solo conocen al mediador, reduciendo asi el numero de interconexiones.</p>
<p>Por ejemplo, <code>DirectorDialogoFuente</code> podria ser el mediador entre los utiles de un cuardro de dialogo. Un objeto <code>DirectorDialogoFuente</code> conoce a los utiles de un dialogo y coordina su interaccion. Funciona como un concentrador<span class="note" ><sup><a href="#48" >48</a></sup></span> de comunicaciones para utiles:</p>
<figure>
<img src="img/101.png" />
</figure>
<p>El siguiente diagrama de interaccion ilustra como cooperan los objetos para manejar un cambio en la seleccion de una lista:</p>
<figure>
<img src="img/102.png" />
</figure>
<p>Esta es la sucesion de eventos que tienen lugar cuando la seleccion de una lista pasa a un campo de entrada:</p>
<ol class="num" >
<li>
<p>La lista desplegable le dice a su director que ha cambiado.</p>
</li>
<li>
<p>El director obtiene la seleccion de la lista.</p>
</li>
<li>
<p>El director le pasa la seleccion al campo de entrada.</p>
</li>
<li>
<p>Ahora que el campo de entrada contiene algo de texto, el director activa uno o varios botones que permitan inicializar una accion (por ejemplo, <q>negrita</q> o <q>cursiva</q>).</p>
</li>
</ol>
<p>Notese como el director media entre la lista y el campo de entrada. Los utiles se comunican unos con otros solo indirectamente, a travez del director. No tienen que saber nada de los otros; al unico al que conocen es al director. Ademos dado que el comportamiento se encuentra localizado en una clase, puede cambiarse o reemplazarse extendiendo o sustituyendo esa clase.</p>
<p>Asi es como la abstraccion <code>DirectorDialogoFuente</code> puede integrarse en una biblioteca de clases:</p>
<figure>
<img src="img/103.png" />
</figure>
<p><code>DirectorDialogo</code> es una clase abstracta que define el comportamiento general de un dialogo. Los clientes llaman a la operacion <code>MostrarDialogo</code> para mostrar el dialogo en la pantalla. <code>CrearUtiles</code> es una operacion abstracta que crea los utiles de un dialogo. <code>UtilModificado</code> es otra operacion abstracta a la que llaman los utiles para informar a su director de que han cambiado. Las subclases de <code>DirectorDialogo</code> redefinen <code>CrearUtiles</code> para crear los utiles apropiados, asi como <code>UtilModificado</code> para manejar los cambios.</p>
</div>
<h4 id="mediator-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Mediator cuando</p>
<ul>
<li>
<p>un conjunto de objetos se comunican de forma bien definida, pero compleja. Las interdependencias resultantes no estan estructuradas y son dificiles de comprender.</p>
</li>
<li>
<p>es dificil reutilizar un objeto, ya que este se refiere a otros muchos objetos, con los que se comunica.</p>
</li>
<li>
<p>un comportamiento que esta distribuido entre varias clases deberia poder ser adaptado sin necesidad de una gran cantidad de subclases.</p>
</li>
</ul>
</div>
<h4 id="mediator-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/104.png" />
</figure>
<p>Una estructura de objetos tipica podria parecerse a esta:</p>
<figure>
<img src="img/105.png" />
</figure>
</div>
<h4 id="mediator-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Mediador</code> (<code>DirectorDialogo</code>)</p>
<ul>
<li>
<p>define una interfaz para comunicarse con sus objetos <code>Colega</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>MediadorConcreto</code> (<code>DirectorDialogoFuente</code>)</p>
<ul>
<li>
<p>implementa el comportamiento cooperativo coordinado objetos <code>Colega</code>.</p>
</li>
<li>
<p>conoce a sus <code>Colega</code>s.</p>
</li>
</ul>
</li>
<li>
<p><b>clases</b> <code>Colega</code> (<code>ListaDesplegable</code>, <code>CampoDeEntrada</code>)</p>
<ul>
<li>
<p>cada clase <code>Colega</code> conoce a su objeto <code>Mediador</code>.</p>
</li>
<li>
<p>cada <code>Colega</code> se comunica con su mediador cada vez que, de no existir este, se hubiera comunicado con otro <code>Colega</code>.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="mediator-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p>Los Colegas envian y reciber peticiones a traves de un Mediador. El mediador implementa el comportamiento cooperativo encaminando estas peticiones a los Colegas apropiados.</p>
</div>
<h4 id="mediator-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron Mediador tiene las siguientes ventajas e inconvenientes:</p>
<ol class="num" >
<li>
<p><em>Reduce la herencia.</em> Un mediador localiza el comportamiento que de otra manera estaria distribuido en varios objetos. Para cambiar este comportamiento solo es necesario crear una subclase del Mediador; las clases <code>Colega</code> puden ser reutilizadas tal cual.</p>
</li>
<li>
<p><em>Desacopla a los Colegas.</em> Un mediador promueve un bajo acoplamiento entre Colegas. Las clases <code>Colega</code> pueden usarse y modificarse de forma independiente.</p>
</li>
<li>
<p><em>Simplifica los protocolos de los objetos.</em> Un mediador sustituye interacciones muchos-a-muchos por interacciones una-a-muchos entre el mediador y sus colegas. Las relaciones uno-a-muchos son mas faciles de compreder, mantener y extender.</p>
</li>
<li>
<p><em>Abstrae como cooperan los objetos.</em> Hacer de la mediacion un concepto independiente y encapsularla en un objeto permite centrarse en como interactuan los objetos en vez de en su comportamiento individual. Eso ayuda a clarificar como interactuarn los objetos de un sistema.</p>
</li>
<li>
<p><em>Centrar el control.</em> El patron Mediator cambia complejidad de interaccion por complejidad en el mediador. Dado que un mediador encapsula protocolos, puede hacerse mas complejo que cualquier <code>Colega</code> individual. Esto puede hacer del mediador un monolito dificil de mantener.</p>
</li>
</ol>
</div>
<h4 id="mediator-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Son pertinentes los siguientes detalles de implementacion para el patron Mediator:</p>
<ol class="num" >
<li>
<p><em>Omitir la clase abstracta <code>Mediador</code>.</em> No es necesario definir una clase abstracta <code>Mediador</code> cuando los Colegas solo trabajan con un mediador. El acoplamiento abstracto proporcionado por la clase <code>Mediador</code> permite que los <code>Colega</code>s trabajen con diferentes subclases de <code>Mediador</code>, y viceversa.</p>
</li>
<li>
<p><em>Comunicacion <code>Colega</code>-<code>Mediador</code>.</em> Los Colegas tienen que comunicarse con su mediador cuando tiene lugar un evento de interes. Un enfoque es implementar el Mediador como un Observador, usando el patron <a href="#observer" >Observer</a>. Las clases <code>Colega</code> hacer de <code>Sujeto</code>, enviando notificaciones al mediador cada vez que cambia su estado. El mediador responde propagando los efectos del cambio a otros Colegas.</p>
<p>Otro enfoque define en el Mediador una interfaz de notificacion especializada que permite a los Colegas ser mas directos en su comunicacion. Smalltalk/V para Windows usa una forma de delegacion: cuando se comunica con el mediador, un Colega se pasa a si mismo como parametro, permitiendo al mediador identificar al emisor. El Codido de Ejemplo usa este enfoque y la implementacion de Smalltalk/V se examina mas adelante en los Usos Conocidos.</p>
</li>
</ol>
</div>
<h4 id="mediator-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Usaremos un <code>DirectorDialogo</code> para implementar el cuadro de dialogo de seleccion del tipo fuente que se mostro en la Motivacion. La clase abstracta <code>Directordialogo</code> define la interfaz para los directores.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">DirectorDialogo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">DirectorDialogo</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">MostrarDialogo</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">UtilModificado</span><span class="p">(</span><span class="n">Util</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="n">DirectorDialogo</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">CrearUtiles</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>Util</code> es la clase base abstracta para los utiles. Un util conoce a su director.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Util</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Util</span><span class="p">(</span><span class="n">DirectorDialogo</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Modificado</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ManejarRaton</span><span class="p">(</span><span class="n">EventoRaton</span><span class="o">&amp;</span> <span class="n">evento</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">DirectorDialogo</span><span class="o">*</span> <span class="n">_director</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>Modificado</code> llama a la operacion <code>UtilModificado</code> del director. Los utiles llaman a <code>UtilModificado</code> sobre su director para informarle de un evento significativo.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Util</span><span class="o">::</span><span class="n">Modificado</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_director</span><span class="o">-&gt;</span><span class="n">UtilModificado</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Las subclases de <code>DirectorDialogo</code> redefinen <code>UtilModificado</code> para afectar a los utiles apropiados. El util pasa una referencia a si mismo como parametro a <code>UtilModificado</code>, para que el director pueda identificar al util modificado. Las subclases de <code>DirectorDialogo</code> redefinen el metodo virtual pero <code>CrearUtiles</code> para construir los utiles del dialogo.</p>
<p><code>ListaDesplegable</code>, <code>CampoDeEntrada</code> y <code>Boton</code> son subclases de <code>Util</code> para elementos especializados de la interfaz de usuario. <code>ListaDesplegable</code> proporciona una operacion <code>ObtenerSeleccion</code> para obtener la seleccion actual, y la operacion <code>EstablecerTexto</code> de <code>CampoDeEntrada</code> permite poner texto en el campo.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ListaDesplegable</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Util</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListaDesplegable</span><span class="p">(</span><span class="n">DirectorDialogo</span><span class="o">*</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">ObtenerSeleccion</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EstablecerLista</span><span class="p">(</span><span class="n">Lista</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;*</span> <span class="n">elementos</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ManejarRaton</span><span class="p">(</span><span class="n">EventoRaton</span><span class="o">&amp;</span> <span class="n">evento</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>

<span class="k">class</span> <span class="nc">CampoDeEntrada</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Util</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">CampoDeEntrada</span><span class="p">(</span><span class="n">DirectorDialogo</span><span class="o">*</span><span class="p">);</span>

    <span class="n">virtua</span> <span class="kt">void</span> <span class="nf">EstablecerTexto</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">texto</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">ObtenerTexto</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ManejarRaton</span><span class="p">(</span><span class="n">EventoRaton</span><span class="o">&amp;</span> <span class="n">evento</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p><code>Boton</code> es un util sencillo que llama a <code>Modificado</code> cada vez que es pulsado. Esto se hace en la implementacion de <code>ManejarRaton</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Boton</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Util</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Boton</span><span class="p">(</span><span class="n">DirectorDialogo</span><span class="o">*</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EstablecerTexto</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">texto</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ManejarRaton</span><span class="p">(</span><span class="n">EventoRaton</span><span class="o">&amp;</span> <span class="n">evento</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>

<span class="kt">void</span> <span class="n">Boton</span><span class="o">::</span><span class="n">ManejarRaton</span> <span class="p">(</span><span class="n">EventoRaton</span><span class="o">&amp;</span> <span class="n">evento</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">Modificado</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>La clase <code>DirectorDialogoFuente</code> media entre los utiles del cuadro de dialogo. <code>DirectorDialogoFuente</code> es una subclase de <code>DirectorDialogo</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">DirectorDialogoFuente</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DirectorDialogo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">DirectorDialogoFuente</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">DirectorDialogoFuente</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">UtilModificado</span><span class="p">(</span><span class="n">Util</span><span class="o">*</span><span class="p">);</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">CrearUtiles</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Boton</span><span class="o">*</span> <span class="n">_aceptar</span><span class="p">;</span>
    <span class="n">Boton</span><span class="o">*</span> <span class="n">_cancelar</span><span class="p">;</span>
    <span class="n">ListaDesplegable</span><span class="o">*</span> <span class="n">_fuenteLista</span><span class="p">;</span>
    <span class="n">CompoDeEntrada</span><span class="o">*</span> <span class="n">_nombreFuente</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>DirectorDialogoFuente</code> se ocupa de los utiles que muestra. Redefine <code>CrearUtiles</code> para crear los utiles e inicializar sus referencias para que apunten a el:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">DirectorDialogoFuente</span><span class="o">::</span><span class="n">CrearUtiles</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_aceptar</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Boton</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="n">_cancelar</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Boton</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="n">_fuenteLista</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListaDesplegable</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="n">_nombreFuente</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CampoDeEntrada</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

    <span class="c1">// rellenar la lista con los nombres de fuentes disponibles
</span><span class="c1"></span>
    <span class="c1">// ensambla los utiles en el dialogo
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p><code>UtilModificado</code> garantiza que los utiles trabajen juntos adecuadamente:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">DirectorDialogoFuente</span><span class="o">::</span><span class="n">UtilModificado</span> <span class="p">(</span>
    <span class="n">Util</span><span class="o">*</span> <span class="n">elUtilModificado</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">elUtilModificado</span> <span class="o">==</span> <span class="n">_fuenteLista</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_nombreFuente</span><span class="o">-&gt;</span><span class="n">EstablecerTexto</span><span class="p">(</span><span class="n">_fuenteLista</span><span class="o">-&gt;</span><span class="n">ObtenerSeleccion</span><span class="p">());</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">elUtilModificado</span> <span class="o">==</span> <span class="n">_aceptar</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// aplicar el cambio de fuente y cerrar el dialogo
</span><span class="c1"></span>        <span class="c1">// ...
</span><span class="c1"></span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">elUtilModificado</span> <span class="o">==</span> <span class="n">_cancelar</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// cerrar el dialogo
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>La complejidad de <code>UtilModificado</code> crece proporcionalmente a la complejidad del dialogo. Los dialogos grandes son indeseables por otras razones, por supuesto, pero la complejidad del mediador podria mitigar los beneficios del patron en otras aplicaciones.</p>
</div>
<h4 id="mediator-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Tanto ET++ [<a href="#wgm88" >WGM88</a>] como la biblioteca de clases THINK C [<a href="#sym93b" >Sym93b</a>] usan objetos parecidos a directores como mediadores entre los utiles de los dialogos.</p>
<p>La arquitectura de Smalltalk/V para Windows esta basada en una estructura de mediadores [<a href="#lal94" >LaL94</a>]. En ese entorno, una aplicacion consiste en un objeto <code>Window</code> que contiene un conjunto de paneles. La biblioteca contiene varios objetos <code>Pane</code> predefinidos; ejemplos de estos son <code>TextPane</code>, <code>Listbox</code>, <code>Button</code>, etcetera. Estos paneles pueden usarse sin necesidad de heredar de ellos. Un desarrollador de aplicaciones solo hereda de <code>ViewManager</code>, una clase que es la responsable de realizar la coordinacion entre paneles. <code>ViewManager</code> es el Mediador, y cada panel solo conoce a su gestor de vistas, considerado como el <q>propietario</q> del panel. Los paneles no se refieren unos a otros directamente.</p>
<p>El siguiente diagrama de objetos muestra una instancia de una aplicacion en tiempo de ejecucion:</p>
<figure>
<img src="img/106.png" />
</figure>
<p>Smalltalk/V usa un mecanismo de eventos para la comunicacion <code>Pane</code>-<code>ViewManager</code>. Un panel genera un evento cuando quiere obtener informacion del mediador o cuando quiere informar a este de que ha ocurrido algo significativo. Un evento define un simbolo (por ejemplo, <code>#select</code>) que lo identifica. Para manejar el evento, el gestor de vistas registra el selector de metodo con el panel. Este selector es el manejador de evento; sera invocado cada vez que ocurra un evento.</p>
<p>El codigo siguiente muestra un esbozo de como se crea un objeto <code>ListaPane</code> dentro de una subclase de <code>ViewManager</code> y como <code>ViewManager</code> resgitra un manejador de eventos para el evento <code>#select:</code></p>
<pre class="code" ><code class="chroma" ><span class="bp">self</span> <span class="nf">addSubpane:</span> (<span class="nc">ListPane</span> <span class="nb">new</span>
          <span class="nf">paneName:</span> <span class="s">&#39;miListPane&#39;</span><span class="p">;</span>
          <span class="nf">owner:</span> <span class="bp">self</span><span class="p">;</span>
          <span class="nf">when:</span> <span class="ss">#select</span> <span class="nf">perform:</span> <span class="ss">#listSelect:</span>)<span class="p">.</span>
</code></pre>
<p>Otra aplicacion del patron Mediator es coordinar actualizaciones complejas. Un ejemplo de esto es la clase <code>GestorDeCambios</code> mencionada en el patron <a href="#observer" >Observer</a>. <code>GestorDeCambios</code> hace de mediador entre sujetos y observaderes para evitar actualizaciones redundantes. Cuando un objeto cambia, se notifica al <code>GestorDeCambios</code>, quien coordina la actualizacion notificando a su vez los objetos dependientes.</p>
<p>Una aplicacion similar aparece en el framework de dibujo Unidraw [<a href="#vl90" >VL90</a>], que usa una clase llama CSolver para hacer cumplir las restricciones de conectividad entre <q>conectores</q>. Los objetos de los editores graficos pueden unirse entre si de diferentes formas. Los conectores son utiles en aplicaciones que mantienen la conectividad automaticamente, como editores de diagramas y sistemas de diseño de circuitos. CSolver es un mediador entre conectores, que resuelve las restricciones de conectividad y actualiza las posiciones de los conectores para que las reflejon adecuadamente.</p>
</div>
<h4 id="mediator-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>El patron <a href="#facade" >Facade</a> difiere del Mediator en que abstrae un subsistema de objetos para proporcionar una interfaz mas conveniente. Su protocolo es unidireccional; es decir, los objetos Fachada hacen peticiones a las clases del subsistema pero no a la inversa. Por el contrario, el patron Mediador permite un comportamiento cooperativo que no es proporcionado por los objetos Colegas y el protocolo es multidireccional.</p>
<p>Los Colegas pueden comunicarse con el mediador usando el patron <a href="#observer" >Observer</a>.</p>
</div>
<h3 id="memento" >Memento</h3>
<h4 id="memento-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Representa y externaliza el estado interno de un objeto sin violar la encapsulacion, de forma que este puede volver a dicho estado mas tarde.</p>
</div>
<h4 id="memento-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Token<span class="note" ><sup><a href="#49" >49</a></sup></span></p>
</div>
<h4 id="memento-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>A veces es necesario guardar el estado interno de un objeto. Esto es necesario cuando se implementan casillas de verificacion o mecanismos de deshacer que permiten a los usuarios anular operaciones provisionales y recuperarse de los errores. Debe guardarse informacion del estado en algun sitio para que los objetos puedan volver a su estado anterior. Pero los objetos normalmente encapsulan parte de su estado, o todo, haciendolo inaccesible a otros objetos e imposible de guardar externamente. Exponer este estado violara la encapsulacion, lo que puede comprometer la fiabilidad y extensibilidad de la aplicacion.</p>
<p>Pensemos, por ejemplo, en un editor que permite conectar objetos. Un usuario puede conectar dos rectangulos con una linea, y los rectangulos permanecen conectados cuando el usuario mueve cualquiera de ellos. El editor garantiza que la linea se estira para mantener la conexion.</p>
<figure>
<img src="img/107.png" />
</figure>
<p>Una forma habitual de mantener relaciones de conectividad entre objetos es mediante un sistema de resolucion de problemas. Podemos encapsular esta funcionalidad en un objeto <code>ResolventeDeRestricciones</code>. <code>ResolventeDeRestricciones</code> almacena las conexiones a medida que se van creando estas y genera ecuaciones matematicas que las describen. Cada vez que el usuario hace una conexion o modifica el diagrama resuelve dichas ecuaciones. <code>ResolventeDeRestricciones</code> usa los resultados de sus calculos para volver a colocar los graficos de forma que mantengan las conexiones adecuadas.</p>
<p>Permitir que se puedan deshacer ciertas operaciones en esta aplicacion no es tan sencillo como en un principio podria parecer. Una manera obvia de deshacer una operacion de movimiento es guardar la distancia que se ha movido el objeto desde su posicion original y mover este hacia atras una distancia equivalente. Sin embargo, esto no garantiza que todos los objetos aparezcan como estaban antes. Supongamos que hay algo de holgura en la conexion. En ese caso, mover el rectangulo hacia atras, a su posicion original, no producira necesariamente el efecto deseado.</p>
<figure>
<img src="img/108.png" />
</figure>
<p>En general, la interfaz publica de <code>ResolventeDeRestricciones</code> podria no ser suficente para permitir revertir con presicion sus efectos sobre otros objetos. El mecanismo de deshacer debe trabajar mas estrechamente con <code>ResolventeDeRestricciones</code> para reestablecer el estado previo, pero, por otro lado, tambien deberiamos evitar exponer al mecanismo de deshacer las interioridades de <code>ResolventeDeRestricciones</code>.</p>
<p>Este problema se puede solucionar con el patron Memento. Un memento es un objeto que almacena una instancia del estado interno de otro objeto ––el creador del memento––. El mecanismo de deshacer solicitara un memento al creador cuando necesite comprobar el estado de este. El creador inicializa el memento con informacion que representa su estado actual. Solo el creador puede almacenar y recuperar informacion del memento ––el memento es <q>opaco</q> a otros objetos––.</p>
<p>En el ejemplo del editor grafico que se acaba de describir, el <code>ResolventeDeRestricciones</code> puede actuar como un creador. La siguiente secuencia de eventos representa el proceso de deshacer:</p>
<ol class="num" >
<li>
<p>El editor solicita un memento al <code>ResolventeDeRestricciones</code> como un efecto lateral de la operacion de mover.</p>
</li>
<li>
<p>El <code>ResolventeDeRestricciones</code> crea y devuelve un memento, en este caso una instancia de una clase <code>EstadoDelResolvente</code>. Un memento del <code>EstadoDelResolvente</code> contiene estructuras de datos que describen el estado actual de las ecuaciones y variables internas del <code>ResorventeDeRestricciones</code>.</p>
</li>
<li>
<p>Mas tarde, cuando el usuario deshace la operacion mover, el editor le devuelve al <code>ResolventeDeRestricciones</code> el <code>EstadoDelResolvente</code>.</p>
</li>
<li>
<p>Dependiendo de la informacion del <code>EstadoDelResolvente</code>, el <code>ResolventeDeRestricciones</code> cambia sus estructuras de datos internas para devolver sus ecuaciones exactamente a su estado anterior.</p>
</li>
</ol>
<p>Este acuerdo permite al <code>ResolventeDeRestricciones</code> confiar a otros objetos la informacion que necesita para volver a un estado previo sin exponer sus estructuras y reprepresentaciones internas.</p>
</div>
<h4 id="memento-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Memento cuando</p>
<ul>
<li>
<p>hay que guardar una instancia del estado de un objeto (o de parte de este) para que pueda volver posteriormente a ese estado, y</p>
</li>
<li>
<p>una interfaz directa para obtener el estado exponga detalles de implementacion y rompa la encapsulacion del objeto</p>
</li>
</ul>
</div>
<h4 id="memento-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/109.png" />
</figure>
</div>
<h4 id="memento-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Memento</code> (<code>EstadoDelResolvente</code>)</p>
<ul>
<li>
<p>guarda el estado interno del objeto <code>Creador</code>. El memento puede guardar tanta informacion del estado interno del creador como sea necesario a discrecion del creador</p>
</li>
<li>
<p>protege frente a accesos de otros objetos que no sean el creador. Los mementos tienen realmente dos interfaces. El <code>Conserje</code> ve una interfaz <em>reducida</em> del Memento ––solo puede pasar el memento a otros objetos––. El Creador, por el contrario, ve una interfaz <em>amplia</em>, que le permite acceder a todos los datos necesarios para volver a su estado anterior. Idealmente, solo el creador que produjo el memento estaria autorizado a acceder al estado interno de este.</p>
</li>
</ul>
</li>
<li>
<p><code>Creador</code> (<code>ResolventeDeRestricciones</code>)</p>
<ul>
<li>
<p>crea un memento que contiene una instancia de su estado interno actual.</p>
</li>
<li>
<p>usa el memento para volver a su estado anterior.</p>
</li>
</ul>
</li>
<li>
<p><code>Conserje</code> (mecanismo de deshacer)</p>
<ul>
<li>
<p>es responsable de guardar en un lugar seguro el memento.</p>
</li>
<li>
<p>nunca examina los contenidos del memento, ni opera sobre ellos.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="memento-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p>Un conserje solicita un memento a un creador, lo almacena durante un tiempo y se lo devuelve a su creador, tal y como ilustra el siguiente diagrama de interaccion:</p>
<figure>
<img src="img/110.png" />
</figure>
<p>A veces el conserje no devolvera el memento a su creador, ya que el creador podria no necesitar nunca volver a un estado anterior.</p>
</li>
<li>
<p>Los mementos son pasivos. Solo el creador que creo el memento asignara o recuperara su estado.</p>
</li>
</ul>
</div>
<h4 id="memento-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron Memento tiene varias consecuencias:</p>
<ol class="num" >
<li>
<p><em>Preservacion de los limites de la encapsulacion.</em> El memento evita exponer informacion que solo deberia ser gestionada por un creador, pero que sin embargo debe ser guardada fuera del creador. El patron oculta a otros objetos las interioridades, potencialmente complejas, del Creador, preservando asi los limites de la encapsulacion.</p>
</li>
<li>
<p><em>Simplifica al Creador.</em> En otros diseños que persiguen conservar la encapsulacion, el Creador mantiene las versiones de su estado interno que han sido soliciadas por los clientes. Eso asigna toda la responsabilidad de gestion del almacenamiento al Creador. Que sean los clientes quienes gestiones el estado que solucitan simplifica al Creador y evita que los clientes tengan que notificar a los creadores cuando han acabado.</p>
</li>
<li>
<p><em>El uso de mementos puede ser costoso.</em> Los mementos podrian producir un coste considerable si el Creador debe copiar grandes cantidades de informacion para guardarlas en el memento o si los clientes crean y devuelven mementos a su creador con mucha frucuencia. A menos que encapsular y reestablecer el estado del Creador sea poco costoso, el patron podria no ser apropiado. Vease la discucion acerca de los cambios incrementales en la seccino de Implementacion.</p>
</li>
<li>
<p><em>Definicion de interfaces reducidas y amplias.</em> En algunos lenguajes puede ser dificil garantizar que solo el creador acceda al estado del memento.</p>
</li>
<li>
<p><em>Costes ocultos en el cuidado de los mementos.</em> un conserje es responsable de borrar los mementos que custodia. Sin embargo, el conserje no sabe cuanto estado hay en el memento. De hay que el conserje que deberia ser ligero pueda provocar grandes costes de almacenamientos cuando debe guardar mementos.</p>
</li>
</ol>
</div>
<h4 id="memento-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Estas son dos cuestiones a considerar a la hora de implementar el patron Memento:</p>
<ol class="num" >
<li>
<p><em>Soperte del lenugaje.</em> Los mementos tienen dos interfaces: una amplia para los creadores y otra reducida para otros objetos. Lo ideal seria que el lenguaje de implementacion permitiese dos niveles de proteccion estatica. C++ permite hacer esto haciendo que <code>Creador</code> sea una clase amiga de memento y haciendo privada a la interfaz amplia del <code>Memento</code>. Solo la interfaz reducido deberia ser declarada publica. Por ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Estado</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Creador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Memento</span><span class="o">*</span> <span class="n">CrearMemento</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">EstablecerMemento</span><span class="p">(</span><span class="k">const</span> <span class="n">Memento</span><span class="o">*</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">Estado</span><span class="o">*</span> <span class="n">_estado</span><span class="p">;</span>      <span class="c1">// estructuras  de datos internas
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Memento</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// interfaz publica reducida
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="o">~</span><span class="n">Memento</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// miembros privados accesibles solo para el Creador
</span><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Creador</span><span class="p">;</span>
    <span class="n">Memento</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">EstablecerEstado</span><span class="p">(</span><span class="n">Estado</span><span class="o">*</span><span class="p">);</span>
    <span class="n">Estado</span><span class="o">*</span> <span class="nf">ObtenerEstado</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">Estado</span><span class="o">*</span> <span class="n">_estado</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
</li>
<li>
<p><em>Guardar solo los cambios incrementales.</em> Cuando los mementos se crean y se devuelven a su creador en una secuencia predecible, el <code>Memento</code> puede guardar unicamente el <em>cambio</em> con respecto al estado interno del creador.</p>
<p>Por ejemplo, las ordenes de deshacer de un historial pueden usar mementos para asegurar que las ordenes vuelven a su estado original exacto cuando se deshacen (vease el patron <a href="#command" >Command</a>). El historial define un orden concreto en el que las ordenes pueden deshacerse y repetirse. Eso significa que los mementos pueden guardar unicamente el cambio producido por una orden, en vez del estado completo de cada objeto al que afecta. En el ejemplo de la seccion de Motivacion, el resolvente de problemas podria guardor solo aquellas estructuras internas que cambian para que las lineas sigan uniendo a los rectangulos, en vez de guardar las posiciones absolutas de estos objetos.</p>
</li>
</ol>
</div>
<h4 id="memento-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>El codigo C++ que aqui se muestra ilustra el ejemplo del <code>ResolventeDeRestricciones</code> que se discutio anteriormente. hemos usado objetos <code>OrdenMover</code> (vease <a href="#command" >Command</a>) para (des)hacer la translacion de un objeto grafico de una posicion a otra. El editor grafico llama a la operacion <code>Ejecutar</code> de la orden para mover un objeto grafico, y a <code>Deshacer</code> para deshacer el movimiento. La orden guarda su destino, la distancia movida y una instancia de <code>MementoDelResolventeDeProblemas</code>, un memento que contiene estado del resolvente de problemas.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Grafico</span><span class="o">:</span>
    <span class="c1">// clase base para los objetos graficos del editor grafico
</span><span class="c1"></span>
    <span class="k">class</span> <span class="nc">OrdenMover</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">OrdenMover</span><span class="p">(</span><span class="n">Grafico</span><span class="o">*</span> <span class="n">destino</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">incremento</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Ejecutar</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Deshacer</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">MementoDelResolventeDeRestricciones</span><span class="o">*</span> <span class="n">_estado</span><span class="p">;</span>
    <span class="n">Punto</span> <span class="n">_incremento</span><span class="p">;</span>
    <span class="n">Grafico</span><span class="o">*</span> <span class="n">_destino</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>Las restricciones de conexion son establecidas por la clase <code>ResolventeDeRestricciones</code>. Su principal funcion miembro es <code>Resorver</code>, que resuelve las restricciones registradas con la operacion <code>AnadirRestriccion</code>. Para permitr deshacer, el estado de <code>ResorventeDeRestricciones</code> puede externalizarse con <code>CrearMemento</code> en una instancia de <code>MementoDelResolventeDeRestricciones</code>. El resolvente de restricciones puede volver a un estado previo llamando a <code>EstablecerMemento</code>. <code>ResolventeDeRestricciones</code> es un <a href="#singleton" >Singleton</a>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ResolventeDeRestricciones</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">ResolventeDeRestricciones</span><span class="o">*</span> <span class="n">Instancia</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">Resolver</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">AnadirRestriccion</span><span class="p">(</span>
        <span class="n">Grafico</span><span class="o">*</span> <span class="n">principioConexion</span><span class="p">,</span> <span class="n">Grafico</span><span class="o">*</span> <span class="n">finConexion</span>
    <span class="p">);</span>
    <span class="kt">void</span> <span class="nf">EliminarRestriccion</span><span class="p">(</span>
        <span class="n">Grafico</span><span class="o">*</span> <span class="n">principioConexion</span><span class="p">,</span> <span class="n">Grafico</span><span class="o">*</span> <span class="n">finConexion</span>
    <span class="p">);</span>

    <span class="n">MementoDelResolventeDeRestricciones</span><span class="o">*</span> <span class="nf">CrearMemento</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">EstablecerMemento</span><span class="p">(</span><span class="n">MementoDelResolventeDeRestricciones</span><span class="o">*</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// estado no trivial y operaciones para hacer cumplir
</span><span class="c1"></span>    <span class="c1">// la semantica de las conexiones
</span><span class="c1"></span><span class="p">};</span>

<span class="k">class</span> <span class="nc">MementoDelResolventeDeRestricciones</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">MementoDelResolventeDeRestricciones</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">ResolventeDeRestricciones</span><span class="p">;</span>
    <span class="n">MementoDelResolventeDeRestricciones</span><span class="p">();</span>

    <span class="c1">// estado privado del resolvente de restricciones
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>Dadas estas interfaces, podemos implementar los miembro <code>Ejecutar</code> y <code>Deshacer</code> de <code>OrdenMover</code> como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">OrdenMover</span><span class="o">::</span><span class="n">Ejecutar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">ResolventeDeRestricciones</span><span class="o">*</span> <span class="n">resolvente</span> <span class="o">=</span> <span class="n">ResolventeDeRestricciones</span><span class="o">::</span><span class="n">Instancia</span><span class="p">();</span>
    <span class="n">_estado</span> <span class="o">=</span> <span class="n">resolvente</span><span class="o">-&gt;</span><span class="n">CrearMemento</span><span class="p">();</span> <span class="c1">// crea un memento
</span><span class="c1"></span>    <span class="n">_destino</span><span class="o">-&gt;</span><span class="n">Mover</span><span class="p">(</span><span class="n">_incremento</span><span class="p">);</span>
    <span class="n">resolvente</span><span class="o">-&gt;</span><span class="n">Resolver</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">OrdenMover</span><span class="o">::</span><span class="n">Deshacer</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">ResolventeDeRestricciones</span><span class="o">*</span> <span class="n">resolvente</span> <span class="o">=</span> <span class="n">ResolventeDeRestricciones</span><span class="o">::</span><span class="n">Instancia</span><span class="p">();</span>
    <span class="n">_destino</span><span class="o">-&gt;</span><span class="n">Mover</span><span class="p">(</span><span class="o">-</span><span class="n">_incremento</span><span class="p">);</span>
    <span class="n">resolvente</span><span class="o">-&gt;</span><span class="n">EstablecerMemento</span><span class="p">(</span><span class="n">_estado</span><span class="p">);</span> <span class="c1">// vuelve al estado anterior
</span><span class="c1"></span>    <span class="n">resolvente</span><span class="o">-&gt;</span><span class="n">Resolver</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p><code>Ejecutar</code> adquiere un memento del <code>MementoDelResolventeDeRestricciones</code> antes de mover al grafico. <code>Deshacer</code> mueve el grafico hacia atras, devuelve el resolvente de restricciones a su estado anterior y, por ultimo, le dice al resolvente de restricciones que resuelva sus restricciones.</p>
</div>
<h4 id="memento-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>El ejemplo anterior esta tomado del soporte para conectividad de Unidraw a traves de su clase CSolver [<a href="#vl90" >VL90</a>].</p>
<p>Las colecciones de Dylan [<a href="#app92" >App92</a>] proporcionan una interfaz de interaccion que refleja el patron Memento. Estas colecciones tienen la nocion de un objeto <q>estado</q>, el cual es un memento que representa el estado de la iteracion. Cada coleccion puede representar el estado actual de la iteracion en la forma que prefiera; dicha representacion permanece completamente oculta a los clientes. El enfoque de Dylan para la iteracion podria transladarse asi a C++:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Coleccion</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Coleccion</span><span class="p">();</span>

    <span class="n">EstadoIteracion</span><span class="o">*</span> <span class="nf">CrearEstadoInicial</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Siguiente</span><span class="p">(</span><span class="n">EstadoIteracion</span><span class="o">*</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">HaTerminado</span><span class="p">(</span><span class="k">const</span> <span class="n">EstadoIteracion</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">Elemento</span> <span class="nf">ElementoActual</span><span class="p">(</span><span class="k">const</span> <span class="n">EstadoIteracion</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">EstadoIteracion</span><span class="o">*</span> <span class="nf">Copiar</span><span class="p">(</span><span class="k">const</span> <span class="n">EstadoIteracion</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">Insertar</span><span class="p">(</span><span class="k">const</span> <span class="n">Elemento</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Eleminar</span><span class="p">(</span><span class="k">const</span> <span class="n">Elemento</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p><code>CrearEstadoInicial</code> devuelve un objeto <code>EstadoIteracion</code> inicializado para la coleccion. <code>Siguiente</code> hace avanzar el objeto estado a la siguiente posicion en la iteracion; en realidad lo que hace es incrementar el indice de la iteracion. <code>HaTeriminado</code> devuelve <code>true</code> si <code>Siguiente</code> ha avanzado mas alla del ultimo elemento de la coleccion. <code>ElementoActual</code> desreferencia el objeto estado y devuelve el elemento de la coleccion al cual se refiere. <code>Copiar</code> devuelve una copia del objeto estado. Esto es util para marcar un punto en una interaccion.</p>
<p>Dada una clase <code>TipoDeElemento</code>, podemos iterar sobre una coleccion de instancias suyas como sigue:<span class="note" ><sup><a href="#50" >50</a></sup></span></p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">TipoDeElemento</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Procesar</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Coleccion</span><span class="o">&lt;</span><span class="n">TipoDeElemento</span><span class="o">*&gt;</span> <span class="n">unaColeccion</span><span class="p">;</span>
<span class="n">EstadoIteracion</span><span class="o">*</span> <span class="n">estado</span><span class="p">;</span>

<span class="n">estado</span> <span class="o">=</span> <span class="n">unaColeccion</span><span class="p">.</span><span class="n">CrearEstadoInicial</span><span class="p">();</span>

<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">unaColeccion</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">(</span><span class="n">estado</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">unaColeccion</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">(</span><span class="n">estado</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Procesar</span><span class="p">();</span>
    <span class="n">unaColeccion</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">(</span><span class="n">estado</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">delete</span> <span class="n">estado</span><span class="p">;</span>
</code></pre>
<p>La interfaz de la iteracion basada en el memento tiene dos beneficios interesantes:</p>
<ol class="num" >
<li>
<p>Puede haber mas de un estado para la misma coleccion (y lo mismo es cierto para el patron <a href="#iterator" >Iterator</a>).</p>
</li>
<li>
<p>No necesita romper la encapsulacion para permitir la iteracion. El memento solo es interpretado por la propia coleccion; nadie mas tiene acceso a el. Otros enfoques para iterar requieren romper la encapsulacion haciendo a las clase iterador amigas de las clases de sus colecciones (vease el patron <a href="#iterator" >Iterator</a>). La situacion es a la inversa en la implementacion basada en el memento. <code>Coleccion</code> es amiga de <code>IteratorState</code>.</p>
</li>
</ol>
<p>El toolkit de resolucion de problemas QOCA guarda informacion incremental en mementos [<a href="#hhmv92" >HHMV92</a>]. Los cliente pueden obtener un memento que represente la solucion actual a un sistema de ecuaciones. El memento contiene solo aquellas variables de las ecuaciones que han camdiabo desde la ultima solucion. Normalmente, para cada nueva solucion solo cambia un pequeño subconjunto de las variables del resolvente. Este subconjunto es sufuciente para devolver el resolvente a su solucion precedente; volver a soluciones anteriores requiere almacenar mementos de las soluciones intermedias. Por tanto, no se pueden establecer mementos en cualquier orden; QOCA se basa en un mecanismo de historial para revertir a soluciones anteriores.</p>
</div>
<h4 id="memento-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p><a href="#command" >Command</a>: Las ordenes pueden usar mementos para guardar el estado de las operaciones que pueden deshacerse.</p>
<p>Iterator: puede usar mementos para iteracion, tal como acabamos de describir.</p>
</div>
<h3 id="observer" >Observer</h3>
<h4 id="observer-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Define una dependencia de uno-a-muchos entre objetos, de forma que cuando un objeto cambie de estado se notifique y se actualicen automaticamente todos los objetos que depnden de el.</p>
</div>
<h4 id="observer-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Dependents (Dependientes), Publish-Subcscribe (Publicar-Subscribir)</p>
</div>
<h4 id="observer-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Un efecto lateral habitual de dividir un sistema en una coleccion de clases cooperantes es la necesidad de mantener una consistencia entre objetos relacionados. No queremos alcanzar esa consistenca haciendo a las clases fuertemente acopladas, ya que eso reduciria su reutilizacion.</p>
<p>Por ejemplo, muchos toolkits de interfaces graficas de usuario separan los aspectos de presentacion de la interfaz de usuario de los datos de aplicacion subyacentes [<a href="#kp88" >KP88</a>, <a href="#lvc89" >LVC89</a>, <a href="#p+88" >P+88</a>, <a href="#wgm88" >WGM88</a>]. Las clases que definen los datos de las aplicaciones y las representaciones pueden reutilizarse de forma independiente. Tambien pueden trabajar juntas. Un objeto hoja de calculo y un grafico de barras pueden representar la informacion contenida en el mismo objeto de datos de aplicacion usando diferentes representaciones. La hoja de calculo y el grafico de barras no se conocen entre si, permitiendo asi reutilizar solo aquel que se necesite. Pero se <em>comportan</em> como si lo hicieran. Cuando el usuario cambia la informacion de la hoja de calculo, la barra de herramientas refleja los cambios inmediatamente, y viceversa.</p>
<figure>
<img src="img/111.png" />
</figure>
<p>Este comportamiento implica que la hoja de calculo y el grafico de barras son dependientes del objeto de datos y, por tanto, se les deberia notificar cualquer cambio en el estado de este. Y no hay razon para limitar a dos el numero de objetos dependientes; puede haber cualquier numero de interfaces de usuario diferentes para los mismos datos.</p>
<p>El patron Observer describe como establecer estas relaciones. Los principales objetos de este patron son <b>el sujeto</b> y <b>el observador</b>. Un sujeto puede tener cualquier numero de observadores dependientes de el. Cada vez que el sujeto cambia su estado se notifica a todos sus observadores. En respuesta, cada obeservador consultara al sujeto para sincronizar su estado con el estado de este.</p>
<p>Este tipo de interaccion tambien se conoce como <b>publicar-suscribir</b>. El sujeto es quien publica las notificaciones. Envia estas notificaciones sin tener que conocer quienes son sus observadores. Pueden suscribirse un numero indeterminado de observadores para recibir notificaciones.</p>
</div>
<h4 id="observer-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Observer en cualquiera de las situaciones siguientes:</p>
<ul>
<li>
<p>Cuando una abstraccion tiene dos aspectos y uno depende del otro. Encapsular estos aspectos en objetos separados permite modificarlos y reutilizarlos de forma independiente.</p>
</li>
<li>
<p>Cuando un cambio en un objeto requiere cambiar otros, y no sabemos cuantos objetos necesitan cambiarse.</p>
</li>
<li>
<p>Cuando un objeto deberia ser capaz de notificar a otros sin hacer suposiciones sobre quienes son dichos objetos. En otras palabras, cuando no queremos que estos objetos esten fuertemente acoplados.</p>
</li>
</ul>
</div>
<h4 id="observer-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/112.png" />
</figure>
</div>
<h4 id="observer-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Sujeto</code></p>
<ul>
<li>
<p>conoce a sus observadores. Un sujeto puede ser observado por cualquier numero de objetos <code>Observador</code>.</p>
</li>
<li>
<p>proporciona una interfaz para asignar y quitar objetos <code>Observador</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>Observador</code></p>
<ul>
<li>
<p>define una interfaz para actualizar los objetos que deben ser notificados ante cambios en un sujeto.</p>
</li>
</ul>
</li>
<li>
<p><code>SujetoConcreto</code></p>
<ul>
<li>
<p>almacena el estado de interes para los objetos <code>ObservadorConcreto</code>.</p>
</li>
<li>
<p>envia una notificacion a sus observadores cuando cambia su estado.</p>
</li>
</ul>
</li>
<li>
<p><code>ObservadorConcreto</code></p>
<ul>
<li>
<p>mantiene una referencia a un objeto <code>SujetoConcreto</code>.</p>
</li>
<li>
<p>guarda un estado que deberia ser consistente con el del sujeto.</p>
</li>
<li>
<p>implementa la interfaz de actualizacion del <code>Observador</code> para mantener su estado consistente con el del sujeto.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="observer-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>SujetoConcreto</code> notifica a sus observadores cada vez que se produce un cambio que pudiera hacer que el estado de estos fuera inconsistente con el suyo.</p>
</li>
<li>
<p>Despues de ser informado de un cambio en el sujeto concreto, un objeto <code>ObservadorConcreto</code> puede pedirle al sujeto mas informacion. <code>ObservadorConcreto</code> usa esta informacion para sincronizar su estado con el del sujeto.</p>
<p>El siguiente diagrama de interaccion muestra las colaboraciones entre un sujeto y dos observadores:</p>
<figure>
<img src="img/113.png" />
</figure>
<p>Notese como el objeto <code>Observador</code> que inicializa la peticion de cambio pospone su actualizacion hasta que obtiene una notificacion del sujeto. Notificar no simpre es llamado por el sujeto. Puede ser llamado por un observador o por un tipo de objeto completamente diferente. La seccion de Implementacion examina algunas variantes comunes.</p>
</li>
</ul>
</div>
<h4 id="observer-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron <code>Observador</code> permite modificar los sujetos y observadores de forma independiente. Es posible reutilizar objetos sin reutilizar sus observadores, y viceversa. Esto permite añadir observadores sin modificar el sujeto u otros observadores.</p>
<p>Otras ventajas e inconvenientes del patron Observer son los siguientes:</p>
<ol class="num" >
<li>
<p><em>Acoplamiento abstracto entre <code>Sujeto</code> y <code>Observador</code>.</em> Todo lo que un sujeto sabe es que tiene una lista de observadores, cada uno de los cuales se ajusta a la interfaz simple de la clase abstracta <code>Observador</code>. El sujeto no conce la clase concreta de ningun observador. Por tanto el acoplamiento entre sujetos y observadores es minimo.</p>
<p>Gracias a que <code>Sujeto</code> y <code>Observador</code> no estan fuertemente acoplados, pueden pertenecer a diferentes capas de abstraccion de un sistema. Un sujeto de bajo nivel puede comunicarse e informar a un observador de mas alto nivel, manteniendo de este modo intacta la estructura de capas del sistema. Si juntasemos al <code>Sujeto</code> y al <code>Observador</code> en un solo objeto, entonces el objeto resultante deberia dividirse en dos capas (violando asi la separacion en capas) o estaria obligado a residir en una capa u otra (lo que puede comprometer la abstraccion en capas).</p>
</li>
<li>
<p><em>Capacidad de comunicacion mediante difusion.</em> A diferencia de una peticion ordinaria, la notificacion enviada por un sujeto no necesita especificar su receptor. La notificacion se envia automaticamente a todos los objetos interesados que se hayan suscrito a ella. Al sujeto no le importa cuantos objetos interesados haya; su unica responsabilidad es notificar a sus observadores. Esto nos da la libertad de añadir y quitar observadores en cualquier momento. Se deja al observador manejar u obviar una notificacion.</p>
</li>
<li>
<p><em>Actualizaciones inesperadas.</em> Dudo que los observadores no saben de la presencia de los otros, pueden no saber el coste ultimo de cambiar el sujeto. Una operacion aparentemente inofensiva sobre un sujeto puede dar lugar a una serie de actualizaciones en cascada de observadores y sus objetos dependientes. Mas aun, los criterios de dependencia que no estan bien definidos o mantenidos suelen provocar falsas actualizaciones, que pueden ser muy dificiles de localizar.</p>
<p>Este problema se ve agravado por el hecho de que el prototipo de actualizacion simple no proporciona detalles acerca de <em>que</em> ha cambiado en el sujeto. Sin protocolos adicionales para ayudar a los observadores a descubrir que ha cambiado, pueden verse obligados a trabajar duro para deducir los cambios.</p>
</li>
</ol>
</div>
<h4 id="observer-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>En esta seccion se examinan varias cuestiones relativas a la implementacion del mecanismo de dependencia.</p>
<ol class="num" >
<li>
<p><em>Correspodencia entre los sujetos y sus observadores.</em> El modo mas simple de que un sujeto conozca a los observadores a los que deberia notificar es guardar referencias a ellos explicitamente en el sujeto. Sin embargo, dicho almacenamiento puede ser demaciado costoso cuando hay muchos sujetos y pocos observadores. Una solucion es intercambiar espacio por tiempo usando una busqueda asociativa (por ejemplo, mediante una tabla de dispersion ––en ingles, tabla <em>hash</em>––) para mantener la correspondencia sujeto-observador. Asi, un sujeto que no tenga observadores no incurrira en ningun coste de almacenamiento. Por otro lado, este enfoque incrementa el coste de acceder a los observadores.</p>
</li>
<li>
<p><em>Observar mas de un sujeto.</em> Puede tener sentido en algunas situaciones que un observador dependa de mas de un sujeto. Por ejemplo, una hoja de calculo puede depender de mas de un origen de datos. En tales casos es necesario extender la interfaz de <code>Actualizar</code> para que el observador sepa que sujeto esta enviando la notificacion. El sujeto puede simplemente pasarse a si mismo como parametro en la operacion <code>Actualizar</code>, permitiendo asi al observador saber que sujeto examinar.</p>
</li>
<li>
<p><em>¿Quien dispara la actualizacion?</em> El sujeto y sus observadores se basan en el mecanismo de notificacion para permanecer consistentes. Pero, ¿que objeto llama realmente a <code>Notificar</code> para disparar la actualizacion? He aqui dos posibilidades:</p>
<ol class="alpha" >
<li>
<p>Hacer que las operaciones que establezcan el estado del <code>Sujeto</code> llamen a <code>Notificar</code> despues de cambiar el resto del mismo. La ventaja de este enfoque es que los clientes no tienen que acordarse de llamar a <code>Notificar</code> sobre el sujeto. El inconveniente es que varias operaciones consecutivas provocaran varias actualizaciones consecutivas, lo que puede ser ineficiente.</p>
</li>
<li>
<p>Hacer que los clientes sean responsables de llamar a <code>Notificar</code> en el momento adecuado. La ventaja aqui es que el cliente puede esperar a disparar la actualizacion hasta que se produzcan una serie de cambios de estado, evitando asi las innecesarias actualizaciones intermedias. El inconveniente es que los clientes tienen la responsabilidad añadida de disparar la actualizacion. Eso hace que sea propenso a erorres, ya que los clientes pueden olvidares de llamar a <code>Notificar</code>.</p>
</li>
</ol>
</li>
<li>
<p><em>Referencias perdidas a los sujetos borrados.</em> Borrar un sujeto no deberia producir referencias perdidas en sus observadores. Una manera de evitar esto es hacer que el sujeto notifique a sus observadores cuando va a ser borrado, para que estos puedan inicializar la referencia al sujeto. En general, borrar los observadores no suele ser una opcion, ya que puede haber otros objetos que hagan referencia a ellos, y tambien pueden estar observando a otros sujetos.</p>
</li>
<li>
<p><em>Asegurarse de que el estado del <code>Sujeto</code> es consistente con sigo mismo antes de la notificacion.</em> Es importante garantizar que el estado del <code>Sujeto</code> es consistente consigo mismo antes de llamar a <code>Notificar</code>, porque los observadores le piden al sujeto su estado actual mientras actualizan su propio estado.</p>
<p>Es facil violar involuntariamente esta regla de auto-consistencia cuando las operaciones de las subclases de <code>Sujeto</code> llaman a operaciones heredadas. Por ejemplo, en la siguiente secuencia de codigo la actualizacion se dispara cuando el sujeto se encuentra en un estado inconsistente:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">MiSujeto</span><span class="o">::</span><span class="n">Operacion</span> <span class="p">(</span><span class="kt">int</span> <span class="n">nuevoValor</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ClaseBaseSujeto</span><span class="o">::</span><span class="n">Operacion</span><span class="p">(</span><span class="n">nuevoValor</span><span class="p">);</span>
         <span class="c1">// se dispara la notificacion
</span><span class="c1"></span>
    <span class="n">_miVar</span> <span class="o">+=</span> <span class="n">nuevoLavol</span><span class="p">;</span>
         <span class="c1">// se actualiza el estado de la subclase (¡demasiado tarde!)
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Se puede salvar este escollo enviando notificaciones en metodos plantilla (<a href="#template-method" >Template Method</a>) de la clase abstracta <code>Sujeto</code>, definiendo una operacion primitiva para que sea redefinida por las subclases y haciendo que <code>Notificar</code> sea la ultima operacion del metodo plantilla, lo que garantizara que el objeto es consistente consigo mismo cuando las subclases redefinan las operaciones de <code>Sujeto</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Texto</span><span class="o">::</span><span class="n">Cortar</span> <span class="p">(</span><span class="n">SeleccionDeTexto</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SistituirSeloccion</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>   <span class="c1">// redefinida en las subclases
</span><span class="c1"></span>    <span class="n">Notificar</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Por cierto, siempre es una buena idea documentar que operaciones del <code>Sujeto</code> disparan notificaciones.</p>
</li>
<li>
<p><em>Evitar protocolos especificos del observador: los modelos push y pull.</em> Las implementaciones del patron Observer suelen hacer que el sujeto envie informacion adicional sobre el cambio. El sujeto pasa esta informacion como un parametro de <code>Actualizar</code>. La cantidad de informaicon puede variar mucho.</p>
<p>En un extremo, al que llamaremos <b>modelo push</b>, el sujeto envia a los observadores informacion detallada acerca del cambio, ya quieran estos o no. El otro extremo es el <b>modelo pull</b>; el sujeto no envia nada mas que la notificacion minima, y los observadores piden despues los detalles explicitamente.</p>
<p>El modelo pull enfatiza la ignorancia del sujeto respecto a sus observadores, mientras que el modelo push asume que los sujetos saben algo sobre las necesidades de sus observadores. El modelo push puede hacer que los observadores sean menos reutilizables, ya que las clases <code>Sujeto</code> hacen suposiciones sobre las clases <code>Observador</code> que pudieran no ser siempre ciertas. Por otro lado, el modelo pull puede ser ineficiente, ya que las clases Observador deben determinar que ha cambiado sin ayuda por parte del <code>Sujeto</code>.</p>
</li>
<li>
<p><em>Epecificar las modificaciones de interes explicitamente.</em> Se puede mejorar la eficiencia extendiendo la interfaz de registro del sujeto para permitir que los observadores registren solo a aquellos eventos concretos que les interesen. Cuando ocurre uno de tales eventos, el sujeto informa unicamente a aquellos observadores que se han registrado como interesados en ese evento. Una manera de permitir esto es usar la nocion de aspectos en los objetos <code>Sujeto</code>. Para registrarse como interesado en eventos particulares, los observadores se adscriben a sus sujetos usando</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Sujeto</span><span class="o">::</span><span class="n">Adscribir</span><span class="p">(</span><span class="n">Observador</span><span class="o">*</span><span class="p">,</span> <span class="n">Aspecto</span><span class="o">&amp;</span> <span class="n">interes</span><span class="p">);</span>
</code></pre>
<p>donde <code>interes</code> especifica el evento de interes. En el momento de la notificacion, el sujeto proporciona a sus observadores el aspecto que ha cambiado como un parametro de la operacion <code>Actualizar</code>. Por ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Observador</span><span class="o">::</span><span class="n">Actualizar</span><span class="p">(</span><span class="n">Sujeto</span><span class="o">*</span><span class="p">,</span> <span class="n">Aspecto</span><span class="o">&amp;</span> <span class="n">interes</span><span class="p">);</span>
</code></pre>
</li>
<li>
<p><em>Encapsular la semantica de las actualizaciones complejas.</em> cuando la relacion de dependencia entre sujetos y observadores es particularmente compleja, puede ser necesario un objeto que mantenga estas relaciones. Llamaremos a este objeto un <code>GestorDeCambios</code>. Su proposito es minimizar el trabajo necesario para lograr que los observadores reflejen un camibo en su sujeto. Por ejemplo, si una operacion necesita cambiar varios sujetos interdependientes, puede ser necesario asegurarse de que se notifica a sus observadores solo despues de que <em>todos</em> los sujetos han sido modificados, para evitar notificar a los observadores mas de una vez.</p>
<p><code>GestorDeCambios</code> tiene tres responsabilidades:</p>
<ol class="alpha" >
<li>
<p>Hace corresponder a un sujeto con sus observadores, proporcionando una interfaz para mantener dicha correspondencia. Esto elimina la necesidad de que los sujetos mantengan referencias a otros observadores y viceversa.</p>
</li>
<li>
<p>Define una determinada estrategia de actualizacion.</p>
</li>
<li>
<p>Actualiza todos los observadores dependientes a peticion de un sujeto.</p>
</li>
</ol>
<p>El diagrama siguiente representa una implementacion del patron Obserer basada en un <code>GestorDeCambios</code> simple. Hay dos tipos de <code>GestorDeCambios</code>. <code>GestorDeCambiosSimple</code> es simplista en el sentido de que siempre actualiza todos los observadores de cada sujeto. Por el contrario, <code>GestorDeCambiosGDA</code> maneja grafos dirigidos-aciclicos de dependencias entre sujetos y sus observadores. Es preferible un <code>GestorDeCambiosGDA</code> frente a un <code>GestorDeCambiosSimple</code> cuando un observador observa a mas de un sujeto. En ese caso, un cambio en dos o mas sujetos podria causar actualizaciones redundantes. El <code>GestorDeCambiosGDA</code> garantiza que el observador solo recibe una unica actualizacion. <code>GestorDeCambiosSimple</code> esta bien cuando las actualizaciones multiples no constituyen un problema.</p>
<figure>
<img src="img/114.png" />
</figure>
<p><code>GestorDeCambios</code> es una instancia del patron <a href="#mediator" >Mediator</a>. En general, solo hay un unico <code>GestorDeCambios</code>, y es conocido globalmente. El patron <a href="#sigleton" >Sigleton</a> seria aqui de utilidad.</p>
</li>
<li>
<p><em>Unir las clases <code>Sujeto</code> y <code>Observador</code>.</em> Las bibliotecas de clases escritas en lenguajes que carecen de herencia multiple (como Smalltalk) generalmente no definen clases separadas <code>Sujeto</code> y <code>Observador</code>, sino que juntan sus interfaces en una clase. Eso permite definir un objeto que haga tanto de sujeto como de observador sin usar herencia multiple. En Smalltallk, por ejemplo, las interfaces de <code>Sujeto</code> y <code>Observador</code> se definen en la clase raiz <code>Object</code>, haciendolas asi disponibles para todas las clases.</p>
</li>
</ol>
</div>
<h4 id="observer-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Una clase abstracta define la interfaz <code>Observador</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Sujejo</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Observador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Observador</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Actualizar</span><span class="p">(</span><span class="n">Sujeto</span><span class="o">*</span> <span class="n">elSujetoQueCambio</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Observador</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>Esta implementacion permite multiples sujetos por cada observador. El sujeto que se pasa a la operacion <code>Actualizar</code> permite que el observador determine que objeto ha cambiado cuando este observa mas de uno.</p>
<p>De forma similar, una clase abstracta define la interfaz de <code>Sujeto</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Sujeto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Sujeto</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Adscribir</span><span class="p">(</span><span class="n">Observador</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Quitar</span><span class="p">(</span><span class="n">Observador</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Notificar</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Sujeto</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Lista</span><span class="o">&lt;</span><span class="n">Observador</span><span class="o">*&gt;</span> <span class="o">*</span><span class="n">_observadores</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Sujeto</span><span class="o">::</span><span class="n">Adscribir</span> <span class="p">(</span><span class="n">Observador</span><span class="o">*</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_observadores</span><span class="o">-&gt;</span><span class="n">Insertar</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Sujeto</span><span class="o">::</span><span class="n">Quitar</span> <span class="p">(</span><span class="n">Observador</span><span class="o">*</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_observadores</span><span class="o">-&gt;</span><span class="n">Eliminar</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Sujeto</span><span class="o">::</span><span class="n">Notificar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Observador</span><span class="o">*&gt;</span> <span class="n">i</span><span class="p">(</span><span class="n">_observadores</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">Primero</span><span class="p">();</span> <span class="o">!</span><span class="n">i</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">i</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Actualizar</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><code>Reloj</code> es un sujeto concreto que almacena y mantiene la hora del dia, notificando a sus observadores cada segundo. <code>Reloj</code> proporciona la interfaz para obtener unidades de tiempo por separado, como la hora, los minutos o los segundos.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Reloj</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Sujeto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Reloj</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">ObtenerHora</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">ObtenerMinuto</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">ObtenerSegundo</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">Pulso</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>La operacion <code>Pulso</code> es llamada por un reloj interno a intervalos de tiempo regulares para proporcionar una base de tiempo fiable. <code>Pulso</code> actualiza el estado interno de <code>Reloj</code> y llama a <code>Notificar</code> para informar a los observadores del cambio:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Reloj</span><span class="o">::</span><span class="n">Pulso</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// actualiza el estado del tiempo interno
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">Notificar</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Ahora podemos definir una clase <code>RelojDigital</code> que muestra el tiempo. Esta clase hereda su funcionalidad grafica de una clase <code>Util</code><span class="note" ><sup><a href="#28" >28</a></sup></span> proporcionada por un toolkit de interfaces de usuario. La interfaz del observador se combina con la de <code>RelojDigital</code> heredando de <code>Observador</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">RelojDigitar</span><span class="o">:</span> <span class="k">public</span> <span class="n">Util</span><span class="p">,</span> <span class="k">public</span> <span class="n">Observador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">RelojDigital</span><span class="p">(</span><span class="n">Reloj</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">RelojDigital</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Actualizar</span><span class="p">(</span><span class="n">Sujeto</span><span class="o">*</span><span class="p">);</span>
        <span class="c1">// redefine la operacion de Observador
</span><span class="c1"></span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Dibujar</span><span class="p">();</span>
        <span class="c1">// redefine la operacion de Util;
</span><span class="c1"></span>        <span class="c1">// define como dibujar el reloj digital
</span><span class="c1"></span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Reloj</span><span class="o">*</span> <span class="n">_sujeto</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">RelojDigital</span><span class="o">::</span><span class="n">RelojDigital</span> <span class="p">(</span><span class="n">Reloj</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_sujeto</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">_sujeto</span><span class="o">-&gt;</span><span class="n">Adscribir</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">RelojDigital</span><span class="o">::</span><span class="n">RelojDigital</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_sujeto</span><span class="o">-&gt;</span><span class="n">Quitar</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Antes de que la operacion <code>Actualizar</code> dibuje la apariencia del reloj, se comprueba que el sujeto de la notificacion sea el sujeto del reloj:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">RelojDigital</span><span class="o">::</span><span class="n">Actualizar</span> <span class="p">(</span><span class="n">Sujeto</span><span class="o">*</span> <span class="n">elSujetoQueCambio</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">elSujetoQueCambio</span> <span class="o">==</span> <span class="n">_sujeto</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dibujar</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RelojDigital</span><span class="o">::</span><span class="n">Dibujar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// obtiene los nuevos valores del sujeto
</span><span class="c1"></span>
    <span class="kt">int</span> <span class="n">hora</span> <span class="o">=</span> <span class="n">_sujeto</span><span class="o">-&gt;</span><span class="n">ObtenerHora</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">minuto</span><span class="o">=</span> <span class="n">_sujeto</span><span class="o">-&gt;</span><span class="n">ObtenerMinuto</span><span class="p">();</span>
    <span class="c1">// etc.
</span><span class="c1"></span>    <span class="c1">// dibuja el reloj digital
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Se puede definir una clase <code>RelojAnalogico</code> de la misma manera.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">RelojAnalogico</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Util</span><span class="p">,</span> <span class="k">public</span> <span class="n">Observador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">RelojAnalogico</span><span class="p">(</span><span class="n">Reloj</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Actualizar</span><span class="p">(</span><span class="n">Sujeto</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Dibujar</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>El siguiente codigo crea un <code>RelojAnalogico</code> y un <code>RelojDigital</code> que siempre muestra el mismo tiempo:</p>
<pre class="code" ><code class="chroma" ><span class="n">Reloj</span><span class="o">*</span> <span class="n">reloj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Reloj</span><span class="p">;</span>
<span class="n">RelojAnalogico</span><span class="o">*</span> <span class="n">relojAnalogico</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RelojAnalogico</span><span class="p">(</span><span class="n">reloj</span><span class="p">);</span>
<span class="n">RelojDigital</span><span class="o">*</span> <span class="n">relojDigital</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RelojDigital</span><span class="p">(</span><span class="n">reloj</span><span class="p">);</span>
</code></pre>
<p>Cada vez que <code>reloj</code> emite un pulso, los dos relojes se actualizaran y se volveran a dibujar de manera apropiada.</p>
</div>
<h4 id="observer-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>El primer y tal vez mas importante ejemplo de patron Observer aparece en el Modelo/Vista/Contrelador de Smalltalk (MVC), el framework de interfaces de usuario en el entorno de Smalltalk [<a href="#kp88" >KP88</a>]. La clase <code>Modelo</code> de MCV desepeña el papel de <code>Sujeto</code>, mientras que <code>Vista</code> es la clase base de los observadores. Smalltalk, ET++ [<a href="#wgm88" >WGM88</a>] y la biblioteca de clases THINK [<a href="#sym93b" >Sym93b</a>] proporcionan un mecanismo general de dependencia poniendo las interfaces de <code>Sujeto</code> y <code>Observador</code> en la clase base de todas las otras classe del sistema.</p>
<p>Otros toolkits de interfaces de usuario que emplean este patron son InterViews [<a href="#lvc89" >LVC89</a>]. Andrew Toolkit [<a href="#p+88" >P+88</a>] y Unidraw [<a href="#vl90" >VL90</a>]. InterViews define explicitamente las clases <code>Observer</code> y <code>Observable</code> (para los sujetos). Andrew las llama <q>vista</q> y <q>objeto de datos</q>, respectiviamente. Unidraw divide los obejetos del editor grafico en partes <code>Vista</code> (para los observadores) y <code>Sujeto</code></p>
</div>
<h4 id="observer-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p><a href="#mediator" >Mediator</a>: encapsulando semanticas de actualizaciones complejas, el GestorDeCambios actua como mediador entre sujetos y observadores.</p>
<p><a href="#singleton" >Singleton</a>: el <code>GestorDeCambios</code> puede usar el patron Singleton para que sea unico y globalmente accesible.</p>
</div>
<h3 id="state" >State</h3>
<h4 id="state-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Permite que un objeto modifique su comportamiento cada vez que cambie su estado interno. Parecera que cambia la clase del objeto.</p>
</div>
<h4 id="state-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Objects for States (Estados como Objetos)</p>
</div>
<h4 id="state-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Pensemos en una clase <code>ConexionTPC</code> que representa una conexion de red. Un objeto <code>ConexionTPC</code> puede encontrarse en uno de los siguientes estados: Establecida, Escuchando o Cerrada. Cuando un objeto <code>ConexionTPC</code> recibe peticiones de otros objetos, les reponde de distinta forma dependiendo de su estado actual. Por ejemplo, el efecto de una peticion <code>Abrir</code> depende de si la conexion se encuentra en su estado Cerrada o en su estado Establecida. El patron State describe como puede <code>ConexionTPC</code> exhibir un comportamiento diferente en cada estado.</p>
<p>La idea clave de este patron es introducir una clase abstracta llama <code>EstadoTPC</code> que representa los estados de la conexion de red. La clase <code>EstadoTCP</code> declara una interfaz comun para todas las clases que representan diferentes estados operacionales. Las subclases de <code>EstadoTCP</code> implementan comportamiento especifico de cada estado. Por ejemplo, las clases <code>TCPEstablecida</code> y <code>TCPCerrada</code> implementan comportamiento concreto de los estados <code>Establecida</code> y <code>Cerrada</code> de una <code>ConexionTCP</code>.</p>
<p>La clase <code>ConexionTCP</code> mantiene un objeto de estado (una instancia de una subclase de <code>EstadoTCP</code>) que representa el estado actual de la conexion TCP. La clase <code>ConexionTCP</code> delega todas las peticiones dependientes del estado en este objeto de estado. <code>ConexionTPC</code> usa su instancia de la subclase de <code>EstadoTCP</code> para realizar operaciones que dependen del estado de la conexion.</p>
<figure>
<img src="img/115.png" />
</figure>
<p>Cada vez que cambia el estado de la conexion, el objeto <code>ConexionTPC</code> cambia el objeto de estado que usa. Cuando la conexion pasa de establecida a cerrada, por ejemplo, <code>ConexionTPC</code> sustituira su instancia de <code>TCPEstablecida</code> por una instancia de <code>TCPCerrada</code>.</p>
</div>
<h4 id="state-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron State en cualquiera de los siguientes dos casos:</p>
<ul>
<li>
<p>El comportamiento de un objeto depende de su estado, y debe cambiar en tiempo de ejecucion dependiendo de ese estado.</p>
</li>
<li>
<p>Las operaciones tienen largas sentencias condicionales con multimples ramas que dependen del estado del objeto. Este estado se suele representar por una o mas constantes enumeradas. Muchas veces son varias las operaciones que contienen esta misma estructura condicional. El patron State pone cada rama de la condicion en una clase aparte. Esto nos permite tratar al estado del objeto como un objeto de pleno derecho que puede variar independientemente de otros objetos.</p>
</li>
</ul>
</div>
<h4 id="state-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/116.png" />
</figure>
</div>
<h4 id="state-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Contexto</code> (<code>ConexionTCP</code>)</p>
<ul>
<li>
<p>define la interfaz de interes para los clientes.</p>
</li>
<li>
<p>mantiene una instancia de una subclase de <code>EstadoConcreto</code> que define el estado actual.</p>
</li>
</ul>
</li>
<li>
<p><code>Estado</code> (<code>EstadoTCP</code>)</p>
<ul>
<li>
<p>define una interfaz para encapsular el comportamiento asociado con un determinado estado del Contexto.</p>
</li>
</ul>
</li>
<li>
<p><b>subclases de</b> <code>EstadoConcreto</code> (<code>TCPEstablecida</code>, <code>TCPEscuchando</code>, <code>TCPCerrada</code>)</p>
<ul>
<li>
<p>cada subclase implementa un comportamiento asociado con un estado del Contexto.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="state-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p>Contexto delega las peticiones que dependen del estado en el objeto <code>EstadoConcreto</code> actual.</p>
</li>
<li>
<p>Un contexto puede pasarse a si mismo como parametro para que el objeto <code>Estado</code> maneje la peticion. Esto permite al objeto <code>Estado</code> acceder al contexto si fuera necesario.</p>
</li>
<li>
<p>Contexto es la interfaz principal para los clientes. Los clientes pueden configurar un contexto con objetos <code>Estado</code>. Una vez que esta configurado el contexto, sus clientes ya no tienen que tratar con los objetos <code>Estado</code> directamente.</p>
</li>
<li>
<p>Cualquiera de las subclases de <code>Contexto</code> o de <code>EstadoConcreto</code> pueden decidir que estado sigue a otro y bajo que circunstancias.</p>
</li>
</ul>
</div>
<h4 id="state-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron State tiene las siguientes consecuencias:</p>
<ol class="num" >
<li>
<p><em>Localiza el comportamiento dependiente del estado y divide dicho comportamiento en diferentes estados.</em> El patron State situa en un objeto todo el comportamiento asociado con un determinode estado. Como todo el codigo dependiente del estado reside en una subclase de <code>Estado</code>, pueden añadirse facilmente nuevos estados y transiciones definiendo nuevas subclases. Una alternativa es usar valores de datos para definir los estados internos y hacer que las operaciones de <code>Contexto</code> comprueben dichos datos explicitamente. Pero en ese caso tendriamos sentencias condicionales repartidas por toda la implementacion de <code>Contexto</code>. Añadir un nuevo estado podria requerir cambiar varias operaciones, complicando el mantenimiento.</p>
<p>El patron State evita este problema, pero puede introducir otro, al distribuir el comportamiento para los diferentes estados en varias subclases de Estado. Esto incrementa el numero de clases y es menos compacto que una unica clase. Pero dicha distribucion es realmente buena si hay muchos estados, que de otro modo necesitarian grandes sentencias condicionales.</p>
<p>Al igual que ocurre con los procedimientos largos, hay que tratar de evitar las grandes sentencias condicionales. Son monoliticas y tienden a hacer el codigo menos explicito, lo que a su vez las hace dificiles de modificar y extender. El patron State ofrece un modo mejor de estructurar el codigo dependiente del estado. La logica que determina las transiciones entre estados no reside en sentencias <code>if</code> o <code>switch</code> monoliticas, sino que se reparte entre las subclases de <code>Estado</code>. Al encapsular cada transicion y accion en una clase estamos elevando la idea de un estado de ejecucion a objetos de estado en toda regla. Esto impone una estructura al codigo y hace que su intencion sea mas clara.</p>
</li>
<li>
<p><em>Hace explicitas las transiciones entre estados.</em> Cuando un objeto define su estado actual unicamente en terminos de valores de datos internos, sus transiciones entre estados carecen de una representacion explicita; solo aparecen como asignaciones a determinadas variables. Introducir objetos separados para los diferentes estados hace que las transiciones sean mas explicitas. Ademas, los objetos <code>Estado</code> pueden proteger al <code>Contexto</code> frente a uestados internos inconsistentes, ya que las transiciones entre estados son atomicas desde una perspectiva del <code>Contexto</code> ––tiene lugar cambiando una variable (el objeto varible del <code>Contexto</code>, <code>Estado</code>––, no varias [<a href="#dclf93" >dCLF93</a>]).</p>
</li>
<li>
<p><em>Los objetos <code>Estado</code> pueden compartirse.</em> En caso de que los objetos <code>Estado</code> no tengan variables ––es decir, si el estado que representan esta totalmente representado por su tipo–– entonces varios contextos pueden compartir un mismo objeto <code>Estado</code>. Cuando se comparten los estados de este modo, son en esencia pesos ligeros (vease el patron <a href="#flyweight" >Flyweight</a>) que no tiene estado intrinseco, sino solo comportamiento.</p>
</li>
</ol>
</div>
<h4 id="state-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>El patron Estado da lugar a una serie de cuestiones de implementacion:</p>
<ol class="num" >
<li>
<p><em>Quien difene las transiciones entre estados?</em> El patron State no especifica que participante define los criterios para las transiciones entre estados. Si estos criterios son fijos, entonces pueden implementarse enteramente en el <code>Contexto</code>. No obstante, es generalmente mas flexible y conveniente que sean las propias subclases de <code>Estado</code> quienes especifiquen su estado sucesor y cuando llevar a cabo la transicion. Esto requiere añadir una interfaz al <code>Contexto</code> que permita a los objetos <code>Estado</code> asignar explicitamente el estado actual del <code>Contexto</code>.</p>
<p>Descentralizar de esta forma la logica de transicion facilita modificar o extender dicha logica definiendo nuevas subclases de <code>Estado</code>. Una desventaja de la descentralizacion es que una subclase de <code>Estado</code> conocera al menos a otra, lo que introduce dependencias de implementacion entre subclases.</p>
</li>
<li>
<p><em>Una alternativa basada en tablas.</em> Cargill, en su libro <em>C++ Programming Style</em> [<a href="#car92" >Car92</a>], describe otra forma de estructurar el codigo dirigido por estados: mediante tablas que hagan corresponder entradas con transiciones de estado. Para cada estado, una tabla hace corresponder cada posibre entrada con un estado sucesor. Este enfoque convierte codigo condicional (y funciones virtuales, en el caso del patron State) en una tabla de busqueda.</p>
<p>La principal ventaja de las tablas es la seguridad; se pueden cambiar los criterios de transicion modificando datos en vez de codigo de programa. Hay no obstante, algunos inconvenientes:</p>
<ul>
<li>
<p>Una tabla de busqueda es normalmente menos eficiente que una llamada a una funcion (virtual).</p>
</li>
<li>
<p>Situar la logica de transicion en un formato tabular uniforme hace que los criterios de transicion sean menos explicitos y, por tanto, mas dificiles de comprender.</p>
</li>
<li>
<p>Suele dificultar añadir acciones que acompañen a las transiciones de estado. El enfoque dirigido por una tabla representa los estados y sus transiciones, pero debe ser aumentado para realizar algun tipo de procesamiento arbitrario con cada transicion.</p>
</li>
</ul>
<p>Las principales diferencias entre las maquinas de estados basadas en tablas y el patron State se pueden resumir en esta: el patron State modela comportamiento especifico del estado, mientras que el enfoque basado en una tabla se centra en definir las transiciones de estado.</p>
</li>
<li>
<p><em>Crear y destruir objetos Estado.</em> Una cuestion de implementacion que hay que ponderar es si (1) crear los objetos <code>Estado</code> solo cuando se necesitan y destruirlos despues, o si (2) crearlos al principio y no destruirlos nunca.</p>
<p>La primera eleccion es preferible cuando no se conocen los estados en tiempo de ejecucion y los contextos cambian de estado con poca frucuencia. Este enfoque envita crear objetos que no se usaran nunca, lo que puede ser importante si los objetos <code>Estado</code> guardan una gran cantidad de informacion. El segundo enfoque es mejor cuando los cambios tienen lugar rapidamente, en cuyo caso querremos evitar destruir los estados, ya que pueden volver a necesitarse de nuevo en breve. Los costes de creacion se pagan una vez al principio, y no existen costes de destruccion. No obstante, este enfoque puede no ser apropiado, ya que el <code>Contexto</code> debe guardar referencias a todos los estados en los que pudiera entrar.</p>
</li>
<li>
<p><em>Usar herencia dinamica.</em> Cambiar el comportamiento de una determinada peticion podria lograrse cambiando la clase del objeto en tiempo de ejecucion, pero esto no es posible en la mayor parte de los lenguajes de programacion orientados a objetos. Las excepciones incluyen Self [<a href="#us87" >US87</a>] y otros lenguajes basados en delegacion que proporcionan dicho mecanismo y por tanto admiten el patron State directamente. Los objetos en Self pueden delegar operaciones en otros objetos para obtener una especie de herencia dinamica. Cambiar el destino de la delegacion en tiempo de ejecucion cambia por tanto la estructura de herencia. Este mecanismo permite que los objetos cambien su comportamiento, y viene a ser lo mismo que cambiar su clase.</p>
</li>
</ol>
</div>
<h4 id="state-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>El ejemplo siguiente muestra el codigo C++ para el ejemplo de la conexion TCP que se describio en la seccion de Motivacion. Este ejemplo es una version simplificada del protocolo TCP; no se describe el protocolo completo ni todos los estados de las conexiones TCP.<span class="note" ><sup><a href="#51" >51</a></sup></span></p>
<p>En primer lugar, definimos la clase <code>ConexionTCP</code>, que proporciona una interfaz para transmitir datos y que procesa las peticiones para cambiar el estado.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">FlujoOctetosTCP</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">EstadoTCP</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ConexionTCP</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ConexionTCP</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">AbrirActiva</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">AbrirPasiva</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Cerrar</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">Enviar</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">AcuseDeRecibo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Sincronizar</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">ProcesarOcteto</span><span class="p">(</span><span class="n">FlujoOctetosTCP</span><span class="o">*</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">friendo</span> <span class="k">class</span> <span class="nc">EstadoTCP</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">CambiarEstado</span><span class="p">(</span><span class="n">EstadoTCP</span><span class="o">*</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">EstadoTCP</span><span class="o">*</span> <span class="n">_estado</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p><code>ConexionTCP</code> guarda una instancia de la clase <code>EstadoTCP</code> en la variable miembro <code>_estado</code>. La clase <code>EstadoTCP</code> duplica la interfaz para cambiar el estado de <code>ConexionTCP</code>. Cada operacion <code>ConexionTCP</code> recibe como parametro una instancia de <code>ConexionTCP</code>, lo que permite a <code>EstadoTCP</code> acceder a los datos de <code>ConexionTCP</code> y cambiar el estado de la conexion.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">EstadoTCP</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Transmitir</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">,</span> <span class="n">FlujoOctetosTCP</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">AbrirActiva</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">AbrirPasiva</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Cerrar</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Sincronizar</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">AcuseDeResibo</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Enviar</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">);</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">CambiarEstado</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">,</span> <span class="n">EstadoTCP</span><span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
<p><code>ConexionTCP</code> delega todas las peticiones dependiendo del estado en su instancia de <code>EstadoTCP</code>, <code>_estado.ConexionTCP</code> tambien proporciona una operacion para cambiar esta varable por un nuevo <code>EstadoTCP</code>. El constructor de <code>ConexionTCP</code> inicializa este objeto al estado <code>TCPCerrada</code> (definida mas adelante).</p>
<pre class="code" ><code class="chroma" ><span class="n">ConexionTCP</span><span class="o">::</span><span class="n">ConexionTCP</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_estado</span> <span class="o">=</span> <span class="n">TCPCerrada</span><span class="o">::</span><span class="n">Instancia</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConexionTCP</span><span class="o">::</span><span class="n">CambiarEstado</span> <span class="p">(</span><span class="n">EstadoTCP</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_estado</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConexionTCP</span><span class="o">::</span><span class="n">AbrirActiva</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_estado</span><span class="o">-&gt;</span><span class="n">AbrirActiva</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConexionTCP</span><span class="o">::</span><span class="n">AbrirPasiva</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_estado</span><span class="o">-&gt;</span><span class="n">AbrirPasiva</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConexionTCP</span><span class="o">::</span><span class="n">Cerrar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_estado</span><span class="o">-&gt;</span><span class="n">Cerrar</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConexionTCP</span><span class="o">::</span><span class="n">AcuseDeRecibo</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_estado</span><span class="o">-&gt;</span><span class="n">AcuseDeRecibo</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConexionTCP</span><span class="o">::</span><span class="n">Sincronizar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_estado</span><span class="o">-&gt;</span><span class="n">Sincronizar</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p><code>EstadoTCP</code> implementa el comportamiento predeterminado de todas las peticiones delegadas en el. Tambien puede cambiar el estado de una <code>ConexionTCP</code> mediante la operacion <code>CambiarEstado</code>. <code>EstadoTCP</code> se declara como amiga de <code>ConexionTCP</code> para dar a esta operacion un acceso restringido.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">EstadoTCP</span><span class="o">::</span><span class="n">Transmitir</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">,</span> <span class="n">FlujoOctetosTCP</span><span class="o">*</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="n">EstadoTCP</span><span class="o">::</span><span class="n">AbrirActiva</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="n">EstadoTCP</span><span class="o">::</span><span class="n">AbrirPasiva</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="n">EstadoTCP</span><span class="o">::</span><span class="n">Cerrar</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="n">EstadoTCP</span><span class="o">::</span><span class="n">Sincronizar</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">EstadoTCP</span><span class="o">::</span><span class="n">CambiarEstado</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">EstadoTCP</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">c</span><span class="o">-&gt;</span><span class="n">CambiarEstado</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Las subclases de <code>EstadoTCP</code> implementan comportamiento especifico de ese estado. Una conexion TCP puede encontrarse en muchos estados: Establecida, Escuchando, Cerrada, etc., y hay una subclase de <code>EstadoTCP</code> para cada uno de ellos. Examinaremos estas tres subclases en detalle: <code>TCPEstablecida</code>, <code>TCPEscuchando</code> y <code>TCPCerrada</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">TCPEstablecida</span> <span class="o">:</span> <span class="k">public</span> <span class="n">EstadoTCP</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">EstadoTCP</span><span class="o">*</span> <span class="n">Instancia</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Transmitir</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">,</span> <span class="n">FlujoOctetosTCP</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Cerrar</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">TCPEscuchando</span> <span class="o">:</span> <span class="k">public</span> <span class="n">EstadoTCP</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">EstadoTCP</span><span class="o">*</span> <span class="n">Instancia</span><span class="p">();</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Enviar</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">);</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>

<span class="k">class</span> <span class="nc">TCPCerrada</span> <span class="o">:</span> <span class="k">public</span> <span class="n">EstadoTCP</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">EstadoTCP</span><span class="o">*</span> <span class="n">Instancia</span><span class="p">();</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">AbrirActiva</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">AbrirPasiva</span><span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span><span class="p">);</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Las subclases de <code>EstadoTCP</code> no mantienen un estado local, de modo que pueden compartirse, siendo solo necesaria una instancia de cada una. Esta unica instancia de cada subclase de <code>EstadoTCP</code> se obtiene a traves de la operacion estatica <code>Instancia</code>.<span class="note" ><sup><a href="#52" >52</a></sup></span></p>
<p>Cada subclase de <code>EstadoTCP</code> implementa comportamiento especifico de ese estado para aquellas peticiones validas en ese estado:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">TCPCerrada</span><span class="o">::</span><span class="n">AbribActiva</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// envia SYN, recibe SYN, ACK, etc.
</span><span class="c1"></span>
    <span class="n">CambiarEstado</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">TCPEstablecida</span><span class="o">::</span><span class="n">Instancia</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TCPCerrada</span><span class="o">::</span><span class="n">AbrirPasiva</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CambiarEstado</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">TCPEscuchando</span><span class="o">::</span><span class="n">Instancia</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TCPEstablecida</span><span class="o">::</span><span class="n">Cerrar</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// envia FIN, recibe ACK de FIN
</span><span class="c1"></span>
    <span class="n">CambiarEstado</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">TCPEscuchando</span><span class="o">::</span><span class="n">Instancia</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TCPEstablecida</span><span class="o">::</span><span class="n">Transmitir</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">FlujoOctetosTCP</span><span class="o">*</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">ProcesarOcteto</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TCPEscuchando</span><span class="o">::</span><span class="n">Enviar</span> <span class="p">(</span><span class="n">ConexionTCP</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// envia SYN, recibe SYN, ACK, etc.
</span><span class="c1"></span>
    <span class="n">CambiarEstado</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">TCPEstablecida</span><span class="o">::</span><span class="n">Instancia</span><span class="p">());</span>
<span class="p">}</span>
</code></pre>
<p>Despues de realizar el trabajo concreto de este estado, estas operaciones llaman a la operacion <code>CambiarEstado</code> para cambiar el estado de <code>ConexionTCP</code>. <code>ConexionTCP</code> no sabe nada sobre el protocolo de <code>ConexionTCP</code>; son las subclases de <code>EstadoTCP</code> quienes definen cada transicion de estado y accion de TCP.</p>
</div>
<h4 id="state-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Johson y Zweig [<a href="#jz91" >JZ91</a>] describen el patron State y su aplicacion a los protocolos de conexion TCP.</p>
<p>La mayoria de programas de dibujo interactivos proporcionan <q>herramientas</q> para llevar a cabo operaciones mediante manipulacion directa. Por ejemplo, una herramienta de dibujado de lineas permite al usuario selecciononar formas. Suele haber una paleta de herramientas para elegir. El usuario concibe esta actividad como tomar una herramienta y manejarla, pero en realidad el comportamiento del editor cambia con la herramienta actual: cuando esta activa una herramienta de dibujado creamos formas; cuando esta activa la herramienta de seleccion seleccionamos formas; y asi sucesivamente. Podemos usar el patron State para cambiar el comportamiento del editor que depende de la herramienta actual.</p>
<p>Podemos definir una clase abstracta <code>Herramienta</code> a partir de la cual definir subclases que implementen comportamiento especifico de la herramienta. El editor de dibujo mantiene un objeto <code>Herramienta</code> actual al cual delega las peticiones. Cuando el usuario selecciona una nueva herramienta, cambia este objeto, haciendo que el comportamiento del editor cambie en consecuencia.</p>
<p>Esta tecnica se emplea en los frameworks de editores de dibujo HotDraw [<a href="#joh92" >Joh92</a>] y UniDraw [<a href="#vl90" >VL90</a>]. Esto permite que los clientes definan nuevos tipos de herramientas facilmente. En HotDraw, la clase <code>DrawingController</code> redirige las peticiones al objeto <code>Tool</code> (<em>herramienta</em>) actual. En Unidraw, las clases correspondientes son <code>Viewer</code> y <code>Tool</code>. El siguiente diagrama de clases muestra un esbozo de las interfaces <code>Tool</code> y <code>DrawingController</code>:</p>
<figure>
<img src="img/117.png" />
</figure>
<p>El modismo de Coplien Sobre-Carta (<em>Envelope-Letter</em>) [<a href="#cop92" >Cop92</a>] esta relacionado con el patron State. Sobre-Carta es una tecnica para cambiar la clase de un objeto en tiempo de ejecucion. El patron State es mas especifico, centrandose en como tratar con un objeto cuyo comportamiento depende de su estado.</p>
</div>
<h4 id="state-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>El patron <a href="#flyweight" >Flyweight</a> explica cuando y como compartir objetos Estado.</p>
<p>Los objetos Estado muchas veces son <a href="#Singleton" >Singletons</a>.</p>
</div>
<h3 id="strategy" >Strategy</h3>
<h4 id="strategy-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Define una familia de algoritmos, encapsula cada uno de ellos y los hace intercambiables. Permite que un algoritmo varie independientemente de los clientes que lo usan.</p>
</div>
<h4 id="strategy-tambien-conocido-como" >Tambien Conocido Como</h4>
<div class="hBody-4" >
<p>Policy (Politica)</p>
</div>
<h4 id="strategy-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Existen muchos algoritmos para dividir un flujo de texto. Codificar dichos algoritmos en las clases que los usan no resulta una buena practica por varias razones:</p>
<ul>
<li>
<p>Los clientes que necesitan dividir el texto en lineas se vuelven mas complejos si tienen que incluir dicho codigo, lo que los hace mas grandes y mas dificiles de matener, sobre todo si permiten varios algoritmos diferentes de division en lineas.</p>
</li>
<li>
<p>Los distintos algoritmos seran apropiados en distintos momentos. No tenemos por que permitir multiples algoritmos si no los vamos a usar todos.</p>
</li>
<li>
<p>Es dificil añadir nuevos algoritmos o modificar los existentes cuando la division en lineas es parte integral de un cliente.</p>
</li>
</ul>
<p>Estos problemos pueden evitarse definiendo clases que encapsulen los diferentes algoritmos de division de lineas. Un algoritmo asi encapsulado se denomina una estrategia.</p>
<figure>
<img src="img/118.png" />
</figure>
<p>Supongamos que una clase <code>Composicion</code> debe mantener y actualizar los saltos de linea del texto mostrado en un visor. Las estrategias de division en lineas no estan implementadas en la clase <code>Composicion</code>. En vez de eso, se implementan separadamente por las subclases de la clase abstracta <code>Componedor</code>. Las subclases de <code>Componedor</code> implementan diferentes estrategias:</p>
<ul>
<li>
<p><code>ComponedorSimple</code> implementa una estrategia simple que calcula un salto de linea cada vez.</p>
</li>
<li>
<p><code>ComponedorTeX</code> implementa el algoritmo <b>TeX</b> para buscar los saltos de linea. Esta estrategia trata de optimizar los saltos de line globalmente, es decir, un parrafo cada vez.</p>
</li>
<li>
<p><code>ComponedorMatriz</code> implementa una estrategia que selecciona los saltos de liene de modo que cada fila tenga un numero determinado de elementos. Es util para dividir una serie de iconos en filas, por ejemplo.</p>
</li>
</ul>
<p>Una <code>Composicion</code> mantiene una referencia a un objeto <code>Componedor</code>. Cada vez que una <code>Composicion</code> vuelve a formatear su texto, reenvia esta responsabilidad a su objeto <code>Componedor</code>. El cliente de <code>Composicion</code> especifica que <code>Componedor</code> deberia usarse, y dicho <code>Componedor</code> sera instalado en la <code>Composicion</code>.</p>
</div>
<h4 id="strategy-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Strategy cuando</p>
<ul>
<li>
<p>muchas clases relacionadas difieren solo en su comportamiento. Las estrategias permiten configurar una clase con un determinado comportamiento de entre muchos posibles.</p>
</li>
<li>
<p>se necesitan distintas variantes de un algoritmo. Por ejemplo, podriamos definir algoritmos que reflejasen distintas soluciones de compromiso entre tiempo y espacio. Pueden usarse estrategias cuando estas variantes se implementan como una jerarquia de clases de algoritmos [<a href="#ho87" >HO87</a>].</p>
</li>
<li>
<p>un algoritmo usa datos que los clientes no deberian conocer. Usese el patron Strategy para evitar exponer estructuras de datos complejas y dependientes del algoritmo.</p>
</li>
<li>
<p>una clase define muchos comportamientos, y estos se representan como multiples sentecias condicionales en sus operaciones. En vez de tener muchos condicionales, podemos mover las ramas de estos a su propia clase <code>Estrategia</code>.</p>
</li>
</ul>
</div>
<h4 id="strategy-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/119.png" />
</figure>
</div>
<h4 id="strategy-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Estrategia</code> (<code>Componedor</code>)</p>
<ul>
<li>
<p>declara una interfaz comun a todos los algoritmos permitidos. El <code>Contexto</code> usa esta interfaz para llamar al algoritmo definido por una <code>EstrategiaConcreta</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>EstrategiaConcreta</code> (<code>ComponedorSimple</code>, <code>ComponedorTeX</code>, <code>ComponedorMatriz</code>)</p>
<ul>
<li>
<p>implementa el algoritmo utilizando la interfaz de <code>Estrategia</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>Contexto</code> (<code>Composicion</code>)</p>
<ul>
<li>
<p>se configura con un objeto <code>EstrategiaConcreta</code></p>
</li>
<li>
<p>mantiene una referencia a un objeto <code>Estrategia</code>.</p>
</li>
<li>
<p>puede definir una interfaz que permita a la <code>Estrategia</code> acceder a sus datos.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="strategy-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Estrategia</code> y <code>Contexto</code> interactuan para implementar el algoritmo elegido. Un contexto puede pasar a la estratiga todos los datos requeridos por el algoritmo cada vez que se llama a este. Otra alternativa es que el contexto se pase a si mismo como argumento de las operaciones de <code>Estrategia</code>. Eso permite a la estrategia hacer llamadas al contexto cuando es necesario.</p>
</li>
<li>
<p>Un contexto redirige peticiones de los clientes a su estrategia. Los clientes normalmente crean un objeto <code>EstrategiaConcreta</code>, el cual pasan al contexto; por tanto, los clientes interactuan exclusivamente con el contexto. Suele haber una familia de clases <code>EstrategiaConcreta</code> a elegir por el cliente.</p>
</li>
</ul>
</div>
<h4 id="strategy-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>El patron Strategy presenta las siguientes ventajas e inconvenietes:</p>
<ol class="num" >
<li>
<p><em>Familias de algoritmos relacionados.</em> Las jerarquies de clases <code>Estrategia</code> definen una familia de algoritmos o comportamientos para ser reutilizados por los contextos. La herencia puede ayudar a sacar factor comun de la funcionalidad de estos algoritmos.</p>
</li>
<li>
<p><em>Una alternativa a la herencia.</em> La herencia ofrece otra forma de permitir una variedad de algoritmos o comportamientos. Se puede heredar directamente de una clase <code>Contexto</code> para proporcionar diferentes comportamientos. Pero esto liga el comportamiento al <code>Contexto</code>, mezclando la implementacion del algoritmo con la del <code>Contexto</code>, lo que hace que este sea mas dificil de comprender, mantener y extender. Y no se puede modificar el algoritmo dinamicamente. Acabaremos teniendo muchas clases relacionadas cuya unica diferencia es el algoritmo o comportamiento que utilizan. Encapsular el algoritmo en clases <code>Estrategia</code> separadas nos permite variar el algoritmo independientemente de su contexto, haciendolo mas facil de cambiar, compreder y extender.</p>
</li>
<li>
<p><em>Las estrategias eliminan las sentencias condicionales.</em> El patron Strategy ofrece una alternativa a las sentencias condicionales para seleccionar el comportamieto deseado. Cuando se juntan muchos comportamientos en una clase es dificil no usar sentecias condicionales para seleccionar el comportamiento correcto. Encapsular el comportamiento en clases <code>Estrategia</code> separadas elimina estas sentencias condicionales.</p>
<p>Por ejemplo, sin estrategias, el codigo para dividir un texto en lineas podria parecerse a</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Composicion</span><span class="o">::</span><span class="n">Reparar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">_estrategiaDeDivision</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">EstrategiaSimple</span><span class="p">:</span>
        <span class="n">ComponerConComponedorteSimple</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">EstrategiaTeX</span><span class="p">:</span>
        <span class="n">ComponerConComponedorTeX</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">// si es necesario, combina los resultados
</span><span class="c1"></span>    <span class="c1">// con la composicion existente
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>El patron Estrategia elimina esta sentencia condicional delegando la tarea de division en lineas en el objeto <code>Estrategia</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Composicion</span><span class="o">::</span><span class="n">Reparar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">_componer</span><span class="o">-&gt;</span><span class="n">Componer</span><span class="p">();</span>
    <span class="c1">// si es necesario, combina los resultados
</span><span class="c1"></span>    <span class="c1">// con la composicion existente
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Un codigo que contiene muchas sentecias condicionales suele indicar la necesidad de aplicar el patron Estrategia.</p>
</li>
<li>
<p><em>Una eleccion de implementaciones.</em> Las estrategias pueden proporcionar distintas implementaciones del mismo comportamiento. El cliente puede elegir entre estrategias con diferentes soluciones de compromiso entre tiempo y espacio.</p>
</li>
<li>
<p><em>Los clientes deben conocer las diferentes Estrategias.</em> El patron tiene el inconveniente potencial de que un cliente debe conprender como difieren las Estrategias antes de seleccionar la adecuada. los clientes pueden estar expuestos a cuestiones de implementacion. Por tanto, el patron Strategy deberia usarse solo cuando la variacion de comportamiento sea relevante a los clientes.</p>
</li>
<li>
<p><em>Costes de comunicacion entre Estrategia y Contexto.</em> La interfaz de <code>Estrategia</code> es compartida por todas las clases <code>EstrategiaConcreta</code>, ya sea el algoritmo que implementa trivial o complejo. Por tanto, es probable que algunos objetos <code>EstrategiaConcreta</code> no usen toda la informacion que reciben a traves de dicha interfaz, las estrategias concretas simples pueden incluso no utilizar nada de dicha informacion. Eso significa que habra veces en las que el contexto crea e inicializa parametros que nunca se usan. Si esto puede ser un problema, necesitaremos un acoplamiento mas fuerte entre <code>Estrategia</code> y <code>Contexto</code>.</p>
</li>
<li>
<p><em>Mayor numero de objetos.</em> Las estrategias aumentan el numero de objetos de una aplicacion. A veces se puede reducir este coste implementando las estrategias como objetos sin estado que puedan ser compartidos por el contexto. El contexto mantiene cualquier estado residual, pasandolo en cada peticion al objeto <code>Estrategia</code>. Las estrategias compartidas no deberian mantener el estado entre invocaciones. El patron <a href="#flyweight" >Flyweight</a> describe este enfoque en mas detalle.</p>
</li>
</ol>
</div>
<h4 id="strategy-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Examinemos las siguientes cuestiones de implementacion:</p>
<ol class="num" >
<li>
<p><em>Definir las interfaces <code>Estrategia</code> y <code>Contexto</code>.</em> Las interfaces <code>Estrategia</code> y <code>Contexto</code> deben permitir a una <code>EstrategiaConcreta</code> acceder de manera eficiente a cualquier dato que esta necesite del contexto, y viceversa.</p>
<p>Un enfoque es hacer que <code>Contexto</code> pase los datos como parametros a las operaciones de <code>Estrategia</code> ––en otras palabras, lleva los datos a la estrategia––. Esto mantiene a <code>Estrategia</code> y <code>Contexto</code> desacoplados. Por otro lado, <code>Contexto</code> podria pasar datos a la <code>Estrategia</code> que esta no necesita.</p>
<p>Otra tecnica consiste en que un contexto se pase a <em>si mismo</em> como argumento, y que la estrategia pida los datos explicitamente al contexto. Como alternativa, la estrategia puede guardar una referencia a su contexto, eliminando asi la necesidad de pasar nada. De cualquiera de las dos formas, la estrategia puede pedir exactamente lo que necesita. Pero ahora <code>Contexto</code> debe definir una interfaz mas elaborada para sus datos, lo que acopla mas estrechamente a <code>Estrategia</code> y <code>Contexto</code>.</p>
<p>Las necesidades del algoritmo concreto y sus requisitos de datos determinaran cual es la mejor tecnica.</p>
</li>
<li>
<p><em>Estrategias como parametros de plantillas.</em> En C++, pueden usarse las plantillas para configurar una clase como una estrategia. Esta tecnica solo se puede aplicar si (1) se puede seleccionar la <code>Estrategia</code> en tiempo de compilacion, y (2) no hay que cambiarla en tiempo de ejecucion. En este caso, la clase a configurar (por ejemplo, <code>Contexto</code>) se define en una clase plantilla que tiene como parametro una clase <code>Estrategia</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">UnaEstrategia</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Contexto</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">Operacion</span><span class="p">()</span> <span class="p">{</span> <span class="n">laEstrategia</span><span class="p">.</span><span class="n">HacerAlgoritmo</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">UnaEstrategia</span> <span class="n">laEstrategia</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>La clase se configura con una clase <code>Estrategia</code> en el momento en que se crea una instancia:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">MiEstrategia</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">HacerAlgoritmo</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">Contexto</span><span class="o">&lt;</span><span class="n">MiEstrategia</span><span class="o">&gt;</span> <span class="n">unContexto</span><span class="p">;</span>
</code></pre>
<p>Con plantillas, no hay necesidad de definir una clase abstracta que defina la interfaz de la <code>Estrategia</code>. Usar <code>Estrategia</code> como un parametro de plantilla tambien nos permite enlazar estaticamente una <code>Estrategia</code> a su <code>Contexto</code>, lo que puede aumentar la eficiencia.</p>
</li>
<li>
<p><em>Hacer opcionales los objetos Estrategia.</em> La clase <code>Contexto</code> puede simplificarse en caso de que tenga sentido no tener un objeto <code>Estrategia</code>. La clase <code>Contexto</code> comprueba si tiene un objeto <code>Estrategia</code> antes de acceder a el. En caso de que exista, lo usa normalmente. Si no hay una estrategia, <code>Contexto</code> realiza el comportamiento predeterminado. La ventaja de este enfoque es que los clientes no tienen que tratar con los objetos <code>Estrategia</code> <em>a menos</em> que no les sirva el comportamiento predeterminado.</p>
</li>
</ol>
</div>
<h4 id="strategy-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>A continuacion se muestra el codigo de alto nivel del ejemplo de la seccion de la Motivacion, que esta basado en la implementacion de las clases <code>Composicion</code> y <code>Componedor</code> de InterViews [<a href="#lci+92" >LCI+92</a>].</p>
<p>La clase <code>Composicion</code> tiene una coleccion de instancias de <code>Componente</code>, que representan los elementos graficos y de texto de un documento. Una composicion distribuye los objetos componente en lineas usando una instancia de una subclase de <code>Componedor</code>, la cual encapsula una estrategia de division en lineas. Cada componente tiene un tamaño natural asociado, una dimension maxima y otra minima. Estas definen cuanto puede crecer el componente por encima de su tamaño natural y cuanto puede encogerse, respectivamente. La composicion pasa estos valores a un componedor, que los usa para determinar la mejor posicion para los saltos de linea.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Composicion</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Composicion</span><span class="p">(</span><span class="n">Componedor</span><span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Reparar</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Componedor</span><span class="o">*</span> <span class="n">_componedor</span><span class="p">;</span>
    <span class="n">Componente</span><span class="o">*</span> <span class="n">_componentes</span><span class="p">;</span>   <span class="c1">// la lista de componentes
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">_contadorComponentes</span><span class="p">;</span>   <span class="c1">// el numero de componentes
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">_anchoLinea</span><span class="p">;</span>            <span class="c1">// el ancho de linea de la composicion
</span><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">_saltosLinea</span><span class="p">;</span>          <span class="c1">// la posicion de los saltos de
</span><span class="c1"></span>                                <span class="c1">// linea en los componentes
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">_contadorLineas</span><span class="p">;</span>        <span class="c1">// el numero de lineas
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>Cuando se necesita una neuva distribucion, la composicion le pide a su componedor que determine donde situar los saltos de linea. La composicion pasa al componedor tres arrays que definen el tamaño natural y las dimenciones maximas y minimas de los componentes. Tambien pasa el numero de componentes, el ancho de la linea y un array que rellena el componedor con la posicion de cada salto de liena. El componoder devuelve el numero de saltos calculados.</p>
<p>La interfaz del <code>Componedor</code> permite que la composicion pase a este toda la informacion que necesita. Esto es un ejemplo de <q>llevar los datos a la estrategia</q>:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Componedor</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">Componer</span><span class="p">(</span>
        <span class="n">Coord</span> <span class="n">natural</span><span class="p">[],</span> <span class="n">Coord</span> <span class="n">estirado</span><span class="p">[],</span> <span class="n">Coord</span> <span class="n">encogido</span><span class="p">[],</span>
        <span class="kt">int</span> <span class="n">contadorComponentes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">anchoLinea</span><span class="p">,</span> <span class="kt">int</span> <span class="n">saltos</span><span class="p">[]</span>
    <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Componedor</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>Notese que <code>Componedor</code> es una clase abstracta. Las subclases concretas definen estrategias concretas de division en lineas.</p>
<p>La composicion llama a su componedor en su operacion <code>Reparar</code>. En primer lugar, <code>Reparar</code> inicializa los arrays con el tamaño natural y las dimensiones maxima y minima de cada componente (omitiremos los detalles de como se hace esto en aras de la brevedad). A continuacion, llama al componedor para obtener los saltos de linea. Finalmente, distribuye los componentes en funcion de los saltos de linea (tambien omitido):</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Composicion</span><span class="o">::</span><span class="n">Reparar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">Coord</span><span class="o">*</span> <span class="n">natural</span><span class="p">;</span>
    <span class="n">Coord</span><span class="o">*</span> <span class="n">maxima</span><span class="p">;</span>
    <span class="n">Coord</span><span class="o">*</span> <span class="n">minima</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">contadorComponentes</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">saltos</span><span class="p">;</span>

    <span class="c1">// preparar los arreglos con el tamaño deseado de los componentes
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span>
    <span class="c1">// determina donde van los saltos:
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">contadorSaltos</span><span class="p">;</span>
    <span class="n">contadorSaltos</span> <span class="o">=</span> <span class="n">_componedor</span><span class="o">-&gt;</span><span class="n">Componer</span><span class="p">(</span>
        <span class="n">natural</span><span class="p">,</span> <span class="n">maxima</span><span class="p">,</span> <span class="n">minima</span><span class="p">,</span>
        <span class="n">contadorComponentes</span><span class="p">,</span> <span class="n">_anchoLinea</span><span class="p">,</span> <span class="n">saltos</span>
    <span class="p">);</span>

    <span class="c1">// coloca los componentes en funcion de los saltos
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Veamos ahora las subclases de <code>Componedor</code>. <code>ComponedorSimple</code> examina los componentes de una linea cada vez, para determinar donde deberian ir los saltos:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ComponedorSimple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Componedor</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ConponedorSimple</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Componer</span><span class="p">(</span>
        <span class="n">Coord</span> <span class="n">natural</span><span class="p">[],</span> <span class="n">Coord</span> <span class="n">maxima</span><span class="p">[],</span> <span class="n">Coord</span> <span class="n">minima</span><span class="p">[],</span>
        <span class="kt">int</span> <span class="n">contadorComponentes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">anchoLinea</span><span class="p">,</span> <span class="kt">int</span> <span class="n">saltos</span><span class="p">[]</span>
    <span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p><code>ComponedorTeX</code> usa una estrategia mas global. Examina un <em>parrado</em> cada vez, teniendo en cuenta el tamaño y la dimension maxima de los componentes. Tambien trata de asignar un &#34;color&#34; uniforme al parrafo minimizando el espacio entre componentes.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ComponederTeX</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Componedor</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ComponedorTeX</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Componer</span><span class="p">(</span>
        <span class="n">Coord</span> <span class="n">natural</span><span class="p">[],</span> <span class="n">Coord</span> <span class="n">maxima</span><span class="p">[],</span> <span class="n">Coord</span> <span class="n">minima</span><span class="p">[],</span>
        <span class="kt">int</span> <span class="n">contadorComponentes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">anchoLinea</span><span class="p">,</span> <span class="kt">int</span> <span class="n">saltos</span><span class="p">[]</span>
    <span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p><code>ComponedorMatriz</code> separa los componentes en lineas a intervalos regulares.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ComponedorMatriz</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Componedor</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ComponedorMatriz</span><span class="p">(</span><span class="kt">int</span> <span class="n">intervalo</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Componer</span><span class="p">(</span>
      <span class="n">Coord</span> <span class="n">natural</span><span class="p">[],</span> <span class="n">Coord</span> <span class="n">maxima</span><span class="p">[],</span> <span class="n">Coord</span> <span class="n">minima</span><span class="p">[],</span>
      <span class="kt">int</span> <span class="n">contadorComponentes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">anchoLinea</span><span class="p">,</span> <span class="kt">int</span> <span class="n">saltos</span><span class="p">[]</span>
  <span class="p">);</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre>
<p>Estas clases no usan toda la informacion que se le pasa a <code>Componer</code>. <code>ComponedorSimple</code> no hace uso de la dimencion maxima de los componentes, y solo tiene en cuenta el ancho natural de estos. <code>ComponedorTeX</code> usa toda la informacion que recibe, mientras que <code>ComponedorMatriz</code> no usa nada.</p>
<p>Para crear una instancia de <code>Composicion</code> es necesario pasarle el componedor que queremos que use:</p>
<pre class="code" ><code class="chroma" ><span class="n">Composicion</span><span class="o">*</span> <span class="n">rapida</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Composicion</span><span class="p">(</span><span class="k">new</span> <span class="n">ComponedorSimple</span><span class="p">);</span>
<span class="n">Composicion</span><span class="o">*</span> <span class="n">elegante</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Composicion</span><span class="p">(</span><span class="k">new</span> <span class="n">ComponedorTeX</span><span class="p">);</span>
<span class="n">Composicion</span><span class="o">*</span> <span class="n">iconos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Composicion</span><span class="p">(</span><span class="k">new</span> <span class="n">ComponedorMatriz</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
</code></pre>
<p>La <code>intrefaz</code> de <code>Componedor</code> esta cuidadosamente diseñada para permitir toda clase de algoritmos de composicion que pudieran implementar las subclases. No queremos tener que cambiar esta interfaz con cada nueva subclase, ya que eso requeriria cambiar las subclases existentes. En general, las interfaces <code>Estrategia</code> y <code>Contexto</code> determinan en que medida consigue el patron su proposito.</p>
</div>
<h4 id="strategy-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Tanto ET++ [<a href="#wgm88" >WGM88</a>] como InterViews usan estrategias para encapsular diferentes algoritmos de division en lineas tal y como se ha descrito aqui.</p>
<p>En el Sistema RTL System para optimizacion de codigo en los compiladores [<a href="#jml92" >JML92</a>], las estrategias definen diferentes esquemas de asignacion de registros (RegisterAllocator) y de politicas de planificacion de juegos de instrucciones (RISCscheduler, CISCscheduler). Esto proporciona flexibilidad a la hora de usar el optimizador para diferentes arquitecturas de maquinas.</p>
<p>El framework de moteres de calculo ET++ SwapsManager, calcula los precios de diversos intrumentos financieros [<a href="#eg92" >EG92</a>]. Sus abstracciones clave son <code>Instrument</code> y <code>YieldCurve</code>. Los diferentes instrumentos se implementan como subclases de <code>Intrument</code>. <code>YieldCurve</code> calcula los tipos de descuento, que determinan el valor actual de los flujos de caja futuros. Ambas clases delegan parte de su comportamiento en objetos Estrategia. El framework proporciona una familia de clase <code>EstrategiaConcreta</code> para generar flujos de caja, valorar permutas financieras y calcular tipos de descuento. Se pueden crear nuevos motores de calculo configurando <code>Istrument</code> y <code>YieoldCurve</code> con los distintos objetos <code>EstrategiaConcreta</code>. Este enfoque permite combinar y usar las implementaciones existentes de <code>Estrategia</code> asi como definir otras nuevas.</p>
<p>Los componentes de Booch [<a href="#bv90" >BV90</a>] usan estrategias como argumentos de plantillas. Las clases de colecciones de Booch permiten tres tipos de estrategias de asignacion de memoria: gestionada (asignacion mediante un <em>pool</em>), controlada (las asignaciones y liberaciones estan protegidas por bloqueos) y sin gestionar (el asignador de memoria predeterminado). Estas estrategias se pasan como argumentos de plantilla a una clase de coleccion cada vez que se crea una instancia de esta. Por ejemplo, una coleccion de tamaño variable que usa la estrategia de no gestionar se crea como una <code>UnboundedCollection</code>.</p>
<p>RApp es un sistema para el diseño de circuitos integrados [<a href="#ga89" >GA89</a>, <a href="#ag90" >AG90</a>]. RApp debe dibujar cables que conectan los distintos subsistemas de un circuito. Los algoritmos que determinan por donde deben ir dichos cables se definen en RApp como subclases de una clase abstracta <code>Router</code>. <code>Router</code> es una clase Estrategia.</p>
<p>ObjectWindows de Borland [<a href="#bor94" >Bor94</a>] usa estrategias en los cuadros de dialogo para asegurar que el usuario introduzca datos validos. Por ejemplo, los numeros podrian tener que estar dentro de un intervalo determinado, y un campo numerico solo deberia aceptar digitos. Validar que una cadena es correcta puede necesitar una tabla de busqueda.</p>
<p>ObjectWindows usa objetos <code>Validator</code> para encapsular estrategias de validacion. Los validadores son ejemplos de objetos Estrategia. Los campos de entrada de datos delegan la validacion a un objeto <code>Validator</code> opcional. El cliente asigna un validador a un campo que necesita ser validado (esto constituye un ejemplo de una estrategia opcional). Cuando se cierra el dialogo, los campos de entrada le piden a sus validadores que validen los datos. La biblioteca de clases proporciona validadores para los casos mas comunes, como un <code>RangeValidator</code> (validador de intervalo) para numeros. Se pueden definir facilmente nuevas estrategias especificas del cliente heredando de la clase <code>Validator</code>.</p>
</div>
<h4 id="strategy-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p><a href="#flyweight" >Flyweight</a>: los objetos Estrategia suelen ser buenos pesos ligeros.</p>
</div>
<h3 id="template-method" >Template Method</h3>
<h4 id="template-method-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Define en una operacion el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos de un algoritmo sin cambiar su estructura.</p>
</div>
<h4 id="template-method-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Pensemos en un framework que proporciona las clases <code>Aplicacion</code> y <code>Documento</code>. La clase <code>Aplicacion</code> es la responsable de abrir el documento guardado en un formato externo, como por ejemplo un fichero. Un objeto <code>Documento</code> representa la informacion de un documento una vez que este ha sido leido del fichero.</p>
<p>Las aplicaciones construidas con el framework pueden heredar de <code>Aplicacion</code> o <code>Documento</code> para adaptarse a necesidades esecificas. Por ejemplo, una aplicacion de dibujo define las subclase <code>AplicacionDeDibujo</code> y <code>DocumentoDeDibujo</code>; una aplicacion de hoja de calculo define las subclases <code>AplicacionDeHojaDeCalculo</code> y <code>DocumentoDeHojaDeCalculo</code>.</p>
<figure>
<img src="img/120.png" />
</figure>
<p>La clase <code>Aplicacion</code> define el algoritmo para abrir y leer un documento en su operacion <code>AbrirDocumento</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Aplicacion</span><span class="o">::</span><span class="n">AbrirDocumento</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nombre</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SePuedeAbrirDocumento</span><span class="p">(</span><span class="n">nombre</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// no se puede abrir este documento
</span><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Documento</span><span class="o">*</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">HacerCrearDocumento</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">doc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_docs</span><span class="o">-&gt;</span><span class="n">AnadirDocumento</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
        <span class="n">APuntoDeAbrirDocumento</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
        <span class="n">doc</span><span class="o">-&gt;</span><span class="n">Abrir</span><span class="p">();</span>
        <span class="n">doc</span><span class="o">-&gt;</span><span class="n">HacerLeer</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><code>AbrirDocumento</code> define cada paso para abrir el documento. Comprueba si el documento puede abrise, crea el objeto <code>Documento</code> especifico de la aplicacion, lo añade a su cojunto de documentos y lee el <code>Documento</code> de un fichero.</p>
<p>Llamaremos a <code>AbrirDocumento</code> un <b>metodo plantilla</b>. Un metodo plantilla define un algoritmo en terminos de operaciones abstractas que las subclases deben definir para proporcionar un determinado comportamiento. Las subclases de <code>Aplicacion</code> definen los pasos del algoritmo que comprueban si el decumento puede abrise (<code>SePuedeAbrirDocumento</code>) y que crean el <code>Documento</code> (<code>HacerCrearDocumento</code>). Las clases <code>Documento</code> definen el paso que lee el documento (<code>HacerLeer</code>). El metodo plantilla tambien define una operacion que permite que las subclases de <code>Aplicacion</code> sepan cuando se va abrir el documento (<code>APuntoDeAbrirDocumento</code>).</p>
<p>Al definir algunos de los pasos de un algoritmo usando operaciones abstractas, el metodo plantilla fija su ordenacion, pero permite que las subclases de <code>Aplicacion</code> y <code>Documento</code> modifiquen dichos pasos para adecuarse a sus necesidades.</p>
</div>
<h4 id="template-method-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>El patron Template Method deberia usarse</p>
<ul>
<li>
<p>para implementar las partes de un algoritmo que no cambian y dejar que sean las subclase quienes implementen el comportamiento que puede variar.</p>
</li>
<li>
<p>cuando el comportamiento repetido de varias subclases deberia factorizarse y ser localizado en una clase comun para evitar el codigo duplicado. Esta es una buena idea de <q>refactorizar para generalizar</q>, tal como la describen Opdyke y Johnson [<a href="#oj93" >OJ93</a>]. En primer lugar identificamos las diferencias en el codigo existente y a continuaicon separamos dichas diferencias en nuevas operaciones. Por ultimo, sustituimos el codigo que cambia por un metodo que llama a una de estas nuevas operaciones.</p>
</li>
<li>
<p>para controlar las extensiones de las subclases. Podemos definir un metodo plantilla que llame a operaciones <q>de enganche</q> (vease las Consecuencias) en determinados puntos, permitiendo asi las extensiones solo en esos puntos.</p>
</li>
</ul>
</div>
<h4 id="template-method-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/121.png" />
</figure>
</div>
<h4 id="template-method-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>ClaseAbstacta</code> (<code>Aplicacion</code>)</p>
<ul>
<li>
<p>define operaciones primitivas abstractas que son definidas por las subclases para implementar los pasos de un algoritmo.</p>
</li>
<li>
<p>implementa un metodo plantilla que define el esqueleto de un algoritmo. El metodo plantilla llama a las operaciones primitivas asi como a operaciones definidas en <code>ClaseAbstracta</code> o a las de otros objetos.</p>
</li>
</ul>
</li>
<li>
<p><code>ClaseConcreta</code> (<code>MiAplicacion</code>)</p>
<ul>
<li>
<p>Implementa las operaciones primitivas para realizar los pasos del algoritmo especificos de las subclases.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="template-method-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<p><code>ClaseConcreta</code> se basa en la <code>ClaseAbstracta</code> para implementar los pasos de un algoritmo que no cambian.</p>
</div>
<h4 id="template-method-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>Los metodos plantillas son una tecnica fundamental de reutilizacion de codigo. Son particularmente importantes en las bibliotecas de clases, ya que son el modo de factorizar y extraer el comportamiento comun de las clases de la biblioteca.</p>
<p>Los metodos plantilla llevan a una estructura de control invertido que a veces se denomina <q>el principio de Hollywood</q>, es decir, <q>No nos llame, nosotros le llamaremos</q> [<a href="#swe85" >Swe85</a>]. Esto se refiere a como una clase padre llama a las operaciones de una subclase y no al reves.</p>
<p>Los metodos plantilla llaman a los siguientes tipos de operaciones:</p>
<ul>
<li>
<p>operaciones concretas (ya sea de la <code>ClaseConcreta</code> o de las clases cliente);</p>
</li>
<li>
<p>operaciones de <code>ClaseAbstracta</code> (es decir, operaciones que suelen ser utiles para las subclases);</p>
</li>
<li>
<p>operaciones primitvas (es decir, operaciones abstractas);</p>
</li>
<li>
<p>metodos de fabricacion (vease el patron <a href="#factory-method" >Factory Method</a>); y</p>
</li>
<li>
<p>operaciones de enganche, que proporcionan el comportamiento predeterminado que puede ser modificado por las subclases si es necesario. Una operacion de enganche normalmente no hace nada por omision.</p>
</li>
</ul>
<p>Es importante que los metodos plantilla especifiquen que operacines son enganches (que <em>pueden</em> ser redefinidas) y cuales son operaciones abstractas (que <em>deben</em> ser redefinidas). Para reutilizar una clase abstracta apropiadamente, los escritores de las subclases deben saber que operaciones estan diseñadas para ser redefinidas.</p>
<p>Una subclase puede <em>extender</em> el comportamiento de una operacion de una clase padre redefiniendo la operacion y llamando explicitamente a la operacion del padre:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">ClaseDerivada</span><span class="o">::</span><span class="n">Operacion</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ClaseDerivada extiende el comportamiento
</span><span class="c1"></span>    <span class="n">ClasePadre</span><span class="o">::</span><span class="n">Operacion</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Desgraciadamente, es facil olvidarse de llamar a la operacion heredada. Podemos trasformar esta operacion en un metodo plantilla que le de control al padre sobre como este puede ser extendido por las subclases. La idea es llamar a una operacion de enganche desde un metodo plantilla en la clase padre. Las subclases pueden entoces redefinir esta operacion de enganche:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">ClasePadre</span><span class="o">::</span><span class="n">Operacion</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// comportamiento de ClasePadre
</span><span class="c1"></span>    <span class="n">OperacionDeEnganche</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p><code>OperacionDeEnganche</code> no hace nada en la <code>ClasePadre</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">ClasePadre</span><span class="o">::</span><span class="n">OperacionDeEnganche</span> <span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</code></pre>
<p>Las subclases redefinen <code>OperacionDeEnganche</code> para extender su comportamiento:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">ClaseDerivada</span><span class="o">::</span><span class="n">OperacionDeEnganche</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// extension de la clase derivada
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<h4 id="template-method-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Merece la pena tener en cuenta tres detalles de implementacion:</p>
<ol class="num" >
<li>
<p><em>Usar el control de acceso de C++.</em> En C++, las operaciones primitivas a las que llama un metodo plantilla pueden ser declaradas como miembros protegidos. Esto garantiza que solo pueden ser llamadas por el metodo plantilla. Las operaciones primitivas que <em>deben</em> ser redefinidas se declaran como virtuales puras. El metodo plantilla en si no deberia ser redefinido; por tanto podemos hacer que sea una funcion miembro no virtual.</p>
</li>
<li>
<p><em>Minimzar las operaciones primitivas.</em> Un objeto importante para diseñar metodos plantilla es minimizar el numero de operaciones primitivas que una subclase debe redefinir para dar cuerpo al algoritmo. Cuantas mas operaciones necesiten ser redefinidas, mas tediosas se vuelven las cosas para los clientes.</p>
</li>
<li>
<p><em>Convenios de nominacion.</em> Se pueden identificar las operaciones que deberian ser redefinidas añadiendo un prefijo a sus nombres. Asi, por ejemplo, el framework MaccApp para aplicaciones de Machintosh [<a href="#app89" >App89</a>] añade a los nombres de los metodos plantilla el prefijo <q><code>Do-</code></q>: <q><code>DoCreateDocument</code></q>, <q><code>DoRead</code></q>, etcetera.</p>
</li>
</ol>
</div>
<h4 id="template-method-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>El siguiente codigo en C++ muestra como puede una clase padre obligar a sus subclases a respetar un ivariente. El ejemplo procede del AppKit de NeXT AppKit [<a href="#add94" >Add94</a>]. Pensemos en una clase <code>Vista</code> que permite dibujar en la pantalla. <code>Vista</code> hace cumplir el invariante de que sus subclases pueden dibujar en una vista solo despues de que esta ha recibido el <q>foco</q>, lo que requiere establecer de forma apropiada parte del estado del dibujo (como, por ejemplo, las fuentes y los colores).</p>
<p>Podemos usar un metodo plantilla, <code>Mostrar</code>, para establecer dicho estado. <code>Vista</code> define dos operaciones concretas, <code>AsignarFoco</code> y <code>QuitarFoco</code>, que establecen y limpian el estado del dibujo, respectivamente. La operacion <code>HacerMostrar</code> de <code>Vista</code> es quien realiza el dibujado real. <code>Mostrar</code> llama a <code>AsignarFoco</code> antes de <code>HacerMostrar</code> para configurar el estado del dibujo; <code>Mostrar</code> llama a <code>QuitarFoco</code> para liberar dicho estado.</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Vista</span><span class="o">::</span><span class="n">Mostrar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">AsignarFoco</span><span class="p">();</span>
    <span class="n">HacerMostrar</span><span class="p">();</span>
    <span class="n">QuitarFoco</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Para conservar el invariente, los clientes de <code>Vista</code> siempre llaman a <code>Mostrar</code>, y las subclases de <code>Vista</code> siempre redefinen <code>HacerMostrar</code>.</p>
<p><code>HacerMostrar</code> no hace nada en <code>Vista</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Vista</span><span class="o">::</span><span class="n">HacerMostrar</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</code></pre>
<p>Las subclases lo redefinen para añadir su comportamiento de dibujado especifico:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">MiVista</span><span class="o">::</span><span class="n">HacerMostrar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// muestra los contenidos de la vista
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<h4 id="template-method-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>Los metodos plantilla son tan fundamentales que pueden encontrarse en casi cualquier clase abstracta. Wirfs-Brock et al. [<a href="#wbww90" >WBWW90</a>, <a href="#wbj90" >WBJ90</a>] proporcionan una buena discusion de los metodos plantilla.</p>
</div>
<h4 id="template-method-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p>Los <a href="#Factory-Method" >Metodos de Fabricacion</a> se llaman muchas veces desde metodos plantilla. En el ejemplo de la seccion de Motivacion, el metodo de fabricacion <code>HacerCrearDocumento</code> es llamado por el metodo plantilla <code>AbrirDocumento</code>.</p>
<p><a href="#strategy" >Strategy</a>: Los metodos plantilla usan la herencia para modificar una parte de un algoritmo. Las estrategias usan delegacion para variar el algoritmo completo.</p>
</div>
<h3 id="visitor" >Visitor</h3>
<h4 id="visitor-proposito" >Proposito</h4>
<div class="hBody-4" >
<p>Representa una operacion sobre los elementos de una estructura de objetos. Permite definir una nueva operacion sin cambiar las clases de los elementos sobre los que opera.</p>
</div>
<h4 id="visitor-motivacion" >Motivacion</h4>
<div class="hBody-4" >
<p>Pensemos en un compilador que representa programas con arboles sintacticos abstractos. Necesitaremos realizar operaciones sobre dichos arboles sintacticos abstractos para llevar a cabo el analisis <q>semantico estatico</q>, como comprobar que todas las variebles estan definidas. Tambien necesitaremos generar codigo. Por tanto, podriamos definir operaciones para la comprobacion de tipos, la optimizacion de codigo, el analisis de flujo, comprobar que se asignan valores a las variebles antes de su uso, etcetera. Mas aun, podriamos usar los arboles sintacticos abstractos para imprimir con formato, reestructurar el programa, instrumentacion de codigo o calcular diferentes metricas de un programa.</p>
<p>La mayoria de estas operaciones necesitaran tratar a los nodos que representan sentencias de asignacion de forma distinta que a los que representa variables o expresiones aritmeticas. Por tanto, habra una clase para sentencias de asignacion, otra para los accesos a variables, otra para expresiones aritmeticas y asi sucesivamente. El conjunto de clases de nodos depende del lenguaje que esta siendo compilado, por supuesto, pero no cambia mucho para un lenguaje dado.</p>
<figure>
<img src="img/122.png" />
</figure>
<p>Este diagrama muestra parte de la jerarquia de clase de <code>Nodo</code>. El problema aqui es que distribuir todas estas operaciones a traves de las distintas clases de nodos conduce a un sistema que es dificil de compreder, mantener y cambiar. Sera confuso tener la comprobacion de tipos mezclada con el codigo de impresion o con el de analisis de flujo. Ademas, añadir una nueva operacion normalmente obliga a recompilar todas estas clases. Seria mejor si cada nueva operacion pudiera ser añadida por separado y las clases de nodos fuesen independientes de las operaciones que se aplican sobre ellas.</p>
<p>Podemos lograr ambas cosas empaquetando las operaciones relacionadas de las distintas clases en un objeto aparte, llamado <b>visitante</b>, al que se le pasen los elementos del arbol sintactico abstracto a medida que va siendo recorrido. Cuando un elemento <q>acepta</q> al visitante, le envia una peticion que codifica la clase del elemento. Tambien incluye al elemento como argumento. El visitante ejecutara entonces la operacion para ese elemento ––la operacion que solia estar en la clase elemento––.</p>
<p>Por ejemplo, un compilador que no usara visitantes podria comprobar los tipos de un procedimiento llamando a la operacion <code>ComporbarTipos</code> sobre su arbol sintactico abstracto. Cada uno de los nodos implementaria <code>ComprobarTipos</code> llamando a <code>ComprobarTipos</code> sobre sus componentes (vease el diagrama de clases precedente). Si la comprobacion de tipos de un procedimiento usara visitantes, entonces crearia un objeto <code>VisitanteComprobacionDeTipos</code> y llamaria a la operacion <code>Aceptar</code> sobre el arbol sintactico abstracto con ese objeto como argumento. Cada uno de los nodos implementaria <code>Aceptar</code> llamando a su vez al visitante: un nodo de asignacion llama a la operacion <code>VisitarAsignacion</code> del visitante, mientras que una referencia a una variable llama a <code>VisitarReferenciaAVariable</code>. Lo que antes era la operacion <code>ComprobarTipos</code> de la clase <code>NodoAsignacion</code> ahora es la operacion <code>VisitarAsignacion</code> de <code>VisitanteComprobacionDeTipos</code>.</p>
<p>Para hacer que los visitantes sirvan para algo mas que simplemente la comprobacion de tipos necesitamos una clase padre abstracta, <code>VisitanteNodo</code>, para todos los visitantes de un arbol sintactico abstracto. <code>VisitanteNodo</code> debe declarar una operacion para clase de nodo. Una aplicacion que necesite calcular metricas de programas definira nuevas subclases de <code>VisitanteNodo</code> y ya no necesitara añadir codigo especifico de una aplicacion a las clases de los nodos. El patron <code>Visitor</code> encapsula las operaciones de cada fase de compilacion en un visiante asociado a esa fase.</p>
<figure>
<img src="img/123a.png" />
</figure>
<figure>
<img src="img/123b.png" />
</figure>
<p>Con el patron <code>Visitor</code>, definimos dos jerarquias de clases: una para los elementos sobre los que se opera (la jerarquia de <code>Nodo</code>) y otra para los visitantes que definen operaciones sobre los elementos (la jerarquia de <code>VisitanteNodo</code>). La forma de crear una nueva operacion es añadiendo una nueva subclase a la jerarquia de clases de los visitantes. Siempre y cuando no cambie la gramatica aceptada por el compilador (es decir, siempre que no tengamos que añadir nuevas subclases de <code>Nodo</code>), podemos añadir nueva funcionalidad simplemente definiendo nuevas subclases de <code>VisitanteNodo</code>.</p>
</div>
<h4 id="visitor-aplicabilidad" >Aplicabilidad</h4>
<div class="hBody-4" >
<p>Usese el patron Visitor cuando</p>
<ul>
<li>
<p>una estructura de objetos contiene muchas clases de objetos con diferentes interfaces, y queremos realizar operaciones sobre esos elementos que dependen de su clase concreta.</p>
</li>
<li>
<p>se necesitan realizar muchas operaciones distintas y no relacionadas sobre objetos de una estructura de objetos, y queremos evitar <q>contaminar</q> sus clases con dichas operaciones. El patron Visitor permite mantener juntas operaciones relacionadas definiendolas en una clase. Cuando la estructura de objetos es compartida por varias aplicaciones, el patron Visitor permite poner operaciones solo en aquellas aplicaciones que las necesitan.</p>
</li>
<li>
<p>las clases que definen la estructura de objetos rara vez cambian, pero muchas veces queremos definir nuevas operaciones sobre la estructura. Cambiar las clases de la estructura de objetos requiere redefinir la interfaz para todos los visitantes, lo que es potencialmente costoso. Si las clases de la estructura cambian con frecuencia, probablemente sea mejor definir las operaciones en las propias clases.</p>
</li>
</ul>
</div>
<h4 id="visitor-estructura" >Estructura</h4>
<div class="hBody-4" >
<figure>
<img src="img/124.png" />
</figure>
</div>
<h4 id="visitor-participantes" >Participantes</h4>
<div class="hBody-4" >
<ul>
<li>
<p><code>Visitante</code> (<code>VisitanteNodo</code>)</p>
<ul>
<li>
<p>declara una operacion <code>Visitar</code> para cada clase de operacion <code>ElementoConcreto</code> de la estructura de objetos. El nombre y signatura de la operacion identifican a la clase que envia la peticion <code>Visitar</code> al visitante. Eso permite al visitante determinar la clase concreta de elemento que esta siendo visitada. A continuacion el visitante puede acceder al elemento directamente a traves de su interfaz particular.</p>
</li>
</ul>
</li>
<li>
<p><code>VisitanteConcreto</code> (<code>VisitanteComprobacionDeTipos</code>)</p>
<ul>
<li>
<p>implementa cada operacion declarada por <code>Visitante</code>. Cada operacion implementa un fragmento del algoritmo definido para la clase correspondiente de la estructura. <code>VisitanteConcreto</code> proporciona el contexto para el algoritmo y guarda su estado local. Muchas veces este estado acumula resultados durante el recorrido de la estructura.</p>
</li>
</ul>
</li>
<li>
<p><code>Elemento</code> (<code>Nodo</code>)</p>
<ul>
<li>
<p>define una operacion <code>Aceptar</code> que toma un visitante como argumento.</p>
</li>
</ul>
</li>
<li>
<p><code>ElementoConcreto</code> (<code>NodoAsignacion</code>, <code>NodoRefVariable</code>)</p>
<ul>
<li>
<p>implementa una operacion <code>Aceptar</code> que toma un visitante como argumento.</p>
</li>
</ul>
</li>
<li>
<p><code>EstructuraDeObjetos</code> (<code>Programa</code>)</p>
<ul>
<li>
<p>puede enumerar sus elementos.</p>
</li>
<li>
<p>puede proporcionar una interfaz de alto nivel para permitir al visitante visitar a sus elementos.</p>
</li>
<li>
<p>puede ser un compuesto (vease el patron <a href="#composite" >Composite</a>) o una coleccion, como una lista o un cojunto.</p>
</li>
</ul>
</li>
</ul>
</div>
<h4 id="visitor-colaboraciones" >Colaboraciones</h4>
<div class="hBody-4" >
<ul>
<li>
<p>Un cliente que usa el patron Visitor debe crear un objeto <code>VisitanteConcreto</code> y a continuacion recorrer la estructura, visitando cada objeto con el visitante.</p>
</li>
<li>
<p>Cada vez que se visita a un elemento, este llama a la operacion del Visitante que se correponde con su clase. El elemento se pasa a si mismo como argumento de la operacion para permitir al visitante acceder a su estado, en caso de que sea necesario.</p>
<p>El siguiente diagrama de interaccion ilustra las colaboraciones entre una estructura de objetos, un visitante y dos elementos:</p>
<figure>
<img src="img/125.png" />
</figure>
</li>
</ul>
</div>
<h4 id="visitor-consecuencias" >Consecuencias</h4>
<div class="hBody-4" >
<p>Algunas de las ventajas e inconvenientes del patron Visitor son las siguientes:</p>
<ol class="num" >
<li>
<p><em>El visitante facilita añadir nuevas operaciones.</em> Los visitantes facilitan añadir nuevas operaciones que dependen de los componentes de objetos complejos. Podemos definir una nueva operacion sobre una estructura simplemente añadiendo un nuevo visitante. Si, por el contrario, extendiesemos la funcionalidad sobre muchas clases, habria que cambiar cada clase para definir una nueva operacion.</p>
</li>
<li>
<p><em>Un visitante agrupa operaciones relacionadas y separa las que no lo estan.</em> El comportamiento similar no esta desperdigado por las clases que definen la estructura de objetos; esta localizado en un visitante. Las partes de comportamiento no relacionadas se dividen en sus propias subclases del visitante. Esto simplifica tanto las clases que definen los elementos como los algoritmos definidos por los visitantes. Cualquier estructura de datos especifica de un algoritmo puede estar oculta en el visitante.</p>
</li>
<li>
<p><em>Es dificil añadir nuevas clases de <code>ElementoConcreto</code>.</em> El patron Visitor hace que sea complicado añadir nuevas subclases de <code>Elemento</code>. Cada <code>ElementoConcreto</code> nuevo da lugar a una nueva operacion abstracta del Visitante y su correspondiente implementacion en cada clase <code>VisitanteConcreto</code>. A veces se puede proporcionar en <code>Visitante</code> una implementacion predeterminada que puede ser heredada por la mayoria de los visitantes concretos, pero esto representa una excepcion mas que una regla.</p>
<p>Por tanto la cuestion fundamental a considerar a la hora de aplicar el patron Visitor es si es mas probable que cambie el algoritmo aplicado sobre una estructura de objetos o las clases de los objetos que componen la estrucutra. La jerarquia de clases de Visitante puede ser dificil de mantener, cuando se añaden nuevas clases de <code>ElementoConcreto</code> con frecuencia. En tales casos, es probablemente mas facil definir las operaciones en las clases que componen la estructura. Si la jeraquia de clase de <code>Elemento</code> es estable pero estamos continuamente añadiendo operacione o cambiando algoritmos, el patron Visitor nos ayudara a controlar dichos cambios.</p>
</li>
<li>
<p><em>Visitar varias jerarquias de clases.</em> Un iterador (vease el patron <a href="#iterator" >Iterator</a>) puede visitar a los objetos de una estructura llamando a sus operaciones a medida que los recorre. Pero un iterador no puede trabajar en varias estructuras de objetos con distintos tipos de elementos. Por ejemplo, la interfaz <code>Iterador</code> definida el la seccion <a href="#Iterator-Codigo-de-Ejemplo" >Codigo de Ejemplo</a> de su respectivo patron, puede acceder unicamente a objetos del tipo <code>Elemento</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Iterador</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">Elemento</span> <span class="n">ElementoActual</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>Esto implica que todos los elementos que el iterador puede visitar tienen una clase padre comun <code>Elemento</code>.</p>
<p>El patron Visitor no tiene esta restriccion. Puede visitar objetos que no tienen una clase padre comun. Se puede añadir cualquier tipo de objeto a la intefaz de un Visitante. Por ejemplo, en</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Visitante</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="kt">void</span> <span class="n">VisitarMiTipo</span><span class="p">(</span><span class="n">MiTipo</span><span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">VisitarTuTipo</span><span class="p">(</span><span class="n">TuTipo</span><span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
<p><code>MiTipo</code> y <code>TiTipo</code> no tienen por que estar relacionados en modo alguno atravez de la herencia.</p>
</li>
<li>
<p><em>Acumular el estado.</em> Los visitantes pueden acumular estado a medida que van visitanto cada elemento de la estructura de objetos. Sin un visitante, este estado se pasaria como argumentos extra a las operaciones que realizan el recorrido, o quiza como variables globales.</p>
</li>
<li>
<p><em>Romper la encapsulacion.</em> El enfoque del patron Visitor asume que la interfaz de <code>ElementoConcreto</code> es lo bastate pontente como para que los visitantes hagan su trabajo. Como resultado, el patron suele obligarnos a proporcionar operaciones publicas que accedan al estado interno de un elemento, lo que puede comprometer su encapsulacion.</p>
</li>
</ol>
</div>
<h4 id="visitor-implementacion" >Implementacion</h4>
<div class="hBody-4" >
<p>Cada estructura de objetos tendra una clase <code>Visitante</code> asociada. Esta clase visitante abstracta declara una operacion <code>VisitarElementoConcreto</code> para cada clase de <code>ElementoConcreto</code> que define la estructura de objetos. Cada operacion <code>Visitar</code> de <code>Visitante</code> declara como argumento un <code>ElementoConcreto</code> en particular, permitiendo al <code>Visitante</code> acceder directamente a la interfaz del <code>ElementoConcreto</code>. Las clases <code>VisitanteConcreto</code> redefinen cada operacion <code>Visitar</code> para implementar el comportamiento especifico del visitante para la correspondiente clase <code>ElementoConcreto</code>.</p>
<p>La clase <code>Visitante</code> se declararia asi en C++:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Visitante</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">VisitarElementoA</span><span class="p">(</span><span class="n">ElementoA</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarElementoB</span><span class="p">(</span><span class="n">ElementoB</span><span class="o">*</span><span class="p">);</span>

    <span class="c1">// y asi para otros elementos concretos
</span><span class="c1"></span><span class="k">protected</span><span class="o">:</span>
    <span class="n">Visitante</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>Cada clase de <code>ElementoConcreto</code> implementa una operacion <code>Aceptar</code> que llama a la operacion <code>Visitantar...</code> del visitante correspondiente a ese <code>ElementoConcreto</code>. De modo que la operacion que es llamada al final depende tanto de la clase del elemento como de la clase del visitante.<span class="note" ><sup><a href="#53" >53</a></sup></span></p>
<p>Los elementos concretos se declaran como</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Elemento</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Elemento</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Aceptar</span><span class="p">(</span><span class="n">Visitante</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Elemento</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ElementoA</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Elemento</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ElementoA</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Aceptar</span><span class="p">(</span><span class="n">Visitante</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span><span class="p">.</span><span class="n">VisitarElementoA</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ElementoB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Elemento</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ElementoB</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Aceptar</span><span class="p">(</span><span class="n">Visitante</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span><span class="p">.</span><span class="n">VisitarElementoB</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre>
<p>Una clase <code>ElementoCompuesto</code> podria implementar <code>Aceptar</code> como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">ElementoCompuesto</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Elemento</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Aceptar</span><span class="p">(</span><span class="n">Visitante</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Lista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">*&gt;*</span> <span class="n">_hijos</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">ElementoCompuesto</span><span class="o">::</span><span class="n">Aceptar</span> <span class="p">(</span><span class="n">Visitante</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IteradorLista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">*&gt;</span> <span class="n">i</span><span class="p">(</span><span class="n">_hijos</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">Primero</span><span class="p">();</span> <span class="o">!</span><span class="n">i</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">i</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Aceptar</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">v</span><span class="p">.</span><span class="n">VisitarElementoCompuesto</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Estas son otras dos cuestiones de implementacion que surgen al aplicar el patron Visitor:</p>
<ol class="num" >
<li>
<p><em>Doble despacho.</em> El Patron Visitor nos permite añadir operaciones a clases sin modificar estas. Esto se logra mediante una tecnica llamada <b>doble-despacho</b>, la cual es muy conocida. De hecho, algunos lenguajes de programacion la permiten directamente (por ejemplo, CLOS). Otros lenguajes, como C++ y Smalltalk, permiten el <b>despacho-unico</b>.</p>
<p>En lenguajes de despacho-unico, dos son los criterios que determinan que operacion satisfara una peticion: el nombre de la peticion y el tipo del receptor. Por ejemplo, la operacion a la que llamara una peticion a <code>GenerarCodigo</code> dependera del tipo de objeto nodo al que se le pida. En C++, llamar a <code>GeneraCodigo</code> sobre una instancia de <code>NodoRefVariable</code> llamara a <code>NodoRefvariable::GenerarCodigo</code> (que genera codigo para una referencia a una variable). Llamar a <code>GenerarCodigo</code> sobre un <code>NodoAsignacion</code> llamara a <code>NodoAsignacion::GenerarCodigo</code> que generara codigo para una asignacion). La operacion que se ejecuta depende tanto del tipo del solicitante como del tipo del receptor.</p>
<p><q>Doble-despacho</q> simplemente significa que la operacion que se ejecuta depende del tipo del solicitante y de los tipos de <em>dos</em> receptores. <code>Aceptar</code> es una operacion de doble-despacho. Su significado depende de dos tipos: el del <code>Visitante</code> y el del <code>Elemento</code>. El doble-despacho permite a los visitantes solicitar diferentes operaciones en cada clase de elemento.<span class="note" ><sup><a href="#54" >54</a></sup></span></p>
<p>Esta es la clave del patron Visitor: la operacion que se ejecuta depende tanto del tipo del <code>Visitante</code> como del tipo del <code>Elemento</code> visitado. En vez de enlazar las operaciones estaticamente en la interfaz de <code>Elemento</code>, podemos fusionar las operaciones en un <code>Visitante</code> y usar <code>Aceptar</code> para hacer el enlace en tiempo de ejecucion. Extender la interfaz de <code>Elemento</code> consiste en definir una nueva subclase de <code>Visitante</code> en vez de muchas nuevas subclases de <code>Elemento</code>.</p>
</li>
<li>
<p><em>¿Quien es el responsable de recorrer la estructura de objetos?</em> Un visitante debe visitar cada elemento de la estructura de objetos. La cuestion es, ¿como lo logra? Podemos poner la responsabilidad del recorrido en cualquiera de estos tres sitios: en la estructura de objetos, en el visitante o en un objeto iterador aparte (vease el patron <a href="#iterator" >Iterator</a>).</p>
<p>Muchas veces es la estructura de objetos la responsable de la iteracion. Una coleccion simplemente iterara sobre sus elementos, llamando a la operacion <code>Aceptar</code> de cada uno. Un compuesto generalmente se recorrera a si mismo haciendo que cada operacion <code>Aceptar</code> recorra los hijos del elemento y llame a <code>Aceptar</code> sobre cada uno de ellos, recursivamente.</p>
<p>Otra solucion es usar un iterador para visitar los elementos. En C++, podriamos usar un iterador interno o externo, dependiendo de que esta disponible y que es mas eficiente. En Smalltalk, normalmente usamos un iterador interno mediante <code>do:</code> y un bloque. Puesto que los iteradores internos son implementados por la estructura de objetos, usar un iterador interno se parece mucho a hacer que sea la estructura de objetos la responsable de la iteracion. La principal diferencia estriba en que un iterador interno no provocara un doble-despacho ––llamara a una operacion del <em>visitante</em> con un <em>elemento</em> como argumento, frente a llamar a una operacion del <em>elemento</em> con el <em>visitante</em> como argumento––. Pero resulta sencillo usar el patron Visitor con un iterador interno si la operacion del visitante simplemente llama a la operacion del elemento sin recursividad.</p>
<p>Incluso se podria poner el algoritmo del recorrido en el visitante, si bien en ese caso acabariamos duplicando el codigo del recorrido en cada <code>VisitanteConcreto</code> de cada agregado <code>ElementoConcreto</code>. La principal razon para poner la estrategia de recorrido en el visitante es implementar un recorrido especialmente complejo, que dependa de los resultados de las operaciones de la estructura de objetos. En el Codigo de Ejemplo se vera un ejemplo para este caso.</p>
</li>
</ol>
</div>
<h4 id="visitor-codigo-de-ejemplo" >Codigo de Ejemplo</h4>
<div class="hBody-4" >
<p>Como los visitantes suelen asociarse a compuestos, usaremos la clase <code>Equipo</code> que se definio en el Codigo de Ejemplo del patron <a href="#composite" >Composite</a> para ilustrar el patron Visitor. Usaremos el patron Visitor para definir operaciones para realizar el inventario de materiales y calcular el coste total de un equipo. Las clases <code>Equipo</code> son tan sencillas que realmente no seria necesario usar el patron Visitor, pero lo haremos asi para mostrar que implicaciones conllevan la implementacion de este patron.</p>
<p>A continuacion se muestra de nuevo la clase <code>Equipo</code> del <a href="#composite" >Composite</a>. La hemos aumentado con la operacion <code>Aceptar</code> para que pueda funcionar con un visitante.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Equipo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Equipo</span><span class="p">();</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">Nombre</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_nombre</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">Vatio</span> <span class="nf">Potencia</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Moneda</span> <span class="nf">PrecioNeto</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="n">Moneda</span> <span class="nf">PrecioConDescuento</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Aceptar</span><span class="p">(</span><span class="n">VisitanteEquipo</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Equipo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">_nombre</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>Las operaciones de <code>Equipo</code> devuelven los atributos de un equipo, tales como su consumo de potencia y su coste. Las subclases redefinen estas operaciones de forma apropiada a cada tipo de equipo (por ejemplo, chasis, unidades y placas base).</p>
<p>La clase abstracta para todos los visitantes de equipos tiene una funcion virtual para cada subclase de equipo, como se muestra a continuacion. Todas las funciones virtuales no hacen nada por omision.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">VisitanteEquipo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">VisitanteEquipo</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarDisquetera</span><span class="p">(</span><span class="n">Disquetera</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarTarjeta</span><span class="p">(</span><span class="n">Tarjeta</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarChasis</span><span class="p">(</span><span class="n">Chasis</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarBus</span><span class="p">(</span><span class="n">Bus</span><span class="o">*</span><span class="p">);</span>

    <span class="c1">// y asi para el resto de subclases concretas de Equipo
</span><span class="c1"></span><span class="k">protected</span><span class="o">:</span>
    <span class="n">VisitanteEquipo</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>Las subclases de <code>Equipo</code> definen <code>Aceptar</code> basicamente de la misma forma: llamando a la operacion de <code>VisitanteEquipo</code> que se corresponda con la clase que recibe la peticion <code>Aceptar</code>, como en:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Disquetera</span><span class="o">::</span><span class="n">Aceptar</span> <span class="p">(</span><span class="n">VisitanteEquipo</span><span class="o">&amp;</span> <span class="n">visitante</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">visitor</span><span class="p">.</span><span class="n">VisitarDisquetera</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Los equipos que contienen otros equipos (en concreto, las subclases de <code>EquipoCompuesto</code> en el patron <code>Composite</code>) implementan <code>Aceptar</code> iterando sobre sus hijos y llamando a <code>Aceptar</code> sobre cada uno de ellos. A continuacion llama a la operacion <code>Visitar</code> como siempre. Por ejemplo, <code>Chasis::Aceptar</code> podria recorrer todas las partes del <code>Chasis</code> como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">Chasis</span><span class="o">::</span><span class="n">Aceptar</span> <span class="p">(</span><span class="n">VisitanteEquipo</span><span class="o">&amp;</span> <span class="n">visitante</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span>
        <span class="n">IteradorLista</span> <span class="o">&lt;</span><span class="n">Equipo</span><span class="o">*&gt;</span> <span class="n">i</span><span class="p">(</span><span class="n">_partes</span><span class="p">);</span>
        <span class="o">!</span><span class="n">i</span><span class="p">.</span><span class="n">HaTerminado</span><span class="p">();</span>
        <span class="n">i</span><span class="p">.</span><span class="n">Siguiente</span><span class="p">()</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">i</span><span class="p">.</span><span class="n">ElementoActual</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Aceptar</span><span class="p">(</span><span class="n">visitar</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">visitante</span><span class="p">.</span><span class="n">VisitarChasis</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Las subclases de <code>VisitanteEquipo</code> definen algoritmos concretos sobre la estructura de equipos. El <code>VisitantePrecio</code> calcula el coste de la estructura de equipos, calculando el precio neto de todos los equipos simples (por ejemplo, las disqueteras) y el precio con descuento de todos los equipos compuestos (como los chasis y buses).</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">VisitantePrecio</span> <span class="o">:</span> <span class="k">public</span> <span class="n">VisitanteEquipo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">VisitantePrecio</span><span class="p">();</span>

    <span class="n">Moneda</span><span class="o">&amp;</span> <span class="n">ObtenerPrecioTotal</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarDisquetera</span><span class="p">(</span><span class="n">Disquetera</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarTarjeta</span><span class="p">(</span><span class="n">Tarjeta</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarChasis</span><span class="p">(</span><span class="n">Chasis</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarBus</span><span class="p">(</span><span class="n">Bus</span><span class="o">*</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">Moneda</span> <span class="n">_total</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">VisitantePrecio</span><span class="o">::</span><span class="n">VisitarDisquetera</span> <span class="p">(</span><span class="n">Disquetera</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_total</span> <span class="o">+=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">PrecioNeto</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">VisitantePrecio</span><span class="o">::</span><span class="n">VisitarChasis</span> <span class="p">(</span><span class="n">Chasis</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_total</span> <span class="o">+=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">PrecioConDescuento</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p><code>VisitantePrecio</code> calculara el coste total de todos los nodos de la estructura de equipos. Notese que <code>VisitantePrecio</code> elige la politica de precios apropiada para una clase de equipo despachando a la correspondiente funcion miembro. Y lo que es mas, podemos cambiar la politica de precios de una estructura de equipo simplemente cambiando la clase <code>VisitantePrecio</code>.</p>
<p>Podemos definir un visitante para realizar un inventario como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">VisitanteInventario</span> <span class="o">:</span> <span class="k">public</span> <span class="n">VisitanteEquipo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">VisitanteInventario</span><span class="p">();</span>

    <span class="n">Inventario</span><span class="o">&amp;</span> <span class="n">ObtenerInventario</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarDisquetera</span><span class="p">(</span><span class="n">Disquetera</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarTarjeta</span><span class="p">(</span><span class="n">Tarjeta</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarChasis</span><span class="p">(</span><span class="n">Chasis</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitarBus</span><span class="p">(</span><span class="n">Bus</span><span class="o">*</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Inventario</span> <span class="n">_inventario</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>El <code>VisitanteInvertario</code> acumula los totales de cada tipo de equipo de la estructura de objetos. <code>VisitanteInventario</code> usa una clase <code>Inventario</code> que define una interfaz para añadir equipamiento (que no nos molestaremos en definir aqui).</p>
<pre class="code" ><code class="chroma" ><span class="kt">void</span> <span class="n">VisitanteInventario</span><span class="o">::</span><span class="n">VisitarDisquetera</span> <span class="p">(</span><span class="n">Disquetera</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_inventario</span><span class="p">.</span><span class="n">Acumular</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">VisitanteInventario</span><span class="o">::</span><span class="n">VisitarChasis</span> <span class="p">(</span><span class="n">Chasis</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_inventario</span><span class="p">.</span><span class="n">Acumular</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Asi es como podemos usar un <code>VisitanteInventario</code> en una estructura de equipos:</p>
<pre class="code" ><code class="chroma" ><span class="n">Equipo</span><span class="o">*</span> <span class="n">componente</span><span class="p">;</span>
<span class="n">VisitanteInventario</span> <span class="n">visitante</span><span class="p">;</span>

<span class="n">componente</span><span class="o">-&gt;</span><span class="n">Aceptar</span><span class="p">(</span><span class="n">visitor</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sa"></span><span class="s">&#34;Inventario &#34;</span>
     <span class="o">&lt;&lt;</span> <span class="n">componente</span><span class="o">-&gt;</span><span class="n">Nombre</span><span class="p">()</span>
     <span class="o">&lt;&lt;</span> <span class="n">visitante</span><span class="p">.</span><span class="n">ObtenerInventario</span><span class="p">();</span>
</code></pre>
<p>Ahora veremos como implementar el ejemplo de Smalltalk del patron Interpreter (vease su respectiva seccion <a href="#Interpreter-Codigo-de-Ejemplo" >Codigo de Ejemplo</a>) con el patron Visitor. Como en el ejemplo anterior, este es tan pequeo que el Visitante probablemente no nos aporte gran cosa, pero proporciona un buen ejemplo de como usar el patron. Ademas, muestra una situacion en la que la interacion es responsabilidad del visisitante.</p>
<p>La estructura de objetos (expresiones regulares) se compone de cuatro clases, y todas ellas tienen un metodo <code>aceptar:</code> que toma un visitante como argumento. En la clase <code>ExpresionSecuencia</code>, el metodo <code>aceptar:</code> se define como</p>
<pre class="code" ><code class="chroma" ><span class="nf">aceptar:</span> <span class="nv">unVisitante</span>
     <span class="o">^</span> <span class="nv">unVisitante</span> <span class="nf">visitarSecuencia:</span> <span class="nf">self</span>
</code></pre>
<p>En la clase <code>ExpresionRepetir</code>, el metodo <code>aceptar:</code> envia el mensaje <code>visitarRepetir:</code>. En la clase <code>ExpresionAlternativa</code>, envia el mensaje <code>visitarAlternativa:</code>. En la clase <code>ExpresionLiteral</code>, envia el mensaje <code>visitarLiteral:</code></p>
<p>Las cuatro clases tambien deben tener funciones de acceso que pueda usar el visitante. Para <code>ExpresionSecuencia</code> estas son <code>expresion1</code> y <code>expresion2</code>; para <code>ExpresionAlternativa</code> son <code>altertaniva1</code> y <code>alternativa2</code>; para <code>ExpresionRepetir</code> es su <code>repeticion</code>; y para <code>ExpresionLiteral</code> sus <code>compontentes</code>.</p>
<p>La clase <code>VisitanteConcreto</code> es <code>VisitanteReconocedorER</code>. Es la responsable del recorrido porque su algoritmo de recorrido es irregular. La mayor irregularidad es que una <code>ExpresionRepetir</code> recorrera repetidamente su componente. La clase <code>VisitanteReconocedorER</code> tiene una variable de instancia <code>estadoEntrada</code>. Sus metodos son, en esencia, los mismos que los metodos <code>reconocer:</code> de las clases de expresiones del patron Interpreter, salvo que estas sustituyen el argumento llamado <code>estadoEntrada</code> por el nodo con la expresion que esta siendo reconocida. En cualquier caso, siguen devolviendo el conjunto de flujos que puede reconocer la expresion para indentificar el estado actual.</p>
<pre class="code" ><code class="chroma" ><span class="nf">vistiarSecuencia:</span> <span class="nv">expSecuencia</span>
     <span class="nv">estadoEntrada</span> <span class="o">:=</span> <span class="nv">expSecuencia</span> <span class="nf">expresion1</span> <span class="nf">aceptar:</span> <span class="bp">self</span><span class="p">.</span>
     <span class="o">^</span> <span class="nv">expSecuencia</span> <span class="nf">expresion2</span> <span class="nf">aceptar:</span> <span class="bp">self</span><span class="p">.</span>

<span class="nf">visitarRepetir:</span> <span class="nv">expRepetir</span>
     <span class="o">|</span><span class="nv"> estadoFinal </span><span class="o">|</span>
     <span class="nv">estadoFinal</span> <span class="o">:=</span> <span class="nv">estadoEntrada</span> <span class="nf">copy</span><span class="p">.</span>
     [<span class="nv">estadoEntrada</span> <span class="nf">isEmpty</span>]
         <span class="nb">whileFalse:</span>
             [<span class="nv">estadoEntrada</span> <span class="o">:=</span> <span class="nv">expRepetir</span> <span class="nf">repeticion</span> <span class="nf">aceptar:</span> <span class="bp">self</span><span class="p">.</span>
              <span class="nv">estadoFinal</span> <span class="nf">addAll:</span> <span class="nv">estadoEntrada</span>]<span class="p">.</span>
     <span class="o">^</span> <span class="nf">estadoFinal</span>

<span class="nf">visitarAlternativa:</span> <span class="nv">expAlternativa</span>
     <span class="o">|</span><span class="nv"> estadoFinal estadoOriginal </span><span class="o">|</span>
     <span class="nv">estadoOriginal</span> <span class="o">:=</span> <span class="nv">estadoEntrada</span><span class="p">.</span>
     <span class="nv">estadoFinal</span> <span class="o">:=</span> <span class="nv">expAlternativa</span> <span class="nf">alternativa1</span> <span class="nf">aceptar:</span> <span class="bp">self</span><span class="p">.</span>
     <span class="nv">estadoEntrada</span> <span class="o">:=</span> <span class="nv">estadoOriginal</span><span class="p">.</span>
     <span class="nv">estadoFinal</span> <span class="nf">addAll:</span> (<span class="nv">expAlternativa</span> <span class="nf">alternativa2</span> <span class="nf">aceptar:</span> <span class="bp">self</span>)<span class="p">.</span>
     <span class="o">^</span> <span class="nf">estadoFinal</span>

<span class="nf">visitarLiteral1:</span> <span class="nv">expLiteral1</span>
     <span class="o">|</span><span class="nv"> estadoFinal tStream </span><span class="o">|</span>
     <span class="nv">estadoFinal</span> <span class="o">:=</span> <span class="nc">Set</span> <span class="nb">new</span><span class="p">.</span>
     <span class="nf">estadoEntrada</span>
         <span class="err">do:</span>
             [<span class="o">:</span><span class="nv">stream</span> <span class="o">|</span> <span class="nv">tStream</span> <span class="o">:=</span> <span class="nv">stream</span> <span class="nf">copy</span><span class="p">.</span>
                  (<span class="nv">tStream</span> <span class="nf">nextAvailable:</span>
                      <span class="nv">expLiteral</span> <span class="nf">componentes</span> <span class="nf">size</span>
                  ) <span class="nf">=</span> <span class="nv">expLiteral</span> <span class="nf">componentes</span>
                      <span class="nb">ifTrue:</span> [<span class="nv">estadoFinal</span> <span class="nf">add:</span> <span class="nv">tStream</span>]
             ]<span class="p">.</span>
     <span class="o">^</span> <span class="nf">estadoFinal</span>
</code></pre>
</div>
<h4 id="visitor-usos-conocidos" >Usos Conocidos</h4>
<div class="hBody-4" >
<p>El compilador Smalltalk-80 tiene una clase Visitante llamada <code>ProgramNodeEnumerator</code>. Se usa sobre todo para los algoritmos que analizan el codigo fuente. No se usa para generacion de codigo o impresion con formato, aunque se podria.</p>
<p>IRIS Inventor [<a href="#str93" >Str93</a>] es un toolkit para desarrollar aplicaciones graficas en 3-D. Inventor representa una escena tridimensional como una jerarquia de nodos, cada uno de los cuales representa o bien un objeto geometrico o bien uno de sus atributos. Operaciones como mostrar una escena o establecer una accion para un evento de entrada necesitan recorrer esta estructura de varias formas. Inventor lleva a cabo esto usando visitantes llamados <q>acciones</q>. Hay diferentes visitantes para la visualizacion, el manejo de eventos, la busqueda, guardar en ficheros o determinar las cajas limitrofes.</p>
<p>Para facilitar la adicion de nuevos nodos, <code>Inventor</code> implementa un esquema de doble-despacho en C++. Este esquema se basa en la informacion de tipos en tiempo de ejecucion y en una tabla bidimencional en la que las filas representan visitantes y las columnas clases de nodos. Las casillas guardan un puntero a la funcion asignada a esas clases de visitante y nodo.</p>
<p>Mark Linton acuño el termino <q>Visitor</q> en la especificacion de Fresco Application Toolkit, de X Consortium [<a href="#lp93" >LP93</a>].</p>
</div>
<h4 id="visitor-patrones-relacionados" >Patrones Relacionados</h4>
<div class="hBody-4" >
<p><a href="#composite" >Composite</a>: los visitantes pueden usarse para aplicar una operacion sobre una estructura de objetos definida por el patron Composite.</p>
<p><a href="#interpreter" >Interpreter</a>: se puede aplicar el patron Visitor para llevar a cabo la interpretacion.</p>
</div>
<h3 id="discusion-sobre-los-patrones-de-comportamiento" >Discusion sobre los patrones de comportamiento</h3>
<h4 id="encapsular-lo-que-varia" >Encapsular lo que varia</h4>
<div class="hBody-4" >
<p>Encapsular aquello que puede variar es el tema de muchos patrones de comportamiento. Cuando un determinado aspecto de un programa cambia con frecuenca, estos patrones definen un objeto que encapsula dicho aspecto. De esa manera, otras partes del programa pueden colaborar con el objeto siempre que dependan de ese aspecto. Los patrones normalmente definen una clase abstracta que describe el objeto encapsulado, y el patron toma su nombre de ese objeto.<span class="note" ><sup><a href="#55" >55</a></sup></span> Por ejemplo,</p>
<ul>
<li>
<p>un objeto <a href="#Strategy" >Estrategia</a> encapsula un algoritmo,</p>
</li>
<li>
<p>un objeto <a href="#State" >Estado</a> encapsula un comportamiento dependiente del estado,</p>
</li>
<li>
<p>un objeto <a href="#Mediator" >Mediador</a> encapsula el protocolo entre objetos, y</p>
</li>
<li>
<p>un objeto <a href="#Iterator" >Iterador</a> encpasula el modo en que se accede y se recorren los componentes de un objeto agregado.</p>
</li>
</ul>
<p>Estos patrones describen aspectos de un programa que es probable que cambien. La mayoria de los patrones tienen dos tiepos de objetos: el nuevo objeto que encapsula el aspecto y el objeto existente que usa el nuevo objeto creado. Normalmente, si no fuera por el patron, la funcionalidad de los nuevos objetos seria una parte integral de los existentes. Por ejemplo, el codigo de una Estrategia probablemente estaria ligado al Contexto de la estrategia, y el codigo de un Estado se encontraria implementado directamente en el Contexto del estado.</p>
<p>Pero no todos los patrones de comportamiento de objetos dividen asi la funcionalidad. Por ejemplo, el patron <a href="#chain-of-responsibility" >Chain of Responsibility</a> trata con un numero indeterminado de objetos (una cadena), cada uno de los cuales puede que ya exista en el sistema.</p>
<p>El patron Chain of Responsibility muestra otra diferencia entre los patrones de comportamiento: no todos definen relaciones de comunicacion estaticas entre las clases. El patron Chain of Responsibility describe el modo de comunicacion entre un numero indefinido de objetos. Otros patrones usan objetos que pasan como argumentos.</p>
</div>
<h4 id="objetos-como-argumentos" >Objetos como argumentos</h4>
<div class="hBody-4" >
<p>Varios patrones introducen un objeto que siempre se usa como argumento. Uno de ellos es el <a href="#visitor" >Visitor</a>. Un objeto Visitante es el argumento de una operacion polimorfica <code>Aceptar</code> del objeto que visita. El visitante nunca se considera parte de estos objetos, incluso aunque la alternativa convencional al patron consiste en distribuir el codigo del Visitante entre las clases de la estructura de objetos.</p>
<p>Otros patrones definen objetos que actuan como elementos magicos que se pasan de una lado a otro y que mas tarde pueden ser invocados. Tanto el patron <a href="#command" >Command</a> como el <a href="#memento" >Memento</a> entran en esta categoria. En el Command, el elemento representa una peticion; en el Memento, representa el estado interno de un objeto en un momento concreto. En ambos casos, el elemento puede tener una representacion interna compleja, pero los clientes nunca llegan a percibirla. No obstante, incluso aqui hay diferencias. El polimorfismo es importante en el patron Command, ya que ejecutar el objeto <code>Orden</code> es una operacion palimorfica. Por el contrario, la interfaz del Memento es tan limitada que este solo puede pasarse como un valor. Por tanto, es plobable que no presente ninguna operacion polimorfica a sus clientes.</p>
</div>
<h4 id="la-comunicacion,-¿deberia-estar-encapsulada-o-distribuida?" >La comunicacion, ¿Deberia estar encapsulada o distribuida?</h4>
<div class="hBody-4" >
<p>El <a href="#mediator" >Mediator</a> y el <a href="#observer" >Observer</a> son patrones rivales. La diferencia entre ellos es que el patron Observer distribuye la comunicacion introduciendo objetos Observador y Sujeto, mientras que un objeto Mediador encapsula la comunicacion entre objetos.</p>
<p>En el patron Observer, no hay ningun objeto individual que encapsule una restriccion. En ves de eso, el Observador y el Sujeto deben cooperar para mantener  la restriccion. Los patrones de comunicacion se determinan por el modo en que se interconectan los observadores y los sujetos: un sujeto individual normalmente tiene muchos observadores, y a veces el observador de un sujeto es un sujeto de otro observador. El patron Mediator centraliza mas que distribuye, ubicando en el mediador la responsabilidad de mantener la restriccion.</p>
<p>Hemos descubierto que es mas facil hacer Observaciones y Sujetos reutilizables que hacer Mediadores reutilizables. El patron Observer promueve la separacion y bajo acoplamiento entre el Observador y el Sujeto, lo que conduce a clases de grano mas fino que son mas aptas para ser reutilizadas.</p>
<p>Por otro lado, es mas facil entender el flujo de comunicacion en el Mediator que en el Observer. Los observadores y sujetos suelen conectarse nada mas crearse, y es dificil ver mas tarde en el programa como estan conectados. Si conocemos el patron Observer, debemos entender que el modo en que se conectan los observadores y los sujetos es importante, y tambien sabremos que conexiones buscar. Sin embargo, la indireccion introducida por este patron sigue haciendo que el sistema sea dificil de entender.</p>
<p>Los observadores pueden parametrizarse en Smalltalk con mensajes para acceder al estado del sujeto, lo que los hace mas reutilizables de lo que son en C++. Esto hace que en Smalltalk sea mas atractivo el Observer que el mediator. De hay que un programador de Smalltalk generalmente use el Observer donde un programador de C++ usaria un Mediator.</p>
</div>
<h4 id="desacoplar-emisores-y-receptores" >Desacoplar emisores y receptores</h4>
<div class="hBody-4" >
<p>Cuando los objetos que colaboran se refieren unos a otros explicitamente, se vuelven dependientes unos de otros, y eso puede tener un impacto adverso sobre la division en capas y la reutilizacion de un sistema. Los patrones Command, Observer, Mediator y Chain of Responsibility tratan el problema de como desacoplar emisores y receptores, cada uno con sus ventajas e inconvenientes.</p>
<p>El patron Command permite el desacoplamiento usando un objeto Orden que define un enlace entre un emisor y un repceptor:</p>
<figure>
<img src="img/126.png" />
</figure>
<p>El objeto <code>Orden</code> proporciona una interfaz simple para emitir la peticion (es decir, la operacion <code>Ejecutar</code>). Definir la conexion emisor-receptor en un objeto aparte permite que el emisor funcione con diferentes receptores. Gracias a mantener al emisor desacoplado de los receptores es mas facil reutilizar los emisores. Mas aun, es posible reutilizar el objeto Orden para parametrizar un receptor con diferentes emisores. El patron Command necesita que haya una subclase por cada conexion emisor-receptor, si bien el patron describe tecnicas de implementacion que evitan la herencia.</p>
<p>El patron Observer desacopla los emisores (sujetos) de los receptores (observadores) definiendo una interfaz para indicar cambios en los sujetos. Observer define un enlace mas debil que Command entre el emisor y el receptor, ya que un sujeto puede tener multiples observadores, cuyo numero puede variar en tiempo de ejecucion.</p>
<figure>
<img src="img/127.png" />
</figure>
<p>Las interfaces Sujeto y Observador del patron Observer estan diseñadas para posibles cambios en la comunicacion. Por tanto, el patron Observer es mejor para desacoplar objetos cuando hay dependencias de datos entre ellos.</p>
<p>El patron mediator desacopla los objetos haciendo que se refieran unos a otros indirectamente, a traves del objeto Mediador.</p>
<figure>
<img src="img/128.png" />
</figure>
<p>Un objeto <code>Mediador</code> encamina peticiones entre objetos <code>Colega</code>, y centraliza su comunicacion. En consecuencia, los colegas solo pueden hablar entre si a traves de la interfaz del <code>Mediador</code>. Dado que dicha interfaz es fija, el <code>Mediador</code> podria tener que implementar su propio mecanismo de despacho para una flexibilidad añadida. Las peticiones pueden ser codificadas junto con sus argumentos de tal forma que los compañeros pueden solicitar un conjunto de peticiones ilimitado.</p>
<p>El patron Mediator puede reducir la herencia en un sistema, al centralizar el comportamiento de comunicacion en una clase en vez de distribuirlo entre las subclases. Sin embargo, los esquemas de despacho <em>ad hoc</em> suelen disminuir la seguridad de tipos.</p>
<p>Por ultimo, el patron Chain Of Responsibility desacobla al emisor del receptor pasando la peticion a lo largo de una cadena de receptores potenciales:</p>
<figure>
<img src="img/129.png" />
</figure>
<p>Puesto que la interfaz entre emisores y receptores es fija, la Cadena de Responsabilidad tambien puede requerir un esquema de despacho personalizado. Por tanto, tiene los mismo inconvenientes de seguridad de tipos que el mediator. La Cadena de Responsabilidad es un buen modo de desacoplar el emisor y el receptor en caso de que la cadena ya forme parte de la estructura del sistema y haya uno o varios objetos capaces de manejar la peticion. Y es mas, el patron ofrece una flexibilidad añadida en el sentido de que la cadena puede cambiarse o ampliarse facilmente.</p>
</div>
<h4 id="resumen" >Resumen</h4>
<div class="hBody-4" >
<p>Con unas pocas excepciones, los patrones de diseño de comportamiento se complementan y se refuerzan entre si. Una clase de una cadena de responsabilidad, por ejemplo, probablemente incluya almenos una aplicacion del patron <a href="#template-method" >Template Method</a>. El metodo de plantilla puede usar operaciones primitivas para determinar si el objeto deberia manejar la peticion y para elegir el objeto al cual reenviarla. La cadena puede usar el patron Command para representar peticiones como objetos. El <a href="#interpreter" >Interpreter</a> puede usar el patron State para definir contexto para el analisis. Un iterador puede recorrer un agregado, y un visitante puede aplicar una operacion a cada elemento del agregado.</p>
<p>Los patrones de comportamiento funcionan bien con otros patrones tambien. Por ejemplo, un sistema que usa el patron <a href="#composite" >Composite</a> podria usar un visitante para realizar operaciones sobre los componentes de la composicion. Podria usar una cadena de responsabilidad para que los componentes puedan acceder a las propiedades globales a traves de su padre. Tambien podrian usar el <a href="#decorator" >Decorator</a> para redefinir estas propiodades sobre partes de la composicion. O el patron Observer para ligar una estructura a la otra, y el patron State para que un componente pueda cambiar su comportamiento cuando cambia su estado. La propia composicion podria ser creada usando el enfoque del patron <a href="#builder" >Builder</a> y se podria tratar como un <a href="#prototype" >Prototype</a> por otras partes del sistema.</p>
<p>Los sistemas orientados a objetos bien diseñados no son mas que eso ––tienen multiples patrones incrustados en ellos––, pero no necesariamente porque sus diseñadores los hayan pensado en esos terminos. La composicion de <em>patrones</em> en vez de la de clases nos permite lograr la misma sinergia mas facilmente.</p>
</div>
<h2 id="capitulo-6" >Conclusion</h2>
<div class="hBody-2" >
<p>Es posible argüir que este libro no ha logrado gran cosa. Despues de todo, no presenta ningun algoritmo o tecnica de programacion que no se haya usado anteriormente. Tampoco proporciona un metodo riguroso para el diseño de sistemas, ni desarrolla una nueva teoria de diseño ––simplemente, documenta diseños existentes––. Podria concluirse, tal vez, que es una razonable guia de aprendizaje, pero que ciertamente no ofrece gran cosa a un diseñador orientado a objetos experimentado.</p>
<p>Esperamos que no piense asi. Catalogar los patrones de diseño es importante. Nos da nombres y definiciones estadar de las tecnicas que usamos. Si no estudiaramos los patrones de diseño de software no podriamos mejorarlos, y seria dificil presentar otros nuevos.</p>
<p>Este libro es solo un comienzo. Contiene algunos de los patrones de diseño mas comunes que utilizan los diseñadores orientados a objetos, y que sin embargo la gente conoce y aprende solo de oidas o estudiando los sistemas existentes. Las versiones preliminares del libro indujeron a otra gente a anotar los patrones de diseño que usaban, y todavia deberia inducir mas a ello en su nueva forma. Esperamos que esto marque el principio de un movimento de documentacion de la experiencia de los profecionales del software.</p>
<p>Este capitulo discute el impacto que creemos que tendran los patrones de diseño, como se relacionan con otros trabajos de diseño y como puede uno involucrarse en la tarea de encontrar y catalogar patrones.</p>
</div>
<h3 id="6.1" >Que esperar de los patrones de diseño</h3>
<div class="hBody-3" >
<p>los patrones de diseño de este libro pueden afectar de varias formas el modo en que diseñamos software orientado a objetos, basandonos en nuestra experiencia diaria con ellos.</p>
</div>
<h4 id="un-vocabulario-de-diseño-comun" >Un vocabulario de diseño comun</h4>
<div class="hBody-4" >
<p>Los estudios de programadores expertos de lenguajes convencionales muestran que el conocimiento y la experiencia no se organizan simplemente en torno a la sintaxis, sino en estructuras conceptuales mayores, tales como algoritmos, estructuras de datos y modismos [<a href="#as85" >AS85</a>, <a href="#cop92" >Cop92</a>, <a href="#ss86" >SS86</a>], asi como en maneras de lograr un determinado objetivo [<a href="#se84" >SE84</a>]. Los diseñadores probablemente no piensan en la notacion que estan usando para documentar su diseño, sino que intentan comparar la situacion actual de diseño con planos, algoritmos, estructuras de datos y modismos que han aprendido en el pasado.</p>
<p>Los informaticos nominan y catalogan las estructuras de datos y algoritmos, pero no suelen dar nombre a otros tipos de patrones. Los patrones de diseño proporcionan un vocabulario comun que los diseñadores usan para comunicar, documentar y explorar alternativas de diseño. Los patrones de diseño hacen que un sistema parezca menos complejo, permitiendonos hablar de el con un mayor nivel de abstraccion del que permite una notacion de diseño o un lenguaje de programacion. Los patrones de diseño elevan el nivel en el que diseñamos y discutimos diseños con nuestros colegas.</p>
<p>Una vez que haya absorbido los patrones de diseño de este libro, su vocabulario de diseño cambiara casi con toda seguridad. Hablara directamente en terminos de los nombres de los patronesde diseño. Se oira asi mismo decir cosas como <q>aqui deberiamos usar el patron Observer</q>, o <q>extraigamos una estrategia de estas clases</q>.</p>
</div>
<h4 id="una-ayuda-para-la-documentacion-y-el-aprendizaje" >Una ayuda para la documentacion y el aprendizaje</h4>
<div class="hBody-4" >
<p>Conocer los patrones de diseño de este libro facilita la comprension de los sistemas existentes. La mayoria de los grandes sistemas orientados a objetos usan estos patrones de diseño. Las personas que aprenden programacion orientada a objetos a menudo se quejan de que los sistemas con los que estan trabajando utilizan la herencia de formas enrevesadas, y que es dificil seguir el flujo de control. En gran parte esto se debe a que no comprenden los patrones de diseño del sistema. Aprender estos patrones de diseño le ayudara a compreder los sistemas software existentes.</p>
<p>Estos patrones de diseño tambien pueden convertirle en un diseñador mejor. Si trabaja con sistemas orientados a objetos lo suficientemente grandes, probablemente aprenda estos patrones por si mismo. Pero leer el libro le ayudara a aprender mucho mas deprisa. Aprender estos patrones ayudara a un novato a comportarse mas como un experto.</p>
<p>Mas aun, describir un sistema en terminos de los patrones que usa hara que este sea mucho mas facil de entender. De otro modo, la gente tendra que hacer ingerieria inversa sobre el diseño para descubrir los patrones que usa. Tener un vocabulario comun significa que no tenemos que describir el patron de diseño entero; podemos simplemente nombrarlo y confiar en que quien lo lea lo conozca. Un lector que no conoce los patrones tendra que buscarlos en primer lugar, pero eso sigue siendo mas facil que hacer ingenieria inversa.</p>
<p>Nosotros usamos estos patrones en nuestros propios diseños y pensamos que tienen un valor incalculable. No obstante, usamos los patrones de forma simplista y discutible. Los usamos para elegir nombres para las clases, para pensar en un buen diseño y enseñarlo, y para describir diseños en terminos de la secuencia de patrones que hemos aplicado [<a href="#bj94" >BJ94</a>]. Es facil imaginarse formas mas sofisticadas de usar los patrones, como herramientas CASE o documentos hipertexto basados en patrones. Pero los patrones son una gran ayuda incluso sin herramientas sofisticadas.</p>
</div>
<h4 id="un-complemento-de-los-metodos-existentes" >Un complemento de los metodos existentes</h4>
<div class="hBody-4" >
<p>Los metodos de diseño orientado a objetos estan pensados para promover el buen diseño, para enseñar a los nuevos diseñadores como diseñar bien y para estandarizar el modo en que se desarrollan los diseños. Un metedo de diseño generalmente define un conjunto de notaciones (normalemente graficas) para modelar varios aspectos de un diseño, junto con un conjunto de reglas que gobiernan como y cuando usar cada notacion. Los metodos de diseño normalmente describen los problemas que tienen lugar en un diseño, como resolverlos y como evaluar el diseño. Pero se han mostrado incapaces de representar la experienca de los diseñadores expertos.</p>
<p>Creemos que nuestros patrones de diseño son una muestra importante de lo que hemos estado echando de menos en los metodos de diseño. Los patrones de diseño muestran como usar tecnicas primitivas como objetos, herencia y polimorfismo. Muestran como parametrizar un sistema con un algoritmo, un comportamiento, un estado o con la base de objetos que debe crear. Los patrones de diseño proporcionan una forma de describir mejor <q>el porque</q> de un diseño, en vez de limitarse a registrar los resultados de nuestras decisiones. Las secciones de Aplicabilidad, Consecuencias e Implementacion de los patrones de diseño le ayudaran en las decisiones que tenga que tomar.</p>
<p>Los patrones de diseño son especialmente utiles a la hora de pasar de un modelo de analisis a un modelo de implementacion. A pesar de que muchas afirmaciones prometen una suave transicion del analisis orientado a objetos al diseño, en la practica la transicion es cualquier cosa menos suave. Un diseño flexible y reutilizable contendra objetos que no estan en el modelo de analisis. El lenguaje de programacion y las bibliotecas de clases utilizados afectan al diseño. Los modelos de analisis muchas veces deben ser rediseñados para hacerlos mas reutilizables. Muchos de los patrones de diseño del catalogo se enfrentan a estos problemas, mootivo por el que los denominamos patrones <em>de diseño</em>.</p>
<p>Un metodo de diseño complejo necesita patrones de mas tipos que los de diseño. Tambien puede haber patrones de analisis, patrones de diseño de interfaces de usuario o patrones de ajuste del rendimiento. Pero los patrones de diseño son una parte esencial, que ha sido obviada hasta ahora.</p>
</div>
<h4 id="un-objetivo-para-la-refactorizacion" >Un objetivo para la refactorizacion</h4>
<div class="hBody-4" >
<p>Uno de los problemas del desarrollo de software reutilizable es que a menudo tiene que ser reorganizado o refactorizado [<a href="#oj90" >OJ90</a>]. Los patrones de diseño ayudan a determinar como reorganizar un diseño, y pueden reducir la cantidad de refactorizacion que es necesario hacer luego.</p>
<p>El ciclo de vida del software orientado a objetos tiene varias fases. Brian Foote identifica estas como las fases de protipado, expansion y consolidacion [<a href="#foo92" >Foo92</a>].</p>
<p>La fase de prototipado es una oleada de actividad en la que el software ve la luz a traves del prototipado rapido y de los cambios incrementales, hasta que se descubren un conjunto de requisitos iniciales y alcanza la adolescencia. En este punto, el software normalmente consiste en jerarquias de clases que reflejan fielmente las entidades del dominio del problema inicial. El principal tipo de reutilizacion es de caja blanca mediante la herencia.</p>
<p>Una vez que el software ha alcanzado su adolescencia y se pone en servicio, su evolucion esta gobernada por dos necesidades contradictorias: (1) el software debe satisfacer mas requisitos, y (2) el software debe ser mas reutilizable. Nuevos requisitos añaden nuevas clases y operaciones, y tal vez jerarquias de clases completas. El software cambia hacia una fase de expansion para descubrir nuevos requisitos. Esto, no obstante, no puede continuar durante largo tiempo. Al final el software se volvera demasiado inflexible para permitir mas cambios. Las jerarquias de clases ya no se corresponderan con ningun dominio de problema. En vez de eso, reflejaran muchos dominios de problemas, y las clases definiran muchas operaciones y variables de instancia sin relacion entre si.</p>
<p>Para seguir evolucionando, el software debe ser reorganizado en un proceso conocido como <b>refactorizacion</b>. Esta es la fase en la que suelen aparecer los frameworks. Refactorizar implica desbrozar las clases en componetes de proposito general y especial, moviendo operaciones hacia arriba y hacia abajo en la jeraquia de clases, y racionalizando las interfaces de las clases. Esta fase de consolidacion produce muchos nuevo tipos de objetos, a menudo mediante descomposicion de los objetos existentes, y usando composicion de objetos en vez de la herencia. Por tanto, la reutilizacion de caja negra sustituye a la de caja blanca. La necesidad constante de satisfacer mas requisitos, junto con la necesidad de mas reutilizacion lleva al software orientado a objetos a travez de repetidas faces de expansion y consolidacion ––expansion a medida que se satisfacen nuevos requsitios, y consolidacion a medida que el software se vuelve mas general––.</p>
<figure>
<img src="img/130.png" />
</figure>
<p>Este ciclo es inevitable. Pero los buenos diseñadores estan pendientes de los cambios que pueden dar lugar a refactorizaciones. Los buenos diseñadores tambien conocen estructuras de clases y objetos que pueden ayudarles a eviar refactorizaciones ––sus diseños son mas robustos frente a los cambios de requsitos––. Un analisas de requisitos concienzudo pondra de manifiesto aquellos requisitos que es probable que cambien durante la vida del software, y un buen diseño sera robusto frente a dichos cambios.</p>
<p>Nuestros patrones de diseño reflejan muchas de las estructuras que resultan de la refactorizacion. Usando estos patrones en las faces tempranas del diseño se previenen posteriores refactorizaciones. Pero incluso aunque no veamos como aplicar un patron hasta que hayamos construido nuestrro sistema, el patron todavia puede mostrarnos como cambiarlo. Los patrones de diseño nos proporcionan asi objetivos para nuestras refactorizaciones.</p>
</div>
<h3 id="6.2" >Una breve historia</h3>
<div class="hBody-3" >
<p>El catalogo comenzo como parte de la tesis doctoral de Erich [<a href="#gam91" >Gam91</a>, <a href="#gam92" >Gam92</a>]. Cerca de la mitad de los patrones actuales estaban en su tesis. Para el OOPSLA &#39;91 habia oficialmente un catalogo independiente, y Richard se unio a Erich para trabajar en el. John comenzo a trabajar en el enseguida. Para el OOPSLA &#39;92, Ralph se habia unido al grupo. Trabajo duro para ajustar el catalogo para su publicacion en ECOOP &#39;93, pero pronto nos dimos cuenta de que un articulo de 90 paginas no iba a ser aceptado. De modo que resumimos el catalogo y enviamos el resumen, que fue aceptado. Al poco, decidimos convertir el catalogo en un libro.</p>
<p>Nuestron nombres de los patrones han cambiado algo desde entonces. <q>Wrapper</q> (envoltorio) se convirtio en <q>Decorator</q> (decorador), <q>Glue</q> (pegamento) se convirtio en <q>Facade</q> (fachada), <q>Solitaire</q> (solitario) en <q>Singleton</q> (unico), y <q>Walker</q> (caminante) en <q>Visitor</q> (visitante). Se quitaron un par de patrones porque no parecian lo suficientemente importantes. Pero, aparte de eso, el conjunto de patrones del catalogo ha cambiado poco desde finales de 1992. Los patrones en si, no obstante, han evolucionado tremendamente.</p>
<p>De hecho, darse cuenta de que algo es un patron es la parte facil. Todos nosotros trabajamos de forma activa en la construccion de sistemas orientados a objetos, y hemos descubierto que es facil reconocer a los patrones cuando se miran bastastes sistemas. Pero <em>encontrar</em> patrones es mucho mas facil que <em>describirlos</em>.</p>
<p>Si construye sistemas y a continuacion reflexiona sobre lo que ha construido, vera patrones en lo que hace. Pero es dificil describir los patrones para que otra gente que no los conoce los compreda y se de cuenta de por que son importantes. Los expertos reconocieron inmediatamente el valor del catalogo en sus etapas iniciales. Pero los unicos que podrian entneder los patrones eran aquellos que ya los habian usado.</p>
<p>Puesto que uno de los principales propositos del libro era enseñar diseño orientado a objetos a los nuevos diseñadores, sabiamos que teniamos que mejorar el catalogo. Ampliamos el tamaño medio de un patron de menos de 2 a mas de 10 paginas, incluyendo un detallado ejemplo de motivacion y codigo de ejemplo. Tambien comenzamos a examinar las ventajas e inconvenientes y las distintas formas de implementar el patron. Esto hizo que los patrones fuesen mas faciles de entender.</p>
<p>Otro cambio importante del ultimo año ha sido dar mas importancia al problema que es resuelto por un patron. Lo mas facil es ver un patron como una solucion, como una tecnica que puede adaptarse y reutilizarse. Es mas dificil ver cuando resulta <em>apropiado</em> ––caracterizar los problemas que resuelve y el contexto en el que constituye la mejor solucion––. En general, es mas facil ver <em>que</em> hace algo que saber <em>por que</em>, y el <q>porque</q> de un patron es el problema que resuelve. Conocer el proposito de un patron tambien es importante, porque nos ayuda a elegir los patrones a aplicar. El autor de un patron debe establecer y caracterizar el problema que resuelve el patron, incluso aunque tenga que hacelo despues de haber descubierto la solucion.</p>
</div>
<h3 id="6.3" >La comunidad de patrones</h3>
<div class="hBody-3" >
<p>Nosotros no somos los unicos interesados en escribir libros que cataloguen los patrones que utilizan los expertos. Formamos parte de una comunidad mayor interesada en los patrones en general, y en los patrones de software en particular. Christopher Alexander es el arquitecto que primero estudio los patrones en los edificios y comunidades y que desarrollo un <q>lenguaje de patrones</q> para generarlos. Su trabajo nos ha inspirado una y otra vez. Por tanto, es adecuado y merece la pena comparar su trabajo con el nuestro. A continuacion veremos el trabajo de otros en patrones de software.</p>
</div>
<h4 id="los-lenguajes-de-patrones-de-alexander" >Los lenguajes de patrones de Alexander</h4>
<div class="hBody-4" >
<p>Nuestro trabajo se parece al de Alexander en muchos aspectos. Ambos estan basados en observar los sistemas existentes y buscar patrones en ellos. Ambos tienen plantillas para describir patrones (si bien nuestras plantillas son bastante diferentes). Ambos se basan en el lenguaje natural y en montones de ejemplos para describir los patrones, en vez de en lenguajes formales, y ambos dan las razones de cada patron.</p>
<p>Pero hay otros muchos aspectos en los que nuestros trabajos difieren:</p>
<ol class="num" >
<li>
<p>La gente ha estado haciendo casas durante miles de años, y hay muchos ejemplos clasicos a los que acudir. Hemos estado haciendo software durante un periodo de tiempo relativamente corto, y hay pocos que puedan considerarse clasicos.</p>
</li>
<li>
<p>Alexander da un orden en el que deberian utilizarse sus patrones; nosotros no.</p>
</li>
<li>
<p>Los patrones de Alexander hacen hincapie en el problema que solucionan, mientras que los patrones de diseño describen con mas detalle la solucion.</p>
</li>
<li>
<p>Alexander afirma que sus patrones generan edificios completos. nosotros no afirmamos que nuestros programas generaran programas completos.</p>
</li>
</ol>
<p>Cuando Alexander afirma que se puede diseñar una casa simplemente aplicando sus patrones uno detras de otro, tiene metas similares a las de esos metodologos del diseño orientado a objeto que dan recetas de diseño. Alexander no niega la necesidad de la creatividad; algunos de sus patrones requieren compreder los habitos de vida de la gente que usara las casas, y su creencia en la <q>poesia</q> del diseño implica un nivel de experienca mas alla del lenguaje de patrones en si.<span class="note" ><sup><a href="#56" >56</a></sup></span> Pero su descripcion de como los patrones generan diseño implica que un lenguaje de patrones puede hacer que el proceso de diseño sea determinista y repetible.</p>
<p>El punto de vista de Alexander nos ha ayudado a centrarnos en las ventajas e inconvenientes de los diseños ––las diferentes <q>fuerzas</q> que ayudan a dar forma a un diseño––. Su influencia nos hizo trabajar mas duro para compreder la aplicabilidad y consecuencias de nuestros patrones. Tambien evito que nos preocuparamos de definir una representacion formal para los patrones. Aunque dicha representacion podria hacer posible automatizar los patrones, en este punto es mas importante explorar el espacio de los patrones de diseño que formalizarlo.</p>
<p>Desde el punto de vista de Alexander, los patrones de este libro no constituyen un lenguaje. Dada la gran cantidad de sitemas software que se construyen, es dificil imaginarse como podriamos proporcionar un conjunto <q>completo</q> de patrones, que ofreciese instrucciones paso a paso para diseñar una plicacion. Podemos hacerlo para ciertas clases de aplicaciones, tales com escribir informes o hacer un sistema de entrada de formularios. Pero nuestro catalogo tan solo es una coleccion de patrones relacionados; no podemos pretender que sea un lenguaje de patrones.</p>
<p>De hecho, pensamos que es poco probable que haya <em>nunca</em> un lenguaje de patrones completo para el software. No obstante, es ciertamente posible hacer uno que sea <em>mas</em> completo. Se podrian haber añadido los frameworks y como usarlos [<a href="#joh92" >Joh92</a>], patrones para el diseño de interfaces de usuario [<a href="#bj94" >BJ94</a>], patrones de analisis [<a href="#coa92" >Coa92</a>] y todos los otros aspectos del desarrollo de software. Los patrones de diseño no son solo una parte de un lenguaje mayor de patrones de software.</p>
</div>
<h4 id="patrones-de-software" >Patrones De Software</h4>
<div class="hBody-4" >
<p>Nuestra primer experiencia colectiva en el estudio de la arquitectura del software fue en un taller de OOPSLA &#39;91 conducido por Bruce Anderson. El taller estaba dedicado a desarrollar un manual para arquitectos de software (a juzgar por este libro, sospechamos que <q>enciclopedia de arqutectura</q> seria un nombre mas apropiado que <q>manual de arquitectura</q>). Ese primer taller llevo a una serie de encuentros, el mas reciente de los cuales fue la primera conferencia en Lenguajes de Patrones de Programas (<em>Pattern Languages of Programs</em>) celebrada en agosto de 1994. Esto ha creado una comunidad de personas interesadas en documentar la experienca en el software</p>
<p>Por supuesto, otros ya habian tenido este objetivo. El <em>The Art of Computer Programming</em> de Donald Knuth [<a href="#knu73" >Knu73</a>] fue uno de los primeros intentos de catalogar el conocimiento en el software, aunque el se centro en describir algoritmos. Incluso asi, la tarea se evidencio demasiado grande como para ser terminada. Las series de <em>Graphics Gems</em> [<a href="#gla90" >Gla90</a>, <a href="#arv91" >Arv91</a>, <a href="#kir92" >Kir92</a>] son otro catalogo de conocimiento de diseño, anuque tamben tiende a centrarse en algoritmos. El programa de Arqutectura de Software Especifica del Dominio, patrocinado por el Departamente de Defensa de los Estados Unidos [<a href="#gm92" >GM92</a>], se centra en recoger informacion arquitectonica. La comunidad de ingenieria de software basada en el conocimiento trata de represetar el conocimiento relativo al sorftware en general. Hay muchos otros grupos con objetivos al menos similares al nuestro.</p>
<p><em>Advanced C++: Programming Styles and Idioms</em>, de James Coplien [<a href="#cop92" >Cop92</a>] tambien nos ha influido. Los patrones de este libro tienden a ser mas especificos de C++ que los nuestros, y su libro tambien contiene muchos patrones de mas bajo nivel. Pero hay cosas en comun, como señalamos en nuetros patrones. Jim ha sido un miembro activo de la comunidad de patrones. Actualmente esta trabajando en patrones que describen los roles de las personas en las organizaciones de desarrollo de software.</p>
<p>Hay otros muchos sitios en los que se pueden encontrar descripciones de patrones. Kent Beck fue una de las primeras personas de la comunidad del software que defendio el trabajo de Christopher Alexander. En 1993 comenzo a escribir una columna en <em>The Smalltalk Report</em> sobre patrones de Smalltalk. Peter Coad tambien habia pasado cierto tiempo seleccionando patrones. Su articulo sobre patrones nos parece que contiene sobre todo patrones de analisis [<a href="#coa92" >Coa92</a>]; no hemos visto sus ultimos patrones, aunque sabemos que sigue trabajando en ellos. Hemos oido hablar de varios libros sobre patrones que estan escribiondese, pero tampoco hemos visto ninguno. Todo lo que podemos hacer es decir que estan en camino. Uno de estos libros sera de la conferencia de Lenguajes de Patrones de Programas.</p>
</div>
<h3 id="6.4" >Una invitacion</h3>
<div class="hBody-3" >
<p>¿Que puede hacer si esta interesado en los patrones? En primer lugar, uselos y busque otros patrones que se ajusten a su diseño. En los proximos años apareceran un monton de libros y articulos acerca de patrones, de modo que habra muchas fuentes de nuevos patrones. desarrolle su vocabulario de patrones y uselo. Uselo cuando hable con otras personas sobre diseños. Uselo cuando piense y escriba sobre ellos.</p>
<p>En segundo lugar, sea un consumidor critico. El catalogo de patrones de diseño es resultado de un duro trabajo, no solo nuestro, sino de docenas que nos dieron su opinion. Si encuentra un ploblema o cree que es necesaria mas explicacion, pongase en contacto con nosotros. Lo mismo vale para cualquier otro catalogo de patrones: ¡deles su opinion a los autores! Una de las mejores cosas de los patrnose es que apartan las decisiones de diseño del reino de la mera intuicion. Permiten que los autores sean explicitos sobre las ventajas e inconvenientes que proporcionan, lo que facilita ver los fallos de sus patrones y discutir con ellos. Aprovechese de ello.</p>
<p>En tercer lugar, observe que patrones usa y anotelos. Haga de ellos parte de su documentacion. Muestrelos a otras personas. No necesita estar en un laboratoria de investigacion para descubrir patrones. De hecho, encontrar patrones relevantes es practicamente imposible si carece de experiencia practica. Animese a escribir su propio catalogo de patrones... ¡pero asegurese de que alguien mas le ayuda a darles forma!</p>
</div>
<h3 id="6.5" >Una reflexion a modo de despedida</h3>
<div class="hBody-3" >
<p>Los mejores diseño usaran muchos patrones de diseño que se imbrican entre si para producir un mejor todo. Como afirma Christopher Alexander:</p>
<blockquote>
<p>Es posible hacer edificios enlazando patrones, de un modo poco preciso. Un edificio asi construido es una mezcolanza de patrones. No es denso. No es profundo. Pero tambien es posible juntar patrones de modo que muchos patrones se solapen en un mismo espacio fisico: el edificio en muy denso; tiene muchos significados representados en un espacio reducido; y atraves de esa densidad, se hace profundo.</p>
<div class="quote-author" >
<p>A Patter Language [ALX+77, pagina xli]</p>
</div>
</blockquote>
</div>
<h2 id="apendice-a" >Glosario</h2>
<div class="hBody-2" >
<dl>
<dt>acoplamiento</dt>
<dd>
<p>El grado en que los componentes software dependen unos de otros.</p>
</dd>
<dt>acoplamiento abstracto</dt>
<dd>
<p>Dada una clase <em>A</em> que tiene una referencia a una clase abstracta <em>B</em>, la clase <em>A</em> se dice que tiene un <em>acoplamiento abstracto a B</em>. Lo llamamos acoplamiento abstracto porque <em>A</em> se refiene al <em>tipo</em> de un objeto, no a un objeto concreto.</p>
</dd>
<dt>clase</dt>
<dd>
<p>Una clase define la interfaz de un objeto y su implementacion. Especifica la representacion interan de un objeto y define las operaciones que este puede llevar a cabo.</p>
</dd>
<dt>clase abstracta</dt>
<dd>
<p>Una clase cuyo principal proposito es definir una interfaz. Una clase abstracta delega parte de su implementacion, o toda, en sus subclases. No se pueden crear instancias de una clase abstracta.</p>
</dd>
<dt>clase mezclable</dt>
<dd>
<p>Una clase diseñada para ser combinada con otras por medio de la herencia. Las clases mezclables suelen ser abstractas.</p>
</dd>
<dt>clase amiga</dt>
<dd>
<p>En C++, una clase que tiene los mismos permisos de acceso a las operaciones y datos de una clase que la propia clase.</p>
</dd>
<dt>clase concreta</dt>
<dd>
<p>Una clase que no tiene operaciones abstractas. Se puden crean instancias de ella.</p>
</dd>
<dt>clase padre</dt>
<dd>
<p>La clase de la que hereda otra clase. Tiene como sinonimos superclase (Smalltalk), clase base (C++) y clase antecesora.</p>
</dd>
<dt>composicion de objetos</dt>
<dd>
<p>Ensablar o <em>componer</em> objetos para obtener un comportamiento mas complejo.</p>
</dd>
<dt>constructor</dt>
<dd>
<p>En C++, una operacion que se invoca automaticamente para inicializar las nuevas instancias.</p>
</dd>
<dt>delegacion</dt>
<dd>
<p>Un mecanismo de implementacion mediante el cual un objeto redirige o <em>delega</em> una peticion, a otro objeto. El delegado lleva a cabo la peticion en nombre del objeto original.</p>
</dd>
<dt>destructor</dt>
<dd>
<p>En C++, una operacion a la que se invoca automaticamente para terminar un objeto que esta a punto de ser borrado.</p>
</dd>
<dt>diagrama de clases</dt>
<dd>
<p>Un diagrama que representa clases, su estructura y operaciones internas, y las relaciones estaticas entre ellas.</p>
</dd>
<dt>diagrama de interaccion</dt>
<dd>
<p>Un diagrama que muestra el flujo de peticiones entre objetos.</p>
</dd>
<dt>diagrama de objetos</dt>
<dd>
<p>Un diagrama que representa una determinada estrucutra de objteos en tiempo de ejecucion.</p>
</dd>
<dt>encapsulacion</dt>
<dd>
<p>El resultado de ocultar la representacion e implementacion en un objeto. La representacion no es visible y no se puede acceder a ella directamente desde el exterior del objeto. El unico modo de acceder a la representacion de un objeto y de modificarla es atraves de sus operaciones.</p>
</dd>
<dt>enlace dinamico</dt>
<dd>
<p>La asociacion en tiempo de ejecucion entre una peticion a un objeto y una de sus operaciones. En C++, solo las funciones virtuales puras estan enlazadas dinamicamente.</p>
</dd>
<dt>framework</dt>
<dd>
<p>Un conjunto de clases cooperantes que forman un diseño reutilizable para determinada clase de software. Un framework proporciona una guia arquitectonica para dividir el diseño en clases abstractas y definir sus responsabilidades y colaboraciones. Un desarrollador adapta el framework a una aplicacion concreta heredando y componiendo instancias de las clases del framework.</p>
</dd>
<dt>herencia</dt>
<dd>
<p>Una relacion que define una cantidad en terminos de otra. La herencia de clases define una nueva clase en terminos de una o mas clases padre. La nueva clase hereda su interfaz y sus implementaciones de sus padres. La nueva clase se dice que es una subclase o (en C++) una clase derivada. La herencia de clases combina <b>herencia de Interfaces</b> y <b>herencia de implementacion</b>. La herencia de interfaces define una nueva interfaz en terminos de una o varias interfaces existentes. La herencia de implementacion define una nueva implementacion en terminos de una o varias implementaciones existentes.</p>
</dd>
<dt>herencia privada</dt>
<dd>
<p>En C++, una clase de la que se hereda solo por su implementacion.</p>
</dd>
<dt>interfaz</dt>
<dd>
<p>El conjunto de todas las signaturas definidas por las operaciones de un objeto. La interfaz describe el conjunto de peticiones a las que puede responder un objeto.</p>
</dd>
<dt>metaclase</dt>
<dd>
<p>Las clases son objetos en Smalltalk. Una metaclase es la clase de un objeto clase.</p>
</dd>
<dt>objeto</dt>
<dd>
<p>Una entidad de tiempo de ejecucion que empaqueta datos y los procedimientos que operan sobre esos datos.</p>
</dd>
<dt>objeto agregado</dt>
<dd>
<p>Un objeto que se compone de subobjetos. Los subobjetos se denominan las partes, y el agregadao es reponsable de ellos.</p>
</dd>
<dt>operacion</dt>
<dd>
<p>Los datos de un objeto solo pueden ser manipulados por sus operaciones. Un objeto realiza una operacion cuando recibe una peticion. En C++, a las operacines se las denomina <b>funciones miembro</b>. Smalltalk usa el termino <b>metodo</b>.</p>
</dd>
<dt>operacion abstracta</dt>
<dd>
<p>Una operacion que declara una signatura pero no la implementa. En C++, una operacion abstracta se corresponde con una funcion miembro virtual pura.</p>
</dd>
<dt>operacion de clase</dt>
<dd>
<p>Una operacion que pertenece a una clase y no a un objeto individual. En C++, las operaciones de clase se denominan <b>funciones miembro estaticas</b>.</p>
</dd>
<dt>patron de diseño</dt>
<dd>
<p>Un patron de diseño nomina, da los motivos y explica sistematicamente un diseño general que resuelve un problema de diseño recurrente en los sistemas orientados a objetos. Describe el problema, la solucion, cuando aplicar este y sus consecuencias. Tambien ofrece trucos de implementacion y ejemplos. La solucion es una disposicion general de clases y objetos que resuelven el problema. Esta adaptada e implementada para resolver el problema en un determinado contexto.</p>
</dd>
<dt>peticion</dt>
<dd>
<p>un objeto lleva a cabo una operacion cuando recibe la peticion correspondiente de otro objeto. Un sinonimo frecuente de peticion es <b>mensaje</b>.</p>
</dd>
<dt>polimorfismo</dt>
<dd>
<p>La capacidad de sustituir los objetos que se ajustan a una interfaz por otros en tiempo de ejecucion</p>
</dd>
<dt>protocolo</dt>
<dd>
<p>Extiende el concepto de interfaz para incluir todas las secuencias de peticiones permitidas.</p>
</dd>
<dt>receptor</dt>
<dd>
<p>El objeto destino de una pecition.</p>
</dd>
<dt>redefinicion</dt>
<dd>
<p>Volver a definir una operacion (heredada de una clase padre) en una subclase</p>
</dd>
<dt>referencia de objetos</dt>
<dd>
<p>Un valor que indentifica a otro objeto.</p>
</dd>
<dt>relacion de agregacion</dt>
<dd>
<p>La relacion entre un objeto agregado y sus padres. Una clase define esta relacion con sus instancias (objetos agregados).</p>
</dd>
<dt>relacion de asociacion</dt>
<dd>
<p>Una clase que se refiere a otra clase tiene una <em>asociacion</em> con esa clase.</p>
</dd>
<dt>reutilizacion de caja blanca</dt>
<dd>
<p>Un estilo de reutilizacion basado en la herencia de clases. Una subclase reutiliza la interfaz e implementacion de su clase padre, pero puede acceder a los aspectos privades de su padre.</p>
</dd>
<dt>reutilizacion de caja negra</dt>
<dd>
<p>un estilo de reutilizacion basado en la composicion de objetos. Los objetos compuestos no se revelan entre si sus detalles internos, lo que los hace ser como <q>cajas negras</q>.</p>
</dd>
<dt>signatura</dt>
<dd>
<p>La signatura de una operacion define su nombre, parametros y tipo de retorno.</p>
</dd>
<dt>subclase</dt>
<dd>
<p>Una clase que hereda de otra. En C++, una subclase se denomina una clase derivada.</p>
</dd>
<dt>subsistema</dt>
<dd>
<p>Un grupo independiente de clases que colaboran para llevar a cabo una serie de responsabilidades.</p>
</dd>
<dt>subtipo</dt>
<dd>
<p>Un tipo es un subtipo de otro si su interfaz contiene a la interfaz de aquel.</p>
</dd>
<dt>supertipo</dt>
<dd>
<p>El tipo padre del que hereda otro tipo.</p>
</dd>
<dt>tipo</dt>
<dd>
<p>El nombre de una determinada interfaz</p>
</dd>
<dt>tipo parametrizado</dt>
<dd>
<p>Un tipo que deja sin especificar alguno de sus tipos constituyentes. Los tipos sin especificar se porporcionan como parametros en el momento de su uso. En C++, los tipos parametrizados se llaman plantillas.</p>
</dd>
<dt>toolkit</dt>
<dd>
<p>Una coleccion de clases que proporcionan una funcionalidad util pero que no definen el diseño de una aplicacion.</p>
</dd>
<dt>variable de instancia</dt>
<dd>
<p>Un elemento de datos que define parte de la representacion de un objeto. C++ usa el termino <b>miembro de datos</b>.</p>
</dd>
</dl>
</div>
<h2 id="apendice-b" >Guia de la notacion</h2>
<div class="hBody-2" >
<p>A lo largo del libro se usan diagramas para ilustrar las ideas importantes. Algunos diagramas son formales, como una captura de pantalla de un cuadro de dialogo o un esquema que representa un arbol de objetos. Pero lo que son los patrones de diseño usan notaciones mas formales para denotar relaciones e interacciones entre clases y objetos. En este apendice se describen dichas notaciones en detalle.</p>
<p>Usamos tres notaciones graficas distintas:</p>
<ol class="num" >
<li>
<p>Un <b>diagrama de clase</b> representa clases, su estructura y las relaciones estaticas entre ellas.</p>
</li>
<li>
<p>Un <b>diagrama de objetos</b> muestra una determinada estructura de objetos en tiempo de ejecucion.</p>
</li>
<li>
<p>Un <b>diagrama de interaccion</b> muestra el flujo de peticiones entre objetos.</p>
</li>
</ol>
<p>Cada patron de diseño incluye al menos un diagrama de clases. Las otras notaciones se usan cuando son necesarias para completar la descripcion. Los diagramas de clases y objetos estan basados en OMT (<em>Object Modeling Technique</em>, Tecnica de Modelado de Objetos) [<a href="#rbp+91" >RBP+91</a>, <a href="#rum94" >Rum94</a>].<span class="note" ><sup><a href="#57" >57</a></sup></span> Los diagramas de interaccion estan tomados de Objectory [<a href="#jcjo92" >JCJO92</a>] y del metodo Booch [<a href="#boo94" >Boo94</a>].</p>
</div>
<h3 id="b.1" >Diagrama de clases</h3>
<div class="hBody-3" >
<p>La figura B.1a muestra la notacion OMT para las clases abstractas y concretas. Una clase se denota por un rectangulo con el nombre de la clase en negrita en la parte superior. Las principales operaciones de la clase aparecen bajo el nombre de la clase. Las variables de instancia se muestran debajo de las operaciones. La informacion de tipos es opcional; nosotros usamos el convenio de C++, que situa el nombre de tipo antes del nombre de la operacion (para singnificar el tipo de retorno), variable de instancia o parametro real. Si el tipo aparece en cursiva quiere decir que la operacion es abstracta.</p>
<div class="figure" >
<h1 class="figure">(a) Clases abstractas y concretas</h1>
<figure>
<img src="img/131.png" />
</figure>
</div>
<p>En algunos diseños resulta util ver donde hacen referencia las clases cliente a las clases Participante. Cuando un patron incluye una clase Cliente como una de sus participantes (lo que quiere decir que el cliente tiene alguna responsabilidad en el patron, el Cliente aparece como una clase ordinaria. Un ejemplo de esto lo tenemos en el patron <a href="#flyweight" >Flyweight</a>. Cuando el patron no incluye el Cliente como participante (es decir, los clientes no tienen responsabilidades en el patron), pero a pesar de eso incluirlo en el diagrama ayuda a clarificar el modo en que el patron interactua con sus clientes, entonces la clase Cliente se muestra en gris, como en la figura B.1b. Un ejemplo de esto es el patron <a href="#proxy" >Proxy</a>. Un Cliente en gris tambien deja claro que no ha sido omitido accidentalmente de la seccion de Participantes.</p>
<div class="figure" >
<h1 class="figure">(b) Relaciones entre clases</h1>
<figure>
<img src="img/132.png" />
</figure>
</div>
<p>La figura B.1c muestra varias relaciones entre clases. La notacion OMT para la herencia de clases es un triangulo que conecta a una subclase (<code>FormaLinea</code> en la figura) a su clase padre (<code>Forma</code>). Una referencia a un objeto que representa una relacion de agregacion o parte-todo se indica mediante una flecha con un rombo en su base. La flecha apunta a la clase del agregado (por ejemplo, <code>Forma</code>). Una flecha sin rombo denota asociacion (por ejemplo, una <code>FormaLinea</code> tiene una referencia a un objeto <code>Color</code> que puede ser compartido con otras formas). La referencia puede tener un nombre cerca de la base para distinguirla de otras referencias.<span class="note" ><sup><a href="#58" >58</a></sup></span></p>
<div class="figure" >
<h1 class="figure">(c) relacion entre clases</h1>
<figure>
<img src="img/133.png" />
</figure>
</div>
<p>Tambien es util mostrar que clases crean instancias de que otras. Para ello usamos una flecha con la linea punteada, ya que OMT no lo permite. Llamamos a esto la relacion <q>crea</q>. la flecha apunta a la clase de la que se crea la instancia. En la figura B.1.c, <code>HerramientasDeCreacion</code> crea objetos <code>FormaLinea</code></p>
<p>OMT tambien define un circulo relleno que representa <q>mas de uno</q>. Cuando el circulo aparece en el extremo de una referencia quiere decir que hay muchos objetos referenciados o agregados. La figura B.1c representa un agregado <code>Dibujo</code> que contiene multiples objetos de tipo <code>Forma</code>.</p>
<div class="figure" >
<h1 class="figure">(d) Notacion en pseudocodigo</h1>
<figure>
<img src="img/134.png" />
</figure>
</div>
<p>Por ultimo, hemos aumentado OMT con anotaciones en pseudocodigo que nos permiten esbozar las implementaciones de las operaciones. La figura B.1d muestra la anotacion en pseudocodigo para la operacion <code>Dibujar</code> de la clase <code>Dibujo</code>.</p>
</div>
<h3 id="b.2" >Diagrama de objetos</h3>
<div class="hBody-3" >
<p>Un Diagrama de objetos muestra exclusivamente instancias. Representa una instancia de los objetos de un patron de diseño. Los objetos tienen por nombre <q>unAlgo</q>, donde <em>Algo</em> es la clase del objeto. Nuestro simbolo de un objeto (modificado ligeramente del estandar OMT) es un rectangulo con los bordes redondeados y una linea que separa el nombre del objeto de las referencias a otros objetos. Las flechas indican el objeto referenciado. La figura B.2 muestra un ejemplo.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-b.2" >Figura B.2</span>: Notacion de los diagramas de objetos</h1>
<figure>
<img src="img/135.png" />
</figure>
</div>
</div>
<h3 id="b.3" >Diagrama de iteracion</h3>
<div class="hBody-3" >
<p>Un diagrama de interacion muestra el orden en que se ejecutan las peticiones entre objetos. La figura B.3 es un diagrama de interaccion que muestra como se añade una forma a un dibujo.</p>
<div class="figure" >
<h1 class="figure"><span id="figura-b.3" >Figura B.3</span>: Notacion de los diagramas de interaccion</h1>
<figure>
<img src="img/136.png" />
</figure>
</div>
<p>En un diagrama de interaccion, el tiempo fluye de arriba a abajo. Una linea vertical indica el tiempo de vida de un determinado objeto. La convencion de nominacion de objetos es la misma que la de los diagramas de objetos ––el nombre de la clase con los articulos indenterminados <q>un</q> o <q>una</q> como prefijo (por ejemplo, <code>unaForma</code>––). Si no se crea ninguna instancia del objeto hasta un tiempo despues del instante inicial representado en el diagrama, entonces su linea vertical aparece punteada hasta el momento de la creacion.</p>
<p>Un rectangulo vertical indica que un objeto esta activo; es decir, que esta procesando una peticion. La operacion puede enviar peticiones a otros objetos; esto se indica con una flecha horizontal que apunta al objeto receptor. El nombre de la peticion se muestra encima de la flecha. Una peticion se representa con una flecha hacia si mismo.</p>
<p>La figura B.3 muestra que la primera repeticion procede de <code>unaHerramientaDeCreacion</code> para crear <code>unaFormaLinea</code>. A continuacion, se añade <code>unaFormaLinea</code> a <code>unDibujo</code>, lo que hace que <code>unDibujo</code> se envie a si mismo una peticion <code>Actualizar</code>. Notese que <code>unDibujo</code> envia una peticion <code>Dibujar</code> a <code>unaFormaLinea</code> como parte de la operacion <code>Actualizar</code>.</p>
</div>
<h2 id="apendice-c" >Clases fundamentales</h2>
<div class="hBody-2" >
<p>Este apendice documenta las clases fundamentales que usamos en el codigo de ejemplo C++ de varios patrones de diseño. Las hemos mantenido intencionadamente simples y minimas. Describiremos las clases siguientes:</p>
<ul>
<li>
<p><code>Lista</code>, una lista ordenada de objetos.</p>
</li>
<li>
<p><code>Iterador</code>, la interfaz para acceder en secuencia a los objetos de un agregado.</p>
</li>
<li>
<p><code>IteradorLista</code>, un iterador para recorrer una <code>Lista</code>.</p>
</li>
<li>
<p><code>Punto</code>, un punto de dos dimenciones.</p>
</li>
<li>
<p><code>Rect</code>, un rectangulo</p>
</li>
</ul>
<p>Algunos de los tipos estandar mas recientes de C++ puede que no esten disponibles en todos los compiladores. En concreto, si nuestro compilador no define <code>bool</code>, podemos definirlo manualmente como sigue:</p>
<pre class="code" ><code class="chroma" ><span class="k">typedef</span> <span class="kt">int</span> <span class="kt">bool</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="nb">true</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="nb">false</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre>
</div>
<h3 id="c.1" >Lista</h3>
<div class="hBody-3" >
<p>La clase de plantilla <code>Lista</code> proporciona un contenedor basico para guardar una lista ordenada de objetos. <code>Lista</code> guarda los elementos por valor, lo que significa que sirve tanto para tipos predefinidos como para instancias de clases. Por ejemplo, <code>Lista&lt;int&gt;</code> declara una lista de <code>int</code>s. Pero la mayoria de los patrones usan <code>Lista</code> para guardar punteros a objetos, como en <code>Lista&lt;Glifo*&gt;</code>. De ese modo se puede usar <code>Lista</code> para listas heterogeneas.</p>
<p>Por conveniencia, <code>Lista</code> tambien proporciona sinonimos para operaciones de pilas, lo que hace mas explicito al codigo que usa <code>Lista</code> para pilas, sin necesidad de definir otra clase.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Lista</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Lista</span><span class="p">(</span><span class="kt">long</span> <span class="n">tamano</span> <span class="o">=</span> <span class="n">CAPACIDAD_LISTA_PREDETERMINADA</span><span class="p">);</span>
    <span class="n">Lista</span><span class="p">(</span><span class="n">Lista</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Lista</span><span class="p">();</span>
    <span class="n">Lista</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Lista</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="kt">long</span> <span class="nf">Contar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">Elemento</span><span class="o">&amp;</span> <span class="n">Obtener</span><span class="p">(</span><span class="kt">long</span> <span class="n">indice</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">Elemento</span><span class="o">&amp;</span> <span class="n">Primero</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">Elemento</span><span class="o">&amp;</span> <span class="n">Ultimo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">Incluye</span><span class="p">(</span><span class="k">const</span> <span class="n">Elemento</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">Insertar</span><span class="p">(</span><span class="k">const</span> <span class="n">Elemento</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">InsertarAlPrincipio</span><span class="p">(</span><span class="k">const</span> <span class="n">Elemento</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">Eliminar</span><span class="p">(</span><span class="k">const</span> <span class="n">Elemento</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">EliminarUltimo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">EliminarPrimero</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">EliminarTodos</span><span class="p">();</span>

    <span class="n">Elemento</span><span class="o">&amp;</span> <span class="n">Cima</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">Meter</span><span class="p">(</span><span class="k">const</span> <span class="n">Elemento</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Elemento</span><span class="o">&amp;</span> <span class="n">Sacar</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>Las secciones siguientes describen estas operaciones en mas detalle.</p>
</div>
<h4 id="costruccion,-destruccion,-inicializacion-y-asignacion" >Costruccion, Destruccion, Inicializacion y Asignacion</h4>
<div class="hBody-4" >
<dl>
<dt><code>Lista(long tamano)</code></dt>
<dd>
<p>inicializa la lista. El parametro <code>tamano</code> es una indicacion del numero inicial de elementos.</p>
</dd>
<dt><code>Lista(Lista&amp;)</code></dt>
<dd>
<p>redefine el constructor de copia predeterminado para que los datos miembros se inicialicen adecuadamente.</p>
</dd>
<dt><code>~Lista()</code></dt>
<dd>
<p>libera las estructuras de datos internas, pero <em>no</em> los elementos de la lista. La clase no esta diseñada para ser heredada; por tanto, el destructor no es virtual.</p>
</dd>
<dt><code>Lista&amp; operator=(const Lista&amp;)</code></dt>
<dd>
<p>Implementa la operacion de asignacion para asignar correctamente los datos miembros.</p>
</dd>
</dl>
</div>
<h4 id="acceso" >Acceso</h4>
<div class="hBody-4" >
<p>Estas operaciones proporcionan el acceso basico a los elementos de la lista.</p>
<dl>
<dt><code>long Contar() const</code></dt>
<dd>
<p>devuelve el numero de objetos de la lista.</p>
</dd>
<dt><code>Elemento&amp; Obtener(long indice) const</code></dt>
<dd>
<p>devuelve el objeto del indice actual.</p>
</dd>
<dt><code>Elemento&amp; Primero() const</code></dt>
<dd>
<p>devuelve el primer objeto de la lista.</p>
</dd>
<dt><code>Elemento&amp; Ultimo() const</code></dt>
<dd>
<p>devuelve el ultimo objeto de la lista.</p>
</dd>
</dl>
</div>
<h4 id="adicion" >Adicion</h4>
<div class="hBody-4" >
<dl>
<dt><code>void Insertar(const Elemento&amp;)</code></dt>
<dd>
<p>añade el argumento a la lista, pasando a ser el ultimo elemento.</p>
</dd>
<dt><code>void InsertarAlPrincipio(const Elemento&amp;)</code></dt>
<dd>
<p>añade el argumento a la lista, pasando a ser el primer elemento.</p>
</dd>
</dl>
</div>
<h4 id="borrado" >Borrado</h4>
<div class="hBody-4" >
<dl>
<dt><code>void Eliminar(const Elemento&amp;)</code></dt>
<dd>
<p>elimina el elemento dado de la lista. Esta operacion requiere que el tipo de los elementos de la lista admita el operador <code>==</code> para la comparacion.</p>
</dd>
<dt><code>void EliminarPrimero()</code></dt>
<dd>
<p>elimina el primer elemento de la lista.</p>
</dd>
<dt><code>void EliminarUltimo()</code></dt>
<dd>
<p>elimina el ultimo elemento de la lista.</p>
</dd>
<dt><code>void EliminarTodos()</code></dt>
<dd>
<p>elimina todos los elementos de la lista.</p>
</dd>
</dl>
</div>
<h4 id="interfaz-de-la-pila" >Interfaz de la pila</h4>
<div class="hBody-4" >
<dl>
<dt><code>Elemento&amp; Cima() const</code></dt>
<dd>
<p>devuelve el elemento de la cima (cuando la <code>Lista</code> es vista como una pila).</p>
</dd>
<dt><code>void Meter(const Elemento&amp;)</code></dt>
<dd>
<p>mete el elemento en la pila.</p>
</dd>
<dt><code>Elemento&amp; Sacar()</code></dt>
<dd>
<p>extrae el elemento de la cima de la pila.</p>
</dd>
</dl>
</div>
<h3 id="c.2" >Iterador</h3>
<div class="hBody-3" >
<p><code>Iterador</code> es una clase abstracta que define una interfaz de recorrido para agregados.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Iterador</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Primero</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Siguiente</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">HaTerminado</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Elemento</span> <span class="nf">ElementoActual</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Iterador</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
<p>Las operaciones hacen lo siguiente:</p>
<dl>
<dt><code>virtual void Primero()</code></dt>
<dd>
<p>posiciona el iterador sobre el primer objeto del agregado.</p>
</dd>
<dt><code>virtual void Siguiente()</code></dt>
<dd>
<p>posiciona el iterador en el siguiente objeto de la secuencia.</p>
</dd>
<dt><code>virtual bool HaTerminado() const</code></dt>
<dd>
<p>devuelve <code>true</code> cuando no hay mas objetos en la secuencia.</p>
</dd>
<dt><code>virtual Elemento ElementoActual() const</code></dt>
<dd>
<p>devuelve el objeto situado en la posicion actual de la secuencia.</p>
</dd>
</dl>
</div>
<h3 id="c.3" >IteradorLista</h3>
<div class="hBody-3" >
<p><code>IteradorLista</code> implementa la interfaz <code>Iterador</code> para recorrer objetos <code>Lista</code>. Su constructor recibe la lista a recorrer como argumento.</p>
<pre class="code" ><code class="chroma" ><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Elemento</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IteradorLista</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Iterador</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">IteradorLista</span><span class="p">(</span><span class="k">const</span> <span class="n">Lista</span><span class="o">&lt;</span><span class="n">Elemento</span><span class="o">&gt;*</span> <span class="n">unaLista</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Primero</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Siguiente</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">HaTerminado</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Elemento</span> <span class="nf">ElementoActual</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>
<h3 id="c.4" >Punto</h3>
<div class="hBody-3" >
<p><code>Punto</code> representa un punto en un espacio bidimencional de coordenadas cartecianas. <code>Punto</code> permite cierta aritmetica de vectores minima. Las coordenadas de un <code>Punto</code> se definen como:</p>
<pre class="code" ><code class="chroma" ><span class="n">tipedef</span> <span class="kt">float</span> <span class="n">Coord</span><span class="p">;</span>
</code></pre>
<p>Las operaciones de <code>Punto</code> se explican por si mismas.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Punto</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">Punto</span> <span class="n">Cero</span><span class="p">;</span>

    <span class="n">Punto</span><span class="p">(</span><span class="n">Coord</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">);</span>

    <span class="n">Coord</span> <span class="nf">X</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="kt">void</span> <span class="nf">X</span><span class="p">(</span><span class="n">Coord</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">Coord</span> <span class="nf">Y</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="kt">void</span> <span class="nf">Y</span><span class="p">(</span><span class="n">Coord</span> <span class="n">y</span><span class="p">);</span>

    <span class="k">friend</span> <span class="n">Punto</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">friend</span> <span class="n">Punto</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">friend</span> <span class="n">Punto</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">friend</span> <span class="n">Punto</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="n">Punto</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Punto</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Punto</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Punto</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="n">Punto</span> <span class="n">opeartor</span><span class="o">-</span><span class="p">();</span>

    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">friend</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
<p>El miembro estatico <code>Cero</code> representa el <code>Punto(0, 0)</code>.</p>
</div>
<h3 id="c.5" >Rect</h3>
<div class="hBody-3" >
<p><code>Rect</code> representa un rectangulo alineado con el eje. Un <code>Rect</code> se define por un punto de origen y una dimension (esto es, su ancho y su alto). Las operaciones de <code>Rect</code> son muy faciles de entender.</p>
<pre class="code" ><code class="chroma" ><span class="k">class</span> <span class="nc">Rect</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">Rect</span> <span class="n">Cero</span><span class="p">;</span>

    <span class="n">Rect</span><span class="p">(</span><span class="n">Coord</span> <span class="n">x</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">y</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">ancho</span><span class="p">,</span> <span class="n">Coord</span> <span class="n">alto</span><span class="p">);</span>
    <span class="n">Rect</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">origen</span><span class="p">,</span> <span class="n">cont</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">dimension</span><span class="p">);</span>

    <span class="n">Coord</span> <span class="nf">Ancho</span>    <span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="kt">void</span> <span class="nf">Ancho</span>    <span class="p">(</span><span class="n">Coord</span><span class="p">);</span>
    <span class="n">Coord</span> <span class="nf">Alto</span>     <span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="kt">void</span> <span class="nf">Alto</span>     <span class="p">(</span><span class="n">Coord</span><span class="p">);</span>
    <span class="n">Coord</span> <span class="nf">Izquierda</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="kt">void</span> <span class="nf">Izquierda</span><span class="p">(</span><span class="n">Coord</span><span class="p">);</span>
    <span class="n">Coord</span> <span class="nf">Inferior</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="kt">void</span> <span class="nf">Inferior</span> <span class="p">(</span><span class="n">Coord</span><span class="p">);</span>

    <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">Origen</span>   <span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="kt">void</span> <span class="nf">Origen</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">Dimension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="kt">void</span> <span class="nf">Dimension</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">MoverA</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Mover</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="nf">EstaVacio</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">Contiene</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
<p>El miembro estatico <code>Cero</code> es equivalente al rectangulo</p>
<pre class="code" ><code class="chroma" ><span class="n">Rect</span><span class="p">(</span><span class="n">Punto</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">Punto</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</code></pre>
</div>
<h2 id="bibliografia" >Bibliografia</h2>
<div class="hBody-2" >
<p>[<span id="add94" >Add94</span>] Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumeness 1 y 2, 1994.</p>
<p>[<span id="ag90" >AG90</span>] D.B. Anderson y S. Gossain. Hierarchy evolution y the software lifecycle. In TOOLS &#39;90 Conference Proceedings, pp. 41–50, Paris, Junio de 1990. Prentice Hall.</p>
<p>[<span id="ais+77" >AIS+77</span>] Christopher Alexander, Sara Ishikawa, Murray Silverstein, Max Jacobson, Ingrid Fiksdahl-King, y Shlomo Angel. A Pattern Language. Oxford University Press, Nueva York, 1977.</p>
<p>[<span id="app89" >App89</span>] Apple Computer, Inc., Cupertino, CA. Macintosh Programmers Workshop Pascal 3.0 Reference, 1989.</p>
<p>[<span id="app92" >App92</span>] Apple Computer, Inc., Cupertino, CA. Dylan. An object-oriented dynamic language, 1992.</p>
<p>[<span id="arv91" >Arv91</span>] James Arvo. Graphics Gems II.Academic Press, Boston, MA, 1991.</p>
<p>[<span id="as85" >AS85</span>] B. Adelson y E. Soloway. The role of domain experience in software design. IEEE Transactions on Software Engineering, 11(11):1351-1360, 1985.</p>
<p>[<span id="be93" >BE93</span>] Andreas Birrer y Thomas Eggenschwiler. Frameworks in the financial engineering domain: An experience report. En European Conference on Object-Oriented Programming, pp. 21-35, Kaiserslautern, Alemania, julio de 1993. Springer-Verlag.</p>
<p>[<span id="bj94" >BJ94</span>] Kent Beck y Ralph Johnson. Patterns generate architectures. In European Conference on Object-Oriented Programming, pp. 139-149, Bologna, Italy, julio de 1994. Springer-Verlag.</p>
<p>[<span id="boo94" >Boo94</span>] Grady Booch. Object-Oriented Analysis and Design with Applications. Benjamin/Cummings, Redwood City, CA, 1994. Segunda Edicion.</p>
<p>[<span id="bor81" >Bor81</span>] A. Borning. The programming language aspects of ThingLab—a constraint-oriented simulation laboratory. ACM Transactions on Programming Languages and Systems, 3(4):343-387, octubre de 1981.</p>
<p>[<span id="bor94" >Bor94</span>] Borland International, Inc., Scotts Valley, CA. A Technical Comparison of Borland ObjectWindows 2.0 and Microsoft MFC 2.5, 1994.</p>
<p>[<span id="bv90" >BV90</span>] Grady Booch y Michael Vilot. The design of the C++ Booch components. In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 1-11, Ottawa, Canada, Octubre de 1990. ACM Press.</p>
<p>[<span id="cal93" >Cal93</span>] Paul R. Calder. Building User Interfaces with Lightweight Objects. PhD thesis, Stanford University, 1993.</p>
<p>[<span id="car89" >Car89</span>] J. Carolan. Constructing bullet-proof classes. In Proceedings C++ at Work &#39;89. SIGS Publications, 1989.</p>
<p>[<span id="car92" >Car92</span>] Tom Cargill. C++ Programming Style. Addison-Wesley, Reading, MA, 1992.</p>
<p>[<span id="cirm93" >CIRM93</span>] Roy H. Campbell, Nayeem Islam, David Raila, and Peter Madeany. Designing and implementing Choices: An object-oriented system in C++. Communications of the ACM, 36(9):117-126, septiembre de 1993.</p>
<p>[<span id="cl90" >CL90</span>] Paul R. Calder y Mark A. Linton. Glyphs: Flyweight objects for user interfaces. In ACM User Interface Software Technologies Conference, pp. 92-101, Snowbird, UT, octubre de 1990.</p>
<p>[<span id="cl92" >CL92</span>] Paul R. Calder y Mark A. Linton. The object-oriented implementation of a document editor. In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 154-165, Vancouver, British Columbia, Canada, octubre de 1992. ACM Press.</p>
<p>[<span id="coa92" >Coa92</span>] Peter Coad. Object-oriented patterns. Communications of the ACM, 35(9):152-159, septiembre de 1992.</p>
<p>[<span id="coo92" >Coo92</span>] William R. Cook. Interfaces and specifications for the Smalltalk-80 collection classes. In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 1-15, Vancouver, British Columbia, Canada, octuebre de 1992. ACM Press.</p>
<p>[<span id="cop92" >Cop92</span>] James O. Coplien. Advanced C++ Programming Styles and Idioms. Addison-Wesley, Reading, MA, 1992.</p>
<p>[<span id="cur89" >Cur89</span>] Bill Curtis. Cognitive issues in reusing softwareartifacts. In Ted J. Biggerstaff y Alan J. Perlis,editors, Software Reusability, Volume II: Applications and Experience, pp. 269-287. Addison-Wesley, Reading, MA, 1989.</p>
<p>[<span id="dclf93" >dCLF93</span>] Dennis de Champeaux, Doug Lea, y Penelope Faure. Object-Oriented System Development. Addison-Wesley, Reading, MA, 1993.</p>
<p>[<span id="deu89" >Deu89</span>] L. Peter Deutsch. Design reuse y frameworks in the Smalltalk-80 system.  In Ted J. Biggerstaff and Alan J. Perlis, editors, Software Reusability, Volume II: Applications and Experience, pp. 57-71. Addison-Wesley, Reading, MA, 1989.</p>
<p>[<span id="ede92" >Ede92</span>] D. R. Edelson. Smart pointers: They&#39;re smart, but they&#39;re not pointers.  In Proceedings of the 1992 USENIX C++ Conference, pp. 1-19, Portland, OR, agosto de 1992. USENIX Association.</p>
<p>[<span id="eg92" >EG92</span>] Thomas Eggenschwiler y Erich Gamma. The ET++SwapsManager: Using object technology in the financial engineering domain. In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 166-178, Vancouver, British Columbia, Canada, octubre de 1992. ACM Press.</p>
<p>[<span id="es90" >ES90</span>] Margaret A. Ellis y Bjarne Stroustrup. The Annotated C++ Reference Manual. Addison-Wesley,Reading, MA, 1990.</p>
<p>[<span id="foo92" >Foo92</span>] Brian Foote. A fractal model of the life cycles of reusable objects. OOPSLA &#39;92 Workshop on Reuse, octubre de 1992. Vancouver, British Columbia, Canada.</p>
<p>[<span id="ga89" >GA89</span>] S. Gossain y D.B. Anderson. Designing aclass hierarchy for domain representation y reusability. In TOOLS &#39;89 Conference Proceedings, pp. 201-210, CNIT Paris—La Defense, France, noviembre de 1989. Prentice Hall.</p>
<p>[<span id="gam91" >Gam91</span>] Erich Gamma. Object-Oriented Software Development based on ET++: Design Patterns, Class Library, Tools (en aleman). Tesis Doctoral, Universidad de Zurich Institut für Informatik, 1991.</p>
<p>[<span id="gam92" >Gam92</span>] Erich Gamma. Object-Oriented Software Development based on ET++: Design Patterns, Class Library, Tools (en aleman). Springer-Verlag, Berlin, 1992.</p>
<p>[<span id="gla90" >Gla90</span>] Andrew Glassner. Graphics Gems.Academic Press, Boston, MA, 1990.</p>
<p>[<span id="gm92" >GM92</span>] M. Graham y E. Mettala. The Domain-Specific Software Architecture Program. En Proceedings of DARPA Software Technology Conference, 1992, pp. 204-210, April de 1992. Publicado tambien en CrossTalk, The Journal of Defense Software Engineering, pp. 19-21, 32, octubre de 1992.</p>
<p>[<span id="gr83" >GR83</span>] Adele J. Goldberg y David Robson. Smalltalk-80: The Language and Its Implementation. Addison-Wesley, Reading, MA, 1983.</p>
<p>[<span id="hhmv92" >HHMV92</span>] Richard Helm, Tien Huynh, Kim Marriott, and John Vlissides. An object-oriented architecture for constraint-based graphical editing. En Proceedings of the Third Eurographics Workshopon Object-Oriented Graphics, pp. 1-22, Champéry, Switzerland, octubre de 1992. Tambien se encuentra disponible como el infrome tecnico RC 18524 (79392) de la Division de Investigacion de IBM.</p>
<p>[<span id="ho87" >HO87</span>] Daniel C. Halbert y Patrick D. O&#39;Brien.Object-oriented development. IEEE Software,4(5):71-79, septiembre de 1987.</p>
<p>[<span id="ion94" >ION94</span>] IONA Technologies, Ltd., Dublin, Ireland.Programmer&#39;s Guide for Orbix, Version 1.2, 1994.</p>
<p>[<span id="jcjo92" >JCJO92</span>] Ivar Jacobson, Magnus Christerson, Patrik Jonsson, y Gunnar Overgaard.  Object-Oriented Software Engineering—A Use Case Driven Approach. Addison-Wesley, Wokingham, Inglaterra, 1992.</p>
<p>[<span id="jf88" >JF88</span>] Ralph E. Johnson y Brian Foote. Designing reusable classes. Journal of Object-Oriented Programming, 1(2):22-35, junio/julio de 1988.</p>
<p>[<span id="jml92" >JML92</span>] Ralph E. Johnson, Carl McConnell y J. Michael Lake. The RTL system: A framework for code optimization. En Robert Giegerich y Susan L. Graham, editores, Code Generation—Concepts, Tools, Techniques. Proceedings of the International Workshop on Code Generation, pp. 255-274, Dagstuhl, Alemania, 1992. Springer-Verlag.</p>
<p>[<span id="joh92" >Joh92</span>] Ralph Johnson. Documenting frameworks using patterns. In Object-Oriented Programming Systems, Languages,and Applications Conference Proceedings, pp. 63-76, Vancouver, British Columbia, Canada, octubre de 1992. ACM Press.</p>
<p>[<span id="jz91" >JZ91</span>] Ralph E. Johnson y Jonathan Zweig. Delegation in C++. Journal of Object-Oriented Programming, 4(11):22-35, noviembre de 1991.</p>
<p>[<span id="kir92" >Kir92</span>] David Kirk. Graphics Gems III.H arcourt, Brace, Jovanovich, Boston, MA, 1992.</p>
<p>[<span id="knu73" >Knu73</span>] Donald E. Knuth. The Art of Computer Programming, Volumes 1, 2, and 3. Addison-Wesley, Reading, MA, 1973.</p>
<p>[<span id="knu84" >Knu84</span>] Donald E. Knuth. The TeX book. Addison-Wesley, Reading, MA, 1984.</p>
<p>[<span id="kof93" >Kof93</span>] Thomas Kofler. Robust iterators in ET++. Structured Programming, 14:62-85, marzo de 1993.</p>
<p>[<span id="kp88" >KP88</span>] Glenn E. Krasner y Stephen T. Pope. A cookbook for using the model-view controller user interface paradigm in Smalltalk-80. Journal of Object-Oriented Programming, 1(3):26-49, agosto/septiembre 1988.</p>
<p>[<span id="lal94" >LaL94</span>] Wilf LaLonde. Discovering Smalltalk.Benjamin/Cummings, Redwood City, CA, 1994.</p>
<p>[<span id="lci+92" >LCI+92</span>] Mark Linton, Paul Calder, John Interrante, StevenTang, y John Vlissides.  InterViews Reference Manual.CSL, Stanford University, edicion 3.1, 1992.</p>
<p>[<span id="lea88" >Lea88</span>] Doug Lea. libg++, the GNU C++ library. In Proceedings of the 1988 USENIX C++ Conference, pp. 243-256, Denver, CO, octubre de 1988. USENIX Association.</p>
<p>[<span id="lg86" >LG86</span>] Barbara Liskov y John Guttag. Abstraction and Specification in Program Development. McGraw-Hill, Nueva York, 1986.</p>
<p>[<span id="lie85" >Lie85</span>] Henry Lieberman. There&#39;s more to menu systems than meets the screen. In SIGGRAPH Computer Graphics, pp. 181-189, San Francisco, CA, julio de 1985.</p>
<p>[<span id="lie86" >Lie86</span>] Henry Lieberman. Using prototypical objects to implement shared behavior in object-oriented systems. En Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 214-223, Portland, OR, noviembre de 1986.</p>
<p>[<span id="lin92" >Lin92</span>] Mark A. Linton. Encapsulating a C++ library. En Proceedings of the 1992 USENIX C++ Conference, pp. 57-66, Portland, OR, agosto de 1992. ACM Press.</p>
<p>[<span id="lp93" >LP93</span>] Mark Linton y Chuck Price. Building distributed user interfaces with Fresco. En Proceedings of the 7th XTechnical Conference, pp. 77-87, Boston, MA, enero de 1993.</p>
<p>[<span id="lr93" >LR93</span>] Daniel C. Lynch and Marshall T. Rose.Internet System Handbook. Addison-Wesley, Reading, MA, 1993.</p>
<p>[<span id="lvc89" >LVC89</span>] Mark A. Linton, John M. Vlissides y Paul R. Calder. Composing user interfaces with InterViews. Computer, 22(2):8-22, febrero de 1989.</p>
<p>[<span id="mar91" >Mar91</span>] Bruce Martin. The separation of interface and implementation in C++. En Proceedings of the 1991 USENIXC++ Conference, pp. 51-63, Washington, D.C., abril de 1991. USENIX Association.</p>
<p>[<span id="mcc87" >McC87</span>] Paul McCullough. Transparent forwarding: Firststeps. En Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 331-341, Orlando, FL, octubre de 1987. ACM Press.</p>
<p>[<span id="mey88" >Mey88</span>] Bertrand Meyer. Object-Oriented Software Construction. Series in Computer Science. Prentice Hall,Englewood Cliffs, NJ, 1988.</p>
<p>[<span id="mur93" >Mur93</span>] Robert B. Murray. C++ Strategies andTactics. Addison-Wesley, Reading, MA, 1993.</p>
<p>[<span id="oj90" >OJ90</span>] William F. Opdyke y Ralph E. Johnson. Refactoring: An aid in designing application frameworks y evolving object-oriented systems. En SOOPPA Conference Proceedings, pp. 145-161, Marist College, Poughkeepsie, NY, septiembre de 1990. ACM Press.</p>
<p>[<span id="oj93" >OJ93</span>] William F. Opdyke y Ralph E. Johnson. Creating abstract superclasses by refactoring. En Proceedings of the 21st Annual Computer Science Conference (ACM CSC &#39;93), pp. 66-73, Indianapolis, IN, febrero de 1993.</p>
<p>[<span id="p+88" >P+88</span>] Andrew J. Palay et al. The Andrew Toolkit: An overview. En Proceedings of the 1988 Winter USENIX Technical Conference, pp. 9-21, Dallas, TX, febrero de 1988. USENIX Association.</p>
<p>[<span id="par90" >Par90</span>] ParcPlace Systems, Mountain View, CA.ObjectWorks\Smalltalk Release 4 Users Guide, 1990.</p>
<p>[<span id="pas86" >Pas86</span>] Geoffrey Smalltalk-80. A. En Pascoe. Encapsulators: A new software Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 341-346, Portland, OR, octubre de 1986. ACM Press.</p>
<p>[<span id="pug90" >Pug90</span>] William Pugh. Skiplists: A probabilistic alternative to balanced trees. Communications of the ACM,33(6):668-676, junio de 1990.</p>
<p>[<span id="rbp+91" >RBP+91</span>] James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, y William Lorenson. Object-Oriented Modeling and Design. Prentice Hall, Englewood Cliffs, NJ, 1991.</p>
<p>[<span id="rum94" >Rum94</span>] James Rumbaugh. The life of an object model: Howthe object model changes during development. Journal ofObject-Oriented Programming, 7(1):24-32, marzo/abril de 1994.</p>
<p>[<span id="se84" >SE84</span>] Elliot knowledge. Soloway IEEE y  Kate Transactions Ehrlich. En Empirical studies of Software Engineering, programming 10(5):595-609, septiembre de 1984.</p>
<p>[<span id="sha90" >Sha90</span>] Yen-Ping Shan. MoDE: A UIMS for Smalltalk. En ACM OOPSLA/ECOOP &#39;90 Conference Proceedings, pp. 258-268, Ottawa, Ontario, Canada, octubre de 1990. ACM Press.</p>
<p>[<span id="sny86" >Sny86</span>] Alan Snyder. Encapsulation and inheritance in object-oriented languages. En Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 38-45, Portland, OR, noviembre de 1986. ACM Press.</p>
<p>[<span id="ss86" >SS86</span>] James C. Spohrer y Elliot Soloway. Novice mistakes: Are the folk wisdoms correct? Communications of the ACM, 29(7):624-632, julio de 1986.</p>
<p>[<span id="ss94" >SS94</span>] Douglas C. Schmidt y Tatsuya Suda. The Service Configurator Framework: An extensible architecture for dynamically configuring concurrent, multi-service network daemons. En Proceeding of the Second International Workshop on Configurable Distributed Systems, pp. 190-201, Pittsburgh, PA, marzo de 1994. IEEE Computer Society.</p>
<p>[<span id="str91" >Str91</span>] Bjarne Stroustrup. The C++ Programming Language. Addison-Wesley, Reading, MA, 1991. Segunda edicion.</p>
<p>[<span id="str93" >Str93</span>] Paul S. Strauss. IRIS Inventor, a 3D graphics toolkit. En Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 192-200, Washington, D.C., septiembre de 1993. ACM Press.</p>
<p>[<span id="str94" >Str94</span>] Bjarne Stroustrup. The Design and Evolution of C++. Addison-Wesley, Reading, MA, 1994.</p>
<p>[<span id="sut63" >Sut63</span>] I.E. Sutherland. Sketchpad: A Man-MachineGraphical Communication System. Tesis Doctoral, MIT, 1963.</p>
<p>[<span id="swe85" >Swe85</span>] Richard E. Sweet. The Mesa programming environment. SIGPLAN Notices, 20(7):216-229, julio de 1985.</p>
<p>[<span id="sym93a" >Sym93a</span>] Symantec Corporation, Cupertino, CA. Bedrock Developer&#39;s Architecture Kit, 1993.</p>
<p>[<span id="sym93b" >Sym93b</span>] Symantec Corporation, Cupertino, CA. THINK Class Library Guide, 1993.</p>
<p>[<span id="sza92" >Sza92</span>] Duane Szafron. SPECTalk: An object-oriented data specification language.  En Technology of Object-Oriented Languages and Systems (TOOLS 8), pp. 123-138, Santa Barbara, CA, agosto de 1992. Prentice Hall.</p>
<p>[<span id="us87" >US87</span>] David Ungar y Randall B. Smith. Self: The power of simplicity. En Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 227-242, Orlando, FL, octubre de 1987. ACM Press.</p>
<p>[<span id="vl88" >VL88</span>] John M. Vlissides y Mark A. Linton. Applying object-oriented design to structured graphics. En Proceedings of the 1988 USENIX C++ Conference, pp. 81-94, Denver, CO, octubre de 1988. USENIX Association.</p>
<p>[<span id="vl90" >VL90</span>] John M. Vlissides y Mark A. Linton. Unidraw: A framework for building domain-specific graphical editors. ACM Transactions on Information Systems, 8(3):237-268, julio de 1990.</p>
<p>[<span id="wbj90" >WBJ90</span>] Rebecca Wirfs-Brock y Ralph E. Johnson. A survey of current research in object-oriented design. Communications of the ACM, 33(9):104-124, 1990.</p>
<p>[<span id="wbww90" >WBWW90</span>] Rebecca Wirfs-Brock, Brian Wilkerson, y Lauren Wiener. Designing Object-Oriented Software. Prentice Hall, Englewood Cliffs, NJ, 1990.</p>
<p>[<span id="wgm88" >WGM88</span>] André Weinand, Erich Gamma, y Rudolf Marty. ET++—An object-oriented application framework in C++. En Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, pp. 46–57, San Diego, CA, septiembre de 1988. ACM Press.</p>
</div>
<h2 id="notas" >Notas</h2>
<div class="hBody-2" >
<div class="about" >
<div class="about-dt" ><span class="defnote" id="1" >1</span></div>
<div class="about-dd" >
<p>Literalmente, <q>peso mosca</q>. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="2" >2</span></div>
<div class="about-dd" >
<p>El termino original ingles es <q>mixin</q>. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="3" >3</span></div>
<div class="about-dd" >
<p><em>Templates</em> en el original en ingles. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="4" >4</span></div>
<div class="about-dd" >
<p><em>Acquaintance</em> en el original en ingles. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="5" >5</span></div>
<div class="about-dd" >
<p>Literalmente, <q>juego de herramientas</q>. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="6" >6</span></div>
<div class="about-dd" >
<p>Literamente, <q>marco</q>. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="7" >7</span></div>
<div class="about-dd" >
<p>Literalmente, <q>Lo que ve es lo que obtiene</q>. Hace referencia a los editores de documentos (sean de texto, de HTML, etcetera) donde lo que se ve en pantalla coincide con la que sera la apariencia real del documento final (una vez impreso, mostrado en el navegador, etcetera). (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="8" >8</span></div>
<div class="about-dd" >
<p>El diseño de Lexi esta basado en Doc, una aplicacion de edicion de texto desarrollada por Calder [<a href="#cl92" >CL92</a>]</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="9" >9</span></div>
<div class="about-dd" >
<p>Hemos traducido el termino original, <em>look and feel</em>, como <q>interfaz de usuario</q>. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="10" >10</span></div>
<div class="about-dd" >
<p>Los autores tambien suelen ver el documento en terminos de su estructura logica, es decir, en terminos de oraciones, parrafos, secciones, subsecciones y capitulos. Para no complicar en exceso este ejemplo, nuestra representacion interna no almacenara informacion acerca de la estructura logica explicitamente. No abstante, la solucion de diseño que describimos funciona igualmente bien para representar dicha informacion.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="11" >11</span></div>
<div class="about-dd" >
<p><em>Glyph</em>, en el original en ingles. Palabra derivada del griego que podria traducirse como <q>grabado</q>. En castellano existe la palabra <q>petroglifo</q>, para indicar grabados en piedra (DRAE). Hemos tomado la decision de traducirla como <q>glifo</q>, pese a que esta palabra no exista en español, por similitud con el termino ingles y porque aqui no hace alusion a grabado en piedra. Ademas, es esta la forma en que aparece traducida normalmente la palabra en informatica, arquitectura, etcetera. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="12" >12</span></div>
<div class="about-dd" >
<p>Calder fue el primero en usar el termino <q>glifo</q> (glyph) en este contexto [<a href="#cl90" >CL90</a>]. La mayoria de los editores de documentos actuales no utilizan un objeto para cada caracter, presumiblemente por razones de eficiencia. Calder demostro en su tesis que este enfoque es viable [<a href="#cal93" >Cal93</a>]. Nuestros glifos son menos sofisticados que los suyos, en el sentido de que los hemos restringido a jerarquias estrictas por simplicidad. Los glifos de Calder pueden compartirse para reducir costes de almacenamiento, formando asi estructuras de grafos dirigidos aciclicos. Podria aplicarse el patron <a href="#flyweight" >Flyweight</a> para tograr el mismo efecto, pero dejaremos esto como ejercicio para el lector.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="13" >13</span></div>
<div class="about-dd" >
<p>La interfaz aqui descrita es intencionalmente minima para mantener la discusion simple. Una interfaz completa incluiria operaciones para manejar los atributos graficos tales como el color, la fuente y transformaciones de coordenadas, ademas de operaciones para una gestion de los hijos mas sofisticada.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="14" >14</span></div>
<div class="about-dd" >
<p>Un indice entero no es probablemente la mejor manera de especificar los hijos de un glifo, dependiendo de la estructura de datos que este usa. Si el glifo almacena sus hijos en una lista enlazada, seria mas eficiente un puntero a la lista. Veremos una solucion mejor al problema de indexacion en la <a href="#2.8" >Seccion 2.8</a>, cuando estudiemos el analisis de documentos.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="15" >15</span></div>
<div class="about-dd" >
<p>El usuario tendra mas que decir sobre la estructura logica del documento ––las oraciones, parrafos, secciones, capitulos, etcetera––. En comparacion, la estructura fisica resulta menos interesante. A la mayoria de la gente no le preocupa donde se insertan los saltos de linea en un parrafo siempre y cuando este correctamente formateado. Lo mismo ocurre con el formateado de columnas y paginas. Por tanto, al final los usuarios solo especifican restricciones de alto nivel de la estructura fisica, dejando que sea Lexi quien haga el trabajo duro de satisfacerlas</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="16" >16</span></div>
<div class="about-dd" >
<p>El componedor debe obtener los codigos de los caracteres de los glifos <code>Caracter</code> para poder calcular los saltos de linea. En la <a href="#2.8" >Seccion 2.8</a> veremos como obtener esta informacion polimorficamente sin añadir una operacion especifica de caracteres en la interfaz de <code>Glifo</code>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="17" >17</span></div>
<div class="about-dd" >
<p><em>Transparent enclosure</em> en el original en ingles. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="18" >18</span></div>
<div class="about-dd" >
<p><em>Scroller</em> en el original en ingles. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="19" >19</span></div>
<div class="about-dd" >
<p>En ingles, <em>widgets</em>. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="20" >20</span></div>
<div class="about-dd" >
<p>Es decir, volver a realizar una operacion a la que se dio marcha atras (se anularon sus efectos).</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="21" >21</span></div>
<div class="about-dd" >
<p>Conceptualmente, el cliente es el usuario de Lexi, pero en realidad es otro objeto (como un despachador de eventos) que gestiona las entradas del usuario.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="22" >22</span></div>
<div class="about-dd" >
<p><em>Command</em> en el original en ingles. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="23" >23</span></div>
<div class="about-dd" >
<p>El termino original en ingles es <em>undoability</em>. Tanto este como el verbo correspondiente, <em>undo</em> hacen alusion, en este contexto, a la accion de dar marcha atras a las operaciones, esto es a la posibilidad de revertir los efectos de una operacion anterior. Si bien <q>deshacer</q> es una traduccion demasiado literal (el DRAE no sanciona esta acepcion) se ha optado por ella al estar comunmente aceptada en la mayoria de las aplicaciones existentes. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="24" >24</span></div>
<div class="about-dd" >
<p>El original en ingles es <em>hyphenation</em>. Segun el Webster, es la accion y efecto de conectar (dos palabras) o dividir (una palabra al final de la linea) con un guion. En este contexto significa lo segundo. En Español se suele usar el termino <q>guionado</q>, que no aparece en el DRAE. nosotros lo hemos traducido generalmente como <q>insercion de guiones</q>. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="25" >25</span></div>
<div class="about-dd" >
<p>Podriamos usar sobrecarga de funciones para dar a cada una de estas funciones miembro el mismo nombre, puesto que ya estan diferenciadas por sus parametros. Les hemos dado distintos nombres para resaltar sus diferencias, sobre todo cuando son llamadas.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="26" >26</span></div>
<div class="about-dd" >
<p><code>EstaMalEscrita</code> implementa el algoritmo de revision ortografica, que no detallaremos aqui ya que lo hemos hecho independiente del diseño de Lexi. Podemos permitir algoritmos diferentes heredando de <code>RevisiorOrtografico</code>; otra alternativa es aplicar el patron <a href="#strategy" >Strategy</a> (igual que hicimos para el formateado en la <a href="#2.3" >Seccion 2.3</a> para permitir diferentes algoritmos de revision ortografica.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="27" >27</span></div>
<div class="about-dd" >
<p><q>Visitar</q> es un termino ligeramente mas general que <q>analizar</q>. Anticipa la terminologia que usamos en el patron de diseño al que estamos llegando.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="28" >28</span></div>
<div class="about-dd" >
<p>Widgets, en el original en ingles (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="29" >29</span></div>
<div class="about-dd" >
<p>Hemos traducido el termino original en ingles, <em>widget</em>, referido a los distintos elementos de la interfaz de usuario, como <q>util</q>. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="30" >30</span></div>
<div class="about-dd" >
<p><em>Lazy inicialization</em> en el original en ingles. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="31" >31</span></div>
<div class="about-dd" >
<p>Hemos traducido el termino original ingles, <em>widget</em>, como <q>util</q>. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="32" >32</span></div>
<div class="about-dd" >
<p><code>CrearManipulador</code> es un ejemplo de <a href="#factory-method" >Factory Method</a>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="33" >33</span></div>
<div class="about-dd" >
<p><q><code>Imp</code></q> viene de <q>implementacion</q>. A pesar de que, siguiendo la convencion de nominacion que hemos venido empleando a lo largo del libro, tal vez habria sido mas correcto <q><code>ImpVentana</code></q> como nombre de la clase, hemos preferido mantener <q><code>Imp</code></q> como sufijo, al igual que en el original en ingles, por ser este practicamente un convenio de programacion. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="34" >34</span></div>
<div class="about-dd" >
<p>Es facil olvidarse de borrar el iterador una vez que se ha usado. El patron <a href="#iterator" >Iterator</a> en su Seccion <a href="#Iterator-Codigo-de-Ejemplo" >Codigo de Ejemplo</a> muestra como protegerse contra tales errores.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="35" >35</span></div>
<div class="about-dd" >
<p><em>Pool</em>, en el original en ingles. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="36" >36</span></div>
<div class="about-dd" >
<p>El tiempo de busqueda con este esquema es proporcional a la frecuencia de cambios de fuente. El caso peor en cuanto a rendimiento tiene lugar cuando se produce un cambio de fuente para cada caracter, pero eso es poco frecuente en la practica.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="37" >37</span></div>
<div class="about-dd" >
<p>En el Codigo de Ejemplo mostrado anteriormente, la informacion de estilo se hizo extrinseca, dejando al codigo de caracter como el unico estado intrinseco.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="38" >38</span></div>
<div class="about-dd" >
<p>Vease el patron <a href="#abstract-factory" >Abstract Factory</a> para otra aproximacion a la independencia de la interfaz de usuario.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="39" >39</span></div>
<div class="about-dd" >
<p>La implementacion de objetos distribuidos en NEXSTEP [<a href="#add94" >Add94</a>] (en concreto, la clase NXProxy) usa esta tecnica. La implementacion redefine <code>forward</code>, el enganche equivalente en NEXTSTEP.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="40" >40</span></div>
<div class="about-dd" >
<p>El patron <a href="#iterator" >Iterator</a> describe otro tipo de proxy.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="41" >41</span></div>
<div class="about-dd" >
<p>Casi todas las clases tienen, en ultima instancia, a Object como superclase. Por tanto, esto es lo mismo que decir <q>definir una clase que no tenga Object como su superclase</q>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="42" >42</span></div>
<div class="about-dd" >
<p>Para simplificar, omitiremos la precedencia de operadores y asumiremos que es responsabilidad de cualquier otro objeto construir el arbol sintactico.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="43" >43</span></div>
<div class="about-dd" >
<p>Booch se refiere a los iteradores externos como iteradores <b>activos</b> y <b>pasivos</b>, respectivamente [<a href="#boo94" >Boo94</a>]. Los terminos <q>activo</q> y <q>pasivo</q> describen el rol del cliente, no el nivel de actividad del iterador.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="44" >44</span></div>
<div class="about-dd" >
<p>Los cursores son un ejemplo sencillo del patron <a href="#memento" >Memento</a>, y comparten con el muchos de sus detalles de implementacion.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="45" >45</span></div>
<div class="about-dd" >
<p>Podemos hacer esta interfaz todavia <em>mas pequeña</em> juntando <code>Siguiente</code>, <code>HaTerminado</code> y <code>ElementoActual</code> en una unica operacion que avance al siguiente objeto y lo devuelva. Si se llega al final del recorrido esta operacion devulve un valor especial (0, por ejemplo) que marca el final de la ineracion.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="46" >46</span></div>
<div class="about-dd" >
<p>Esto puede garantizarse en tiempo de compilacion simplemente declarando privados los operadores <code>new</code> y <code>delete</code>. No se necesita ninguna implementacion adicional.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="47" >47</span></div>
<div class="about-dd" >
<p>La operacion <code>Recorrer</code> de los ejemplos anteriores es un <a href="#factory-method" >Factory Method</a> con <code>ComprobarElemento</code> y <code>ProcesarElemento</code> como operaciones primitivas.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="48" >48</span></div>
<div class="about-dd" >
<p><em>Hub</em>, en el original en ingles. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="49" >49</span></div>
<div class="about-dd" >
<p>En este contexto, <q>recuerdo</q>. (N. del T.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="50" >50</span></div>
<div class="about-dd" >
<p>Notese que nuestro ejemplo borra el objeto estado al final de la iteracion. Pero no se llamara a <code>delete</code> en caso de que <code>ProcesarElemento</code> lance una excepcion, lo que produciria basura. Esto es un problema en C++, poro no en Dylan, que tiene recoleccion de basura. Discutimos una solucion a este problema en la seccion <a href="#Iterator-Codigo-de-Ejemplo" >Codigo De Ejemplo</a> del patron Iterator.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="51" >51</span></div>
<div class="about-dd" >
<p>Este ejemplo esta basado en el protocolo de conexion TCP descrito por Lynch y Rose [<a href="#lr93" >LR93</a>].</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="52" >52</span></div>
<div class="about-dd" >
<p>Esto hace de cada subclase de <code>EstadoTCP</code> un Singleton (vease el patron <a href="#singleton" >Singleton</a>).</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="53" >53</span></div>
<div class="about-dd" >
<p>Podriamos usar la sobrecarga de funciones para dar a estas operaciones el mismo nombre, como por ejemplo <code>Visitar</code>, ya que las operaciones se diferencian por el parametro que se les pasa. Esta sobrecarga tiene sus pros y sus contras. Por un lado, refuerza el hecho de que cada operacion implica el mismo analisis, solo que sobre un argumento distinto. Por otro lado, podria hacer menos obvio que esta ocurriendo en el sitio de la llamada para alguien que este leyendo el codigo. Realmente se reduce a si creemos que la sobrecarga de funciones es buena o no.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="54" >54</span></div>
<div class="about-dd" >
<p>Si podemos tener <em>doble</em>-despacho, ¿por que no tener <em>trible</em>, <em>cuadruple</em> o cualquier otro numero? En realidad, el doble despacho no es mas que un caso especial de despacho multiple, en el cual la operacion se elige en funcion de un numero cualquiera de tipos (CLOS permite el despacho multiple). Los lenguajes que permiten el despacho doble o multiple ven reducida la necesidad del patron Visitor.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="55" >55</span></div>
<div class="about-dd" >
<p>Este tema tambien afceta a otros tipos de patrones. Tanto el patron <a href="#abstract-factory" >Abstract Factory</a> como el <a href="#builder" >Builder</a> y el <a href="#protype" >Protype</a>, encapsulan el conocimiento sobre como se crean los objetos. El patron <a href="#decorator" >Decorator</a> encapsula la reponsabilidad que puede añadirse a un objeto. El patron <a href="#bridge" >Bridge</a> separa una abstraccion de su implementacion, permitiendolas varias de forma independiente.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="56" >56</span></div>
<div class="about-dd" >
<p>Vease <q>La poesia del lenguaje</q> [<a href="#ais+77" >AIS+77</a>].</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="57" >57</span></div>
<div class="about-dd" >
<p>OMT usa el termino <q>diagrama de objetos</q> para referirse a los diagramas de clases. Nosotros usamos <q>diagrama de objetos</q> para referirnos exclusivamene a diagramas de estructuras de objetos.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="58" >58</span></div>
<div class="about-dd" >
<p>OMT tambien define asociaciones entre clases, que  pueden aparecer como lineas rectas entre rectangulos de clases. Las asociaciones son bidireccionales. Aunque las asociaciones son adecuadas durante el analisis, creemos que son de demasiado alto nivel para expresar las relaciones de los patrones de diseño, debido simplemente a que las asociaciones deben convertirse en referencias a objetos o en punteros durante el diseño. Las referencias a objetos son intrinsecamente dirigidas y se adecuan por tanto mejor a las relaciones que nos ocupan. Por ejemplo, el Dibujo conoce a las Formas, pero estas no saben nada del Dibujo en el que se encuentran. Esta relacion no puede expresarse solo con asociaciones.</p>
</div>
</div>
</div>
</body>
</html>
