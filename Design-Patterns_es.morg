..title       > Patrones de Diseño
..subtitle    > Elementos de software orientado a objetos reutilizable
..author      > Erich Gamma
..author      > Richard Helm
..author      > Ralph Johnson
..author      > John Vlissides
..translator  > Cesar Fernandez Acebal
..lang        > es
..style       > worg-data/worg.css
..options     > fancyCode toc

@ @[^[<({]+[[<({][^]>})]+[]>})]

@ Traducido de:
@   Desing Patterns: Elements of Reusable Object-Oriented Software, First Edition.
@
@ Revision tecnica: Juan Manuel Cueva Lovelle
@
@ ISBN: 0-201-63361-2
@ Equipo editorial
@   Editor: David Fayerman Aragon
@   Tecnico editorial: Ana Isabel Garcia
@ Equipo de produccion
@ Director: Jose A. Clares
@ Tecnico: Tini Cardoso

..center >
  A Karin (E.G.)

  A Sylvie (R.H.)

  A Faith (R.J.)

  A Drug Ann y Matthew (Josue 24,15b) (J.V.)
< center..

* Elogios a Patrones de Diseño

  ..quote >
    @"(Este es uno de los libros mejor escritos y mas maravillosamente
    perspicaces que he leido en mucho tiempo... Este libro establece la
    legitimidad de los patrones del mejor modo: no mediante razonamientos sino
    mediante ejemplos.)

    --Stan Lippman, C++ Report
  < quote..

  ..quote >
    @"(...este nuevo libro de Gamma, Helm, Johnson y Vlissides promete tener un
    impacto importante y definitivo en la disciplina del diseño de
    software. Debido a que @e(Patrones de Diseño) se enuncia a si mismo como
    relacionado solo con software orientado a objetos, temo que los
    desarrolladores de software no pertenecientes a la comunidad de objetos
    puedan pasarlo por alto. Seria una pena. Este libro tiene algo para todos
    aquellos que diseñan software. Todos los diseñadores de software usan
    patrones; entender mejor las abastracciones reutilizables de nuestro trabajo
    solo puede hacernos mejores en el.)

    --Tom DeMarco, IEEE Software
  < quote..

  ..quote >
    @"(Creo que este libro representa una contribucion extremadamente valiosa y
    unica en este campo porque capta una riqueza de experiencia de diseño
    orientado a objetos en una forma compacta y reutilzable. Este Libro es
    seguramente uno al que acudire a menudo en busqueda de poderosas ideas de
    diseño orientado a objetos; despues de todo, de eso es de lo que trata la
    reutilizacion, ¿no es cierto?)

    --Sanjiv Gossain, Journal of Object-Oriented Programming
  < quote..

  ..quote >
    @"(Este libro largamente esperado esta a la altura de todo el año en que ha
    estado en boga anticipadamente. La metafora es la de un libro de patrones de
    un arquitecto lleno de diseños probados y utilizables. Los autores han
    elegido 23 patrones procedentes de decadas de experiencia en orientacion a
    objetos. La brillantez de este libro reside en la disciplina representada
    por ese numero. Dele una copia de @e(Patrones de Diseño) a todo buen
    programador que conozca que quiera ser mejor.)

    --Larry O'Brien, Software Development
  < quote..

  ..quote >
    @"(El Hecho es que los patrones tienen el potencial de cambiar para siempre el
    campo de la ingenieria de software, catapultandola al reino de un diseño
    realmente elegante. De los libros sobre este tema hasta la fecha, @e(Patrones
    de Diseño) es como mucho el mejor. Es un libro par ser leido, estudiado
    interiorizado y querido. Cambiara para siempre el modo en que ve el
    software.)

    --Steve Billow, Journal of Object Oriented Programming
  < quote..

  ..quote >
    @"(@e(Patrones de Diseño) es un libro poderoso. Despues de invertir un poco
    de tiempo en el, la mayoria de los programadores de C++ seran capaces de
    comenzar a aplicar sus @"(patrones) para producir mejor software. Este libro
    suministra un capital intelectual: herramientas concretas que nos ayudan a
    pensar y expresarnos de forma mas efectiva. Puede cambiar drasticamente
    nuestra forma de pensar en la programacion.)

    --Tom Cargill, C++ Report
  < quote..

* Prefacio

  Este libro no es una introduccion a la tecnologia o el diseño orientado a
  objetos. Ya hay muchos libros que sirven bien a ese proposito. Este libro
  presupone que el lector domina razonablemnete al menos un lenguaje de
  programacion orientado a objetos, y seria igualmente deseable que tuviese algo
  de experiencia en el diseño orientado a objetos. En definitiva, que no se
  abalanzara sobre el diccionario mas cercano cuando hablemos de @"(tipos) y
  @"(polimorfirmo), o de la herencia de @"(interfaces) frente a la de
  @"(implementacion).

  Por otro lado, tampoco es este un avanzado tratado tecnico. Es un libro de
  @b(Patrones de diseño) que describe soluciones simples y elegantes a problemas
  especificos de diseño de software orientado a objetos. Los patrones de diseño
  representan soluciones que han sido desarrolladas y han ido evolucionando a lo
  largo del tiempo. Por tanto, no se trata de los diseños que la gente tiende a
  generar inicialmente, sino que reflejan todo el rediseño y la recodificacion
  que los desarrolladores han ido haciendo a medida que luchaban por conseguir
  mayor reutilizacion y felxibilidad en su software. Los patrones de diseño
  expresan estas soluciones de una manera sucinta y facilmente aplicable.

  Los patrones de diseño no requieren caracteristicas sofisticadas del lenguaje
  ni sorprendentes turcos de programacion con los que dejar atonitos a jefes y
  amigos. Todo se puede implementar en lenguajes orientados a objetos estandar,
  Si bien puede costar algo mas de trabajo que las soluciones @e(ad hoc). Pero
  este esfuerzo extra siempre se ve recompensado por un aumento de la
  flexibilidad y la reutilizacion.

  Una vez que haya entendido los patrones de diseño y experimentado con ellos,
  nunca mas pensara en el diseño orientado a objetos de la misma manera que
  antes. Tendra una perspectiva que puede hacer que sus propios diseños sean mas
  felxibles, modulares, reutilizables y comprensibles, lo cual, al fin y al
  cabo, es la principal razon por la que esta interesado en la tecnologia
  orientada a objetos, ¿verdad?

  Una advertencia y unas palabras de animo: no se preocupe si no entiende del
  todo este libro en la primer lectura. ¡Tampoco nosotros lo entendimos todo la
  primera vez que lo escribimos! Recuerde que no es un libro para leer una vez y
  ponerlo despues en una estanteria. Esperamos que acuda a el una y otra vez en
  busca de pistas de diseño y de ispiracion. Este libro ha tenido un largo
  periodo de gestacion. Ha visto cuatro paises, los matrimonios de tres de sus
  autores y el nacimiento de dos hijos. Mucha gente ha participado en su
  desarrollo. Estamos especialmente agradecidos a Bruce Anderson, Kent Beck, y
  André Weinand por su inspiracion y consejos. Tambien a aquellos que revisaron
  los borradores del original: Roguer Bielefeld, Grady Booch, Tom Cargill,
  Marshall Cline, Ralph Hyre, Brian Kernighan, Thomas Laliberty, Mark Lorenz,
  Arthur Riel, Doug Schmidt, Clovis Tondo, Steve Vinoski y Rebecca
  Wirfs-Brock. Tambien queremos agradecer al equipo de Addison-Wesley su ayuda y
  paciencia: Kate Habib, Tiffany Moore. Lisa Raffaele, Padeepa Siva y Jhon
  Wait. Muchas gracias a Carl Kessler, Donny Sabbah, y Mark Wegman, de IBM
  Research, por su apoyo constante a este trabajo.

  Por ultimo, pero no menos importante, nos dieron palabras de aliento y nos
  dijeron que lo que estabamos haciendo valia la pena. Estas personas son, entre
  otros, Jon Avotins, Steve Berozuk, Julian Berdych, Matthias Bohlen, John
  Brant, Allan Clarke, Paul Chisholm, Jens Coldewey, Dave Collinns, Jim Coplien,
  Don Dwiggins, Gabriele Elia, Doug Felt, Brian Foote, Denis Fortin, Ward
  Harold, Hermann Hueni, Nayeem Islam, Bikramjit Kalra, Paul Keefer, Thomas
  Kofler, Doug Lea, Dan LaLiberte, James Long, Ann Louise Luu, Pundi Madhavan,
  Brian Marick, Robert Martin, Dave McComb, Carl McConnell, Christine Mingins,
  Hanspeter Mössenböck, Eric Newton, Marianne Ozkan, Roxsan Payette, Larry
  Podmolik, George Radin, Sita Ramakrishnan, Russ Ramirez, Alexander Ran, Dirk
  Riehle, Brian Rosenburg, Aamod Sane, Duri Schmidt, Rober Seidl, Xin Shu y Bill
  Walker.

  No consideramos a esta coleccion de patrones de diseño como algo completo y
  estatitco; se trata mas bien de una recopilacion de nuestras ideas actuales
  sobre diseño. Los comentarios al respecto seran bienvenidos, ya sean criticas
  de nuestros ejemplos, referencias y usos conocidos que hayamos pasado por alto
  u otros patrones que deberiamos haber incluido. Puede escribirnos a
  Addison-Wesley, o enviar un correo electonico a @l(mailto:design-patterns-source@@cs.uiuc.edu).
  Tambien puede obtener una copia del codigo de las secciones de ejemplo
  enviandonos el mensaje @"(send design pattern source) a
  @l(mailto:design-patterns-source@@cs.uiuc.edu). Y existe una pagina Web en
  @l(http://st-www.cs.uiuc.edu/users/patterns/DPBook/DPBook.html) donde podra
  encontrar informacion de ultima hora y actualizaciones.

  ..tab >
    Mountain View, California E.G.

    Montreal, Quebec R.H.

    Urbana, Illinois R.J.

    Hawthorne, Nuew York J.V.

    ..right >
      Agosto de 1994
  < tab..

* Prologo

  Todas las arquitecturas orientadas a objetos que estan bien estructuradas
  estan repletas de patrones. De hecho, uno de los metodos que utilizo para
  medir la calidad de un sistema orientado a objetos es examinar si los
  desarrolladores le han prestado la debida atencion a las colaboraciones entre
  sus objetos. Centrarse en tales mecanismos durante el desarrollo de un sistema
  puede dar lugar a una arquitectura mas pequeña, simple y mucho mas
  comprensible que si se hubieran obviado los patrones.

  La importancia de los patrones en la construccion de sistema complejos ha sido
  reconocida desde hace tiempo en otras disciplinas. En concreto, Christopher
  Alexander y sus colegas fueron quiza los primeros en proponer la idea de
  emplear un lenguaje de patrones para diseñar la arcquitectura de edificios y
  ciudades. Sus ideas y las contribuciones de otros estan ahora arraigadas en la
  comunidad del software orientado a objetos. Resumiento, el concepto de patron
  de diseño en el software proporciona una clave para ayudar a los
  desarrolladores a aprovechar la experiencia de otros arquitectos expertos.

  En este libro, Erich Gmama, Richard Helm, Ralph Johnson y John Vlissides
  introducen los principios de los patrones de diseño y ofrecen un catalogo de
  dichos patrones. Asi, este libro realiza dos importantes contribuciones. En
  primer lugar, muestra el papel que los patrones pueden desempeñar diseñando la
  arquitectura de sistemas complejos. En segundo lugar, proporciona una
  referencia practica de un cojunto de excelentes patrones que el desarrollador
  puede aplicar para construir sus propias aplicaciones.

  Es un honor para mi haber tenido la oportunidad de trabajar directamente con
  algunos de los autores de este libro en tareas de diseño arquitectonico. He
  aprendido mucho de ellos y sospecho que, leyendo este libro, usted tambien lo
  hara.

  ..right >
    Grady Booch

    Cientifico Jefe, Rational Software Corporation
  < right...

* Prologo a la edicion española

  A veces @-(en informatica al menos) se da el caso de libros que, por la
  especial contribucion que realizan en un campo determinado, se convierten en
  clasicos apenas han sido publicados. Este libro constituye uno de esos casos
  excepcionales. En efecto, a pesar de los pocos años transcurridos desde la
  publicacion del original en ingles, @e(Design Patterns, Elements of Reusable
  Object-Oriented Software), tambien conocido como GoF (de @e(gang of four), o
  @"(banda de los cuatro), en alusion a sus autores), ha revolucionado el campo
  de la arquitectura del software, llevando la tecnologia de la orientacion a
  objetos a un estadio mas avanzado de su evolucion. Hoy dia, pocos son los
  arquitectos desoftware que no han oido hablar de patrones de diseño, y su uso
  generalmente diferencia a un buen diseño de otro que, en el mejor de los
  casos, resuelve un problema concreto pero que se adapta muy mal @-(o no lo
  hace en absoluto) a nuevos requisitos o cambios en los ya existentes.

  No obstante, tambien es cierto que los patrones de diseño aun no son todo lo
  conocidos que debieran, especialmente por parte de los alumnos universitarios
  y de los recien titulados. A la rigidez de las planes de estudio, es muy
  posible que se una la ausencia casi total de pubilcaciones en español acerca
  de este tema. En este sentido, creemos que esta traduccion al castellano puede
  contribuir a catapultar definitivamente este libro al lugar que merece dentro
  de la comunidad hispana de la ingenieria del software. Ademas de servir de
  ayuda a los profesionales que no hayan leido el original en ingles, sin duda
  pasara a ser un libro de texto recomendado de la asignatura de ingenieria del
  software de muchas universidades, enriqueciendo asi el curriculum de futuras
  promociones de ingenieros en informatica.

  Por otro lado, nunca resulta sencillo traducir un libro tecnico en
  informatica. Numerosos barbarismos se han instalado ya en el idioma, de tal
  forma que resulta dificil a veces optar entre lo que seria el termino correcto
  en español o el equivalente comunmente aceptado por la comunidad de la
  ingenieria del software. Uno de los ejemplos mas evidentes lo constituye la
  palabra @"(instancia), para designar cada uno de los objetos creados de una
  clase dada, y que en español tal vez debiera haberse traducido como
  @"(ejemplar). No obstante, pocas palabras hay mas conocidas que esta en la
  jerga de la orientacion a objetos, por lo que pretender cambiarla a estas
  alturas habria sido un acto de vanidad por nuestra parte que solo habria
  contribuido a incrementar la confusion y dificultar la comprension del
  libro. En otras ocaciones, nos encontramos con palabras como @e(framework) o
  @e(toolkit) que hemos dejado sin traducir por el mismo motivo: el lector esta
  acostumbrado a ellas, por lo  que de haberlas traducido probablemente no
  supiese a que se esta haciendo referencia, desvirtuando asi el sentido del
  original.

  Alla donde ha habido dudas, hemos optado por incluir ambos terminos, dando
  preferencia al español e incluyendo el original a continuacion, entre
  parentesis, o bien mediente una nota al pie. Esta ha sido la decision adoptada
  para el nombre de los patrones. El nombre es parte fundamental de un patron,
  ya que, una vez comprendido este, pasa a formar parte, como los propios
  autores indican, de nuestro vocabulario de diseño. Por tanto, los nombres de
  los patrones de diseño han de ser considerados, en este sentido como las
  palabras reservadas de un lenguaje de programacion: no admiten traduccion, so
  pena de engañar al lector. Sin embargo, dado que el nombre designa con una o
  dos palabras el proposito del patron, parecia oportuno que el lector
  desconocedor de la lengua inglesa pudiese conocer su significado. Por ese
  motivo, hemos optado por ofrecer una traduccion, entre parentesis, al comienzo
  de la descripcion de cada patron, aunque posteriormente, en el texto, nos
  refiramos siempre a ellos con su nombre original en ingles.

  Sera dificil que las decisiones adoptadas sean siempre del gusto de todos,
  como inevitable sera, a pesar de todos los esfuerzos, que se haya escapado
  algun error en la version final del libro. En cuarquier caso, sepa el lector
  que se han puesto los mayores esfuerzos en aunar el rigor tecnico con el
  cuidado del idioma, y apelamos a su indulgencia por los errores cometidos, de
  modo consciente o inconsciente.

  No quisieramos terminar este prologo sin dar las gracias a Raul Izquierdo
  Castanedo, Aquilino Adolfo Juan Fuente, Francisco Ortin Soler, Jose Emilio
  Labra gayo y el resto de miembros del @e(Laboratorio de Tecnologias Orientadas
  a Objetos de la universidad de Oviedo) (@l(http://www.ootlab.uniovi.es), por
  el trabajo del grupo de investigacion sobre patrones de diseño y por sus
  valiosos comentarios y aportaciones.

  Por ultimo, esperamos que con esta traduccion al español sean muchos mas los
  que se acerquen a las patrones de diseño, algo que sin duda contribuira a
  seguir mejorando y dignificando asi nuestra profesion, al hacernos mejores
  arquitectos de software. Igualmente, confiamos en que sirva, como ya hemos
  dicho, para ayudar a la formacion de futuras promociones de ingenieros en
  informatica. Haber contribuido a ello, con el minusculo esfuerzo de una
  traduccion, en comparacion con la labor original de Eric Gammna, Rechard Helm,
  Ralph Johnson y John Vlissides, seria algo que nos llenaria de satisfaccion y
  orgullo.

  ..right >
    Cesar Fernandez Acebal

    Juan Manuel Cueva Lovelle

    Oviedo, 20 de junio de 2002
  < right...

* Guia para los lectores

  Este libro tiene dos partes principales. La primera parte (Capitulos 1 y 2)
  describe que son los patrones de diseño y como pueden ayudarle a diseñar
  software orientado a objetos. Incluye un caso de estudio que demuestra como se
  aplican en la practica. La segunda parte del libro (Capitulos 3, 4 y 5) es un
  catalogo de los patrones de diseño propiamente dichos.

  El catalogo constituye la mayor parte del libro. Sus capitulos dividen los
  patrones de diseño en tres tipos: de creacion, estructurales y de
  comportamiento. El catalogo se puede usar de varias formas: puede leerse de
  principio a fin o se puede simplemente ir de un patron a otro. Otra
  posibilidad es estudiar uno de los capitulos. Esto le ayudara a ver como se
  distinguen entre si patrones estrechamente relacionados.

  Puede usar las referencias entre los patrones como una ruta logica a traves del
  catalogo. Este enfoque le hara comprender como se relacionan los patrones
  entre si, como se pueden combinar con otros y que patrones funcionan bien
  juntos. La @l(#Figura 1.1) muestra estas referencias graficamente.

  Otra forma mas de leer el catalogo es usar un enfoque mas orientado al
  problema. Vaya directamente a la @l(#1.6<>Seccion 1.6) para leer algunos
  problemas comunes a la hora de diseñar software orientado a objetos
  reutilizable; despues, lea los patrones que resuelven estos problemas. Algunas
  personas leen primero el catalogo completo y @e(luego) usan un enfoque
  orientado al problema para aplicar los patrones en sus proyectos.

  Si no es un diseñador orientado a objetos experimentado, le recomendamos que
  empiece con los patrones sencillos y mas comunes:

  ..cols >
    - @l(#Abstract Factory)
    - @l(#Adapter)
    - @l(#Composite)
    - @l(#Decorator)
  <>
    - @l(#Factory Method)
    - @l(#Observer)
    - @l(#Strategy)
    - @l(#Template Method)
  < cols..

  Es dificil encontrar un sistema orientado a objetos que no use al menos un par
  de estos patrones,  los grandes sistemas los usan casi todos. Este subconjunto
  le ayudara a entender los patrones de diseño en particular y el buen diseño
  orientado a objetos en general.

* Capitulo 1 <> Introduccion

  Diseñår software orientado a objetos es dificil, y aun lo es mas diseñar
  software orientado a objetos reutilizable. Hay que encontrar los objetos
  pertinentes, factorizarlos en clases con la granularidad adecuada, definir
  interfaces de clases y jerarquias de herencia y establecer las principales
  relaciones entre esas clases y objetos. Nuestro diseño debe ser especifico del
  problema que estamos manejando, pero tambien lo suficientemente general para
  adecuarse a futuros requisitios y problemas. Tambien queremos evitar el
  rediseño, o al menos minimizarlo. Los diseñadores experiemntados de software
  orientado a objetos nos diran que es dificil, sino imposible, lograr un diseño
  flexible y reutilizable a la primera y que, antes de terminar un diseño, es
  frecuente intentar reutilizarlo varias veces, modificandolo cada una de ellas.

  Sin embargo, estos diseñådores experimentados realmente consiguen hacer buenos
  diseño, mientras que los diseñadores novatos se ven abrumados por las opciones
  disponibles y tienden a recurrir a las tecnicas no orientadas a objectos que
  ya usaron antes. A un principante le lleva bastante tiempo aprender en que
  consiste un buen diseño orientado a objetos. Es evidente que los diseñadores
  experimentados saben algo que los principiantes no. ¿Que es?

  Algo que los expertos saben que @e(no) hay que hacer es resolver cada problema
  partiendo de cero. Por el contrario, reutilizan soluciones que ya les han sido
  utiles en el pasado. Cuando ecuentran una solucion buena, la usan una y otra
  vez. Esta experiencia es parte de lo que les convierte en expertos. Por tanto,
  nos encontraremos con patrones recuerrentes de clases y comunicaciones entre
  objetos en muchos sistemas orientados a objetos. Estos patrones resuelven
  problemas concretos de diseño y hacen que los diseños orientados a objetos
  sean mas flexibles, elegantes y reutilizables. Los patrones ayudan a los
  diseñadores a reutilizar buenos diseños al basar los nuevos diseños en la
  experiencia previa. Un diseñador familiarizado con dichos patrones puede
  aplicarlos inmediatamente en los problemas de diseño sin tener que
  redescubrirlos.

  Ilustremes este punto con una analogia. Los novelistas y escritores rara vez
  diseñan las tramas de sus obras desde cero, si no que siguen patrones como el
  del @e(heroe tragico) (Macbeth, Hamlet, etc.) o @e(la novela romantica)
  (innumerables novelas de amor). Del mismo modo, los diseñadores orientados a
  objetos siguen patrones como @"(representar estados con objetos) o @"(decorar
  objetos de manera que se puedan añadir y borrar funcionalidades facilmente).
  Una vez que conocemos el patron, hay muchas decisiones de diseño que se
  derivan de manera natural.

  Todos sabemos el valor de la experiencia en el diseño. ¿Cuantas veces hemos
  tenido un @e(déjà-vu) de diseño @-(esa sensacion de que ya hemos resuelto ese
  problema antes, pero no sabemos exactamente donde ni como)? si pudieramos
  recordar los detalles del problema anterior y de como lo resolvimos podriamos
  valernos de esa experiencia sin tener que reinvertar la solucion. Sin embargo,
  no solemos dedicarnos a dejar constancia de nuestra experiencia en el diseño
  de software para que la usen otros.

  El proposito de este libro es documentar la experiencia en el diseño de
  software orientado a objetos en forma de @b(patrones de diseño). Cada patron
  nomina, explica y evalua un diseño importante y recurrente en los sistemas
  orientados a objetos. Nuestro objetivo es representar esa experincia de diseño
  de forma que pueda ser reutilizada de manera efectiva por otras personas. Para
  lograrlo, hemos documentado algunos de los patrones de diseño mas importantes
  y los presentamos como un catalogo.

  Los patrones de diseño hacen que sea mas facil reutilizar buenos diseños y
  arquitecturas. Al expresar como patrones de diseño tecnicas que ya han sido
  probadas, las estamos haciendo mas accesibles para los desarrolladores de
  nuevos sistemas. Los patrones de diseño nos ayudan a elegir las alternativas
  de diseño que hacen que un sistema sea reutilizable, y a evitar aquellas que
  dificultan dicha reutilizacion. Pueden incluso mejorar la documentacion y el
  mantenimiento de los sistemas existentes al proporcionar una expecificacion
  explicita de las iteracciones entre clases y objetos y de cual es su
  intencion. En definitiva, los patrones de diseño ayudan a un diseñador a
  lograr un buen diseño mas rapidamente.

  Ninguno de los patrones de diseño de este libro describe diseños nuevos o que
  no hayan sido probados. Se han incluido solo aquellos que se han aplicado mas
  de una vez en diferentes sistemas. La mayoria de ellos estaba sin documentar,
  y existian bien como parte del repertorio de la comunidad de la orientacion a
  objetos, bien como elementos de algunos buenos sistemas orientados a objetos
  @-(y de ninguna de ambas formas resultaban faciles de aprender por los
  diseñadores novatos). Asi que, aunque estos diseños no son nuevos, los hemos
  expresado de una forma nueva y accesible: como un catalogo de patrones de
  diseño que tienen un formato consistente.

  A pesar del tamaño del libro, los patrones de diseño que hay en el representan
  solo una parte de lo puede saber un experto. No contiene patrones que tengan
  que ver con concurrencia o programacion distribuida o en tiempo real. Tampoco
  hay patrones de dominios especificos. No se cuenta como construir interfaces
  de usuario, como escribir controladores de dispositivos o como usar una base
  de datos orientada a objetos. Cada una de estas areas tiene sus propios
  patrones, y seria bueno que alguien los catalogase tambien.

** 1.1 <> ¿Que es un patron de diseño?

  Sugun Christopher Alexander, @"(cada patron describe un problema que ocurre
  una y otra vez en nuestro entorno, asi como la solucion a ese problema, de
  tal modo que se pueda aplicar esta solucion un millon de veces, sin hacer lo
  mismo dos veces) [@l(#AIS+77)]. Aunque Alexander se referia a patrones en ciudades
  y edificios, lo que dice tambien es valido para patrones de diseño orientados
  a objetos. Nuestras soluciones se expresan en terminos de objetos e
  interfaces, en vez de paredes y puertas, pero en la esencia de ambos tipos de
  patrones se encuentra una solucion a un problema dentro de un contexto.

  En general, un patron tiene cuatro elementos esenciales:

  1. El @b(nombre del patron) permite describir, en una o dos palabras, un
     problema de diseño junto con sus soluciones y consecuencias. Al dar nombre
     a un patron inmediatamante estamos incrementando nuestro vocabulario de
     diseño, lo que nos permite diseñar con mayor abstraccion. Tener un
     vocabulario de patrones nos permite hablar de ellos con otros colegas,
     mencionarlos en nuestra documentacion y tenerlos nosotros mismos en
     cuenta. De esta manera, resulta mas facil pensar en nuestros diseños y
     transmitirlos a otros, junto con sus ventajas e inconvenientes. Encontrar
     buenos nombres ha sido una de las partes mas dificiles al desarrollar
     nuestro catalogo.

  2. El @b(problema) describe cuando aplicar el patron. Explica el problema y
     su contexto. Puede describir problemas concretos de diseñø (por ejemplo,
     como representar algoritmos como objetos), asi como las estructuras de
     clases u objetos que son sintomaticas de un diseño inflexible. A veces el
     problema incluye una serie de condiciones que deben darse para que tenga
     sentido aplicar el patron.

  3. La @b(solucion) describe los elementos que constituyen el diseño, sus
     relaciones, responsabilidades y colaboraciones. La solucion no describe un
     diseño o una implementacion en concreto, sino que un patron es mas bien
     como una plantilla que puede aplicarse en muchas situaciones diferentes.
     El patron proporciona una descripcion abstracta de un problema de diseño y
     como lo resuelve una disposicion general de elementos (en nuestro caso,
     clases y objetos).

  4. Las @b(consecuencias) son los resultados asi como las ventajas e
     inconvenientes de aplicar el patron. Aunque cuando se describen desiciones
     de diseño muchas veces no se reflejan sus consecuencias, estas son
     fundamentales para evaluar las alternativas de diseño y comprender los
     costes y beneficios de aplicar el patron. Las consecuencias en el software
     suelen referise al equlibrio entre espacio y tiempo. Tambien pueden tratar
     cuestiones de lenguaje e implementacion. Por otro lado, puesto que la
     reutilizacion suele ser uno de los factores de los diseños orientados a
     objetos, las consecuencias de un patron incluyen su impacto sobre la
     flexibilidad, extensibilidad y portabilidad de un sistema. Incluir estas
     consecuencias de un modo explicito nos ayudara a comprenderlas y
     evaluarlas.

  Que es y que no es un patron de diseño es una cuestion que depende del punto
  de vista de cada uno. Lo que para una persona es un patron puede ser un bloque
  primitivo de construccion para otra. En este libro nos hemos centrado en
  patrones situados en un cierto nivel de abstraccion. @e(Patrones de diseño)
  no se ocupa de diseños como listas enlazadas y tablas de dispersion (@e(hash))
  que pueden codificarse en clases y reutilizarse como tales. Tampoco se trata
  de complicados diseños especificos de un dominio para una aplicacion o
  subsistema completo. Los patrones de diseño de este libro son
  @e(descripciones de clases y objetos relacionados que estan particularizados
  para resolver un probelma de diseño general en un determinado contexto).

  Un patron de diseño nomina, abstrae e identifica los aspectos clave de una
  estructura de diseño comun, lo que los hace utiles para crear un diseño
  orientado a objetos reutilizable. El patron de diseño identifica las clases e
  instancias participantes, sus roles y colaboraciones, y la distribucion de
  responsabilidades. Cado patron de diseño se centra en un problema concreto,
  describiendo cuando aplicarlo y si tiene sentido hacerlo teniendo en cuenta
  otras restricciones de diseoñ, asi como las consecuencias y las ventajas e
  inconvenientes de su uso. Por otro lado, como normalmente tendremos que
  implementar nuestros diseños, un patron tambien proporciona codigo de ejemplo
  en C++, y a veces en Smalltalk, para ilustrar una implementacion.

  Aunque los patrones describen diseños orientados a objetos, estan basados en
  soluciones practicas que han sido implementadas en los lenguajes de
  programacion orientados a objetos mas usuales, como Smalltalk y C++, en vez
  de mediante lenguajes procedimentales (Pascal, C, Ada) u otros lenguajes
  orientados a abjetos mas dinamicos (CLOS, Dylan, Self). Nosotros hemos
  elegido Smalltalk y C++ por una cuestion pragmatica: nuestra experiencia
  diaria ha sido con estos lenguajes, y estos cada vez son mas populares.

  La eleccion del lenguaje de programacion es importante, ya que influye en el
  punto de vista. Nuestros patrones presuponen caracteristicas de los lenguajes
  Smalltalk y C++, y esa eleccion determina lo que puede implementarse o no
  facilemente. Si hubieramos supuesto lenguajes procedimentales, tal vez
  hubieramos incluido patrones llamados @"(Herencia), @"(Encapsulacion) y
  @"(Polimorfismo). De manera similar, algunos de nuestros patrones estan
  incluidos directamente en lenguajes orientados a objetos menos corrientes.
  CLOS, por ejemplo, tiene multi-metodos que reducen la necesidad de patrones
  como el @l(#Visitor). De hecho, hay suficientes diferencias entre Smalltalk y
  C++ como para que algunos patrones puedan expresarse mas facilmente en un
  lenguaje que otro (por ejemplo, el @l(#Iterator)).

** 1.2 <> Patrones de diseño en el MVC de Smalltalk

  La triada de clases Modelo/Vista/Controlador (MVC) [@l(#KP88)] se usa para
  interfaces de usuario en Smalltalk-80. Observar los patrones de diseño que
  hay en MVC deberia ayudar a entender que queremos decir con el termino
  @"(patron).

  MVC consiste en tres tipos de objetos. El @b(Modelo) es el objeto de
  aplicacion, la @b(Vista) es su representacion en pantalla y el
  @b(Controlador) define el modo en que la interfaz reacciona a la entrada del
  usuario. Antes de MVC, los diseños de interfaces de usuario tendian a agrupar
  estos objetos en uno solo. MVC los separa para incrementar la flexibilidad y
  reutilizacion.

  MVC desacopla las vistas de los modelos estableciendo entre ellos un
  protocolo de subscripcion/notificacion. Una vista debe asegurarse de que su
  apariencia refleja el estado del modelo. Cada vez que cambian los datos del
  modelo, este se encarga de avisar a las vistas que dependend de el. Como
  respuesta a dicha notificacion, cada vista tiene la oportunidad de
  actualizarse a si misma. Este enfoque permite asignar varias vistas a un
  modelo para ofrecer diferentes presentaciones. Tambien se pueden crear nuevas
  visitas de un modelo sin necesidad de volver a escribir este.

  El siguiente diagrama muestra un modelo y tres vistas (hemos dejado fuera los
  controladores para simplificar). El modelo contiene algunos valores de datos
  y las vistas, consistentes en una hoja de calculo, un histograma y un grafico
  de tarta que muestran estos datos de varias formas. El modelo se comunica con
  sus vistas cuando cambian sus valores, y las vistas se comunican con el
  modelo para acceder a estos.

  ..img > img/001.png

  Si nos fiamos de el, este ejemplo refleja un diseño que desacopla las vistas
  de los modelos. Pero el diseño es aplicable a un problema mas general:
  desacoplar objetos de manera que los cambios en uno puedan afectar a otros
  sin necesidad de que el objeto que cambia conozca detalles de los
  otros. Dicho diseño mas general se describe en el patron @l(#Observer).

  Otras caracteristicas de MVC es que las vistas se pueden anidar. Por ejemplo,
  un panel de control con botones se puede implementar como una vista compleja
  que contiene varias vistas de botones anidadas. La interfaz de usuario de un
  inspector de objetos puede consistir en vistas anidadas que pueden ser
  reutilizadas en un depurador. MVC permite vistas anidadads gracias a la clase
  @c(VistaCompuesta), una subclase de @c(Vista). Los objetos @c(VistaCompuesta)
  pueden actuar simplemente como objetos @c(Vista), es decir, una vista
  compuesta puede usarse en cualquier lugar donde pudiera usarse una vista,
  pero tambien contiene y gestiona vistas anidadas.

  De nuevo, podriamos pensar en el como un diseño que nos permite tratar a una
  vista compuesta exactamente igual que a uno de sus componentes. Pero el
  diseño es aplicable a un problema mas general, que ocurre cada vez que
  queremos agrupar objetos y tratar al grupo como a un objeto individual. El
  patron @l(#Composite) describe este diseño mas general. Dicho patron permite
  crear una jerarquia en la que algunas subclases definen objetos primitivos
  (por ejemplo, @c(Boton)) y otras, objetos compuestos (@c(VistaCompuesta)),
  que ensamblan los objetos primitivos en otros mas complejos.

  MVC tambien permite cambiar el modo en que una vista responde a la entrada de
  usuario sin cambiar su representacion visual. En este sentido, tal vez
  queramos cambiar como responde al teclado, por ejemplo, o hacer que use un
  menu contextual en vez de atajos de teclado. MVC encapsula el mecanismo de
  respuesta en un objeto @c(Controlador). Hay una jerarquia de controladores y
  es facil crear un nuevo controlador como una variacion de uno existente.

  Una vista usa una instancia de una subclase de @c(Controlador) para
  implementar una determinada estrategia de respuesta; para implementar una
  estrategia diferente, simplemente basta con sustituir la instancia por otra
  clase de controlador. Incluso es posible cambiar el controlador de una vista
  en tiempo de ejecucion, para hacer que la vista cambie el modo en que
  responde a la entrada de usuario. Por ejemplo, para desactivar una vista y
  que no acepte entradas basta con asignarle un controlador que haga caso omiso
  de los eventos de entrada.

  La relacion entre @c(Vista) y @c(Controlador) es un ejemplo del patron
  @l(#Strategy). Una Estrategia es un objeto que representa un algoritmo. Es
  util cuando queremos reemplazar el algoritmo, ya sea estatica o dinamicamente,
  cuando existen muchas variantes del mismo o cuando tiene estructuras de datos
  complejas que queremos encapsular.

  MVC usa otros patrones de diseño, tales como el @l(#Factory Method) para
  especificar la clase controlador predeterminada de una vista, el
  @l(#Decorator) para añadir capacidad de desplazamiento a una vista. Pero las
  principales relaciones en MVC se dan entre los patrones de diseño
  @l(#Observer), @l(#Composite) y @l(#Strategy).

** 1.3 <> Descripcion de los patrones de diseño

  ¿Como describimos los patrones de diseño? Las notaciones graficas, aunque
  importantes, no son suficientes. Simplemente representan el producto final
  del proceso de diseño, como las relaciones entre clases y objetos. Para
  reutilizar el diseño, debemos hacer constar las decisiones, alternativas y
  ventajas e inconvenientes que dieron lugar a el. Tambien son importantes los
  ejemplos concretos, porque nos ayudan a ver el diseño en accion.

  Describimos los patrones de diseño empleando un formato consistente. Cada
  patron se divide en secciones de acuerdo a la siguiente plantilla. Esta da
  una estructura uniforme a la informacion, haciendo que los patrones de diseño
  sean mas faciles de aprender, comparar y usar.

  - Nombre de patron y clasificacion ::

    El nombre del patron transmite sucintamente su esencia. Un buen nombre es
    vital, porque pasara a formar parte de nuestro vocabulario de diseño. La
    clasificacion del patron refleja el esquema que se presenta en la
    @l(#1.5<>Seccion 1.5)

  - Proposito  ::

    Una frase breve que responde a las siguientes cuestiones:

    - ¿Que hace este patron de diseño?
    - ¿En que se basa?
    - ¿Cual es el problema concreto de diseño que resuelve?

  - Tambien conocido como ::

    Otros nombres, si existen, por los que se conoce el patron.

  - Motivacion ::

    Un escenario que ilustra un problema de diseño y como las estructuras de
    clases y objetos del patron resuelven el problema. El escenario ayudara a
    entender la descripcion que sigue.

  - Aplicabilidad ::

    - ¿En que situaciones se puede aplicar el patron de diseño?
    - ¿Que ejemplos hay de malos diseños que el patron puede resolver?
    - ¿Como se puede reconocer dichas situaciones?

  - Estructura ::

    Una representacion grafica de las clase del patron usando una notacion
    basada en la Tecnica de Modelado de Objetos (OMT) [@l(#RBP+91)]. Tambien hacemos
    uso de diagramas de interaccion [@l(#JCJO92), @l(#Boo94)] para mostrar secuencias de
    peticiones y colaboraciones entre objetos. El @l(#Apendice B) describe
    estas notaciones en detalle.

  - Participantes ::

    Las clases y objetos participantes en el patron de diseño, junto con sus
    reponsabilidades.

  - Colaboraciones ::

    Como colaboran los participantes para llevar a cabo sus responsabilidades.

  - Consecuencias ::

    - ¿Como consigue el patron sus objetivos?

    - ¿Cuales son las ventajas e inconvenientes y los resultados de usar el
      patron?

    - ¿Que aspectos de la estructura del sistema se pueden modificar de forma
      independiente?

  - Implementacion ::

    - ¿Cuales son las dificultades, trucos o tecnicas que deberiamos tener en
      cuenta a la hora de aplicar el patron?

    - ¿Hay cuestiones especificas del lenguaje?

  - Codigo de ejemplo ::

    Fragmentos de codigo que muestran como se puede implementar el patron en
    C++ o en Smalltalk.

  - Usos conocidos ::

    Ejemplos del patron en sistemas reales. Incluidos al menos dos ejemplos de
    diferentes dominios.

  - Patrones relacionados ::

    - ¿Que patrones de diseño estan estrechamente relacionados con este?
    - ¿Cuales son las principales diferencias?
    - ¿Con que otros patrones deberia usarse?

  Los apendices proporcionan informacion adicional que le ayudara a entender
  los patrones y las discuciones que lo rodean. El @l(#Apendice A) es un
  glosario de la terminologia en el libro. En el @l(#Apendice B) que ya hemos
  mencionado se presentan las diferentes notaciones. Tambien describiremos
  aspectos de las notaciones a medida que las vayamos introduciendo en las
  discuciones venideras. Finalmente, el @l(#Apendice C) contiene el codigo
  fuente de las clases que usamos en los ejemplos.

** 1.4 <> El catalogo de patrones de diseño

  El catalogo contiene 23 patrones de diseño. A continuacion mostraremos el
  nombre y el proposito de cada uno de ellos para ofrecerle una perspectiva
  general.

  - @l(#Abstract Factory) (Fabrica Abstracta) ::

    Proporciona una interfaz para crear familias de objetos relacionados o que
    dependen entre si, sin especificar sus clases concretas.

  - @l(#Adapter) (Adaptador) ::

    Conviente la interfaz de una claze en otra distinta que es la que esperan
    los clientes. Permite que cooperen clases que de otra manera no podrian por
    tener interfaces incompatibles.

  - @l(#Bridge) (Puente) ::

    Desacopla una abstraccion de su implementacion, de manera que ambas puedan
    variar de forma independiente.

  - @l(#Builder) (Constructor) ::

    Separa la construccion de un objeto complejo de su representacion, de forma
    que el mismo proceso de construccion pueda crear diferentes representaciones.

  - @l(#Chain of Responsibility) (Cadena de Responsabilidad) ::

    Evita acoplar el emisor de una peticion a su receptor, al dar a mas de un
    objeto la posibilidad de responder a la peticion. Crea una cadena con los
    objetos receptores y pasa la peticion a traves de la cadena hasta que esta
    sea tratada por algun objeto.

  - @l(#Command) (Orden) ::

    Encapsula una peticion en un objeto, permitiendo asi paramentrizar a los
    clientes con distintas peticiones, encolar o llevar un registro de las
    peticiones y poder deshacer las operaciones.

  - @l(#Composite) (Compuesto) ::

    Combina objetos en estructuras de arbol para representar jerarquias de
    parte-todo. Permite que los clientes traten de manera uniforme a los
    objetos individuales y a los compuestos.

  - @l(#Decorator) (Decorador) ::

    Añade dinamicamente nuevas responsabilidades a un objeto, proporcionando
    una alternativa flexible a la herencia para extender la funcionalidad.

  - @l(#Facade) (Fachada) ::

    Proporciona una interfaz unificada para un conjunto de interfaces de un
    subsistema. Define una interfaz de alto nivel que hace que el subsistema
    sea mas facil de usar.

  - @l(#Factory Method) (Metodo de Fabricacion) ::

    Define una interfaz para crear un objeto, pero deja que sean las subclases
    quienes decidan que clase instanciar. Permite que una clase delegue en sus
    subclases la creacion de objetos.

  - @l(#Flyweight) (Peso Ligero@n(1)) ::

    Usa el comportamiento para permitir un gran numero de objetos de grano fino
    de forma eficiente.

  - @l(#Interpreter) (Interprete) ::

    Dado un lenguaje, define una respresentacion de su gramatica junto con un
    interprete que usa dicha representacion para interpretar sentencias del
    lenguaje.

  - @l(#Iterator) (Iterador) ::

    Proporciona un modo de acceder secuencialmente a los elementos de un objeto
    agregado sin exponer su representacion interna.

  - @l(#Mediator) (Mediador) ::

    Define un objeto que encapsula como interactuan un conjunto de objetos.
    Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a
    otros explicitamente, y permite variar la interaccion entre ellos de forma
    independiente.

  - @l(#Memento) (Recuerdo) ::

    Representa y externaliza el estado interno de un objeto sin violar la
    encapsulacion, de forma que este puede volver a dicho estado mas tarde.

  - @l(#Observer) (Observador) ::

    Define una dependencia de uno-a-muchos entre objetos, de forma que cuando
    cambie de estado se notifica y se actualizan automaticamente todos los
    objetos que dependen de el.

  - @l(#Prototype) (Prototipo) ::

    Especifica los tipos de objetos a crear por medio de una instacia
    prototipica, y crea nuevos objetos copiando de este prototipo.

  - @l(#Proxy) (Apoderado) ::

    Proporciona un sustituto o representante de otro objeto para controlar el
    acceso a este.

  - @l(#Singleton) (Unico) ::

    Garantiza que una clase solo tenga una instancia, y proporciona un punto de
    acceso global a ella.

  - @l(#State) (Stado) ::

    Permite que un objeto modifique su comportamiento cada vez que cambie su
    estado interno. Paracera que cambia la clase de objeto.

  - @l(#Strategy) (Estrategia) ::

    Define una familia de algoritmos, encapsula cada uno de ellos y los hace
    intercambiables. Permite que un algoritmo varie independientemente de los
    clientes que lo usan.

  - @l(#Template Method) (Metodo Plantilla) ::

    Define en una operacion el esqueleto de un algoritmo, delegando en las
    subclases algunos de sus pasos. Permite que las subclases redefinan ciertos
    pasos del algoritmo sin cambiar su estructura.

  - @l(#Visitor) (Visitante) ::

    Representa una operacion sobre los elementos de una estructura de
    objetos. Permite definir una nueva operacion sin cambiar las clases de los
    elementos sobre los que opera.

** 1.5 <> Orgarnizacion del catalogo

  Los patrones de diseño varian en su granularidad y nivel de abstraccion. Dado
  que existen muchos patrones de diseño, es necesario un modo de
  organizarlos. Esta seccion clasifica los patrones de diseño de manera que
  podamos referirnos a familias de patrones relacionados. La clasificacion
  ayuda a aprender mas rapidamente los patrones del catalogo, y tambien puede
  encauzar los esfuerzos para descubrir nuevos patrones.

  Nosotros clasificamos los patrones de diseño siguiendo dos criterios (Tabla
  1.1). El primero de ellos, denominado @b(proposito), refleja que hace un
  patron. Los patrones pueden tener un proposito de @b(creacion),
  @b(estructural) o de @b(comportamiento). Los patrones de creacion tienen que
  ver con el proceso de creacion de objetos. Los patrones estructurales tratan
  con la composicion de clases u objetos. Los de comportamiento caracterizan el
  modo que las clases y objetos interactuan y se reparten la responsabilidad.

  ..figure > @t(Tabla 1.1): Patrones de diseño

    +----------------------------------------------------------------------------------------------------+
    |                                           Proposito                                                |
    +-----------------+-----------------------+---------------------------+------------------------------+
    |                 | De Creacion           | Estructurales             | De Comportamiento            |
    +========+========+=======================+===========================+==============================+
    | Ambito | Clase  | @l(#Factory Method)   | @l(#Adapter) (de clases)  | @l(#Interpreter)             |
    |        |        +-----------------------+---------------------------+------------------------------+
    |        |        |                       |                           | @l(#Template Method)         |
    |        +--------+-----------------------+---------------------------+------------------------------+
    |        | Objeto | @l(#Abstract Factory) | @l(#Adapter) (de objetos) | @l(#Chain of Responsibility) |
    |        |        +-----------------------+---------------------------+------------------------------+
    |        |        | @l(#Builder)          | @l(#Bridge)               | @l(#Command)                 |
    |        |        +-----------------------+---------------------------+------------------------------+
    |        |        | @l(#Prototype)        | @l(#Compositive)          | @l(#Iterator)                |
    |        |        +-----------------------+---------------------------+------------------------------+
    |        |        | @l(#Singleton)        | @l(#Decorator)            | @l(#Mediator)                |
    |        |        +-----------------------+---------------------------+------------------------------+
    |        |        |                       | @l(#Facade)               | @l(#Memento)                 |
    |        |        +-----------------------+---------------------------+------------------------------+
    |        |        |                       | @l(#Flyweight)            | @l(#Observer)                |
    |        |        +-----------------------+---------------------------+------------------------------+
    |        |        |                       | @l(#Proxy)                | @l(#State)                   |
    |        |        +-----------------------+---------------------------+------------------------------+
    |        |        |                       |                           | @l(#Visitor)                 |
    +--------+--------+-----------------------+---------------------------+------------------------------+


  El segundo criterio, denominado ambito, especifica si el patron se aplica
  principalmente a clases o a objetos. Los patrones de clases se ocupan de las
  relaciones entre las clases y sus subclases. Estas relaciones se establecen a
  traves de la herencia, de modo que son relaciones estaticas @-(fiajadas en
  tiempo de compilacion). Los patrones de objetos tratan con las relaciones
  entre objetos, que pueden cambiarse en tiempo de ejecucion y son
  dinamicas. Casi todos los patrones usan la herencia de un modo u otro, asi
  que los unicos patrones etiquetados como @"(patrones de clases) son aquellos
  que se centran en las relaciones entre clases. Notese que la mayoria de los
  patrones tienen un ambito de objeto.

  Los patrones de creacion de clases delegan alguna parte del proceso de
  creacion de objetos en las subclases, mientras que los patrones de creacion de
  objetos lo hacen en otro objeto. Los patrones estructurales de clases usan
  la herencia para componer clases, mientras que los objetos describen formas
  de ensamblar objetos. Los patrones de comportamiento de clases usan la
  herencia para describir algoritmos y flujos de control. mientras que los de
  objetos describen como cooperan un grupo de objetos para realizar una tarea
  que ningun objeto puede llevar a cabo por si solo.

  Hay otras maneras de organizar los patrones. Algunos patrones suelen usarse
  juntos. Por ejemplo, el Composite suele usarse con el Iterator o el
  Visitor. Algunos patrones son alternativas: el Prototype es muchas veces una
  alternativa al Abstract Factory. Algunos patrones dan como resultado diseños
  parecidos, a pesar de que tengan diferentes propositos. Por ejemplo, los
  diagramas de estructura del Composite y el Decorator son similares.

  Otro modo de organizar los patrones de diseño es en funcion de como se hagan
  referencia unos a otros en su seccion @"(Patrones Relacionados). La Figura
  1.1 representa estas relaciones graficamente.

  ..figure > @t(Figura 1.1): Relaciones entre los patrones de diseño

    ..img  > img/Figura-1.1.png

  Es evidente que hay muchas formas de organizar los patrone de diseño. Tener
  muchas formas de pensar en los patrones le hara comprender mejor que es lo que
  hacen, como compararlos y cuando aplicarlos

** 1.6 <> Como resuelven los patrones los problemas de diseño

  Los patrones de diseño resuelven muchos de los problemas diarios con los que
  se enfrentan los diseñådores orientados a objetos, y lo hacen de muchas
  formas diferentes. A Continuacion se muestran algunos de estos problemas y
  como los solucionan los patrones.

*** Encontrar los objetos apropiados

  Los programas orientados a objetos estan formados de objetos. Un objeto
  encapsula tanto datos como los procedimientos que operan sobre esos
  datos. Estos procedimientos es lo que se conoce normalmente como @b(metodos) u
  @b(operaciones). Un objeto realiza una operacion cuando recibe una
  @b(peticion) (o @m(mensaje)) de un @b(cliente).

  Las peticiones son el @e(unico) modo de lograr que un objeto ejecute una
  operacion. Las operaciones son la @e(unica) forma de cambiar los datos
  internos de un objeto. Debido a estas restricciones, se dice que el estado
  interno de un objeto esta encapsulado; no puede accederse a el directamente,
  y su representacion no es visible desde el exterior del objeto.

  Lo mas complicado del diseño orientado a objetos es descomponer un sistema
  en objetos. La tarea es dificil porque entran en juego muchos factores:
  encapsulacion, granularidad, dependencia, flexibilidad, rendimiento,
  evolucion, reutilizacion, etcetera, etcetera. Todos ellos influyen en la
  descomposicion, muchas veces de formas opuestas.

  Las metodologias orientadas a objetos permiten muchos enfoques
  diferentes. Podemos escribir la descripcion de un problema, extraer los
  nombres y verbos, y crear las correspondientes clases y operaciones. O
  podemos centrarnos en las colaboraciones y responsabilidades de nuestro
  sistema. O modelar el mundo real y traducir al diseño los objetos
  encontrados durante el analisis. Siempre habra discrepancias sobre que
  enfoque es mejor.

  Muchos objetos de un diseño proceden del modelo del analisis. Pero los
  diseños orientados a objetos suelen acabar teniendo clases que no tienen su
  equivalente en el mundo real. Algunas de ellas son clases de bajo nivel como
  los arrays. Otras son de mucho mas alto nivel. Por ejemplo, el patron
  @l(#Composite) introduce una abstraccion para tratar de manera uniforme
  objetos que no tienen un equivalente fisico. El modelado estricto del mundo
  real conduce a un sistema que refleja las realidades presentes pero no
  necesariamente las futuras. Las abstracciones que surgen durante el diseño
  son fundamentales para lograr un diseño flexible.

  Los patrones de diseño ayudan a identificar abstracciones menos obvias y los
  objetos que las expresan. Por ejemplo, los objetos que representan un
  proceso o algoritmo no tienen lugar en la naturaleza, y sin embargo son una
  parte crucial de los diseños flexibles. El patron @l(#Strategy) describe
  como implementar familias intercambiables de algoritmos. El patron
  @l(#State) representa cada estado de una entidad como un objeto. Estos
  objetos rara vez se encuentran durante el analisis o incluso en las primeras
  etapas del diseño; son descubiertos mas tarde, mientras se trata de hacer el
  diseño mas flexible y reutilizable.

*** Determinar la granularidad de los objetos

  Los objetos pueden variar enormemente en tamaño y numero. Pueden representar
  cualquier cosa, desde el hardware hasta aplicaciones completas. ¿Como
  decidir entonces que deberia ser un objeto?

  Los patrones de diseño tambien se encargan de esta cuestion. El patron
  @l(#Facade) describe como representar subsistemas completos como objetos, y
  el patron @l(#Flyweight) como permitir un gran numero de objetos de
  granularidad muy fina. Otros patrones de diseño describen formas concretas de
  descomponer un objeto en otros mas pequeños. Los patrones @l(#Abstract
  Factory) y @l(#Builder) producen objetos cuya unica responsabilidad es crear
  otros objetos. El patron @l(#Visitor) y el @l(#Command) dan lugar a objetos
  cuaya unica responsabilidad es implementar una peticon en otro objeto o
  grupo de objetos.

*** Especificar las interfaces de los objetos

  Cada operacion declarada por un objeto especifica el nombre de la operacion,
  los objetos que toma como paramentros y el valor de retorno de la
  operacion. Esto es lo que se conoce como la @b(signatura) de la
  operacion. Al conjunto de todas las signaturas definidas por las operaciones
  de un objeto se le denomita la @b(interfaz) del objeto. Dicha interfaz
  caracteriza al conjunto completo de peticiones que se pueden enviar al
  objeto. Cualquier peticion que concuerde con una signatura de la interfaz
  puede ser enviada al objeto.

  Un @b(tipo) es un nombre que se usa para denotar una determinada interfaz.
  Decimos que un objeto tiene el tipo @"(Ventana) si acepta todas las peticiones
  definidas en una interfaz llamada @"(Ventana). Un objeto puede tener muchos
  tipos, y objetos muy diferentes pueden compartir un mismo tipo. Parte de la
  interfaz de un objeto puede ser caracterizada por un tipo, y otras partes por
  otros tipos. Dos objetos del mismo tipo solo necesitan compartir partes de sus
  interfaces. Las interfaces pueden contener, como subjconjuntos, otras
  interfaces. Se dice que un tipo es un @b(subtipo) de otro si su interfaz
  contiene a la interfaz de su @b(supertipo). Suele decirse que un subtipo
  @e(hereda) la interfaz de su supertipo.

  Las interfaces son fundamentales en los sistemas orientados a objetos. Los
  objetos solo se conocen a traves de su interfaz. No hay modo de saber nada
  de un objeto o pedirle que haga nada si no es atraves de su interfaz. La
  interfaz de un objeto no dice nada acerca de su implementacion @-(distintos
  objetos son libres de implementar las peticiones de forma diferente). Eso
  significa que dos objetos con imprementaciones completamente diferentes
  pueden tener interfaces identicas.

  Cuando se envia una peticion a un objeto, la operacion concreta que se
  ejecuta depende @e(tanto) de la peticion @e(como) del objeto que la
  recibe. Objetos diferentes que soportan peticiones identicas pueden tener
  distintas implementaciones de las operaciones que satisfacen esas
  peticiones. La asociacion en tiempo de ejecucion entre una peticon a un
  objeto y una de sus operaciones es lo que se conoce como @b(enlace
  dinamico).

  El enlace dinamico significa que enviar una peticion no nos liga a una
  implementacion particular hasta el tiempo de ejecucion. Por tanto, podemos
  escribir programas que esperen un objeto con una determinada interfaz,
  sabiendo que cualquier objeto que tenga la interfaz concreta aceptara la
  peticon.

  Mas aun, el enlace dinamico nos permite sustituir objetos en tiempo de
  ejecucion por otros que tengan la misma interfaz. Esta capacidad de
  sustitucion es lo que se conoce como polimorfismo, y es el concepto clave en
  los sistemas orientados a objetos. Permite que un cliente haga pocas
  suposiciones sobre otros objetos aparte de que permitan una interfaz
  determinada. El polimorfirsmo simplifica las definiciones de los clientes,
  desacopla unos objetos de otros y permite que varien las relaciones entre
  ellos en tiempo de ejecucion.

  Los patrones de diseño ayudan a definir interfaces identificando sus
  elementos clave y los tipos de datos que se envian a la interfaz. Un patron
  de diseño tambien puede decir que no debemos poner en la interfaz. El patron
  @l(#Memento) (Recuerdo) es un buen ejemplo de esto. Dicho patron describe
  como encapsular y guardar el estado interno de un objeto para que este
  puedar volver a ese estado posteriormente. El patron estipula que los
  objetos @c(Recuerdo) deben definir dos interfaces: una restringida, que
  permita a los clientes albergar y copiar el estado a recordar, y otra
  protegida que solo pueda usar el objeto original para almacenar y recuperar
  dicho estado.

  Los patrones de diseño tambien especifican relaciones entre interfaces. En
  concreto, muchas veces requieren que algunas clases tengan interfaces
  parecidas, o imponen restricciones a las interfaces de algunas clases. Por
  ejemplo, tanto el patron @l(#Decorator) como el @l(#Proxy) requieren que las
  interfaces de los objetos @c(Decorador) y @c(Proxy) sean identicos a los
  objetos @c(decorado) y @c(representado), respectivamente. En el patron
  @l(#Visitor), la interfaz @c(Visitante) debe reflejar todas las clases de
  objetos que pueden ser visitados.

*** Especificar las implementaciones de los objetos

  Hasta ahora hemos dicho poco sobre como definir realmente un objeto. La
  implementacion de un objeto queda definida por su clase. La clase especifica
  los datos, la representacion interna del objeto y define las operaciones que
  puede realizar.

  Nuestra notacion basada en OMT (resumida en el @l(#Apendice B) muestra una
  clase como un rectangulo con el nombre en negrita. Las operaciones aparecen
  en un tipo de fuente normal bajo el nombre de la clase. Cualquier dato que
  defina la clase viene despues de las operaciones. Por ultimo, se utilizan
  lineas para separar el nombre de la clase de las operaciones y estas de los
  datos:

  ..img > img/002.png

  Los tipos de retorno y de las variables de instancia son opcionales, puesto
  que no suponemos un leguaje de implementacion estaticamente @e(tipado).

  Los objetos se crean @b(instanciando) una clase. Se dice que el objeto es
  una @b(instancia) de la clase. El proceso de crear una instancia de una
  clase asigna espacio de almacenemaiento para los datos internos del objeto
  (representandos por @b(variables de instancia)) y asocia las operaciones con
  esos datos. Se pueden crear muchas instancias parecidas de un objeto
  instanciando una clase.

  Una flecha de linea discontinua indica que una clase crea objetos de otra
  clase. La flecha apunta a la clase de los objetos creados.

  ..img > img/003.png

  Las nuevas clases se pueden definir en terminos de las existentes, usando la
  @b(herencia de clases). Cuando una @b(subclase) hereda de una @b(clase
  padre), incluye las definiciones de todos los datos y operaciones que define
  la clase patre. Los objetos que son instancias de las subclases contendran
  todos los datos definidos por la subclase y por sus clases padre, y seran
  capaces de realizar todas las operaciones definidas por sus subclases y sus
  padres. Indicamos la relacion de subclase con una linea vertical y un
  triangulo:

  ..img > img/004.png

  Una @b(clase abstracta) es aquella cuyo proposito principal es definir una
  interfaz comun para sus subclases. Una clase abstracta delegara parte o toda su
  implementacion en las operaciones definidas en sus subclases; de hay que no se
  pueda crear una instancia de una clase abstracta. Las operaciones que una
  clase abstracta define pero no implementa se denominan @b(operaciones
  abstractas). Las clases que no son abstractas se denominan @b(clases
  concretas).

  Las subclases pueden definir el comportamiento de sus clases padres. Mas
  concretamente, una clase puede definir una operacion definida por su clase
  padre. La redefinicion permite que sean las subclases las que manejen una
  peticion en vez de sus clases padres. La herencia de clases permite definir
  clases simplemente extendiendo otras clases, haciendo que sea facil definir
  familias de objetos de funcionalidad parecida.

  Los nombres de las clases abstractas aparecen en cursiva para distinguirlas
  de las clases concretas. Un diagrama puede incluir el pseudocodigo de la
  implementacion de una operacion; si es asi, el codigo aparecera en una caja
  con la esquina doblada unida por una linea discontinua a la operacion que
  implementa.

  ..img > img/005.png

  Una clase mezclable@n(2) es aquella pensada para proporcionar una interfaz o
  funcionalidad opcional a otras clases. Se parece a una clase abstracta en
  que no esta pensada para que se creen instancias de ella. Las clases
  mezclables requieren herencia multiple:

  ..img > img/006.png

**** Herencia de clases frente a herencia de interfaces

  Es importante entender la diferencia entre la @e(clase) de un objeto y su
  @e(tipo).

  La clase de un objeto define como se implementa un objeto. La clase define
  el estado interno del objeto y la implementacion de sus operaciones. Por el
  contrario, el tipo de un objeto solo se refiere a su interfaz @-(el conjunto
  de peticiones a las cuales puede responder). Un objeto puede tener muchos
  tipos, y objetos de clases diferentes pueden tener el mismo tipo.

  Por supuesto, hay una estrecha relacion entre clase y tipo. Puesto que una
  clase define las operaciones que puede realizar un objeto tambien define el
  tipo del objeto. Cuando decimos que un objeto es una instancia de una clase,
  queremos decir que el objeto admite la interfaz definida por la clase.

  Lenguajse como C++ y Eiffel usan clases para especificar tanto el tipo de un
  objeto como su implementacion. Los programadores de Smalltalk no declaran
  los tipos de las variables; por tanto, el compilador no comprueba que los
  tipos de los objetos asignados a una variable sean subtipos del tipo de la
  variable. Enviar un mensaje requiere comprobar que la clase del receptor
  implementa el mensaje, pero no que el receptor sea una instancia de una
  clase determinada.

  Tambien es importante comprender la diferencia entre la herencia de clases y
  la de interfaces (o subtipado). La herencia de clases define la
  implementacion de un objeto en terminos de la implementacion do otro
  objeto. En resumen, es un mecanismo para compartir codigo y
  representacion. Por el contrario, la herencia de interfaces (o subtipado)
  describe cuando se puede usar un objeto en el lugar de otro.

  Es facil confundir estos dos conceptos, porque muchos lenguajes no hacen
  esta distincion explicita. En lenguajes como C++ y Eiffel, herencia
  significa tanto herencia de interfaces como de implementacion. La manera
  normal de heredar de una interfaz en C++ es heredar publicamente de una
  clase que tiene funciones miembro virtuales (puras). La herencia de
  interfaces pura se puede simular en C++ heredando publicamente de clases
  abstractas puras. La herencia de implementacion o de clases pura puede
  simularse con herencia privada. En Smalltalk, la herencia significa
  simplemente herencia de implementacion. Se pueden asignar instancias de
  cualquier clase a una variable siempre que sus instancias permitan las
  operaciones realizadas sobre el valor de la variable.

  Si bien la mayoria de los lenguajes de programacion no admiten la distincion
  entre herencia de interfaces y de implementacion, la gente hace esa
  distincion en la practica. Los programadores de Smalltalk normalmente tratan
  a las subclases como si fueran subtipos (aunque hay algunas conocidas
  excepciones [@l(#Coo92)]); los programadores de C++ manipulan objetos a traves de
  tipos definidos por clases abstractas.

  Muchos de los patrones de diseño dependen de esta distincion. Por ejemplo,
  los objetos de una cadena en el patron @l(#Chain of Responsibility) deben
  tener un tipo comun, pero normalemnte no comparten la misma
  implementacion. En el patron @l(#Composite), el @c(Componente) define una
  interfaz comun, mientras que el @c(Compuesto) suele definir una
  implementacion comun. Los patrones @l(#Command), @l(#Observer), @l(#State),
  y @l(#Strategy) suelen implementarse con clases abstractas que son
  interfaces puras.

**** Programar para interfaces, no para una implementacion

  La herencia de clases no es mas que un mecanismo para extender la
  funcionalidad de una aplicacion reutilizando la funcionalidad de las clases
  padres. Permite definir rapidamente un nuevo tipo de objeto basandose en otro,
  y obtener asi nuevas implentaciones casi sin esfuerzo, al heredar la mayoria
  de lo que se necesita de clases ya existentes.

  En cualquier caso, reutilizar la implementacion es solo la mitad de la
  historia. Tambien es importante la capacidad de la herencia para definir
  familias de objetos con interfaces @e(identicas) (normalmente heredando de
  una clase abstracta), al ser justamente en lo que se basa el polimorfismo.

  Cuando la herencia se usa con cuidado (algunos diran que cuando se usa
  @e(correctamente)), todas las clases que derivan de una clase abstracta
  compartiran su interfaz. Esto implica que una subclase simplemente añade
  o redefine operaciones y no oculta operaciones de la clase padre. @e(Todas)
  las subclases pueden entonces responder a las peticiones en la interfaz de
  su clase abstracta, convirtiendose asi todas ellas en subtipos de la clase
  abstracta.

  Manipular los objetos solamente en terminos de la interfaz definida por las
  clases abstractas tiene dos ventajas:

  1. Los clientes no tiene que conocer los tipos especificos de los objetos
     que usan, basta con que estos se adhieran a la interfaz que esperan los
     clientes.

  2. Los clientes desconocen las clases que implementan dichos objetos; solo
     conocen las clases abstractas que definen la interfaz.

  Esto reduce de tal manera las dependencias de implementacion entre
  subsistemas que lleva al siguiente principio del diseño orientado a objetos
  reutilizable:

  ..quote >
    Programe para una interfaz, no para una implementacion.
  < quote..

  Es decir, no se deben declarar las variables como instancias de clases
  concretas. En ves de eso, se ajustaran simplemente a la interfaz definida
  por una clase abstracta. Esto sera algo recurrente en los patrones de diseño
  de este libro.

  No obstante, es evidente que en algun lugar del sistema habra que crear
  instancias de clases concretas (esto es, especificar una determinada
  implementacion), y los patrones de creacion (@l(#Abstract Factory),
  @l(#Builder), @l(#Factory Method), @l(#Prototype) y @l(#Singleton)) se
  encargaran de eso. Al abstraer el proceso de creacion de objetos, estos
  patrones ofrecen diferentes modos de asociar una interfaz con su
  implementacion de manera transparente. Los patrones de creacion aseguran que
  el sistema se escriba en terminos de interfaces, no de implementaciones.

*** Poner a Funcionar los mecanismos de Reutilizacion

  La mayoria de la gente comprente conceptos como objetos, interfaces, clases y
  herencia. La dificultad radica en aplicarlos para construir software
  flexible y reutilizable, y los patrones de diseño pueden mostrar como hacerlo.

**** Herencia frente a Composicion

  Las dos tecnicas mas comunes para reutilizar funcionalidad en sistemas
  orientados a objetos son la herencia de clases y la composicion de
  objetos. Como ya hemos explicado, la herencia de clases permite definir una
  implementacion en terminos de otra. A esta forma de reutilizacion mediante
  herencia se le denomina frecuentemente @b(reutilizacion de caja blanca). El
  termino @"(caja blanca) se refiere a la visibilidad: con la herencia, las
  interioridades de las clases padres suelen hacerse visibles a las subclases.

  La composicion de objetos es una alternativa a la herencia de clases. Ahora,
  la nueva funcionalidad se obtiene ensamblando o @e(componiendo) objetos para
  obtener funcionalidad mas compleja. La composicion de objetos requiere que
  los objetos a componer tengan interfaces bien definidas. Este estilo de
  reutilizacion se denomina @b(reutilizacion de caja negra), porque los
  detalles internos de los objetos no son visibles. Los objetos aparecen solo
  como @"(cajas negras).

  Tanto la herencia como la composicion tienen sus ventajas e inconvenientes.
  La herencia de clases se define estaticamente en tiempo de compilacion y es
  sencilla de usar, al estar permitida directamente por el lenguaje de
  programacion. La herencia de clases tambien hace que sea mas facil modificar
  la implementacion que esta siendo reutilizada. Cuando una subclase redefine
  alguna de las operaciones, puede afectar tambien a las operaciones de las que
  hereda, suponiendo que estas llamen a alguna de las operaciones redefinidas.

  Pero la herencia de clases tambien tiene inconvenientes. En primer lugar, no
  se pueden cambiar las implementaciones heredadas de las clases padre en
  tiempo de ejecucion, porque la herencia se define en tiempo de
  compilacion. En segundo lugar, y lo que generalmente es peor, las clases
  padre suelen definir al menos parte de la representacion fisica de sus
  subclases. Como la herencia expone a una subclase los detalles de la
  imprementacios de su padre, suele decirse que @"(la herencia rompe la
  encapsulacion) [@l(#Sny86)]. La implementacion de una subclase se liga de tal
  forma a la implementacion de su clase padre que cualquier cambio en la
  implementacion del padre obligara a cambiar la subclase.

  Las dependencias de implementacion pueden causar problemas al tratar de
  reutilizar una subclase. Cuando cualquier aspecto de la implementacion
  heredada no sea apropiado para nuevos dominios de problemas, la clase padre
  debera ser escrita de nuevo o reemplazada por otra mas adecuada. Esta
  dependencia limita la flexibilidad y la reutilizacion. Una solucion a esto es
  heredar solo de clases abstractas, ya que estas norlamemente tiene poca o
  ninguna implementacion.

  La composicion de objetos se define dinamicamente en tiempo de ejecucion a
  traves de objetos que tienen referencias a otros objetos. La composicion
  requiere que los objetos tengan en cuenta las interfaces de los otros, lo que
  a su vez requiere interfaces cuidadosamente diseñådas que no impidan que un
  objeto sea utilizado por otros. Pero hay una ventaja en esto: puesto que a los
  objetos se accede solo a traves de sus interfaces no se rompe su
  encapsulacion. Cualquier objeto puede ser reemplazado en tiempo de ejecucion
  por otro simpre que sean del mismo tipo. Ademas, como la implementacion de un
  objetos se escribira en terminos de interfaces de objetos, las dependencias de
  implementacion son notablemente menores.

  La composicion de objetos produce otro efecto en el diseño del sistema. Optar
  por lo composicion de objetos frente a la herencia de clases ayuda a mantener
  cada clase encapsulada y centrada en una sola tarea. De esta manera, nuestras
  clases y jerarquias de clases permaneceran pequeñas y sera menos problable que
  se coviertan en monstruos inmanejables. Por otro lado, un diseño basado en la
  composicion de objetos tendra mas objetos (al tener menos clases), y el
  comportamiento del sistema dependere de sus relaciones en vez de estar
  definido en una clase.

  Esto nos lleva a nuestro segundo principio del diseño orientado a objetos:

  ..quote >
    Favorecer la composicion de objetos frente a la herencia de clases.
  < quote..

  Idealmente, solo creariamos nuevos componentes para lograr la reutilizacion.
  Deberiamos ser capacen de conseguir toda la funcionalidad que necesitasemos
  simplemente ensamblando componentes existente a traves de la composicion de
  objetos. Sin embargo, rara vez es este el caso, puesto que el conjunto de
  componentes disponibles nunca es, en la practica, lo suficientemente rico.
  Reutilizar mediante la herencia hace mas facil construir nuevos componentes
  que puedan ser combinados con los antiguos. La herencia y la composicion
  trabajan por lo tanto juntas.

  No obstante, nuestra experiencia es que los diseñadores abusan de la herencia
  como tecnica de reutilizacion, y que los diseños suelen ser mas reutilizabes (y
  mas simples) si dependen mas de la composicion de objetos. En los patrones de
  diseño se vera la composicion de objetos aplicada una y otra vez.

**** Delegacion

  La @b(delegacion) es un modo de lograr que la composicion sea tan potente para
  la reutilizacion como lo es la herencia [@l(#Lie86), @l(#JZ91)]. Con la delegacion,
  @e(dos) son los objetos encargados de tratar una peticion: un objeto receptor
  delega operaciones en su @b(delegado). Esto es parecido a la forma en que las
  subclases envian peticiones a las clases padres. Pero, con la herencia, una
  operacion heredada siempre se puede referir al propio objeto a traves de las
  variables miembro @c(this) de C++ o @c(self) de Smalltalk. Para lograr el
  mismo efecto con la delegacion, el receptor se pasa a si mismo al delegado,
  para que la operacion delegada pueda referirse a el.

  Por ejemplo, en vez de hacer que la clase @c(Ventana) sea una subclase de
  @c(Rectangulo) (porque resulta que las ventanas son rectangulares), la clase
  @c(Ventana) puede reutilizar el comportamiento de @c(Rectangulo) guardando una
  instancia de esta en una variable y delegando en ella el comportamiento
  especifico de los rectangulos. En otras palabras, en vez de hacer que una
  @c(Ventana) sea un @c(Rectangulo), la @c(Ventana) contendra un
  @c(Rectangulo). Ahora @c(Ventana) debe reenviar las poticiones a su instancia
  de @c(Rectangulo) explicitamente, mientras que antes habria heredado esas
  operaciones.

  El siguiente diagrama muestra la clase @c(Ventana) delegando su operacion
  @c(Area) a una instancia de @c(Rectangulo).

  ..img > img/007.png

  Una flecha lisa indica que una clase tiene una referencia a una instancia de
  otra clase. La referencia tiene un nombre opcional, en este caso
  @"(rectangulo).

  La principal ventaja de la delegacion es que hace que sea facil combinar
  comportamientos en tiempo de ejecucion y cambiar la manera en que estos se
  combinan. Nuestra ventana puede hacerse circular en tiempo de ejecucion
  simplemente cambiando su instancia @c(Rectangulo) por una instancia de
  @c(Circulo), suponiendo que @c(Rectangulo) y @c(Circulo) tengan el mismo tipo.

  La delegacion tiene un inconveniente comun a otras tecnicas que hacen al
  software mas flexible mediante la composicion de objetos: el software dinamico
  y altamente parametrizado es mas dificil de entender que el estatico. Hay
  tambien ineficiencias en tiempo de ejecucion, aunque las ineficiencias humanas
  son mas importantes a largo plazo. La delegacion es una buena eleccion en diseño
  solo cuando simplifica mas de lo que complica. No es facil dar reglas que
  digan exactamente cuando hay que usar delegacion, porque su efectividad
  dependera del contexto y de lo acostumbrados que estemos a ella. La delegacion
  funciona mejor cuando se usa de manera muy estilizada, es decir, en patrones
  estandar.

  Varios patrones de diseño usan la delegacion. Los patrones @l(#State),
  @l(#Strategy) y @l(#Visitor) se basan en ella. En el patron State, un objeto
  delega peticiones en un objeto @c(Estado) que representa su estado actual. En
  el patron Strategy, un objeto delega una peticion en un objeto que rpresenta
  una estrategia para llevarla a cabo. Un objeto solo tendra un estado, pero
  puede tener muchas estrategias para diferentes peticiones. El proposito de
  ambos patrones es cambiar el comportamiento de un objeto cambiando los objetos
  en los que este delega. En el patron Visitor, la operacion que se realiza
  sobre cada elemento de una estructura de objetos simpre se delega en el objeto
  @c(Visitante).

  Otros patrones usan la delegacion de manera menos notoria. El patron
  @l(#Mediator) introduce un objeto que hace de mediador en la comunicacion
  entre objetos. A veces, el objeto @c(Mediador) implementa operaciones
  simpremente redirigiendolas a otros objetos; otras veces pasa una referencia a
  si mismo, usando asi verdadera delegacion. El patron @l(#Chain of
  Responsibility) procesa peticiones reenviandolas de un objeto a otro a traves
  de una cadena. A veces la peticion lleva consigo una referencia al ojbeto que
  recibio originalmente la peticion, en cuyo caso el patron esta usando
  delegacion. El patron @l(#Bridge) desacopla una abstraccion de su
  implementacion. En el caso de que la abstraccion y una implementacion concreta
  esten muy relacionadas, la abstraccion puede simplemente delegar operaciones
  en dicha implementacion.

  La delegacion es un ejemplo extremo de composicion de objetos. Muestra como
  simpre se puede substituir la herencia por la composicion de objetos como
  mecanismo de reutilizacion de codigo.

**** Herencia frente a Tipos Parametrizados

  Otra tecnica (no estrictamente orientada a objetos) para reutilizar
  funcionalidad es a traves de los @b(tipos parametrizados), tambien conocidos
  como @b(genericos) (Ada, Eiffel) y @b(plantillas)@n(3) (C++). Esta tecnica permite
  definir un tipo sin especificar todos los otros tipos que usa. Los tipos sin
  especificar se proporcionan como @e(parametros) cuando se va a usar el tipo
  paramentrizado). Por ejemplo, una clase @c(Lista) puede estar parametrizada
  por el tipo de los elementos que contiene. Para declarar una lista de enteros,
  proporcionamos el tipo @"(integer) como parametro del tipo parametrizado
  @c(Lista).

  Para declarar una lista de objetos @c(String), proporcionamos el tipo
  @"(String) como parametro. El lenguaje de implementacion creara una version
  particularizada de la plantilla de la clase @c(Lista) para cada tipo de
  elemento.

  Los tipos parametrizados nos dan una tercera forma (ademas de la herencia de
  clase y la composicion de objetos) de combinar comportamientos en sistemas
  orientados a objetos. Muchos diseños se pueden implementar usando alguna de
  estas tres tecnicas. Para paramentrizar una rutina de ordenacion segun el tipo
  de operacion que usa para comparar elementos, podriamos hacer que la
  comparacion fuese

  1. una operacion implementada por las subclases (una aplicacion del patron
     @l(#Template Method)).

  2. responsabilidad de un objeto pasado a la rutina de ordenacion
     (@l(#Strategy)), o

  3. un argumento de una plantilla C++ o de un generico de Ada que especifica el
     nombre de la funcion a llamar para comparar los elementos.

  Hay diferencias importantes entre estas tecnicas. La composicion de objetos
  nos permite cambiar el comportamiento en tiempo de ejecucion, pero tambien
  requiere indireccion y puede ser menos eficiente. La herencia nos deja
  proporcionar implementaciones de operaciones predeterminadas y que las
  subclases las redefinan. Los tipos parametrizados permiten cambiar los tipos
  que puede utilizar una clase. Que enfoque es mejr depende de nuestras
  restricciones de diseño e implementacion.

  Ninguno de los patrones de este libro trata de tipos paramentrizados, auque
  los usamos en ocaciones para personalizar la implementacion C++ de algun
  patron. Los tipos parametrizados no son necesarios en lenguajes como
  Smalltalk, que no tienen comprobacion de tipos en tiempo de compilacion.

*** Estructuras que relacionan tiempo de ejecucion y tiempo de compilacion

  La estructura en tiempo de ejecucion de un programa orientado a objetos suele
  guardar poco parecido con la estructura de su codigo. La estructura del codigo
  se fija en tiempo de compilacion, y consiste en clases con relaciones de
  herencia estaticas. La estructura de tiempo de ejecucion de un programa
  consiste en redes cambiantes de objetos que se comunican entre si. De hecho,
  ambas estructuras son en gran medida independientes. Tratar de entender una a
  partir de la otra es como tratar de entender el dinamismo de los ecosistemas
  vivos a partir de la taxonomia estatica de plantas y animales, y viceversa.

  Consideremos la distincion entre @b(agregacion) y @b(asociacion)@n(4) de
  objetos, y como se manifiestan esas diferencias en tiempo de ejecucion y en
  tiempo de compilacion. La agregacion implica que un objeto posee a otro o que
  es responsable de el. Normalmente decimos que un objeto @e(tiene) a otro o que
  un objeto @e(es parte) de otro. La agregacion implica que el objeto agregado y
  su propietario tienen la misma vida.

  La asociacion implica que un objeto simplemente @e(conoce) a otro. A veces, a
  la asociacion tambien se le denomina relacion de @"(uso). Los objetos asi
  relacionados pueden pedirse operaciones entre si, pero no son responsables unos
  de otros. Es una relacion mas debil que la agregacion y representa mucho menor
  acoplamiento entre objetos.

  En nuestros diagramas, una flecha con la linea continua denota asociacion,
  mientras que una flecha con un rombo en su base denota agregacion:

  ..img > img/008.png

  Es facil confundir agregacion y asociacion, ya que muchas veces se
  implementan de la misma forma. En Smalltalk, todas las variables son
  referencias a otros objetos, no hay distincion en el lenguaje de programacion
  entre agregacion y asociacion. En C++, la agregacion se puede implementar
  definiendo variables miembro que sean verdaderas instancias, pero es mas
  frecuente definirlas como puntero o referencias a instancias. La asociacion se
  implementa tambien con punteros y referencias.

  En ultima instancia, la asociacion y la agregacion quedan determinadas mas por
  su intencion que por mecanismos explicitos del lenguaje. La distincion puede
  ser dificil de ver en la estructura de tiempo de compilacion, pero es
  notable. Las relaciones de agregacion tienden a ser menos y mas permanentes
  que las de asociacion. Las asociaciones, por el contrario, se hacen y deshacen
  mucho mas frecuentemente, y algunas veces solo existen mientras dura una
  operacion. Tambien son mas dinamicas, haciendolas mas dificiles de distinguir
  en el codigo fuente.

  Con esa disparidad entre las estructuras de tiempo de ejecucion y compilacion
  de un programa, es evidente que el codigo no lo revelara todo acerca de como
  funciona un sistema. La estructura de tiempo de ejecucion de un sistema debe
  ser impuesta mas por el diseñador que por el lenguaje. Las relaciones entre
  objetos y sus tipos deben ser diseñadas con mucho cuiadado, por que van a
  determinar la calidad de la estructura de tiempo de ejecucion.

  Muchos patrones de diseño (en concreto aquellos que tienen ambito de objeto)
  representan explicitamente la distincion entre ambas estructuras. El patron
  @l(#Composite) y el @l(#Decorator) son especialmente utiles para construir
  estructuras de tiempo de ejecucion complejas. El @l(#Observer) involucra
  estructuras de tiempo de ejecucion que sulen ser dificiles de entender si no
  se conoce el patron. El patron @l(#Chain of Responsibility) tambien produce
  patrones de comunicacion que la herencia no pone de manifiesto. En general,
  las estructuras de tiempo de ejecucion no estan claras en el codigo hasta que
  se comprenden los patrones.

*** Diseñar para el cambio

  La clave para maximizar la reutilizacion reside en anticipar nuevos requisitos
  y cambios en los requisitos existentes, y en rediseñar los sistemas de manera
  que puedan evolucionar en consecuencia.

  Para diseñar un sistema que sea robusto a dichos cambios hay que tener en
  cuenta como puede necesitar cambiar el sistema a lo largo de su vida. Un
  diseño que no tenga en cuenta el cambio sufre el riesgo de tener que ser
  rediseñado por completo en el futuro. Dichos cambios pueden involucrar
  redeficiones reimplementaciones de clases, modificar los clientes y voler a
  hacer pruebas. El rediseño afecta a muchas partes del sistema software, por
  lo que los cambios no previstos siempre resultan costosos.

  Los patrones de diseño ayudan a evitar esto al asegurar que un sistema pueda
  cambiar de formas concretas. Cada patron de diseño deja que algun aspecto de
  la estructura del sistema varie independientemente de los otros, haciendo asi
  al sistema mas robusto frente a un tipo de cambio concreto.

  A continuacion se presentan algunas de las causas comunes de rediseño junto con
  los patrones de diseño que lo resuelven:

  1. @e(Crear un objeto especificando su clase explicitamente.) Especificar un
     nombre de clase al crear un objeto nos liga a una implementacion en vez de
     a una interfaz. Esto puede complicar los cambios futuros. Para evitarlo,
     debemos crear los objetos indirectamente.

     Patrones de diseño; @l(#Abstract Factory), @l(#Factory Method),
     @l(#Prototype).

  2. @e(Dependencia de operaciones concretas.) Cuando especificamos una
     determinada operacion, estamos ligandonos a una forma de satisfacer una
     peticion. Evitando ligar las peticiones al codigo, hacemos mas facil
     cambiar el modo de satisfacer una peticion, tanto en tiempo de compilacion
     como en tiempo de ejecucion.

     Patrones de diseño: @l(#Chain of Responsibility), @l(#Command).

  3. @e(Dependencia de plataformas hardware o software.) Las interfaces externas
     de los sistemas operativos y las interfaces de programacion de aplicaciones
     (API) varian para las diferentes plataformas hardware y software. El
     software que depende de una plataforma concreta sera mas dificil de portar
     a otras plataformas. Incluso puede resultar dificil mantenerlo actualizado
     en su plataforma nativa. Pon tanto, es importante diseñar nuestros sistemas
     de manera que limiten sus dependencias de plataforma.

     Patrones de diseño: @l(#Abstract Factory), @l(#Bridge).

  4. @e(Dependencia de las implementaciones o implementaciones de objetos.) Los
     clientes de un objeto que saben como se representa, se almacena, se
     localiza o se implementa, quiza deban ser modificados cuando cambie dicho
     objeto. Ocultar esta informacion a los clientes previene los cambios en
     cascada.

     Patrones de diseño: @l(#Abstract Factory), @l(#Bridge), @l(#Memento),
     @l(#Proxy).

  5. @e(Dependecias algoritmicas.) Muchas veces los algoritmos se amplian,
     optimizan o sustituyen por otros durante el desarrollo y posterior
     reutilizacion. Los objetos que dependen de un algoritmo tendran que cambiar
     cuando este cambie. Por tanto, aquellos algoritmos que es probable que
     cambien deberian estar aislados.

     Patrones de diseño: @l(#Builder), @l(#Iterator), @l(#Strategy),
     @l(#Template Method), @l(#Visitor).

  6. @e(Fuerte acoplamiento). Las clases que estan fuertemente acopladas son
     dificiles de reutilizar por separado, puesto que dependen unas de otras. El
     fuerte acoplamiento lleva a sistemas monoliticos, en los que no se puede
     cambiar o quitar una clase sin entender y cambiar muchas otras. El sistema
     se convierte asi en algo muy denso que resulta dificil de aprender, portar
     y mantener.

     El bajo acoplamiento aumenta lo probabilidad de que una clase pueda ser
     reutilizada ella sola y que un sistema pueda aprenderse, portarse,
     madificarse y extenderse mas facilmente.

     Los patrones de diseño hacen uso de tecnicas como el acoplamiento abstracto
     y la estructuracion de capas para promover sistemas escasamente acoplados.

     Patrones de diseño: @l(#Abstract Factory), @l(#Bridge), @l(#Chain of
     Responsibility), @l(#Command), @l(#Facade), @l(#Mediator), @l(#Observer).

  7. @e(Añadir funcionalidad mediente la herencia.) Particularizar un objeto
     derivando de otra clase no suele ser facil. Cada nueva clase tiene un coste
     de implementacion (inicializacion, finalizacion, etc). Definir una subclase
     tambien requiere un profundo conocimiento de la clase padre. Por ejemplo,
     redefinir una operacion puede requerir redefinir otra, o tener que llamar a
     una operacion heredada. Ademas, la herencia puede conducir a una explosion
     de clases, ya que una simple extension puede obligar a introducir un monton
     de clases nuevas.

     La composicion de objetos en general y la delegacion en particular
     proporcionan alternativas flexibles a la herencia para combinar
     comportamiento. Se puede añadir nueva funcionalidad a una aplicacion
     componiendo los objetos existentes de otra forma en vez de definir subclases
     nuevas de otras clases existentes. No abstante, tambien es cierto que un
     uso intensivo de la composicion de objetos puede hacer que los diseño sean
     mas dificiles de entender. Muchos patrones de diseño producen diseños en
     los que se puede introducir nueva funcionalidad simplemente definiendo una
     subclase y componiendo sus instancias con otras existentes.

     Patrones de diseño: @l(#Bridge), @l(#Chain of Responsibility),
     @l(#Compose), @l(#Decorator), @l(#Observer), @l(#Strategy).

  8. @e(Incapacidad para modificar las clase convetientemente.) A veces hay que
     modificar una clase que no puede ser modificada convenientemente. Quiza
     necesitemos el codigo fuente y no lo tengamos (como puede ser el caso de
     una biblioteca de clases comercial). O tal vez cualquier cambio requiera
     modificar muchas de las subclases existentes. Los patrones de diseño ofrecen
     formas de modificar las clases en tales circunstancias.

     Patrones de diseño: @l(#Adapter), @l(#Decorator), @l(#Visitor).


  Estos ejemplos reflejan la flexibilidad que los patrones de diseño pueden
  ayudarnos a conseguir en nuestro software. Como sea esta flexibilidad de
  crucial depende del tipo de software que estemos desarrollando. Echemos un
  vistaso al papel que desempeñan los patrones dediseño en el desarrollo de tres
  amplias clases de software: programas de aplicacion, @e(toolkits) y
  @e(frameworks).

**** Programas de aplicacion

  Si estamos construyendo un programa de aplicacion, como un editor de
  documentos o una hoja de calculo, la reutilizacion interna, la facilidad de
  mantenimiento y la extension son las principales prioridades. La reutilizacion
  interna hace que no haya que diseñår e implementar mas de lo estrictamente
  necesario. Los patrones de diseño que reducen dependencias pueden aumentar la
  reutilizacion intera. Un acoplamiento mas bajo aumenta la probabilidad de que
  una clase de objeto pueda cooperar con otras. Por ejemplo, cuando eliminamos
  las dependencias de operaciones especificas aislando y encapsulando cada
  operacion, estamos haciendo que sea mas facil reutilizar una operacion en
  diferentes contextos. Lo mismo ocurre cuando eliminamos dependencias
  algoritmicas y de representacion.

  Los patrones de diseño tambien hacen que una aplicacion sea mas facil de
  mantener cuando se usan para limitar las dependencias de plataforma y para
  organizar un sistema en capas. Mejoran la extensibilidad al ilustrar como
  extender jerarquias de clases y como explotar la composicion de objetos.
  Reducir el acoplamiento tambien mejora la extensibilidad. Extender una clase
  aislada es mas facil si esta no depende de otras muchas clases.

**** Toolkits@n(5)

  Muchas veces una aplicacion incorpora clases de una o mas biblitecas de clases
  predefinidas llamadas @e(toolkits). Un toolkit es un conjunto de clases
  relacionadas y reutilizables diseñadas para proporcionar funcionalidad util de
  proposito general. Un ejemplo de toolkit es un conjunto de clases para tratar
  con listas, tablas asociativas, pilas y similares. La biblioteca de flujos de
  entrada/salida de C++ es otro ejemplo. Los toolkits no imponen un diseño
  particular en una aplicacion; simplemente proporcionan funcionalidad que puede
  ayudar a que la aplicacion haga su trabajo. Nos permiten, como
  desarrolladores, evitar recodificar funcionalidad comun. Los toolkits se
  centran en la @e(reutilizacion de codigo), siendo el equivalente orientado a
  objetos de las bibliotecas de subrutinas.

  Diseñar toolkits es posiblemente mas dificil que diseñar una aplicacion, ya
  que aquellos tienen que funcionar en muchas aplicaciones para ser utiles.
  Ademas, el creador del toolkit no puede saber cuales van a ser esas
  aplicaciones o cuales seran sus necesidades especiales. Eso hace que lo mas
  importante sea evitar suposiciones y dependencias que puedan limitar la
  flexibilidad del tookit y consecuentemente su aplicabilidad y efectividad.

**** Frameworks@n(6)

  Un @e(framework) es un conjunto de clases cooperantes que constituyen un
  diseño reutilizable para una clase especifica de software [@l(#Deu89),
  @l(#JF88)]. Por ejemplo, un framework puede estar orientado a la construccion
  de editores graficos para dominios diferentes, como el dibujo artistico, la
  composicion musical y el CAD [@l(#VL90), @l(#Joh92)]. Otro puede ayudar a
  construir compiladores para diferentes lenguajes de programacion y maquinas de
  destino [@l(#JML92)]. Otro podria ayudar a construir aplicaciones de modelado
  financiero [@l(#BE93)]. Personalizamos un framework para una aplicacion
  concreta creando subclases especificas de la aplicacion de clases abstractas
  del framework.

  El framework determina la arquitectura de nuestra aplicacion. Definira la
  estructura general, su particion de clase y objetos, las reponsabilidades
  clave, como colaboran las clases y el hilo de control. Un framework predefine
  estos parametros de diseño de manera que el diseñador o el programador de la
  aplicacion puedan concentrarse en las particularidades de dicha aplicacion. El
  Framework representa las decisiones de diseño que son comunes a su dominio de
  aplicacion. Los framewors hacen incapie asi en la reutilizacion de diseño
  frente a la reutilizacion de codigo, si bien un framework incluira normalmente
  subclases concretas listas para trabajar con ellas inmediatamente.

  La reutilizacion a este nivel lleva a una inversion de control entre la
  aplicacion y el software en el que se basa. Cuando utilizamos un toolkit (o
  una biblioteca de subrutinas tradicional) escribimos el cuerpo principal de la
  aplicacion y llamamos al codigo que queremos reutilizar. Cuando usamos un
  framework podemos reutilizar el cuerpo principal y escribir el codigo al que
  llama. Habra que escribir operaciones con nombres especificos y convenios de
  llamada, pero eso reduce las decisiones de diseño que hay que tomar.

  Como resultado, no solo se pueden construir aplicaciones mas rapidamente, sino
  que las aplicaciones tienen estructuras parecidas, por lque son mas facil de
  mantener y resultan mas consistentes para los usuarios. Por otro lado,
  perdemos algo de libertad creativa, puesto que muchas decisiones de diseño ya
  han sido tomadas por nosotros.

  Si las aplicaciones son dificiles de diseñar, y los toolkits mas dificiles
  todavia, los frameworks son los mas dificiles de todos. Un diseñador de
  frameworks supone que una misma arquitectura servira para todas las
  aplicaciones de ese dominio. Cualquier cambio sustantivo en el diseño del
  framework reducira considerablemente sus beneficios, puesto que su principal
  contribucion a una aplacacion es la arquitectura que define. Por tanto, es
  necesario diseñar el framework para que sea tan flexible y extensible como sea
  posible.

  Ademas, como las aplicaciones dependen tanto del framework, son
  particularmente sensibles a los cambios en las interfaces de este. A medida
  que un framework evoluciona, las aplicaciones tienen que evolucionar con
  el. Esto hace que un bajo acoplamiento sea lo mas importante de todo; si no,
  hasta el mas minimo cambio del framework tendra importantes repercusiones.

  Los problemas de diseño que acabamos de estudiar son fundamentales en el
  diseño del framework. Un framework que los resuelva usando patrones de diseño
  es mucho mas probable que consiga alto grado de reutilizacion del diseño y del
  codigo que otro que no lo haga. Los frameworks maduros normalmente incorporan
  varios patrones de diseño. Los patrones ayudan a hacer que la arquitectura del
  framework sirva para muchas aplicaciones diferentes sin necesidad de rediseño.

  Una ventaja añadida se produce cuando el framework se documenta con los
  patrones de diseño que usa [@l(#BJ94)]. Quien conoce los patrones aprende como
  esta hecho el framework mucho mas rapidamente. Incluso quienes no conocen los
  patrones se pueden beneficiar de la estructura que estos confieren a la
  documentacion del framework. Mejorar la documentacion es importante para
  cualquier tiepo de software, pero es particularmente importante en el caso de
  los frameworks, ya que suelen tener una curva de aprendizaje que es necesario
  superar para que comiencen a ser utiles. Si bien los patrones de diseño puede
  que no allanen del todo dicha curva de aprendizaje, si la pueden hacer menos
  pediente al hacer explicitos los elementos clave del diseño del framework.

  Como los patrones y los frameworks tienen similitudes, mucha gente se pregunta
  en que se diferencian, si es que se diferencian en algo. Son diferentes en
  tres aspectos fundamentales:

  1. @e(Los patrones de diseño son mas abstractos que los frameworks.) Los
     frameworks pueden plasmarse en codigo, pero solo los ejemplos de los
     patrones pueden ser plasmados en codigo. Uno de los puntos fuertes de los
     frameworks es que se pueden escribir en los lenguajes de programacion y de
     ese modo ser no solo estudiados, sino ejecutados y reutilizados
     directamente. Por el contrario, los patrones de diseño de este libro tienen
     que ser implementados cada vez que se emplean. Los patrones de diseño
     tambien reflejan la intencion, las ventajas e inconvenientes y las
     consecuencias de un diseño.

  2. @e(Los patrones de diseño son elementos arquitectonicos mas pequeños que
     los frameworks.) Un framework tipico contiene varios patrones de diseño,
     pero lo contrario nunca es ciento.

  3. @e(Los patrones de diseño estan menos especializados que los frameworks.)
     Los frameworks siempre tienen un dominio de aplicaciones concreto. Un
     editor grafico se puede usar en una simulacion de una fabrica, pero nadie
     lo tomara por un framework de simulacion. Sin embargo, los patrones de
     diseño de este catalogo se pueden usar en praciticamente cualquier tipo de
     aplicacion. Aunque es posible tener patrones de diseño mas especializados
     que los nuestros (como, por ejemplo, patrones de diseño para programacion
     concurrente), incluso estos no imponen una arquitectura de aplicacion como
     haria un framework.


  Los frameworks se estan convirtiendo en algo cada vez mas comun e importante.
  Son el modo en que los sistemas orientados a objetos consiguen la mayor
  reutilizacion. Las aplicaciones orientadas a objetos mas grandes terminaran
  consistiendo en capas de framework que cooperan unos con otros. La mayoria del
  diseño y del codigo de una aplicacion vendra dado o estara influido por los
  frameworks que utilice.

** 1.7 <> Como seleccionar un patron de diseño

  Con mas de 20 patrones de diseño para elegir en el catalogo, puede ser dificil
  encontrar aquel que resuelva un problema de diseño concreto, especialmente si
  el catalogo es nuevo y desconocido para el lector. A continuacion se muestran
  diferentes enfoques para encontrar el patron de diseño que se adecue a su
  problema:

  - @e(Considere como los patrones de diseño solucionan problemsa de diseño.) En
    la @l(#1.6<>Seccion 1.6) se vio como los patrones de diseño ayudan a
    encontrar los objetos apropiados, a determinar la granularidad, a
    especificar interfaces de objetos y otros aspectos en los que los patrones
    ayudan a resolver problemas de diseño. Consultar estas discuciones puede
    ayudarle a guiar su busqueda del patron adecuado.

  - @e(Hojee las secciones Proposito.) La  @l(#1.4<>Seccion 1.4) enumera las
    secciones @e(Proposito) de todos los patrones del catalogo. Lea el proposito
    de cada patron para encontrar uno o varios que parezcan relevantes para su
    problema. Puede usar el esquema de clasificacion de la @l(#Tabla 1.1) para
    guiar su busqueda.

  - @e(Estudie como se interrelacionan los patrones.) La @l(#Figura 1.1) muestra
    graficamente las relaciones entre los patrones de diseño. Estudiar dichas
    relaciones puede ayudarle a dirigirse al patron o grupo de patrones de
    diseño. Estudiar dichas relaciones puede ayudarle a dirigirse al patron o
    grupo de patrones apropiado.

  - @e(Estudie patrones de proposito similar.) El @l(#Catalogo de Patrones de
    Diseño<>Catalogo) tiene tres capitulos: uno para patrones de creacion, otro
    para los patrones estructurales y un tercero para patrones de comportamiento.
    Cada capitulo comienza con unos comentarios de introduccion sobre los
    patrones y termina con una seccion que los compara y contrasta. Estas
    secciones le ayudan a comprender las similitudes y diferencias entre
    patrones de proposito similar.

  - @e(Examine una causa de rediseño.) Observe las causas de rediseño que
    comienzan en la seccion @l(#Diseñar para el cambio) para ver si su problema
    involucra a una o varias de ellas. Una vez hecho eso, vea los patrones que
    ayudan a evitar las causas de rediseño.

  - @e(Piense que deberia ser variable en su diseño.) Este enfoque es el opuesto
    a centrarse en las causas de rediseño. En vez de tener en cuenta que podria
    forzar un cambio en el diseño, piense en que quiere que @e(pueda) ser
    cambiado sin necesidad de rediseñar. Se trata de centrarse en encapsular el
    concepto que puede variar, un tema comun a muchos patrones de diseño. la
    @l(#Tabla 1.2) enumera los aspectos de diseño que los patrones permiten
    variar de forma independiente, es decir, sin rediseño.


  ..figure > @t(Tabla 1.2): Aspectos de diseño que los patrones de diseño
             permiten modificar

    +-------------------+-------------------------+---------------------------------------------------------+
    | Proposito         | Patrones de diseño      | Aspectos que pueden variar                              |
    +===================+=========================+=========================================================+
    | De Creacion       | Abstract Factory        | la familia de los objetos producidos                    |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Builder                 | como se crea un objeto compuesto                        |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Factory Method          | la subclase del objeto que es instanciado               |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Prototype               | la clase del objeto que es instaciado                   |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Singleton               | la unica instancia de una clase                         |
    +-------------------+-------------------------+---------------------------------------------------------+
    | Estructurales     | Adapter                 | la interfaz de un objeto                                |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Bridge                  | la implementacion de un objeto                          |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Composite               | la estrucutar y composicion de un objeto                |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Decorator               | las responsabilidades de un objeto sin usar la herencia |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Facade                  | la interfaz de un subsistema                            |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Flyweight               | el coste de almacenamiento de los objetos               |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Proxy                   | como se accede a un objeto; su ubicacion                |
    +-------------------+-------------------------+---------------------------------------------------------+
    | De comportamiento | Chain of Responsibility | el objeto que puede satisfacer una peticion             |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Command                 | cuando y como se satisface una peticion                 |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Interpreter             | la gramatica e interpretacion de un lerguage            |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Iterator                | como se recorren los elementos de un agregado           |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Mediator                | que objetos interactuan entre si, y como                |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Memento                 | que informacion privada se almacena fuera de un objeto  |
    |                   |                         | y cuando                                                |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Observer                | el numero de objetos que dependen de otro;              |
    |                   |                         | como se mantiene actualizado el objeto dependiente      |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | State                   | el estado de un objeto                                  |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Strategy                | un algoritmo                                            |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Template Method         | los pasos de un algoritmo                               |
    |                   +-------------------------+---------------------------------------------------------+
    |                   | Visitor                 | las operaciones que pueden aplicarse a objetos sin      |
    |                   |                         | cambiar sus clases                                      |
    +-------------------+-------------------------+---------------------------------------------------------+


** 1.8 <> Como usar un patron de diseño

  Una vez que haya elegido un patron de diseño, ¿como usarlo? Lo que sigue a
  continuacion es un enfoque paso a paso para aplicar un patron de diseño de
  manera efectiva:

  1. @e(Lea el patron de principio a fin para tener una perspectiva.) Preste
     patircular atencion a las secciones de Aplicabilidad y Consecuencias para
     asegurarse de que el patron es el adecuado para su problema.

  2. @e(Vuelva atras y estudie las secciones Estructura, Participantes y
     Colaboraciones.) Asegurese de entender las clase y objetos del ptaron y
     como se relacionan entre ellos.

  3. @e(Examine la seccion Codigo de Ejemplo para ver un ejemplo concreto del
     patron en codigo.) Estudiar el codigo ayuda a entender como implementar el
     patron.

  4. @e(Elija nombres significativos en el contexto de la aplicacion para los
     participantes en el patron.) Los nombres de los participantes de los
     patrones de diseño normalmente son demasiado abstractos como para aparecer
     directamente en una aplicacion. Sin embargo, es util incorporar el nombre
     del participante en el nombre que aparece en la aplicacion. Eso ayuda a
     hacer el patron mas explicito en la implementacion. Por ejemplo, si usa el
     patros Strategy para un algoritmo de composicion de texto, es posible que
     tenga las clases @c(EstrategiaComposicionSimple) o
     @e(EstrategiaComposicionTeX).

  5. @e(Defina las clases). Declare sus interfaces, establezca sus relaciones de
     herencia y defina las variables de instancia que representan datos y
     referencias de objetos. Identifique las clases existentes en su aplicacion
     a las que afectara el patron y modifiquelas en consecuencia.

  6. @e(Defina nombres especificos de la aplicacion para las operaciones del
     patron.) Los nombres generalmente dependen de la aplicacion. Use las
     responsabilididades y colaboraciones asociadas con cada operacion como una
     guia. Tambien debe ser coherente en sus convenciones de nombres. Por
     ejemplo, podria usar el prefico @"c(Crear-) de forma constante para denotar
     un metodo de fabricacion.

  7. @e(Implemente las operaciones para llevar a cabo las responsabilidades y
     colaboraciones del patron.) La seccion Implementaciones ofrece pistas que
     le guiaran en la implementacion. Tambien pueden serle de ayuda los ejemplos
     de la seccion Codigo de Ejemplo.


  Estas son solo unas directrices generales que le pueden servir para empezar. A
  medida que pase el tiempo desarrollara su propio metodo para trabajar con
  patrones de diseño.

  Ninguna discusion sobre como usar patrones de diseño estara completa sin unas
  pocas palabras sobre como @e(no) usarlos. Los patrones de diseño no deberian
  ser aplicados indiscriminadamente. Muchas veces estos consiguen la
  flexibilidad y la variabilidad a costa de introducir niveles adicionales de
  indireccion, y eso puede complicar un diseño o disminuir el rendimiento. Un
  patron solo deberia ser aplicado cuando la flexibilidad que proporcione sea
  realmente necesaria. Las secciones de Consecuencias son las mas variosas a la
  hora de evaluar los beneficios y los costes de un patron.

* Capitulo 2 <> Un Caso de estudio: diseñando un editor de documentos

  Este capitulo presenta un caso de estudio consistente en el diseño de un
  editor de documentos @e(What-You-See-Is-What-You-Get)@n(7) (o @"(WYSIWYG))
  llamado @b(Lexi).@n(8) Veremos como los patrones de diseño representan
  soluciones a problemas de diseño de Lexi y otras aplicaciones similares. Al
  final del capitulo habra experimentado con ocho patrones, aprendiendolos
  mediante ejemplos.

  La @l(#Figura 2.1) muestra la interfaz de usuario de Lexi. Una representacion
  WYSIWYG del documento ocupa el area rectangular grande del centro. El
  documento puede combinar el texto y graficos con diferentes estilos de
  formateado. Alrededor del documento estan los tipicos menus desplegables y
  barras de desplazamiento, mas una serie de iconos de pagina que permiten ir a
  una determinada pagina del documento.

  ..figure > @t(Figura 2.1): La interfaz de usuario de Lexi

    ..img  > img/009.png

** 2.1 <> Problemas de diseño

  A continuacon examinaremos siete problemas del diseño de Lexi:

  1. @e(Estructura de los documentos.) La eleccion de la representacion interna
     del documento afecta a practicamente todos los aspectos del diseño de
     Lexi. Tanto la edicion como el formateado, visualizacion y analisis del
     texto necesitaran recorrer dicha representacion. La manera en que
     organicemos esta informacion influira, por tanto, en el resto de la
     aplicacion.

  2. @e(Formateado.) ¿Como coloca realmente lexi el toxto y los graficos en
     lineas y columnas? ¿Que objetos son responsables de llevar a cabo las
     diferentes politicas de formateado? ¿Como interactuan estas con la
     representacion interna del documento?

  3. @e(Adornos de la interfaz de usuario.) La interfaz de usuario de Lexi
     incluye barras de desplazamiento, bordes y sombras que mejoran la
     apariencia del documento WYSIWYG. Es probable que dichos elementos graficos
     cambien a medida que evolucione la interfaz, de hay la importancia de
     poderlos añadir y quitar facilmente, sin que esto afecte al resto de la
     aplicacion.

  4. @e(Permitir multiples estandares de interfaz de usuario.)@n(9) Lexi deberia
     poder adaptarse facilmente a diferentes estandares de interfaz de usuario,
     tales como Motif o Presentation Manager (PM), sin falta de grandes
     modificaciones.

  5. @e(Permitir multiples sistemas de ventanas.) Los distintos estandares de
     interfaz de usuario suelen estar implementados en sistemas de ventanas
     diferentes. El diseño de Lexi deberia ser tan independiente como fuera
     posible del sistema de ventanas.

  6. @e(Operaciones de usuario.) El usuario controla Lexi a traves de varios
     elementos de la interfaz, incluyendo botones y menus desplegables. La
     funcionalidad que hay tras estos elementos de la interfaz se encuentra
     repartida entre los objetos de la aplicacion. El objetivo es proporcionar
     un mecanismo uniforme tanto para acceder a esta funcionalidad dispersa como
     para deshacer sus efectos.

  7. @e(Comprobacion ortografica y separacion de palabras.) ¿Como permite Lexi
     operaciones de analisis tales como la comprobacion de palabras mal escritas
     o determinar los puntos donde debe insertarse un guion de separacion? ¿Como
     podemos minimizar el numero de clases que deben ser modificadas para añadir
     una nueva operacion de este tipo?


  Discutiremos estos problemas de diseño en las secciones siguientes. Cada
  problema tiene asociados una serie de objetivos, ademas de restricciones sobre
  como lograr dichos objetivos. Los objetivos y sus restricciones seran
  explicados en detalle antes de proponer una solucion concreta. El problema y
  su solucion ilustraran uno o mas patrones de diseño. La discusion de cada
  problema culminara con una breve introduccion a los patrones relevantes.

** 2.2 <> Estructura del documento

  Un documento al final no es mas que una disposicion de elementos graficos
  basicos, como caracteres, lineas, poligonos y otras formas. Estos elementos
  representan toda la informacion contenida en el documento. Sin embargo, el
  autor del documento no los suele ver como elmentos graficos, sino en terminos
  de la estructura fisica del documento @-(lineas, columnas, figuras, tablas y
  otras subestructuras).@n(10) A su vez, estas subestructuras tienen otras
  subestructuras propias, y asi sucesivamente.

  La interfaz de usuario de Lexi deberia permitir manipular estas subestructuras
  directamente. Por ejemplo, un usuario deberia ser capaz de manipular un
  diagrama como una unidad, en vez de como una coleccion de primitiva graficas
  individuales, o de poder referirse a una tabla como un todo y no como un
  amasijo de texto y graficos sin estructura. Esto contribuye a que la intenfaz
  de Lexi sea mas simple e intuitiva. Para que la implementacion tenga unas
  caracteristicas similares debemos elegir una representacion interna que se
  corresponda con la estructura fisica del documento.

  En concreto, la representacion interna deberia permitir lo siguiente:

  - Mantener las estructura fisica del documento, es decir, la disposicion de
    texto y graficas en lineas, columnas, tablas, etc.

  - Generar y presentar visualmente el documento.

  - Establecer una correspondencia entre las posiciones en pantalla y los
    elementos de la representacion interna. De esta manera. Lexi puede
    determinar a que se esta refiriendo el usuario cuando apunta a algo en la
    representacion visual.


  Ademas de estos objetivos hay una serie de restricciones. En primer lugar,
  deberiamos tratar uniformemente al texto y a los graficos. La interfaz de
  usuario permite añadir texto a los graficos y viceversa, por lo que deberiamos
  evitar tratar los graficos como un caso especial de texto, o el texto como un
  caso especial de grafico. de no hacerlo asi, acabaremos por tener mecanismos
  redundantes de formateado y manipulacion. Debe ser suficiente con un unico
  conjunto de mecanismos para el texto y los graficos.

  En segundo lugar, nuestra implementacion no deberia distinguir, en la
  representacion interna, entre elementos individuales y grupos de
  elementos. Lexi tendria que ser capaz de tratar de manera uniforme elementos
  simples y compuestos, permitiendo asi documentos todo lo complejos que se
  quiera. Por ejemplo, el decimo elemento de la linea cinco, columna dos, podria
  ser un caracter individual o un intricado diagrama con muchos subelementos. En
  la medida en que sepamos que dicho elemento puede dibujarse a si mismo y
  especificar sus dimenciones, su complejidad no influye en como y donde debe
  aparecer en la pagina.

  Sin embargo, opuesta a esta segunda restriccion esta la necesidad de analizar
  el texto para asuntos como los errores ortograficos y los puntos potenciales
  de division de palabras con guiones. Aunque normalmente no nos preocuparemos
  de si el elemento de una linea es un objeto simple o compuesto, a veces un
  analisis depende de los objetos que estan siendo analizados. Tiene poco
  sentido, por ejemplo, comprobar la ortografia de un poligono, o dividirlo con
  un guion al final de la linea. El diseño de la representacion interna deberia
  tener en cuenta estas y otras restricciones, potencialmente contradictorias.

*** Composicion Recursiva

  Una manera sencilla de representar jararquicamente informacion estructurada es
  mediante una tecnica denominada @b(composicion recursiva), que consiste en
  construir objetos cada vez mas complejas a partir de otros mas simples. La
  compasicion recursiva nos da la posibilidad de componer un documento a partir
  de elementos graficos. Como primer paso, podemos disponer una serie de
  caracteres y graficos de izquierda a derecha para formar una linea del
  documento. Despues, podemos colocar varias lineas formando una columna, varias
  columnas formando una pagina, y asi sucesivamente (vease la Figura 2.2).

  ..figure > @t(Figura 2.2): Composicion recursiva de texto y graficos

    ..img  > img/010.png

  Podemos representar esta estructura fisica dedicando un objeto para cada
  elemento importante. Eso incluye no solo los elementos visibles como
  caracteres y graficos, sino tambien los elementos estructurales, invisibles
  @-(lineas y columnas). El resultado es la estructura de objetos mostrada en la
  Figura 2.3.

  ..figure > @t(Figura 2.3): Estructura de objetos para la compososicion
    recursiva de toxto y graficos

    ..img  > img/011.png

  Al utilizar un objeto para cada caracter y elemento grafico del documento,
  estamos llevando la flexibilidad en el diseño de Lexi a su grado maximo.
  Podemos tratar al texto y a los graficos de manera uniforme con respecto a como
  se dibujan, se formatean y se insertan unos en otros. Y podemos ampliar Lexi
  para que admita nuevos juegos de cararteres sin afectar al resto de la
  funcionalidad. La estructura de objetos de Lexi mimetiza la estructura del
  documento fisico.

  Este enfoque tiene dos repercusiones importantes. La primera es obvia: los
  objetos necesitan sus correspondientes clases. La segunda, que puede resultar
  menos evidente, es que estas clases deben tener interfaces compatibles, ya que
  queremos tratar uniformemente a los objetos. La manera de hacer que las
  interfaces sean compatibles en un lenguaje como C++ es relacionar las clases a
  traves de la herencia.

*** GLIFOS@n(11)

  Definiremos una clase abstracta @c(Glifo) para todos los objetos que pueden
  aparecer en la estructura de un documento.@n(12) Sus subclases definen tanto
  elementos graficas primitivos (por ejemplo, caracteres e imagenes) como
  elementos estructurales (por ejemplo, filas y columnas). La Figura 2.4
  muestra una parte representativa de la jerarquia de las clases @c(Glifo), y la
  @l(#Tabla 2.1) presenta la interfaz basica de un glifo mas detalladamente,
  empleando notacion C++.@n(13)

  ..figure > @t(Figura 2.4): Parte de la jerarquia de clases de @c(Glifo)

    ..img  > img/012.png

  ..figure > @t(Tabla 2.1) Interfaz basica de un glifo

    +-----------------+------------------------------------------+
    | Responsabilidad | Operaciones                              |
    +=================+==========================================+
    | Apariencia      | @c[virtual void Dibujar(Ventana*)]       |
    |                 +------------------------------------------+
    |                 | @c[virtual void Limites(Rect&)]          |
    +-----------------+------------------------------------------+
    | detectar cortes | @c[virtual bool Interseca(const Punto&)] |
    +-----------------+------------------------------------------+
    | estructura      | @c[virtual void Insertar(Glifo*, int)]   |
    |                 +------------------------------------------+
    |                 | @c[virtual void Borrar(Glifo*)]          |
    |                 +------------------------------------------+
    |                 | @c[virtual Glifo* Hijo(int)]             |
    |                 +------------------------------------------+
    |                 | @c[virtual Glifo* Padre()]               |
    +-----------------+------------------------------------------+

  Los glifos tiene tres responsabilidades basicas: (1) saber como dibujarse a si
  mismos, (2) que espacio ocupan y (3) cuales son sus hijos y su padre.

  Las subclases de @c(Glifo) redefinen la operacion @c(Dibujar) para
  visualizarse en una ventana, pasandoles en la llamada a @c(Dibujar) una
  referencia al objeto @c(Ventana). La clase @c(Ventana) define operaciones
  graficas para visualizar texto y figuras basicas en una ventana de la
  pantalla. Una subclase @c(Rectangulo) puede definir @c(Dibujar) como sigue:

  ..src > c++
    void Rectangulo::Dibujar (Ventana* v) {
      v->DibujarRect(_x0, _y0, _x1, _y1);
    }
  < src..

  donde @c(_x0), @c(_y0), @c(_x1), @c(_y1) son datos miembro de @c(Rectangulo)
  que definen dos esquinas opuestas del rectangulo. @c(DibujarRectangulo) es la
  operacion de @c(Ventana) que hace que el rectangulo aparezca en la pantalla.

  Un glifo padre muchas veces necesita saber cuanto espacio ocupa uno de sus
  hijos, por ejemplo para situarlo junto con otros glifos en una linea de manera
  que no se solapen (como se muestra en la @l(#Figura 2.2)). La operacion
  @c(Limites) devuelve el area rectangular que ocpua el glifo, es decir, las
  equinas opuestas del rectangulo mas pequeño que lo contiene. Las subclases de
  @c(Glifo) redefinen esta operacion para devolver el area rectangular en que se
  inscriben.

  La operacion @c(Interseca) comprueba si un punto concreto corta al glifo. Cada
  vez que el usuario hace clic en algun punto del documento, Lexi llama a esta
  operacion para determinar que figura (o estructura de figuras) esta situada
  bajo el cursol del raton. La clase @c(Rectangulo) redefine esta operacion para
  calcular la interseccion del rectangulo y el punto especifico.

  Puesto que los glifos pueden tener hijos, necesitamos una interfaz comun para
  añadir, borrar y acceder a dichos hijos. Por ejemplo, los hijos de una @c(Fila)
  son los glifos que esta coloca en una fila. La operacion @c(Insertar) inserta
  un glifo en la posicion especificada por un indice entero.@n(14). La operacion
  @c(Borrar) borra la figura especificada en caso de que realmente se trate de
  un hijo.

  La operacion @c(Hijo) devuelve el hijo de la posicion indicada, si es que
  existe. Los glifos que, como @c(Fila) Pueden tener hijos, deberian usar la
  operacion @c(Hijo) internamente, en vez de acceder directamente a la
  estructura de datos donde se encuentran estos. De esa manera no habra que
  modificar operaciones como @c(Dibujar) que iteran atraves de los hijos cuando
  se cambie la estructura de datos de, por ejemplo, un array a la lista
  enlazada. De manera similar, @c(Padre) proporciona una interfaz estandar al
  padre de glifo, si es que existe. En lexi los glifos tienen una referencia a
  su padre, y su operacion @c(Padre) simplemente devuelve dicha referencia.

*** Patron Composite

  La composicion recursiva no solo es util para los documentos. Tambien la
  podemos usar para representar cualquier estructura jerarquica potencialmente
  compleja. El patron @l(#Composite) representa la esencia de la composicion
  recursiva en terminos de orientacion a objetos. Este podria ser un buen
  momento para acudir a ese patron y estudiarlo, volviendo a este escenario
  cuando sea necesario.

** 2.3 <> Formateando

  Ya nos hemos puesto de acuerdo sobre el modo de @e(representar) la estructura
  fisica de un documento. Ahora necesitamos saber como construir una estructura
  fisica en @e(particular), es decir, una que corresponda a un documento
  concreto, correctamente formateado. La representacion y el formateado son
  diferentes: la capacidad de representar la estructura fisica del documento no
  nos dice como llegar a una estructura concreta. Esta responsabilidad recae
  principalmente en Lexi. Es el quien debe separar el texto en lineas, las
  lineas en columnas y asi sucesivamente, teniendo en cuenta los deseos del
  usuario. Por ejemplo, este puede querer variar la anchura de los margenes, el
  sangrado y las tabulaciones, interlineado sencillo o doble, y probablemente
  muchas otras restricciones de formateado.@n(15) El algoritmo de formateado de
  Lexi debe tener en cuenta todas estas cosas.

  Por cierto, restringiremos el termino @"(formateado) para referirnos a la
  separacion de glifos en lineas. De hecho, usaremos los terminos @"(formateado)
  y @"(separacion de lineas) como sinonimos. Las tecnicas que veremos se aplican
  por igual a la separacion de las lineas en columnas y a la separacion de
  columnas en paginas.

*** Encapsulacion del algoritmo de formateado

  El proceso de formateado, con todos sus detalles y restricciones, no es facil
  de automatizar. Hay muchas aproximaciones al problema, y la gente ha ideado
  una variedad de algoritmos de formateado con diferentes puntos fuertes y
  debiles. Dado que Lexi es un editor WYSYWYG, una cuestion importante a tener
  en cuenta es el equilibrio entre calidad y velocidad de formateado.
  Generalmente queremos una buena respuesta del editor sin sacrificar la
  apariencia del documento. Este equilibrio depende de muchos factares, no todos
  los cuales pueden determinarse en tiempo de compilacion. Por ejemplo, el
  usuario puede tolerar una respuesta ligeramente mas lenta si a cambio obtiene
  un formateado mejor. Esto puede hacer que sea mas apropiado un algoritmo de
  formateado distinto del original. Otro equilibrio, mas orientado a la
  implementacion, es que se pueda establecer entre la velocidad de formateado y
  los requisitios de almacenamiento: tal vez sea posible reducir el tiempo de
  formateado guardando mas informacion.

  Como los algoritmos de formateado tienden a ser complicados, tambien es
  deseable mantenerlos contenidos o @-(mejor aun) que sean completaente
  independientes de la estructura del documento. Idealmente, podriamos añadir una
  nueva subclase de Glifo sin depender del algritmo de formateado. A la inversa,
  añadir un nuevo algoritmo de formateado no deberia requerir modificar los
  glifos existentes.

  Estas caracteristicas sugieren que deberiamos diseñar Lexi para que sea facil
  cambiar el algoritmo de formateado, al menos en tiempo de compilacion, si no
  en tiempo de ejecucion. Podemos aislar el algoritmo y a la vez hacer que sea
  facilmente reemplazable encapsulandolo en un objeto. Mas concretamente,
  definiremos una jerarquia de clases separada para los objetos que encapsulan
  algoritmos de formateado. La raiz de la jerarquia definira una interfaz que
  soporta una gran variedad de algoritmos de formateado, y cada subclase
  implementara la interfaz para llevar a cabo un algoritmo concreto. Luego
  podemos introducir una subclase de @c(Glifo) que estructurara sus hijos
  automaticamente usando un objeto algoritmo dado.

*** Componedor y composicion

  Definiremos una clase @c(Componedor) para los objetos que pueden encapsular un
  algoritmo de formateado. La interfaz (@l(#Tabla 2.2)) permite que el componedor
  sepa @e(que) glifos formatear y @e(cuando) hacer el formateado. Los glifos que
  formatea son los hijos de una subclase especial de @c(Glifo) llamada
  @c(Composicion), que obtiene una instancia de una subclase @c(Componedor)
  (especializada para un algoritmo concreto de separacion de lineas) cuando se
  crea y le ordena al componedor @c(Componer) sus glifos cuando sea necesario
  (por ejemplo, cuando el usuario cambia de documento). La @l(#Figura 2.5)
  muestra las relaciones entre las clases @c(Composicion) y @c(Componedor).

  ..figure > @t(Tabla 2.2) Interfaz de un conponedor basicos

    +-------------------+-----------------------------------------------+
    | Responsabilidades | Operaciones                                   |
    +===================+===============================================+
    | que formatear     | @c{void EstablecerComposicion( Composicion*)} |
    +-------------------+-----------------------------------------------+
    | cuando formatear  | @c{virtual void Componer()}                   |
    +-------------------+-----------------------------------------------+


  ..figure > @t(Figura 2.5): Relaciones entre las clases @c(Composicion) y @c(Componer)

    ..img  > img/013.png


  Un objeto @c(Composicion) sin formatear solo contiene los glifos visibles que
  constituyen el contenido basico del documento. No contiene glifos que
  determinan la estructura fisica del documento, tales como @c(Fila) y
  @c(Columna). La composicion se encuentra en este estado justo despues de ser
  creada e inicializada con los glifos que deberia formatear. Cuando necesita
  ser formateada, llama a su operacion @c(Componer). A su vez el componedor itera
  atraves de los hjos de la composicion e inserta nuevos glifos @c(Fila) y
  @c(Columna) en funsion de su algoritmo de separacion de lineas.@n(16) La
  @l(#Figura 2.6) muestra la estructura de objetos resultante. Los glifos que
  han sido creados e insertados en la estructura de objetos por el componedor
  aparecen con fondo gris en la figura.

  ..figure > @t(Figura 2.6): Estructura de objetos que muestra el interlineado
    dirigido por un componedor

    ..img  > img/014.png

  Cada subclase de @c(Componedor) puede implementar un algoritmo diferente
  de separacion de lineas. Por jemplo un @c(ComponenteSimple) puede hacer una
  pasada rapida sin preocuparse de cuestiones como el @"(color) del
  documento. Un buen color significa que el documento tiene una distribucion
  uniforme del texto y espacios en blanco. Un @c(ComponendorTeX) implementaria el
  algoritmo @b(TeX) [@l(#Knu84)] completo, que tiene en cuenta cosas como el color a
  cambio de mayores tiempos de formateado.

  Tener dos clase distintas @c(Componedor) y @c(Composicion) garantiza una gran
  separacion entre el codigo correspodiente a la estructura fisica del documento
  y el que lleva a cabo diferentes algoritmos de formateado. Podemos añadir
  nuevas subclases de @c(Componedor) sin tocar las clases de glifos, y
  viceversa. De hecho, podemos cambiar el algoritmo de separacion de lineas en
  tiempo de ejecucion añadiendo una unica operacion @c(EstablecerComponedor) a
  la interfaz basica de un glifo @c(Composicion).

*** Patron Strategy (Estrategia)

  El proposito del patron @c(Strategy) es encapsular un algoritmo de un
  objeto. Los participantes principales en este patron son los objetos
  @c(Estrategia) (que encapsulan diferentes algoritmos) y el contexto en el que
  estos operan. Los componedores son estrategias que encapsulan diferentes
  algoritmos de formateado. Una composicion representa el contexto de estas
  estrategias.

  La clave para aplicar el patron @c(Strategy) es diseñar interfaces para la
  estrategia y su contexto que sean lo suficientemente generales como para
  permitir diversos algoritmos. No deberiamos tener que cambiar la interfaz de
  la estrategia o de su contexto para dar cabida a un nuevo algoritmo. En
  nuestro ejemplo, la capacidad de la interfaz basica de un @c(Glifo) para
  acceder a sus hijos, insertarlos y borrarlos es lo bastante general como para
  que las subclases de @c(Componedor) cambien la estructura fisica del
  documento, independientemente del algoritmo que usen para hacerlo. Asi mismo,
  la interfaz de @c(Componedor) ofrece a las composiciones todo lo que necesitan
  para empezar el formateado.

** 2.4 <> Adornar la interfaz de usuario

  Hemos considerado dos adornos para la interfaz de usuario de Lexi. El primero
  añade un borde alrededor del area de edicion de texto para delimitar la
  pagina. El segundo añade barras de desplazamiento que permite al usuario ver
  diferentes partes de la pagina. Para que sea facil añadir y borrar estos
  adornos (especialmente en tiempo de ejecucion) no deberiamos usar la herencia
  para añadirlos a la interfaz de usuario. Conseguiremos la maxima flexibilidad
  si otros objetos de la interfaz de usuario ni siquiera son concientes de la
  presencia de esos adornos, lo que nos permitira añadirlos y borrarlos sin
  cambiar otras clases.

*** Recinto Transparente@n[17]

  Desde un punto de vista programatico, mejorar el aspecto de la interfaz de
  usuario implica ampliar el codigo existente. Usar la herencia para realizar
  dicha extension impide cambiar los adornos en tiempo de ejecucion, pero este
  enfoque presenta ademas otro problema igual de importante, como es la
  explosion de clases a la que puede dar lugar.

  Podriamos añadir un borde a @c(Composicion) heredando de ella para obtener
  clase @c(ComposicionConBorde), o añadir una interfaz de desplazamiento de la
  misma manera para dar lugar a una clase @c(ComposicionDesplazable). Si
  quisieramos tanto las barras de desplazamiento como un borde, podriamos tener
  una @c(ComposicionDesplazableConBorde), y asi sucesivamente. Llevandolo al
  extremo, acabariamos por tener una clase para cada posible combinacion, una
  solucion que rapidamente se convierte en impracticable en cuanto aumente el
  numero de adornos.

  La composicion de objetos ofrece un mecanismo de aplicacion mas viable y
  extensible. Pero, ¿que objetos componemos? Puesto que sabemos que estamos
  adornando un glifo existente, podriamos hacer que el propio adorno fuese un
  objeto (por ejemplo, una instancia de la clase @c(Borde)). Eso nos da dos
  candidatos para la composicion: el glifo y el borde. El paso siguiente es
  decir quien contiene a quien. Podriamos hacer que el borde contenga el glifo,
  lo que tiene sentido dado que el borde rodeara al glifo en la pantalla. O
  podriamos hacer lo contrario @-(poner el borde dentro del glifo), pero
  entonces tenemos que hacer modificaciones a las correspondientes subclases de
  @c(Glifo) para que sean concientes del borde. Nuestra primer eleccion,
  introducir el glifo en el borde, mantiene el codigo que se encarga de dibujar
  el borde enteramente en la clase @c(Borde), dejando las otras clases intactas.

  ¿A que se parece la clase @c(Borde)? El hecho de que los bordes tengan
  representacion visual sugiere que deberian ser glifos; es decir, que el borde
  deberia ser una subclase de @c(Glifo). Pero hay una razon mas convincente de
  que estos tengan bordes o no. Cuando los clientes le dicen a un glifo normal,
  sin borde, que se dibuje, este deberia hacerlo sin ningun tipo de adorno. Si
  ese glifo esta dentro de un borde, los clientes no deberian tener que tratar
  de modo diferente al borde que lo contiene, sino que simplemente le diran que
  se dibuje, igual que se lo dijeron antes al glifo normal. Esto implica que la
  interfaz de @c(Borde) debe coincidir con la de @c(Glifo), por lo que heredamos
  @c(Borde) de @c(Glifo) para garantizar dicha relacion.

  Todo esto nos lleva al concepto de @b(recinto trasparente), que auna las
  nociones de (1) composicion de un unico hijo (o componente individual) y (2)
  interfaces compatibles. Generalmente los clientes no saben si estan tratando
  con un componente o con su @b(recinto) (es decir, su padre), sobre todo si
  este no hace mas que delegar en su componente todas sus operaciones. Pero el
  recinto tambien puede @e(aumentar) el comportamiente del componente haciendo
  tareas propias antes y despues de delagar una operacion. Asi mismo, puede
  tambien añådir estado al componente. A continuacion veremos como.

*** Monoglifo

  Podemos aplicar el concepto de recinto transparente a todos los glifos que
  pueden adornar a otros. Para concretar este concepto, definiremos una subclase
  de @c(Glifo) llamada @c(MonoGlifo), que servira de clase abstracta para los
  @"(glifos de adorno), como @c(Borde) (vease la Figura 2.7). @c(MonoGlifo)
  guarda una referencia a un componente y reenvia todas las peticiones a el.

  ..figure > @t(Figura 2.7): Relaciones de la clase @c(MonoGlifo)

    ..img  > img/015.png

  Eso hace que, por omision, @c(MonoGlifo) sea totalmente trasparente a los
  clientes. Por ejemplo, @c(Monoglifo) implementa la operacion @c(Dibujar) como
  sigue:

  ..src > c++
    void MonoGlifo::Dibujar (Ventana* v) {
      _componente->Dibujar(v);
    }
  < src..

  Las subclases de @c(MonoGlifo) reimplementan al menos una de estas operaciones
  de reenvio. @c(Borde::Dibujar), por ejemplo, primero invoca a la operacion de
  la clase padre del componente, @c(MonoGlifo::Dibujar), para que el componente
  haga su parte, es decir, dibujar todo menos el borde. Despues,
  @c(Borde::Dibujar) dibuja el borde llamado a una operacion privada
  @c(DibujarBorde), cuyos detalles omitiremos:

  ..src > c++
    void Borde::Dibujar (Ventana* v) {
      MonoGlifo::Dibujar(v);
      DibujarBorde(v);
    }
  < src..

  Notese como @c(Borde::Dibujar) efectivamente @e(extiende) la operacion de la
  clase padre para dibujar el borde, en vez de simplemente @e(reemplazar) la
  operacion de la clase padre, lo que omitiria la llamada a
  @c(MonoGlifo::Dibujar).

  Otra subclase de @c(MonoGlifo) aparece en la @l(#Figura 2.7).
  @c(Desplazamiento)@n(18) es un @c(MonoGlifo) que dibuja a su componente
  en diferentes ubicaciones basandose en la posicion de las dos barras de
  desplazamiento que le añade como adornos. El @c(Desplazamiento), al dibujar su
  componente, le dice al sistema de graficos que lo ajuste a sus limites. Al
  recortar las partes del componente que estan desplazadas fuera de la vista se
  evita que aparezcan en la pantalla.

  Ahora ya contamos con todas las piezan necesarios para añadir un borde y una
  interfaz de desplazamiento al area de edicion de texto de Lexi. Para ello,
  compondremos la instancia existente de @c(Composicion) en una instancia de
  @c(Desplazamiento), para añadir la capacidad de desplazamiento, y el resultado
  lo compondremos en una instancia de Borde. La estructura de objetos resultante
  es la que se muestra en la Figura 2.8.

  ..figure > @t(Figura 2.8): Estructura de objetos con los adornos

    ..img  > img/016.png

  Notese que podemos cambiar el orden de la composicion, poniendo la composicion
  con el borde en la instancia de @c(Desplazamiento). En ese caso el borde se
  desplazaria con el texto, lo cual puede ser o no deseable. La cuestion es que
  el recinto transparente hace que sea facil experimentar con diferentes
  alternativas, liberando a los clientes el codigo de adorno.

  Es tambien importante notar como el borde compone un solo glifo, y no dos o
  mas. Esto es diferente de las composiciones que definimos antes en las que los
  objetos padre podian tener un numero arbitrario de hijos. Aqui, poner un borde
  alrededor de algo implica que ese @"(algo) es singular. Podriamos dar un
  significado a adornar mas de un objeto a la vez, pero entonces tendriamos que
  mezclar mucho tipos de composicion con la nocion de adorno: adorno de fila, de
  columna, etcetera. Eso no nos seria de ayuda, puesto que ya tenemos clases que
  hacen ese tipo de composiciones. Asi que es mejor usar las clases existentes
  para la composicion y añadir nuevas clases para adornar el resultado. Mantener
  los adornos independientes de otros tipos de composicon simplifica las clases
  que se encargan de los adornos y reduce su numero. Tambien nos evita tener que
  replicar la funcionalidad de composicion existente

*** Patron Decorator (Decorador)

  El patron @l(#Decorator) expresa las relaciones de clases y objetos que
  permiten decorar la interfaz mediante los recintos transparentes. El termino
  @"(decoracion) en realidad tiene un significado mas amplio que el que hemos
  considerado aqui. En el patron Decorator, la decoracion se refiere a cualquier
  cosa que añada responsabilididades a un objeto. Podemos pensar, por ejemplo,
  en adornar un arbol sintactico abstacto con acciones semanticas, un
  automata de estados finitos con nuevas transiciones, o una red de objetos
  persistentes con nuevas etiquetas de atributos. El patron Decorator generaliza
  el enfoque que hemos seguido en Lexi para hacerlo aplicable en otros ambitos.

** 2.5 <> Permitir multiples estandares de interfaz de usuario

  Conseguir portabilidad entre plataformas hardware y software es uno de los
  principales problemas del diseño de sistemas. Adaptar Lexi a una nueva
  plataforma no deberia requerir una revision a fondo, o de lo contrario no
  mereceria la pena la adaptacion. Debemos hacer que portar el sistema sea lo
  mas facil posible.

  Un obstaculo para conseguir la portabilidad es la variedad de estandares de
  interfaz de usuario existentes, pensados para imponer una uniformidad entre
  las distintas aplicaciones. Estos estandares definen directrices sobre la
  apariencia de las aplicaciones y como estas reaccionan ante el usuario. Aque
  los estandares existen no son tan diferentes entre si, lo cierto es que nadie
  los confudira @-(las aplicaciones para Motif no tienen exactamente el mismo
  aspecto que sus homolagas en otras plataformas, y viceversa). Una aplicacion
  que ese ejecuta en mas de una plataforma debe ajustarse a la guia de estilo de
  interfaces de usuario de cada una de ellas.

  Nuestros objetivos de diseño son hacer que Lexi se ajuste a multiples
  estandares de unterfaz de usuario y que sea facil admitir otros nuevos a
  medida que vayan surgiendo (como invariablemente sucedera). Tambien queremos
  que nuestro diseño tenga la maxima flexibilidad: que se pueda cambiar la
  interfaz de usuario de Lexi en tiempo de ejecucion.

*** Abstrayendo la creacion de objetos

  Cualquier cosa que veamos y con la que interactuemos en la interfaz de Lexi es
  un glifo combinado con otros glifos invisibles, como la @c(Fila) y
  @c(Columna). Los glifos invisibles componen a otros visibles, como @c(Boton) y
  @c(Caracter), y los ubican corretamente. Las guias de estilo tienen mucho que
  decir acerca de la apariencia y el comportamiento de los llamados
  @"(utiles)@n(19), otro termino con el que se designa a los glifos visibles,
  como botones, barras de desplazamiento y menus, que controlan los elementos de
  una interfaz de usuario. Los utiles podrian usar glifos mas sencillos como
  caracteres, circulos, rectangulos y poligonos para presentar los datos.

  Supondremos que tenemos dos conjuntos de clases de glifos de utiles con los
  que implementar multiples estandares de interfaz de usuario:

  1. Un conjunto de subclases abstractas de @c(Glifo) para cada categoria de
     glifo de util. Por ejemplo, una clase abstracta @c(BarraDeDesplazamiento)
     aumentara la interfaz de un glifo basico para añadir operaciones generales
     de desplazamiento; @c(Boton) es una clase abstracta que añade operaciones
     relacionadas con los botones; etcetera.

  2. Un conjunto de subclases concretas para cada subclase abstracta, las cuales
     implementan diferentes estandares de interfaz de usuario. Por ejemplo,
     @c(BarraDeDesplazamiento) podria tener las subclases
     @c(BarraDeDesplazamientoMotif) y @c(BarraDeDesplazamientoPM), que
     implementan barras de desplazamiento para Motif y Presentation Manager,
     respectivamente.

  Lexi debe distinguir entre los glifos de utiles para diferentes estilos de
  interfaces de usuario. Por ejemplo, cuando necesita colocar un boton en su
  interfaz, debe crear una instancia de una subclase de @c(Glifo) con el estilo
  adecuado de boton (@c(BotonBoton), @c(BotonPM), @c(BotonMac), etc.).

  Esta claro que la implementacion de Lexi no puede hacer esto directamente (por
  ejemplo, mediente una llamada a un constructor de C++). Eso fijaria en el
  codigo el boton de un estilo concreto, haciendo imposible seleccionar el
  estilo en tiempo de ejecucion. Tambien tendramos que localizar cada llamada a
  dicho constructor y cambiarlas para portar Lexi a otra plataforma. Y los
  botones son solo uno de muchos utiles de los que consta la interfaz de usuario
  de lexi. Plagar nuestro codigo con llamadas a los constructores de las clases
  de una interfaz de usuario concreta da como resultado una pesadilla de
  mantenimiento, donde pasar por alto uno solo de estos costructores hara que
  nos encontremos un menu de Motif en medio de nuestra aplicacion para Mac.

  Lexi necesita un modo de determinar los estandares de interfaz de usuario a
  los que esta dirigido, para asi crear los utiles apropiados. No solo debemos
  evitar hacer llamadas explicitas a constructores; tambien debemos ser capaces
  de reemplazar un conjunto completo de utiles facilmente. Podemos lograr ambas
  cosas @e(abstrayendo el proceso de creacion de objetos). Un ejemplo ilustrara
  que queremos decir con esto.

*** Clases Fabrica y Producto

  Normalmente podemos crear una instancia de una barra de desplazamiento de
  Motif con el siguiente codigo C++:

  ..src > c++
    BarraDeDesplazamiento* barra = new BarraDeDesplazamientoMotif;
  < src..

  Esta es la clase de codigo que debemos evitar si queremos minimizar las
  dependencias de la interfaz de usuario en Lexi. Supongamos que inicializamos
  barra como sigue:

  ..src > c++
    BarraDeDesplazamiento* barra = FabricaIGU->CrearBarraDeDesplazamiento();
  < src..

  donde @c(fabricaIGU) es una instancia de la clase @c(FabricaMotif).
  @c(CrearBarraDeDesplazamiento) devuelve una instancia de la subclase correcta
  de @c(BarraDeDesplazamiento) para la interfaz de usuario deseada, en este caso
  Motif. En cuanto a los clientes, el efecto es el mismo que llamar directamente
  al constructor de @c(BarraDeDesplazamientoMotif), pero con una diferencia
  crucial: ya no hay nada en el codigo que haca referencia a Motif por su
  nombre. El objeto @c(fabricaIGU) abstrae el proceso de creacion no solo de
  barras de desplazamiento para Motif, sino de barras de desplazamiento para
  @e(cualquier) estandar de interfaz de usuario. y tampoco se limita a producir
  barras de desplazamiento, sino que puede fabricar una amplia variedad de
  utiles, incluyendo barras de desplazamiento, botones, campos de entrada,
  menus, etcetera.

  Todo esto es posible porque @c(FabricaMotif) es una subclase de
  @c(FabricaIGU), una clase abstracta que define una interfaz general para crear
  glifos de utiles. Incluye operaciones como @c(CreacBarraDeDesplazamiento) y
  @c(CrearBoton) para diferentes tipos de glifos de utiles (@e(widgets)). Las
  subclases de @c(FabricaIGU) implementan estas operaciones para devolver glifos
  tales como @c(BarraDeDesplazamientoMotif) y @c(BotonPM) que implementan una
  interfaz de usuario en concreto. La @l(#Figura 2.9) muestra la jerarquia de
  clases resultante para los objetos @c(fabricaIGU).

  ..figure > @t(Figura 2.9): Jerarquia de clases de @c(FabricaIGU)

    ..img  > img/017.png

  Decimos que las fabricas crean objetos @b(producto). Ademas, los productos
  creados por una fabrica se realacionan entre si; en este caso, los productos
  son todos utiles (@e(widgets)) con el mismo estilo de interfaz de usuario. La
  Figura 2.10 muestra algunas de las clases necesarias para que las fabricas
  trabajen con glifos de utiles.

  ..figure > @t(Figura 2.10): Clases abstractas de producto y subclases concretas

    ..img  > img/018.png

  La ultima cuestion a la que tenemos que responder es de donde viene la
  instancia de @c(FabricaIGU). La respuesta es que de cualquier sitio. La
  variable @c(fabricaIGU) pobria ser un miembro estatico de una clase conocida,
  o incluso una variable local si toda la interfaz de usuario se creara dentro
  de la misma clase o funcion. Hay un patron de diseño, el @l(#Sigleton), que
  permite tratar con objetos conocidos de los que solo ahy una instancia, como
  es este caso. Lo importante es inicializar @c(fabricaIGU) en un punto del
  programa que este @e(antes) de que se use por primera vez para crear utiles,
  pero @e(despues) de que este claro que interfaz de usuario se desea.

  Si la interfaz de usuario se conoce en tiempo de compilacion, @c(fabricaIGU)
  puede ser inicilizada con una simple asignacion de una nueva instancia de una
  fabrica al comienzo del programa:

  ..src > c++
    FabricaIGU* fabricaIGU = new FabricaMotif;
  < src..

  Si el usuario puede especificar la interfaz de usuario con un nombre al
  inicializar el programa, entonces el codigo para crear la fabrica podria ser
  el siguiente:

  ..src > c++
    FabricaIGU* fabricaIGU;
    const char* nombreEstilo = getenv(*INTERFAZ_DE_USUARIO*);
      // el usuario o el entorno lo proporciona al principio

    if (strcmp(nombreEstilo, "Motif") == 0) {
      fabricaIGU = new FabricaMotif;

    } else if (strcmp(nombreEstilo, "Presentation_Manager") == 0) {
      fabricaIGU = new FabricaPM;

    } else {
      fabricaIGU = new FabricaIGUPredeterminada;
    }
  < src..

  Hay formas mas sofisticadas de seleccionar la fabria en tiempo de ejecucion.
  Por ejemplo, podriamos tener un registro que hiciera corresponder cadenas de
  texto con objetos fabrica. Eso nos permitira registrar instancias de nuevas
  subclases de fabricas sin modificar el codigo existente, como requiere el
  enfoque anterior. y no tenemos que enlazar todas las fabricas dependientes de
  la plataforma en la aplicacion. Esto es importante, porque podria no ser
  posible enlazar una @c(FabricaMotif) en una plataforma que no admita Motif.

  Pero la clave es que una vez que hemos configurado la aplicacion con el objeto
  fabrica adecuado, a partir de entonces se activa su estilo de interfaz de
  usuario. Si cambiamos de idea, podemos reinicializar @c(fabricaIGU) con una
  fabrica para otro estilo de interfaz de usuario, y reconstruir entonces la
  interfaz. Independientemente de como y cuando decidamos inicializar
  @c(fabricaIGU), sabemos que una vez que lo hagamos la aplicacion puede crear la
  interfaz de usuario apropiada sin ninguna modificacion.

*** Patron Abstract Factory (Fabrica Abstracta)

  Las fabricas y los productos son los principales participantes del patron
  @l(#Abstract Factory). Este patron muestra como crear familias de objetos
  producto relacionados sin instanciar las clases directamente y hay diferencias
  entre las distintas familias de productos. Podemos elegir entre las distintas
  familias creando una instancia de una fabrica concreta y usandola de forma
  consistente para crear productos a partir de entonces. Tambien podemos cambiar
  familias completas de productos reemplazando la fabrica concreta con una
  instancia de otra diferente. La importancia que el patron Abstract Factory da
  a las @e(familias) de productos diferencia a este de otros patrones de
  creacion, que comprenden un solo tipo de objetos producto.

** 2.6 <> Permitir multiples sistemas de ventanas

  El estilo de la interfaz de usuario es solo una de las muchas cuestiones que
  tienen que ver con la portabilidad. Otra es el entorno de ventanas en el que
  se ejecuta Lexi. Un sistema de ventanas crea la ilusion de ventanas solapadas
  en una pantalla de mapa de bits. Tambien controla el espacio en pantalla para
  las ventanas y dirige hacia ellas la entrada del teclado y del raton.
  Actualemente existen varios sistemas de ventanas importantes y, en gran
  medida, incompatibles (por ejemplo, Macintosh, Presentation Manager, Windows,
  X). Nos gustaria que Lexi se ejecutase en tantos de ellos como fuese posible,
  por la misma razon por la que permitimos multiples estandares de interfaz de
  usuario.

*** Podemos usar una Fabrica Abstracta?

  A primera vista esto puede parecer otra ocasion para aplicar el patron
  Abstract Factory. Pero las restricciones en cuanto a la portabilidad del
  sistema de ventanas difieren significativamente de las de la independencia de
  la interfaz de usuario.

  En aquel caso, cuando aplicabamos el patron Abstract Factory estabamos
  asumiendo que definiriamos clases concretas de utiles para cada estandar de
  interfaz de usuario. Eso significaba que podriamos derivar cada producto
  concreto para un estandar en particular (por ejemplo,
  @c(BarraDeDesplazamientoMotif) y @c(BarraDeDesplazamientoMac)) de una clase de
  producto abstracta (por ejemplo, @c(BarraDeDesplazamiento). Pero supongamos
  que ya tenemos varias jerarquias de clases de diferentes vendedores, una por
  cada estandar de interfaz de usuario. Por supuesto, es altamente improbable
  que estas jeraquias sean en modo alguno compatibles. Asi que no tendremos una
  clase de producto abstracta por cada tipo de util (@c(BarraDeDesplazamiento),
  @c(Boton), @c(Menu), etc.) y el patron Abstract Factory no funcionara sin esas
  clase cruciales. Tenemos que hacer que las diferentes jerarquias de utilies se
  adhieran a un conjunto camun de interfaces de productos abstractas. Solo
  entonces podriamos declarar las operaciones @c(Crear...) en nuestra interfaz
  de fabrica abstracta.

  En el caso de los utiles resolvimos este problema desarrollando nuestras
  propias clases abstractas y concretas de productos. Ahora nos enfrentamos a un
  problema similar cuando intentamos que Lexi funcione en diferentes sistemas de
  ventanas; a saber, que los diferentes sistemas de ventanas tienen interfaces
  de programacion incompatibles. Esta vez, no obstante, las cosas son un poco
  mas dificiles, porque no podemos permitirnos implementar nuestro propio
  sistema de ventanas no estandar.

  Pero nos salva que las interfaces de los sistemas de ventanas, al igual que
  las de los diferentes estandares de interfaces de usuario, no son
  radicalemente diferentes unas de otras, porque por lo general todos los
  sistemas de ventanas hacen las mismas cosas. Necesitamos un conjunto uniforme
  de abstracciones de ventanas que nos premitan tomas diferentes
  implementaciones de sistemas de ventanas y poner cualquiera de ellas bajo una
  interfaz comun.

*** Encapsular dependencias de implementacion

  En la @l(#2.2<>Seccion 2.2) introducimos una clase @c(Ventana) para mostrar un
  glifo o una estructura de glifos en pantalla. No especificamos el sistema de
  ventanas con el que trabajaba este objeto, porque la verdad es que no proviene
  de ningun sistema de ventanas. La clase @c(Ventana) encapsula las operaciones
  que suelen hacer las ventanas en los diferentes sistemas de ventanas:

  - Proporciona operaciones para dibujar formas geometricas basicas.

  - Pueden minimizarse y maximisarse a si mismas.

  - Pueden cambiar su tamaño

  - Pueden (re)dibujar sus contenidos a peticion, por ejemplo cuando son
    maximizadas o cuando se muestra una parte que permanecia oculta de su
    espacio en pantalla.

  La clase @c(Ventana) debe abarcar la funcionalidad de las ventanas de
  diferentes sistemas de ventanas. Consideremos dos filosofias extremas:

  1. @e(Interseccion de funcionalidad.) La clase @c(Ventana) proporciona solo la
     funcionalidad que es comun a @e(todos) los sistemas de ventanas. El
     problema de este enfoque es que nuestra interfaz de @c(Ventana) acaba
     siendo solo tan potente como el sistema de ventanas con menos
     capacidades. No podemos aprovecharnos de caracteristicas mas avanzadas
     incluso aunque la mayoria (pero no todos) los sistemas de ventanas las
     admitan.

  2. @e(Union de funcionalidad). Crear una interfaz que incorpora las
     capacidades de @e(todos) los sistemas exitente. El problema es que la
     interfaz resultante puede ser gigantesga e incoherente. Ademas, tendremos
     que cambiarla (y a Lexi, que depende de ella) cada ves que un vendedor
     revise la interfaz de su sistema de ventanas.

  Ninguno de los dos extremos es una solucion viable, de manera que nuestro
  diseño se situara en algun punto intermedio entre ambos. La clase @c(Ventana)
  proveera una interfaz adecuada que tenga las caracteristicas mas populares de
  los sistemas de ventanas. Como Lexi tratara directamente con ella, la clase
  @c(Ventana) debera incluir tambien un conjunto basico de operaciones graficas
  que permita a los glifos dibujarse a si mismos en una ventana. La Tabla 2.3
  muestra un ejemplo de las operaciones de la interfaz de la clase @c(Ventana).

  ..figure > @t(Tabla 2.3): Interfaz de la clase @c(Ventana)

    +---------------------+---------------------------------------+
    | Responsabilidades   | Operaciones                           |
    +=====================+=======================================+
    | gestion de ventanas | @c{Virtual void Redibujar()}          |
    |                     +---------------------------------------+
    |                     | @c{Virtual void TraerAdelante()}      |
    |                     +---------------------------------------+
    |                     | @c{Virtual void EnviarAtras()}        |
    |                     +---------------------------------------+
    |                     | @c{Virtual void Minimizar()}          |
    |                     +---------------------------------------+
    |                     | @c{Virtual void Maximizar()}          |
    |                     +---------------------------------------+
    |                     | ...                                   |
    +---------------------+---------------------------------------+
    | graficos            | @c{Virtual void DibujarLinea(...)}    |
    |                     +---------------------------------------+
    |                     | @c{Virtual void DibujarRect(...)}     |
    |                     +---------------------------------------+
    |                     | @c{Virtual void DibujarPoligono(...)} |
    |                     +---------------------------------------+
    |                     | @c{Virtual void DibujarTexto(...)}    |
    |                     +---------------------------------------+
    |                     | ...                                   |
    +---------------------+---------------------------------------+


  @c(Ventana) es una clase abstracta. Sus subclases concretas admiten los
  diferentes tipos de ventanas con las que trataran. Por ejemplo, las ventanas
  de aplicacion, los iconos y los dialogos de avisos, son todos ellos ventanas,
  pero tienen comportamientos diferentes. Asi que podemos definir subclases como
  @c(VentanaDeAplicacion), @c(VentanaIcono) y @c(VentanaDialogo) para
  representar tales diferencias. La jerarquia de clases resultante le da a las
  aplicaciones como Lexi una abstraccion de las ventasa uniforme e intuitiva,
  que no depende del sistema de ventas de ningun vendedor en particular.

  Ahora que hemos definido una interfaz de ventana para que Lexi trabaje con
  ello, ¿cual es el papel del sistema de ventas real de una plataforma concreta?
  Dado que no estamos implementando nuestro propio sistema de ventanas, nuestra
  abstraccion de ventana debera ser implementada en algun lugar en terminos de
  lo que proporciona el sistetam de ventanas nativo. ¿Donde reside esa
  implementacion?

  ..img > img/019.png

  Un enfoque es implementar multiples versiones de la clase @c(Ventana) y sus
  subclases, una para cada plataforma de ventanas. Tendriamos que elegir la
  version a usar cuando construyeramos Lexi para una plataforma dada. Pero
  imagine los dolores de cabeza que daria el mantenimiento si tuviesemos que
  estar pendientes de multiples clases, todas llamadas @"c(Ventana), pero cada
  una implementada en un sistema de ventanas diferente. Otra alternativa seria
  crear subclases dependientes de la implementacion para cada clase de la
  jerarquia de @c(Ventana) @-(y acabar teniendo otro problema de explosion de
  subclases como el que tuvimos cuando tratabamos de añadir adornos). Ambas
  alternativas tiene sus deventajas: ninguna nos da la flexibilidad de cambiar
  el sistema de ventanas despues de haber compilado el programa. De manera que
  tendremos que tener diferentes ejecutables.

  Ninguna de estas opciones es muy atractiva, pero ¿que otra cosa podemos hacer?
  Lo mismo que hicimos para el formateado y la decoracion, es decir,
  @e(encapsular el concepto que varia). Lo que cambia en este caso es la
  implementacion del sistema de ventanas. Si encapsulammos la funcionalidad de
  un sistema de ventanas en un objeto, podemos implementar nuestra clase
  @c(Ventana) y sus subclases en terminos de la interfaz de ese objeto. Ademas,
  si esa interfaz sirve para todos los sistemas de ventanas en los que estamos
  interesados, no tendremos que cambiar @c(Ventanas) ni ninguna de sus subclases
  para permitir diferentes sistemas de ventanas. Podemos configurar los objetos
  ventana para el sistema de ventanas que queramos simplemntene pasandoles el
  objeto apropiado que lo encapsula. Incluso podemos configurar la ventana en
  tiempo de ejecucion.

*** Ventana y VentanaImp

  Definiremos una jerarquia de clases @c(VentanaImp) aparte, para ocultar las
  implementaciones de los diferentes sistemas de ventanas. @c(VentanaImp) es una
  clase abstracta para los objetos que encapsulan codigo dependiente del sistema
  de ventanas. Para que Lexi funcione en un sistema de ventanas concreto,
  configuramos cada objeto ventana con una instancia de la subclase de
  @c(VentanaImp) para ese sistema. El diagrama siguiente muestra la relacion
  entre las jerarquias de @c(Ventana) y @c(VentanaImp):

  ..img > img/020.png

  Al ocultar las implementaciones en la clase @c(VentanaImp), evitamos
  contaminar las clase @c(Ventana) con dependencias del sistema de ventanas, lo
  que mantiene a la jerarquia de clases de @c(Ventanas) relativamente pequeña y
  estable. Ademas, podemos ampliar facilmente la jerarquia de implementacion
  para admitir nuevos sistemas de ventanas.

**** Subclases de @c(VentanaImp)

  Las subclases de @c(VentanaImp) convierten peticiones en operaciones
  especificas del sistema de ventanas. Piense en el ejemplo que empleamos en la
  @l(#2.2<>Seccion 2.2). Definiamos @c(Rectangulo::Dibujar) en terminos de la
  operacion @c(DibujarRect) de la instancia de @c(Ventana):

  ..src > c++
    void Rectangulo::Dibujar (Ventana* v) {
      v->DibujarRect(_x0, _y0, _x1, _y0);
    }
  < src..

  La implementacion predeterminada de @c(DibujarRect) usa la operacion abstracta
  para dibujar rectangulos declarada por @c(VentanaImp):

  ..src > c++
    void Ventana::DibujarRect (
      Coord x0, Coord y0, Coord x1, Coord y1
    ) {
      _imp->DispositivoRect(_x0, _y0, _x1, _y0);
    }
  < src..

  donde @c(_imp) es una varible miembro de @c(Ventana) que guarda el objeto
  @c(VentanaImp) con el que se configuro la ventana. La implementacion de la
  ventana esta definida por la instancia de la subclase @c(VentanaImp) a la que
  apunta @c(_imp). Para una @c(VentanaImpX) (esto es, una subclase de
  @c(VentanaImp) para el sistema de ventanas X), la implementacion de
  @c(DispositivoRect) puede parecerse a

  ..src > c++
    void VentanaImpX::DispositivoRect (
      Coord x0, Coord y0, Coord x1, Coord y1
    ) {
      int x = round(min(x0, x1));
      int y = round(min(y0, y1));
      int ancho = round(abs(x0 - x1));
      int alto  = round(abs(y0 - y1));
      XDrawRectangle(_dpy, _winid, _cg, x, y, ancho, alto);
    }
  < src..

  @c(DispositivoRect) esta asi definido porque @c(XDrawRectangle) (la interfaz
  de X para dibujar un rectangulo) define un rectangulo en terminos de su
  esquina inferior izquierda, su ancho y su alto. @c(DispositivoRect) debe
  calcular estos valores a partir de los que recive. En primer lugar determina
  la esquina inferior izquierda (ya que (@c(x0, y0) puede ser cualquiera de las
  cuatro esquinas del rectangulo) y luego calcula el ancho y el alto.

  @c(VentanaImpPM) (una subclase de @c(VentanaImp) para Presentation Manager)
  definiria @c(DispositivoRect) de esta otra forma:

  ..src > c++
    void VentanaImpPM::DibujarRect (
      Coord x0, Coord y0, Coord x1, Coord y1
    ) {
      Cord izquierda = min(x0, x1);
      Cord derecha   = max(x0, x1);
      Cord inferior  = min(y0, y1);
      Cord superior  = max(y0, y1);

      PPDINTL punto[4];

      punto[0].x = izquierda; punto[0].y = superior;
      punto[1].x =   derecha; punto[1].y = superior;
      punto[2].x =   derecha; punto[2].y = inferior;
      punto[3].x = izquierda; punto[3].y = inferior;

      if (
        (GpiBeginPath(_hps, 1L) == false) ||
        (GpiSetCurrentPosition(_hps, &punto[3]) == false) ||
        (GpiPolyLine(_hps, 4L, punto) == GPI_ERROR) ||
        (GpiEndPath(_hps) == false)
      ) {
        // informar del error

      } else {
        GpiStrokePath(_hps, 1L, 0L);
      }
    }
  < src..

  ¿Por que es tan diferente la version para X? Bueno, PM no tiene una operacion
  para dibujar rectangulos explicitamente, como si tenia X. En lugar de eso, PM
  tiene una interfaz mas general para especificar vertices de figuras formadas
  por varios segmentos (lo que se conoce como @e(path)) y para trazar o rellenar
  el area que encierran.

  La implementacion para PM de @c(DispositivoRect) difiere bastante de la de X,
  pero eso no importa. @c(VentanaImp) oculta las diferencias de las
  interfaces de los sistemas de venatas tras una interfaz potencialmente grande
  pero estable. Esto permite que los creadores de las subclases de @c(Ventana)
  se centren en la abstraccion de ventana y no en los detalles del sistema de
  ventanas. Tambien nos permite añadir nuevos sistemas de ventanas sin afectar a
  las clases @c(Ventana).

**** Configurar @c(Ventanas) con @c(VentanaImp)s

  Una cuestion clave que aun no hemos considerado es como se configura una
  ventana con la subclase correcta de @c(VentanaImp). Dicho de otra forma,
  ¿cuando se inicializa @c(_imp), y quien sabe que sistema de ventanas (y,
  consecuentemente, que subclase de @c(VentanaImp)) se esta usando? La ventana
  necesitara algun tipo de @c(VentanaImp) antes de que pueda hacer nada
  interesante.

  Hay varias posibilidades, pero nos centraremos en una que hace uso del patron
  @l(#Abstract Factory). Podemos definir una clase fabrica abstracta
  @c(FabricaSistemaDeVentanas) que proporciona una interfaz para crear
  diferentes tipos de implementaciones de objetos dependientes del sistema de
  ventanas:

  ..src > c++
    class FabricaSistemaDeVentanas {
    public:
      virtual VentanaImp* CrearVentanaImp() = 0;
      virtual ColorImp*   CrearColorImp  () = 0;
      virtual FuenteImp*  CrearFuenteImp () = 0;
      // ...
      // una operacion "Crear..." para todos los recursos
      // del sistema de ventanas
    };
  < src..

  Ahora podemos definir una fabrica concreta para cada sistema de ventanas:

  ..src > c++
    class FabricaSistemaDeVentanasPM : public FabricaSistemaDeVentanas {
      virtual VentanaImp* CrearVentanaImp()
      { return new VentanaImpPM; }
      // ..
    };

    class FabricaSistemaDeVentanasX : public FabricaSistemaDeVentanas {
      virtual VentanaImp* CrearVentanaImp()
      { return new VentanaImpX; }
      // ...
    };
  < src..

  el constructor de la clase base @c(Ventana) puede usar la interfaz de
  @c(FabricaSistemaDeVentanas) para inicializar el miembro @c(_imp) con el
  objeto @c(VentanaImp) apropiado para el sistema de ventanas:

  ..src > c++
    Ventana::Ventana () {
      _imp = fabricaSistemaDeVentanas->CrearVentanaImp();
    }
  < src..

  La variable @c(fabricaSistemaDeVentanas) es una instancia conocida de una
  subclase @c(FabricaSistemaDeVentanas), similar a la variable @c(fabricaIGU)
  que definia el estandar de interfaz de usuario. La variable
  @c(fabricaSistemaDeVentanas) se puede inicializar del mismo modo.

*** Patron Bridge (Puente)

  La clase @c(VentanaImp) define una interfaz con los servicios comunes de los
  sistemas de ventanas, pero su diseño viene dado por otras restricciones que
  las de la intefaz de @c(Ventana). Los programadores de aplicaciones no
  trataran directamente con la interfaz de @c(VentanaImp), sino solo con objetos
  @c(Ventana). Por tanto, la interfaz de @c(VentanaImp) no tiene por que
  coincidir con la vision del mundo que tiene el programador de la aplicacion,
  como fue nuestra preocupacion al diseñar la interfaz y la jerarquia de clases
  de @c(Ventana). La interfaz de @c(VentanaImp) puede reflejar mejor lo que
  proporcionan realmente los distintos sistemas de ventanas, con todas sus
  imperfecciones. Puede aproximarse a uno cualquiera de los enfoques de
  interseccion o de union de funcionalidad, el que mejor se adapte al sistema de
  ventanas de destino.

  Lo importante aqui es darse cuenta de que la interfaz de @c(Ventana) esta
  dirigida al programador de aplicaciones, mientras que @c(VentanaImp) esta
  dirigida a los sistemas de ventanas. Separar la funcionalidad de las ventanas
  en las jerarquias de @c(Ventana) y @c(VentanaImp) nos permite implementar y
  especializar estas interfaces de forma independiente. Los objetos de estas
  jerarquias cooperan entre si para que Lexi funcione en varios sistemas de
  ventanas sin ninguna modificacion.

  La relacion entre @c(Ventana) y @c(VentanaImp) es un ejemplo del patron
  Brige. El proposito de este patron es permitir separar jerarquias de clases
  para que trabajen juntas incluso cuando ambas evolucionan de forma
  independiente. Nuestro criterio de diseño nos lleva a crear dos jerarquias de
  clases sesparadas, una que representa la nocion logica de ventana, y otra para
  representar diferentes implementaciones de ventanas. El patron Bridge nos
  permite mantener y mejorar nuestras abstracciones de ventanas sin tocar el
  codigo dependiente del sistema de ventanas, y a la inversa.

** 2.7 <> Operaciones de usuario

  Parte de la funcionalidad de Lexi esta disponible en la representacion WYSIWYG
  del documento. El usuario introduce y borra texto, mueve el punto de insercion
  y selecciona partes del texto mediente el raton o teclado directamente sobre
  el documento. A otras funciones se accede de marera indirecta a traves de
  operaciones de usuario de los menus desplegables, botones y atajos de teclado
  de Lexi. La funcionalidad incluye operaciones para

  - crear un nuevo documento,
  - abrir, guardar e imprimir un documento existente,
  - contrar y pegar el texto seleccionado,
  - cambiar la fuente y el estilo del texto seleccionada,
  - cambiar el formateo del texto, como su alineacion y justificado,
  - salir de la aplicacion,
  - etcetera, etcetera.

  Lexi proporciona diferentes interfaces de usuario para llevar a cabo estas
  operaciones, pero no queremos asociar una determinada operacion de usuario con
  una interfaz en particular, ya que podemos querer tener varias interfaces de
  usuario para la misma operacion (por ejemplo, podemos pasar la pagina usando
  un boton o una operacion de menu). Tambien podemos querrer cambiar la interfaz
  en un futuro.

  Ademas, estas operaciones estan implementandasa en muchas clases distintas.
  Como programadores, queremos acceder a su funcionalidad sin crear muchas
  dependencias entre las clases de implementacion y de usuario. Si no,
  acabariamos por tener una implementacion fuertemente acoplada, que seria mas
  dificil de comprender, ampliar y mantener.

  Para complicar mas las cosas, queremos que Lexi soporte operaciones de
  deshacer y repetir@n(20) para la mayoria de sus funciones, @e(pero no para
  todas). En concreto, queremos ser capaces de deshacer operaciones que
  modifican el documento, como eliminar, con las que el usuario puede perder
  muchos datos sin darse cuenta. Sin embargo, no deberiamos intentar deshacer
  operaciones como guardar un dibujo o salir de la aplicacion. Estas operaciones
  no deberian tener efecto en el proceso de deshacer. Tampoco queremos un limite
  arbitrario en el numero de niveles de deshacer y repetir.

  Esta claro que permitir operaciones de usuario es fundamental en la
  aplicacion. El objetivo es coseguir un mecanismo simple y extensible que
  satisfaga todas estas necesidades.

*** Encapsular una peticion

  Desde nuestra perspectiva de diseñadores, un menu desplegable no es mas que
  otro tipo de glifo que contiene otros glifos. Lo que distingue a los menus
  desplegables de otros glifos que tienen hijos es que la mayoria de los glifos
  de los menus hacen alguna operacion en respuesta a un clic del raton.

  Supongamos que estos glifos son instancias de una subclase de @c(Glifo)
  llamada @c(ElementoDeMenu) y que estos hacen su trabajo en respuesta a una
  peticion de un cliente@n(21). Llevar a cabo la peticion puede implicar una
  operacion en un objeto, o muchas operaciones sobre muchos objetos, o algo
  entre medias.

  Podriamos definir una subclase de @c(ElementoDeMenu) para cada operacion de
  usuario y luego codificar cada subclase para que realizase la peticion. Pero
  eso no es lo correcto: no necesitamos una subclase de @c(ElementoDeMenu) para
  cada peticion, de la misma manera que no necesitamos una subclase para cada
  cadena de texto de un menu desplegable. Es mas, este enfoque acopla la
  peticion a una interfaz de usuario determinada, haciendo que sea dificil
  satisfacer la peticion a travez de otro elemento de la interfaz.

  Para ilustrar esto, supongamos que pudieramos avanzar a la ultima pagina del
  documento @e(tanto) con un elemento de menu @e(como) pulsando en un icono de
  la interfaz de Lexi (que puede ser mas conveniente para documentos cortos). Si
  asociamos la peticion con un @c(ElementoDeMenu) a traves de la herencia,
  tendremos que hacer lo mismo para el icono y cualquier otro tipo de util que
  pueda responder a dicha peticion. Esto puede dar lugar a un numero de clases
  cercano al producto del numero de tipos de utiles por el numero de
  peticiones.

  Lo que falta es un mecanismo que nos permita parametrizar los elementos de
  menu con la peticion que deben llevar a cabo. De esa forma evitariamos la
  proliferacion de subclases y permitiriamos mas flexibilidad en tiempo de
  ejecucion. Podriamos parametrizar @c(ElementoDeMenu) con la funcion a llamar,
  pero eso no seria una buena solucion, por al menos tres razones:

  1. No soluciona el probelma deshacer/repetir.

  2. Es dificil asociar el estado a una funcion. Por ejemplo, una funcion que
     cambia la fuente necesita saber @e(que) fuente cambiar.

  3. Las funciones son dificiles de extender y es dificil reutilizar partes de
     ellas.

  Estas razones sugieren que deberiamos paramentrizar los elementos de menu con
  un @e(objeto), y no con una funcion. De ese modo podriamos usar la herencia
  para ampliar y reutilizar la implementacion de la peticion, y tambien
  tendriamos un lugar donde almacenar el estado e implementar la funcionalidad
  de deshacer/repetir. Este es otro ejemplo de encapsulacion del concepto que
  varia, en este caso una peticion. Encapsularemos cada peticon en un objeto
  @b(orden).@n(22)

*** Clase @c(Orden) y sus Subclases

  En primer lugar definiremos una clase abstracta @c(Orden) que proporciona una
  interfaz para emitir una peticion. La interfaz basica consiste en una unica
  operacion abstracta denominada @"(Ejecutar). Las subclases de @c(Orden)
  implementan @c(Ejecutar) de distintas formas para satisfacer diferentes
  peticiones. Algunas subclases pueden delegar parte del trabajo, o todo, en
  otros objetos. Otras subclases puede ser capaces de responder a la peticion
  por si solas (vease la @l(#Figura 2.11)). No obstante, para el solicitante un
  objeto @c(Orden) no es mas que eso, un objeto @c(Orden) @-(todos son tratados
  por igual).

  ..figure > @t(Figura 2.11): Parte de la jeraquia de clases de @c(Orden)

    ..img > img/021.png

  Ahora @c(ElementoDeMenu) puede almacenar un objeto @c(Orden) que satisface una
  peticion @l(#Figura 2.12). Le damos a cada objeto elemento de menu una
  instancia de la subclase de @c(Orden) que resulta apropiada para ese elemento,
  de la misma manera que especificamos el texto que aparecera en el. Cuando el
  usuario selecciona un elemento de menu en concreto, el correspondiente
  @c(ElementoDeMenu) simplemente llama a @c(Ejecutar) sobre su objeto @c(Orden)
  para realizar la peticion. Notese que los botones y otros utiles pueden usar
  objetos @c(Orden) igual que lo hacen los elementos del menu.

  ..figure > @t(Figura 2.12): Relacion entre @c(ElementoDeMenu) y @c(Orden)

    ..img > img/022.png

*** Capacidad de Deshacer@n(23)

  Es importante que las aplicaciones interactivas cuenten con la capacidad de
  deshacer/repetir. Para deshacer y repetir ordenes, añadiremos una operacion
  @c(Deshacer) a la interfaz de @c(Orden), que anula los efectos de la operacion
  @c(Ejecutar) precedente, usando la informacion que esta haya guardado. Por
  ejemplo, en el caso de una @c(OndenFuente), la operacion @c(Ejecutar) deberia
  guardar la parte del texto a la que afecta el cambio de fuente junto con la
  fuente o fuentes originales. La operacion @c(Deshacer) de @c(OrdenFuente)
  devolveria el texto a su fuente original.

  A veces la capacidad de deshacer tiene que ser establecida en tiempo de
  ejecucion. Una peticion para cambiar la fuente de una seleccion no hace nada
  si el texto ya aparece en esa fuente. Supongamos que el usuario selecciona
  parte del texto y realiza un cambio de fuente que no tiene ningun efecto.
  ¿Cual deberia ser el resultado de la siguiente peticion deshacer? ¿Un cambio
  sin sentido deberia causar que la peticion deshacer hiciera algo igualmente
  sin sentido? Probablemente no. Si el usuario repite ese cambio de fuente
  varias veces, no deberia tener que realizar exactamente el mismo numero de
  operaciones deshacer para regresar a la ultima operacion con sentido. Si el
  resultado final de ejecutar una orden fue nulo, entoces no hay necesidad de la
  correspodiente operacion deshacer.

  Asi que para determinar si una orden se puede deshacer, añadiremos una
  operacion abstracta @c(Reversible) a la interfaz de @c(Orden). Reversible
  devuelve un valor logico, y las subclases de @c(Orden) pueden redefinir esta
  operacion para devolver verdadero o falso basandose en criterios de tiempo de
  ejecucion.

*** Historial de Ordenes

  El paso final para soportar niveles arbitrarios de deshacer y repetir es
  definir un @b(historial de ordenes), es decir, una lista de ordenes ejecutadas
  (y las anuladas). Conceptualmente, el hitorial de ordenes se parece a esto:

  ..img > img/023.png

  Cada circulo representa un objeto @c(Orden). En este caso el usuario ha
  ejecutado cuatro ordenes. La de mas a la izquierda fue la primera que se
  ejecuto, seguida por la segunda de mas a la izquierda y asi sucesivamente
  hasta la orden mas recientemente ejecutada, que es la mas a la derecha. La
  linea etiquetada como @"(presente) lleva la cuenta de cual fue la ultima
  orden ejecutada (o anulada).

  Para deshacer la ultima orden, simplemente llamaremos a @c(Deshacer) sobre la
  orden mas reciente:

  ..img > img/024.png

  Despues de la operacion de deshacer, movemos la linea @"(presente) una
  orden hacia la izquierda. Si el usuario elige de nuevo deshacer, se anulara la
  siguiente orden mas recientemente ejecutada de la misma manera que se hizo con
  esta, y nos encontraremos en el estado que se muestra a continuacion:

  ..img > img/025.png

  Puede observarse como simplemente repitiendo este procedimiento obtenemos
  multiples niveles de operaciones de deshacer. El numero de estos niveles solo
  esta limitado por la longitud del historial de ordenes.

  Para repetir una orden que se acaba de deshacer, hacemos lo mismos pero a la
  inversa. Las ordenes a la derecha de la linea del presente son las que se
  pueden dashacer en un futuro. Pra repetir la ultima orden anulada, llamamos a
  @c(Ejecutar) en la orden situada a la izquierda de la linea actual:

  ..img > img/026.png

  A continuacion movemos la linea del presente de manera que la siguiente
  operacion de repetir llamara a repetir sobre la siguiente orden en el futuro.

  ..img > img/027.png

  Por supuesto, si la siguiente operacion no es otro repetir, sino un deshacer,
  entonce se anulara la @e(orden) a la izquierda de la linea @"(presente). De
  esta manera el usuario puede ir hacia adelante y hacia atras en el tiempo
  tanto como sea necesario para recuperarse de los errores.

*** Patron Command (Orden)

  Las ordenes de Lexi son una aplicacion del patron @l(#Command), el cual
  describe como encapsular una peticion. El patron Command prescribe una
  interfaz uniforme para emitir peticiones que permite configurar los clientes
  para que traten diferentes peticiones. La interfaz oculta a los clientes la
  implementacion de las peticiones. Una orden puede delegar toda la
  implementacion de la peticon, parte de ella o nada en otros objetos. Esto es
  perfecto para aplicaciones como Lexi, que deben proporcionar un acceso
  centralizado a la funcionalidad que se encuentra desperdigada por toda la
  aplicacion. El patron tambien trata los mecanismo de deshacer y repetir
  incorporados en la interfaz basica de @c(Orden).

** 2.8 <> Revision ortografica e insercion de guiones@n(24)

  El ultimo problema de diseño tiene que ver con el analisis del texto, en
  concreto con la revision ortografica y la introduccion de puntos de insercion
  de guiones donde sea necesario para lograr un buen formateado.

  Las restricciones son similares a las que tuvimos en el problema de diseño del
  formateado, en la @l(#2.3<>Seccion 2.3). Al igual que con las estrategias de
  division de lineas, hay mas de una manera de revisar la ortografia y de
  calcular los puntos donde se pueden insertar guiones de separacion. Por tanto,
  aqui tambien queremos permitir multiples algoritmos. Un conjunto de algoritmos
  puede proporcionar una eleccion de compromiso entre espacio/tiempo/calidad.

  Tambien queremos evitar implementar esta funcionalidad en la estructura del
  documento. Ente objetivo es incluso mas importante aqui que en el caso del
  formateado, ya que la revision ortografica y la insercion de guiones son solo
  dos de todos los tipos potenciales de analisis que podemos querer que permita
  Lexi. Sin duda, querremos ampliar las capacidades analiticas de Lexi con el
  tiempo. Podemos añadir busquedas, herramientas de contar palabras, una
  utilisadd de calculo para sumar los valores de una tabla, revision gramatical,
  etcetera. Pero no queremos cambiar la clase @c(Glifo) y todas sus subclases cada
  vez que introducimos nuevas funcionalidades de este tipo.

  Este rompecabezas lo forman en realidad dos piezas: (1) acceder a la
  informaiocn que va a ser analizada, que se encuentra repartida entre los
  glifos de la estructura del docuemento, y (2) hacer el analisis. Veamos ambas
  piezas por separado

*** Acceder a informacion Dispersa

  Hay muchos tipos de analisis que requieren examinar el texto caracter a
  caracter. El texto a analizar esta repartido en una estructura jerarquica de
  objetos glifo. Para axaminar el texto en dicha estructura necesitamos un
  mecanismo de acceso que conozca las estructuras de datos en las que se
  almacenan los objetos. Algunos glifos pueden almacenar sus hijos en listas
  enlazadas, otros tal vez usen arrays, y otros pueden usar estructuras de datos
  mas extrañas. Nuesto mecanismo de acceso debe ser capaz de tratar con todas
  estas posibilidades.

  Una complicacion añadida es que los diferentes analisis acceden a la
  informacion de diferentes formas. La mayoria de los analisis recorreran el
  texto de pricipo a fin, pero algunos haran lo contrario @-(una busqueda hacia
  atras, por ejemplo, necesita examinar hacia atras en vez de hacia
  delante). Otras operaciones, como la evaluacion de expresiones algebraicas,
  podrian necesitar un recorrido en-orden.

  Por tanto, nuestro mecanismo de acceso se tiene que acomodar a diferentes
  estructuras de datos y debemos permitir diferentes tipos de recorridos, como
  pre-orden y en-orden.

*** Encapsular el acceso y el recorrido

  Por ahora nuestra interfaz de glifo usa un indice entero para que los clientes
  se refieran a sus hijos. Si bien esto puede ser razonable para las clases de
  glifo que almacenan sus hijos en una array, puede ser ineficiente para glifos
  que utilizan una lista enlazada. Un papel importante de la abstraccion de
  glifo es ocultar la estructura de datos en la que se almacenan los hijos. De
  ese modo podemos  cambiar la estructura de datos de un glifo sin que esto
  afecte a otras clases.

  Por tanto, solo el glifo puede saber la estructura de datos que usa. Como
  corolario, la interfaz de glifo no deberia orientarse hacia una estructura de
  datos u otra; no deberia adecuacuarse mejor a arrays que a listas enlazadas,
  por ejemplo.

  Podemos solucionar este problema y permitir diferentes tipos de recorridos al
  mismo tiempo. Podemos poner diferentes capacidades de acceso y recorrido
  directamente en las clases glifo y proporcionar un modo de elegir entre ellas,
  tal ves mediante una constante enumerada como parametro. Las clases se
  pasarian este parametro de unas a otras durante un recorrido para garantizar
  que estan haciendo el mismo tipo de recorrido. Tambien deben pasar cualquier
  informacion acumulada durante el recorrido.

  Podriamos añadir las siguientes operaciones abstractas a la interfaz de Glifo
  para permitir este enfoque:

  ..src > c++
    void Primero(Recorrido tipo);
    void Siguiente();
    bool HaTerminado();
    Glifo* ObtenerActual();
    void Insertar(Glifo*);
  < src..

  Las operaciones @c(Primero), @c(Siguiente) y @c(HaTerminado) controlan el
  recorrido. @c(Primero) lo inicializa. Recibe el tipo de recorrido como un
  parametro de tipo @c(Recorrido), una constante enumerada que tiene valores
  tales como @c(HIJOS) (para recorrer solo los hijos directos del glifo),
  @c(PREORDEN) para recorrer la estructura completa en preorden), @c(POSTORDEN)
  y @c(ENORDEN). @c(Siguiente) avanza hasta el siguiente glifo del recorrido, y
  @c(HaTerminado) informa si el recorrido ha terminado o no. @c(ObtenerActual)
  sustituye a la operacion @c(Hijo), y accede al glifo actual del recorrido.
  @c(Insertar) substituye la operacion antigua, insertando el glifo dado en la
  poscion actual.

  Un analisis usaria el siguiente codigo C++ para hacer un recorrido preorden de
  una estructura de glifos que tiene como raiz @c(g):

  ..src > c++
    Glifo* g;

    for (g->Primero(PREORDEN); !g->HaTerminado(); g->Siguiente()) {
      Glifo* actual = g->ObtenerActual();

      // hace algun analisis
    }
  < src..

  Notese como ha desaparecido el indice entero de la interfaz de glifo. Ya no
  hay nada que predisponga la interfaz hacia un tipo de coleccion u
  otra. Tambien les ahorramos a los clientes tener que implementar ellos mismos
  algunos tipos de recorridos habituales.

  Pero este enfoque sigue teniendo problemas. Por un lado, no pueden permitir
  nuevo recorridos sin ampliar el conjunto de valores enumerados o sin añadir
  nuevas operaciones. Supongamos que queremos una variacion de un recorrido
  preorden que se salte automaticamente glifos no textuales. Tendriamos que
  cambiar la enumeracion @c(Recorrido) para incluir algo como
  @c(PREORDEN_TEXTUAL).

  Nos gustaria no tener que cambiar las declaraciones existentes. Poner todo el
  mecanismo de recorrido en la jerarquia de la clase @c(Glifo) haria que fuese
  dificil modificarlo o ampliarso sin cambiar a su vez muchas otras clases.
  Tambien seria dificil reutilizar el mecanismo para recorrer otros tipos de
  estructuras de objetos. Y no podemos hacer mas de un recorrido a la vez sobre
  la misma estructura.

  Una solucion mejor es, de nuevo, encapsular el concepto que varia, en este caso
  los mecanismos de acceso y recorrido. Podemes introducir una clase de objetos
  llamados @c(Iteradores), cuyo unico proposito es definir diferentes tipos de
  tales mecanismos. Podemos usar la herencia para poder acceder a estructuras de
  datos diferentes de una manera uniforme, asi como permitir nuevos tipos de
  recorridos. Y no tendriamos que cambiar las interfaces de los glifos o tocar
  sus implementaciones para hacerlo.

*** Clase @c(Iterador) y sus subclases

  Usaremos una clase abstracta llamada @c(Iterador) para definir una interfaz
  general que permita recorrer una estructura de objetos y acceder a cada uno de
  sus elementos. Las subclases concretas como @c(IteradorArray) o
  @c(IteradorLista) implementan la interfaz para proporcionar acceso a arrays y
  listas, miestras que @c(IteradorPreorden), @c(IteradorPostorden) y similares
  implementan diferentes recorridos sobre determinadas estructuras. Cada
  subclase de @c(Iterador) tiene una referencia a la estructura que recorre. Las
  instancias de estas subclases se inicializan con dicha referencia cuando se
  crean. La Figura 2.13 muestra la clase @c(Iterador) junto con varias
  subclases. Notese que hemos añadido una operacion abstracta @c(CrearIterador)
  a la interfaz de la clase @c(Glifo) para dar cabida a los iteradores.

  ..figure > @t(Figura 2.13): Clase @c(Iterador) y sus subclases

    ..img > img/028.png

  La interfaz @c(Iterador) provee las operaciones @c(Primero), @c(Siguiente) y
  @c(HaTerminado) para controlar el recorrido. La clase @c(IteradorLista)
  implementa @c(Primero) para que apunte al primer elemento de la lista, y
  @c(Siguiente) hace avanzar al iterador hasta el siguiente elemento de la
  lista. @c(HaTerminado) devuelve si el puntero de la lista apunta mas alla del
  ultimo elemento de la lista. @c(ElementoActual) desreferencia el iterador para
  devolver el glifo al que apunta. Una clase @c(Iteradorarray) haria
  cosas similares pero sobre un array de glifos.

  Ahora podemos acceder a los hijos de una estructura de glifos sin conocer su
  representacion:

  ..src > c++
    Glifo* g;
    Iterador<Glifo*>* i = g->CrearIterador();

    for (i->Primero(); !i->HaTerminado(); i->Siguiente()) {
      Glifo* Hijo = i->ElementoActual();

      // hace algo con el hijo actual
    }
  < src..

  @c(CrearIterador) devuelve, de manera predeterminada, una instancia de
  @c(IteradorNulo). Un @c(IteradorNulo) es un iterador degenerado para glifos
  que no tiene ningun hijo es decir, para los glifos hoja. La operacion
  @c(HaTerminado) de un @c(IteradorNulo) siempre devuelve verdadero.

  Una subclase de glifo que tiene hijos redefinira @c(CrearIterador) para
  devolver una instancia de una subclase de @c(Iterador) diferente. La subclase
  concreta depende de la estructura donde se guardan los hijos. Si la subclase
  de @c(Glifo), @c(Fila), guarda sus hijos en una lista @c(_hijos), entonces su
  operacion @c(CrearIterador) se paracera a esto:

  ..src > c++
    Iterador<Glifo*>* Fila::CrearIterador () {
      return new IteradorLista<Glifo*>(_hijos);
    }
  < src..

  Los iteradores para recorridos preorden y enorden se implimentan en terminos
  de iteradores especificos de glifos. Los iteradores para estos recorridos son
  proporcionados por el glifo raiz de la estructura que recorren. Llaman a
  @c(CrearIterador) sobre los glifos de la estructura y usan una pila para
  guardar los iteradores resultantes.

  Por ejemplo, la clase @c(IteradorPreorden) obtiene el iterador de glifo raiz,
  lo inicializa para que apunte a su primer elemento y luego lo mete en la pila:

  ..src > c++
    void IteradorPreorden::Primero () {
      Iterador<Glifo*>* i = _raiz->CrearIterador();

      if (i) {
        i->Primero();
        _iteradores.BorrarTodos();
        _iteradores.Meter(i);
      }
    }
  < src..

  @c(ElementoActual) simplemente llamaria a @c(ElementoActual) del iterador de
  la cima de la pila:

  ..src > c++
    Glifo* IteradorPreorden::ElementoActual () const {
      return
        _iteradores.Tamano() > 0 ?
        _iteradores.Cima()->ElementoActual() : 0;
    }
  < src..

  La operacion @c(Siguiente) devuelve el iterador de la cima de la pila y le pide
  a su elemento actual que cree un iterador, en un intento de descender en la
  estructura de glifos tanto como sea posible (despues de todo, en esto consiste
  un recorrido en preorden). @c(Siguiente) hace que el nuevo iterador apunte al
  prime elemento a recorrer y lo mete en la pila. Despues, @c(Siguiente)
  comprueba el ultimo iterador; si su operacion @c(HaTerminado) devuelve
  verdadero significa que hemos terminado de recorrer el subarbol (o la hoja)
  actual. En ese caso, @c(Siguiente) saca el iterador de la cima de la pila y
  repite este proceso hasta que encuentra el siguiente recorrido incompleto, si
  es que hay alguno; si no, es que hemos terminado de recorrer la estructura.

  ..src > c++
    void IteradorPreorden::Siguiente () {
      Iterator<Glifo*>* i =
        _iteradores.Cima()->ElementoActual()->CrearIterador();

      i->Primero();
      _iteradores.Meter(i);

      while (_iteradores.Tamano() > 0 &&
             _iteradores.Cima()->HaTerminado()) {
        delete _iteradores.Sacar();
        _iteradores.Cima()->Siguiente();
      }
    }
  < src..

  Notese como la clase @c(Iterador) nos permite añadir nuevos tipos de
  recorridos sin modificar las clases de glifos, simplemente heredamos de
  @c(Iterador) y añadimos un nuevo recorrido, como hemes hecho con
  @c(IteradorPreorden). Las subclases de @c(Glifo) usan la misma interfaz para
  dar a los clientes acceso a sus hijos sin revelar la estructura de datos
  subyacente que usan para almacenarlos. Como los iteradores guardan su propia
  copia del estado del recorrido podemos realizar varios recorridos
  simultaneamente, incluso sobre la misma estructura. Y aunque los recorridos
  que hemos hecho en este ejemplo han sido sobre estructuras de glifos, no hay
  nunguna razon por la que no podamos parametrizar una clase como
  @c(IteradorPreorden) con el tipo de objeto de la estructura. En C++ lo
  hariamos mediante plantillas. Acto seguido podriamos reutilizar el mecanismo
  de @c(IteradorPreorden) para recorrer otras estructuras.

*** Patron Iterator (Iterador)

  El patron @l(#Iterator) representa estas tecnicas para permitir recorrer
  estructuras de objetos y acceder a sus elementos. No solo se puede aplicar a
  estructuras compuestas, sino tambien a colecciones. Abstrae el algoritmo de
  recorrido y oculta a los clientes la estructura interna de los objetos que
  recorre. El patron @c(Iterator) ilustra, una vez mas, como al encapsular el
  concepto que varia ganamos en flexibilidad y reutilizacion. Incluso asi, el
  problema de la iteracion es sorprendentemente complejo, y el patron Iterator
  tiene muchos mas matices y ventajas e inconvenientes que los que hemos
  considerado aqui.

*** Recorrido y acciones del recorrido

  Ahora que tenemos un modo de recorrer la estructura de glifos, necesitamos
  comprobar la ortografia y la insercion de guiones de separacion. Ambos
  analisis implican acumular informacion durante el recorrido.

  En primer lugar tenemos que decidir donde poner la responsabilidad del
  analisis. Podriamos ponerla en las clases @c(Iterador), haciendo asi al
  analisis una parte integral del recorrido. Pero tendremos mucha mas
  flexibilidad y posibilidad de reutilizacion si diferenciamos entre el recorrido
  y las acciones a realizar durante dicho recorrido. Eso es debido a que
  distintos analisis muchas veces requieren el mismo tipo de recorrido . De hay
  que podamos reutilizar el mismo conjunto de iteradores para diferentes
  analisis. Por ejemplo, el recorrido en preorden es comun a muchos analisis,
  incluyendo la revision ortografica, la separacion de palabras mediante guiones,
  la busqueda hacia delante y el recuento de palabras.

  Por tanto habria que separar el analisis y el recorrido. ¿En que otro lugar
  podemos poner la responsabilidad del analisis? Sabemos que hay muchos tipos de
  analisis que podemos querere hacer. Cada analisis hara diferentes cosas en
  distintos puntos del recorrido. Algunos glifos son mas significativos que
  otros, dependiendo del tipo de analisis. Si estamos comprobando la ortografia
  o la insercion de guiones, querremos tener en cuenta los glifos de caracter y
  no los graficos, como lineas o imagenes de mapas de bits. Si estamos haciendo
  separaciones de color, nos interesan los glifos visibles y no los
  invisibles. Es inevitable que haya analisis diferentes para glifos
  diferentes.

  Por tanto, un determinado analisis debe ser capaz de distinguir diferentes
  tipos de glifos. un enfoque obvio es poner la capacidad analitica en las
  propias clases glifo. Para cada analisis podemos añadir una o mas operaciones
  abstractas a la clase @c(Glifo) y tener subclases que las implementen segun el
  papel que cada una desepeñe en el analisis.

  Pero el problema de ese enfoque es que tendremos que cambiar cada clase glifo
  cada vez que añadamos un nuevo tipo de analisis. Podemos paliar este problema
  en algunos casos: si en el analisis participan unas pocas clases, o si la
  mayoria de las clases hacen el analisis de la misma manera, podemos
  proporcionar una implementacion predeterminada para la operacion abstracta en
  la clase @c(Glifo). La operacion predeterminada cubriria asi el caso
  general. De esa manera limitariamos los cambios a la clase @c(Glifo) y a
  aquellas subclases que se aparten de la norma general

  Si bien una implementacion predeterminada reduce el numero de cambios, todavia
  permanece un problema insidioso: la interfaz de @c(Glifo) se expande con cada
  nueva capacidad de analisis. A medida que pase el tiempo las operaciones de
  analisis comenzaran a oscurecer la interfaz basica de @c(Glifo), haciendo
  dificil ver que el principal proposito de un glifo es definir una estructura
  de objetos que tienen apariencia y forma (esa interfaz se pierde entre el
  ruido).

*** Encapsular el analisis

  Segun todos los indicios, necesitamos encapsular el analisis en un objeto
  aparte, de forma similar a como hemos hecho muchas veces hasta ahora. De ese
  modo podriamos todos los mecanismos de un determinado analisis en su propia
  clase. Podriamos usar una instancia de esta clase en conjuncion con el
  iterador apropiado. El iterador @"(llevaria) la instancia a cada glifo de la
  estructura. Este objeto podria entonces realizar una porcion del analisis en
  cada punto del recorrido. El analizador acumula informacion de interes
  (caracteres en este caso) a medida que avanza el recorrido

  ..img > img/029.png

  La cuestion fundamental con este enfoque es como distingue el objeto de analisis
  los tipos de glifos sin recurrir a comprobaciones de tipo o conversiones a un
  tipo inferior (@e(downcast)). No queremos una clase @c(RevisorOrtografico) que
  incluya (pseudo)codigo como

  ..src > c++
    void RevisorOrtografico::Revisar (Glifo* glifo) {
      Caracter* c;
      Fila* f;
      Imagen* i;

      if (c = dynamic_cast<Caracter*>(glifo)) {
        // analizar el caracter

      } else if (f = dynamic_cast<Fila*>(glifo)) {
        // se prepara para analizar sus hijos

      } else if (i = dynamic_cast<Imagen*>(glifo)) {
        // no hace nada
      }
    }
  < src..

  Este codigo es bastante feo. Se basa en caracteristicas bastante esotericas
  como los ahornados de tipo seguros. Tambien resulta dificil de ampliar.
  Tendremos que recordar cambiar el cuerpo de esta funcion cada vez que
  cambiemos de jerarquia de la clase @c(Glifo). De hecho, esta es la clase de
  codigo que los lenguajes orientados a objetos trataban de eliminar.

  Queremos evitar tal enfoque basado en la fuerza bruta, pero ¿como? Pensemos
  que sucede cuando añadimos la siguiente operacion abstracta a la clase
  @c(Glifo):

  ..src > c++
    void Revisame(RevisorOrtografico&)
  < src..

  Definimos @c(Revisame) en cada subclase de @c(Glifo) como sigue:

  ..src > c++
    void SubclaseGlifo::Revisame (RevisorOrtografico& revisor) {
      revisor.RevisarSubclaseGrifo(this);
    }
  < src..

  donde @c(SubclaseGlifo) sera reemplazada por el nombre da la subclase del
  glifo. Notese que cuando se llama a @c(Revisame), se conoce la subclase
  concreta de @c(Glifo) @-(despues de todo, estamos en una de sus
  operaciones). A su vez, la interfaz de la clase @c(RevisorOrtorgrafico)
  incluye una operacion como @c(RevisarSubclaseGlifo) para cada subclase de
  @c(Glifo).@n(25)

  ..src > c++
    class RevisorOrtografico {
    public:
      RevisorOrtografico();

      virtual void RevisarCaracter(Caracter*);
      virtual void RevisarFila(Fila*);
      virtual void RevisarImagen(Imagen*);

      // ... etcetera

      Lista<char*>& ObtenerErroresOrtograficos();

    protected:
      virtual bool EstaMalEscrito(const char*);

    private:
      char _palabraActual[MAX_TAM_PALABRA];
      Lista<char*> _errores;
    };
  < src..

  La operacion del @c(RevisorOrtografico) para glifos de @c(Caracter) puede
  parecerse a esto:

  ..src > c++
    void RevisorOrtografico::RevisarCaracter (Caracter* c) {
      const char c = c->ObtenerCodigoDeCaracter();

      if (isalpha(c)) {
        // añade el caracter alfabetico a _palabraActual

      } else {
        // hemos encontrado un glifo que no es un caracter

        if (EstaMalEscrito(_palabraActual)) {
          // añade la _palabraActual a _errores
          _errores.Insertar(strdup(_palabraActual));
        }

        _palabraActual[0] = '\0';

        // inicializa _parablaActual para comprobar
        // la siguiente palabra
      }
    }
  < src..

  Notese que hemos definido una operacion especial @c(ObtenerCodigoDeCaracter) en
  la clase @c(Caracter). El revisor gramatical puede tratar con operaciones
  especificas de las subclases sin depender de comprobaciones de tipo o
  ahormados @-(nos permite tratar a los objetos de forma especial).

  @c(RevisarCaracter) acumula caracteres alfabeticos en el bufer
  @c(_palabraActual).@n(26) Cuando encuentra un caracter no alfabetico, como un
  guion de subrayado, hace uso de la operacion @c(EstaMalEscrito) para comprobar
  la ortografia de la palabra que esta en @c(_palabraActual). Si la palabra esta
  mal escrita, @c(RevisarCaracter) la añade a la lista de palabras mal
  escritas. A continuacion debe vaciar el bufer @c(_palabraActual) para dejarlo
  listo para la siguiente palabra. Cuando termina el recorrido, se puede obtener
  la lista de palabras mal escritas con la operacion
  @c(ObtenerErroresOrtograficos).

  Ahora podemos recorrer la estructura, llamando a @c(Revisame) sobre cada
  glifo, con el revisor gramatical como argumento. Esto permite al
  @c(RevisorOrtografico) identificar a cada glifo.

  ..src > c++
    RevisorOrtografico revisorOrtografico;
    Composicion* c;

    // ...

    Glifo* g;
    IteradorPreorden i(c);

    for (i.Primeno(); !i.HaTerminado(); i.Siguiente()) {
      g = i.ElementoActual();
      g->Revisame(revisorOrtografico);
    }
  < src..

  El siguiente diagrama de interaccion muestra como trabajan juntos los glifos de
  @c(Caracter) y el objeto @c(RevisorOrtografico):

  ..img > img/030.png

  Este enfoque nos sirve para encontrar errores gramaticales, pero ¿como nos
  ayuda a permitir multiples tipos de analisis? Parece como si tuvieramos que
  añadir una operacion como @c[Revisame(RevisorOrtografico&)] a @c(Glifo) y sus
  subclases cada vez que añadamos un nuevo tipo de analisis. Esto es cierto si
  insistimos en una clase @e(indempendiente) para cada analisis. Pero no hay
  ningun motivo que nos impida dar la misma interfaz a @e(todas) las clases de
  analisis. Al hacerlo asi podemos usarlas polimorficamente. Eso significa que
  podemos reemplazar operacones especificas de cada analisis como
  @c[Revisame(RevisorOrtografico&)] con una operacion independiente del analisis
  que tome un parametro mas general.

*** Clase @c(Vistitante) y sus subclases

  Usaremos el termino @b(visitante) para referirnos generalmente a clases de
  objetos que @"(visitan) otros objetos durante un recorrido y hacen algo
  apropiado.@n(27) En este caso podemos definir una clase @c(Visitante) con una
  interfaz abstracta para visitar glifos en una estructura.

  ..src > c++
    class Visitante {
    public:
      virtual void VisitarCaracter(Caracter*) {}
      virtual void VisitarFila(Fila*) {}
      virtual void VisitarImagen(Imagen*) {}

      // ... etcetera
    };
  < src..

  Las subclases concretas de @c(Visitante) realizan distintos analisis. Por
  ejemplo, podriamos tener una subclase @c(VisitanteRevisionOrtografica) para
  comprobar la ortografia, y una subclase @c(VisitanteSeparacionGuiones) para la
  division de las palabras con guiones al final de la linea.
  @c(VisitanteRevisionOrtografica) se implementaria exactamente como
  implementamos antes el @c(RevisorOrtografico), salvo los nombres de la
  operacion, que reflejarian la interfaz mas general de @c(Visitante). Por
  ejemplo, @c(RevisarCaracter) se llamaria @c(VisitarCaracter).

  Como @c(Revisame) no resulta apropiado para los visitantes que no comprueban
  nada, le daremos un nombre mas general: @c(Aceptar). Su argumento tambien tiene
  que cambiar para recibir un @c(Visitante&), reflejando el hecho de que puede
  aceptar cualquier visitante. Ahora, para añadir un nuevo analisis basta con
  definir una nueva subclase de @c(Visitante) @-(no tenemos que tocar ninguna de
  las clase glifo). Añadiendo la citada operacion a @c(Glifo) y sus subclases
  permitimos cualquier analisis futuro.

  Ya hemos visto como funciona la revision ortografica. Usaremos un enfoque
  similar en @c(VisitanteSeparacionGuiones) para acumular texto. Pero una vez
  que la operacion @c(VisitarCaracter) de @c(VisitanteSeparacionGuiones) ha
  ensamblado una palabra completa, funciona algo diferente. En vez de comprobar
  la ortografia de la palabra, aplica un algoritmo de separacion de silabas para
  adeterminar los puntos potenciales de insercion de guiones en la palabra, si
  es que hay alguno. Entonces, en cada punto de insercion de guiones, inserta un
  glifo discrecional en la composicion. Los glifos discrecionales son isntancias
  de @c(Discrecional), una subclase de @c(Glifo).

  Un glifo discrecional tiene dos apariencias posibles, dependiendo de si es o
  no el ultimo caracter de una linea. Si es el ultimo caracter, entonces se
  representa como un guion; si no, no tiene ninguna representacion. El glifo
  discrecional comprueba su padre (un objeto @c(Fila)) para ver si es el ultimo
  hijo. Hace  esta operacion cada vez que es llamado para que dibuje o calcule
  sus limites. La estrategia de formateado trata a los glifos discrecionales
  como a los espacios en blanco, haciendolos candidatos para terminar una
  linea. El siguiente diagrama muestra como puede aparcer un glifo discrecional
  insertado.

  ..img > img/031.png

*** Patron Visitor (Visitante)

  Lo que se ha descrito hasta aqui es una aplicacion del patron @l(#Visitor). La
  clase @c(Visitante) que se describio anteriormente y sus subclases son los
  participantes clave del patron. El patron Visitor representa la tecnica que
  hemos usado para permitir un numero indefinido de analisis de estructuras de
  glifos sin tener que cambiar las propias clases de los distintos glifos. Otra
  caracteristica interesante de los visitantes es que se pueden aplicar no solo
  a elementos compuestos como nuestras estructuras de glifos, sino a cualquier
  estructura de objetos. Eso incluye conjuntos, listas e incluso grafos
  dirigidos aiclicos. Es mas, las clases que puede visitar un visitante no
  necesitan estar relacionadas unas con otras por medio de una clase padre
  comun. Esto significa que los visitantes pueden funcionar en varias jerarquias
  de clases.

  Una cuestion importante que debemos preguntarnos antes de aplicar el patron
  Visitor es: ¿que jerarquias de clases cambian mas frecuentemente? El patron
  resulta mas apropiado cuando queremos ser capaces de realizar varias
  operaciones diferentes sobre unos objetos que tienen una estructura de clases
  estable. Añadir un nuevo tipo de visitante no requiere ningun cambio en la
  estructura de clases, lo que es especialmente importante cuando la estructura
  de clases es grande. Pero cada vez que se añade una subclase a la estructura,
  tambien habra que actualizar todas nuestras interfaces de visitantes para
  incluir una operacion @c(Visitar)... para cada subclase. en nuestro ejemplo,
  eso significa que añadir una nueva subclase de @c(Glifo) llamada @c(Foo)
  requerira cambiar @c(Visitante) y todas sus subclases para que incluyan una
  operacion @c(VisitarFoo). Pero, dadas las restricciones de nuestro diseño, es
  mucho mas probable que añadamos nuevos tipos de analisis a Lexi que un nuevo
  tipo de Glifo. De manera que el patron Visitor resulta apropiado para nuestras
  necesidades.

** 2.9 <> Resumen

  Hemos aplicado ocho patrones diferentes al diseño de Lexi:

  1. @l(#Composite) para representar la estructura fisica del documento
  2. @l(#Strategy) para permitir diferentes tipos de algoritmos de formateado,
  3. @l(#Decorator) para adornar la interfaz de usuario,
  4. @l(#Abstract Factory) para permitir multiples estandares de interfaz de usuario,
  5. @l(#Bridge) para permitir diferentes platafarmas de ventanas,
  6. @l(#Command) para deshacer operaciones de usuario,
  7. @l(#Iterator) para recorrer estructuras de objetos y acceder a sus elemenentos, y
  8. @l(#Visitor) para permitir un numero indeterminado de capacidades de
     analisis sin complcar la implementacion de la estructura del documento.

  Ninguno de estos problemas de diseño se reduce a aplicaciones de edicion de
  documentos como Lexi. De hecho, la mayoria de aplicaciones no triviales
  tendran ocasion de usar muchos de estos patrones, aunque tal vez para hacer
  cosas diferentes. Una aplicacion de analisis financiero podria usar el patron
  Composite para definir carteras de inversiones formadas por subcarteras y
  cuentas de diferentes tipos. Un compilador podria usar el patron Strategy para
  permitir diferentes esquemas de asignacion de registros para diferentes
  maquinas de destino. Las aplicaciones con una interfaz grafica probablemente
  aplicaran al menos los patrones Decorator y Command tal y como hemos hecho
  aqui.

  Aunque hemos cubierto varios problemas importantes de diseño de Lexi, hay
  mucho otros que no hemos discutido. Este libro describe mas de los ocho
  patrones que hemos usado aqui. Asi que a medida que estudio el resto de
  patrones, piense como podria usar cada uno de ellos en Lexi. O, mejor aun,
  ¡piense como utilizarlos en sus propios diseños!

* Catalogo de Patrones de Diseño
* Capitulo 3 <> Patrones de Creacion

  Los patrones de diseño de creacion abstraen el proceso de creacion de
  instancias. Ayudan a hacer a un sistema independiente de como se crean, se
  componen y se representan sus objetos. Un patron de creacion de clase usa la
  herencia para cambiar la clase de la instancia a crear, mientras que un patron
  de creacion de objetos delega la creacion de la instancia en otro objeto.

  Los patrones de creacion se hacen mas importantes a medida que los sistemas
  evolucionan para depender mas de la composicion de objetos que de la herencia
  de clases. Cuando esto sucede, se pasa de codificar una serie de
  comportamientos fijos a definir un conjunto mas pequeño de comportamientos
  fundamentales que  pueden componerse con otros mas complejos. Asi, para crear
  objetos con un determinado comportamiento es necesario algo mas que
  simplemente crear una instancia de una clase.

  Hay dos temas recurrentes en estos patrones. En primer lugar, todos ellos
  encapsulan el conocimiento sobre las clases concretas que usan el sistema.
  Segundo, todos ocultan como se crean y se asocian las instancias de estas
  clases. Todo lo que el sistema como tal conoce acerca de los objetos son sus
  interfaces, tal y como las definen sus clases abstractas. Por tanto, los
  patrones de creacion dan mucha flexibilidad a que es lo que se crea, quien lo
  crea y cuando. Permiten configurar un sistema con objetos @"(producto) que
  varian mucho en estructura y funcionalidad. La configuracion puede ser
  estatica (esto es, especificada en tiempo de compilacion) o dinamica (en
  tiempo de ejecucion).

  A veces, los patrones de creacion son rivales entre si. Por ejemplo, hay casos
  en los que tanto el patron @l(#Prototype) como el @l(#Abstract Factory)
  podrian usarse provechosamente. Otras veces son complementarios: el patron
  @l(#Builder) puede usar uno de los otros patrones de creacion para implementar
  que componentes debe construir; el patron @l(#Prototype) puede usar el
  @l(#Singleton) en su implementacion.

  Dado que los patrones de creacion estan estrechamente relacionados,
  estudiaremos los cinco juntos para resaltar sus similitudes y diferencias.
  Tambien usaremos un ejemplo comun @-(construir un laberinto para un juego de
  computadora) para ilustrar sus implementaciones. El laberinto y el juego
  cambiaran ligeramente de un patron a otro. A veces el juego consistira
  simplemente en encontrar la salida del laberinto; en ese caso el jugador
  probablemente solo tendra una vision local del laberinto. Otras veces el
  laberinto contendra problemas que resolver y peligros que superar, y estos
  juegos pueden proporcionar un plano de la parte del laberinto que ha sido
  explorada.

  Omitiremos muchos detalles sobre que puede haber en un laberinto y si el juego
  tiene uno o varios jugadores. En vez de eso, nos centraremos en como se crean
  los laberintos. definimos un laberinto como un conjunto de habitaciones. Una
  habitacion conoce sus lindes; estos pueden ser otra habication, una pared o
  una puerta a otra habitacion.

  Las clases @c(Habitacion), @c(Puerta) y @c(Pared) definen los componentes del
  laberinto usado en todos nuestros ejemplos. Definiremos solo las partes de
  esas clases que son importantes para crear un laberinto. Obviaremos los
  jugadores, las operaciones de visualizacion y aquellas para caminar por el
  laberinto, ademas de otras funcionalidades importantes que no son relevantes
  para construir el laberinto.

  El diagrama siguiente muestra la relacion entre estas clases.

  ..img > img/032.png

  Cada habitacion tiene cuatro lados. Usaremos una enumeracion @c(Direccion) en
  las implementaciones en C++ para especificar los lados norte, sur, este y
  oeste de una habitacion:

  ..src > c++
    enum Direccion {Norte, Sur, Este, Oeste};
  < src..

  Las implementaciones en Smalltalk usan los simbolos correspondientes para
  representar estas direcciones.

  La clase @c(LugarDelMapa) es la clas abstracta comun de todos los componentes
  de un laberinto. Para simplificar el ejemplo, @c(LugarDelMapa) solo define una
  operacion, @c(Entrar). Su significado depende de en donde estemos entrando. Si
  entramos en una habitacion cambiara nuestra posicion. Si tratamos de entrar en
  una puerta, puede pasar una de estas dos cosas: si la puerta esta abierta,
  pasaremos a la siguiente habitacion; si esta cerrada, nos daremos con ella de
  nariz.

  ..src > c++
    class LugarDelMapa {
    public:
        virtual void Entrar() = 0;
    };
  < src..

  @c(Entrar) proporciona una base para operaciones mas sofisticadas del
  juego. Por ejemplo, si estamos en una habitacion y decimos @"(ir hacia el
  Este), el juego puede determinar facilmente que @c(LugarDelMapa) se encuentra
  inmediatamente al este, para a continuacion llamar a su operacion
  @c(Entrar). La operacion @c(Entrar) de cada subclase concreta determina si
  cambia nuestra posicion o si nos golpeamos la nariz. En un juego real,
  @c(Entrar) podria tomar como argumento el objeto jugador que se esta moviendo.

  @c(Habitacion) es la subclase concreta de @c(LugarDelMapa) que define las
  relaciones pricipales entre los componentes del laberinto. Mantiene
  referencias a otros objetos @c(LugarDelMapa) y guarda su numero de
  habitacion. Este numero identificara las habitaciones en el laberinto.

  ..src > c++
    class Habitacion : public LugarDelMapa {
    public:
        Habitacion(int numHabitacion);

        LugarDelMapa* ObtenerLado(Direccion) const;
        void EstablecerLado(Direccion, LugarDelMapa*);

        virtual void Entrar();

    private:
        LugarDelMapa* _lados[4];
        int _numeroHabitacion;
    };
  < src..

  Las clases siguientes representan la pared o la puerta que hay en cada lado de
  una estancia.

  ..src > c++
    class Pared : public LugarDelMapa {
    public:
        Pared();

        virtual void Entrar();
    };

    class Puerta : public LugarDelMapa {
    public:
        Puerta(Habitacion* = 0, Habitacion* = 0);

        virtual void Entrar();
        Habitacion* OtroLadoDe(Habitacion*);

    private:
        Room* _habitacion1;
        Room* _habitacion2;
        bool _estaAbierta;
    };
  < src..

  Necesitames conocer mas cosas ademas de las partes del laberinto. definiremos
  tambien una clase @c(Laberinto) que representa una serie de habitaciones.
  @c(Laberinto) tambien puede encontrar una determinada habitacion usando su
  operacion @c(NumeroDeHabitacion).

  ..src > c++
    class Laberinto {
    public:
        Laberinto();

        void AnadirHabitacion(Habitacion*);
        Habitacion* NumeroDeHabitacion(int) const;
    private:
        // ...
    };
  < src..

  @c(NumeroDeHabitacion) podria hacer una busqueda usando una busqueda lineal,
  una tabla de dispersion @%e(hash) o incluso un simple array. Pero no nos
  preocuparemos aqui por esos detalles, si no que nos centraremos en como
  especificar los componentes de un objeto laberinto.

  Ottra clase que definimos es @c(JuegoDelLaberinto), que es la que crea el
  laberinto. Una forma sencilla de crear el laberinto es con una serie de
  operaciones que añadan componentes a un laberinto y los conecten entre si. Por
  ejemplo, las siguientes funciones miembro crearan un laberinto consistente en
  dos habitaciones con una puerta entre ambas:

  ..src > c++
    Laberinto* JuegoDelLaberinto::CrearLaberinto () {
        Laberinto* unLaberinto = new Laberinto;
        Habitacion* h1 = new Habitacion(1);
        Habitacion* h2 = new Habitacion(2);
        Puerta * laPuerta = new Puerta(h1, h2);

        unLaberinto->AnadirHabitacion(h1);
        unLaberinto->AnadirHabitacion(h2);

        h1->EstablecerLado(Norte, new Pared);
        h1->EstablecerLado(Este, laPuerta);
        h1->EstablecerLado(Sur, new Pared);
        h1->EstablecerLado(Oeste, new Pared);

        h2->EstablecerLado(Norte, new Pared);
        h2->EstablecerLado(Este, new Pared);
        h2->EstablecerLado(Sur, new Pared);
        h2->EstablecerLado(Oeste, laPuerta);

        return unLaberinto;
    }
  < src..

  Esta funcion es bastante complicada, teniendo en cuenta que todo lo que hace
  es crear un laberinto con dos habitaciones. Hay maneras obvias de hacerla mas
  simple. Por ejemplo, el constructor de @c(Habitacion) podria inicializar por
  omision los lados con paredes. Pero eso simplemente moveria el codigo a otro
  lugar. El problema real de esta funcion miembro no es su tamaño, sino su
  @e(inflexibilidad), al fijar en el codigo la distribucion del laberinto.
  Cambiar la distribucion significa cambiar esta funcion miembro, ya sea
  redefiniendola @-(lo que significa reimplementarla en su totalidad) o
  cambiando partes de ella @-(lo que es propenso a errores y no promueve la
  reutilizacion).

  Los patrones de creacion muestran como hacer este diseño mas @e(flexible), no
  necesariamente mas pequeño. En concreto, haran que sea mas facil cambiar las
  clases que definen los componentes de un laberinto.

  Supongamos que quisieramos reutilizar la distribucion de un laberinto
  existente para un nuevo juego que contiene laberintos encantados. El juego de
  los laberintos encantados tiene nuevos tipos de componentes, como
  @c(PuertaQueNecesitaHechizo), un tipo de puerta que solo puede cerrarse y
  abrirse con un hechizo; @c(HabitacionEncantada), una habitaicon que puede
  contener elementos no convencionales, tales como llaves magicas o hechizos.
  ¿Como podemos cambiar @c(CrearLaberinto) facilmente para crear laberintos con
  estas nuevas clases de objetos?

  En este caso, el principal obstaculo para el cambio reside en fijar en el
  codigo las clases de las que se crean las instancias. Los patrones de creacion
  proporcionan varias formas de eliminar las referencias explicitas a clases
  concretas en el codigo que necesita crear instancias de ellas:

  - Si @c(CrearLaberinto) llama a funciones virtuales en vez de a constructores
    para crear las habitaciones, paredes y puertas que necesita, entonces podemos
    cambiar las clases de las instancias a crear haciendo una subclase de
    @c(JuegoDelLaberinto) y redefiniendo dichas funciones virtuales). Este
    enfoque es un ejemplo del patron @l(#Factory Method).

  - Si a @c(CrearLaberinto) le pasamos un objeto como parametro a usar para
    crear las habitaciones, paredes y puertas, podemos cambiar las clases de
    estos elementos pasandole un parametro diferente. Este es un ejemplo del
    patron @l(#Abstract Factory).

  - Si a @c(CrearLaberinto) le pasamos un objeto que puede crear un nuevo
    laberinto en su totalidad usando operaciones para añadir habitaciones,
    puertas y paredes al laberinto que construye, podemos usar la herencia para
    cambiar partes del laberinto o el modo en que este es construido. Este es un
    ejemplo del patron @l(#Builder).

  - Si parametrizamos @c(CrearLaberinto) con varias habitaciones, puertas y
    paredes prototipicas, las cuales copia y luego añade al laberinto, podemos
    cambiar la composicion del laberinto sustituyendo estos objetos prototipicos
    por otros diferentes. Este es un ejemplo del patron @l(#Prototype).

  El patron de creacion que falta, el @l(#Singleton), puede garantizal que solo
  haya un laberinto por juego y que todos los objetos del juego puedan acceder
  @-(sin necesidad de acudir a variables o funciones globales). El Singleton
  tambien hace mas facil ampliar o sustituir el laberinto sin tocar el codigo
  existente.

** Abstract Factory
*** Abstract Factory Proposito <> Proposito

  Proporciona una interfaz para crear familias de objetos relacionados o que
  dependen entre si, sin especificar sus clases concretas.

*** Abstract Factory Tambien Conocido Como <> Tambien Conocido Como

  Kit

*** Abstract Factory Motivacion <> Motivacion

  Pensemos en un toolkit de interfaces de usuario que admita multiples
  estandares de interfaz de usuario,@n(9) tales como Motif y Presentation
  Manager. Los distintos estandares interfaz de usuario definen distintos
  aspectos y formas de comportamiento de los @"(utiles)@n(28) de la interfaz de
  usuario, como las barras de desplazamiento, ventanas y botones. Para que una
  aplicacion pueda portarse a varios estandares de interfaz de usuario, esta no
  deberia codificar sus utilez para una interfaz de usuario en particular. Si la
  aplicacion crea instancias de clases o utiles especificos de la interfaz de
  usuario sera dificl cambiar esta mas tarde.

  Podemos solucionar este problema definiendo una clase abstracta
  @c(FabricaDeUtiles) que declara una interfaz para crear cada tipo basico de
  util (@e(widget)). Tambien hay una clase abstracta para cada tipo de util, y
  las subclases concretas implementan utiles para un estandar concreto de
  interfaz de usuario. La interfaz de @c(FabricaDeUtiles) tiene una operacion
  que devuelve un nuevo objeto para cada clase abstracta de util. Los clientes
  llaman a estas operaciones para obtener instancias de utiles, pero no son
  conscientes de las clases concretas que estan usando. De esta manera los
  clientes son independientes de la interfaz de usuario.

  Hay una subclase concreta de @c(FabricaDeUtiles) para cada estandar de interfaz
  de usuario. Cada subclase implementa las operaciones que crean el util
  apropiado para su interfaz de usuario. Por ejemplo, la operacion
  @c(CrearBarraDeDesplazamiento) de la @c(FabriacaDeUtilesMotif) crea y devuelve
  una instancia de una barra de desplazamiento Motif, mientras que la misma
  operacion de @c(FabricaDeUtilesPM) de vuelve una barra de desplazamiento para
  Presentation Manager. Los clientes crean utiles unicamente a travez de la
  interfaz @c(FabricaDeUtiles) y no tienen conocimento de las clases que
  implementan los utiles para una determinada interfaz de usuario. En otras
  palabras, los clientes no tienen que atarse a una clase concreta, sino solo a
  una interfaz definida por una clase abstracta.

  Una @c(FabricaDeUtiles) tambien fuerza a que se cumplan las dependencias
  entre las clase concretas de utiles. Una barra de desplazamiento Motif deberia
  usarse como un boton Motif y un editor de texto Motif, y esa restriccion se
  cumple automaticamente como consecuencia de usar una @c(FabricaDeUtilesMotif).

  ..img > img/033.png

*** Abstract Factory Aplicabilidad <> Aplicabilidad

  Usese el patron Abstract Facttory cuando

  - un sistema debe ser independiente de como se crean, componen y representan
    sus productos.

  - un sistema debe ser configurado con una familia de productos de entre varias.

  - una familia de objetos producto relacionados esta diseñada para ser usada
    conjuntamente, y es necesario hacer cumplir esta restriccion.

  - quiere proporcionar una biblioteca de clases de productos, y solo quiere
    revelar sus interfaces, no sus implementaciones.

*** Abstract Factory Estructura <> Estructura

  ..img > img/034.png

*** Abstract Factory Participantes <> Participantes

  + @c(FabricaAbstracta) (@c(FrabricaDeUtiles))

    - declara una interfaz para operaciones que crean objetos producto
      abstractos.

  + @c(FabricaConcreta) (@c(FabriacaDeUtilesMotif), @c(FabriacaDeUtilesPM))

    - implementa las operaciones para crear objetos producto concretos.

  + @c(ProductoAbstrato) (@c(Ventana), @c(BarraDeDesplazamiento))

    - declara una interfaz para un tipo de objeto producto.

  + @c(ProductoConcreto) (@c(VentanaMotif), @c(BarraDeDesplazamientoMotif))

    - define un objeto producto para que sea creado por la fabrica
      correspondiente.

    - implementa la interfaz @c(ProductoAbstracto).

  + @c(Cliente)

    - solo usa interfaces declaradas por las clases @c(FabricaAbstracta) y
      @c(ProductoAbstracto).

*** Abstract Factory Colaboraciones <> Colaboraciones

  - Normalmente solo se crea una unica instancia de una clase @c(FabricaConcreta)
    en tiempo de ejecucion. Esta fabrica concreta crea objetos que tienen una
    determinada implementacion.

    Para crear diferentes objetos producto los clientes deben usar una fabrica
    concreta diferente.

  - @c(FabricaAbstracta) delega la creacion de objetos producto en su subclase
    @c(FabricaConcreta).

*** Abstract Factory Consecuencias <> Consecuencias

  El patron Abstract Factory tiene las siguientes ventajas e inconvenientes:

  1. @e(Aisla las clases concretas.) El patron Abstract Factory ayuda a
     controlar las clases de objetos que crea una aplicacion. Como una fabrica
     encapsula la responsabilidad y el proceso de creacion de objetos producto,
     aisla a los clientes de las clases de implementacion. Los clientes
     manipulan las instancias a traves de sus interfaces abstractas. Los nombres
     de las clases producto quedan aisladas en la implementacion de la fabrica
     concreta; no aparecen en el codigo cliente.

  2. @e(Facilita el intercambio de familias de productos.) La clase de una
     fabrica concreta solo aparece una vez en una aplicacion @-(cuando se
     crea). Esto facilita cambiar la fabrica concreta que usa una aplicacion.
     Como una fabrica abstracta crea una familia completa de productos, toda la
     familia de productos cambia de una vez. En nuestro ejemplo de la interfaz
     de usuario, podemos cambiar de utiles Motif a utiles Presentation Manager
     simplemente cambiando los correspondientes objetos fabrica y volviendo a
     crear la interfaz.

  3. @e(Promueve la consistencia entre productos.) Cuando se diseñan objetos
     producto en una familia para trabajar juntos, es importante que una
     aplicacion use objetos de una sola familia a la vez. @c(FabricaAbstracta)
     facilita que se cumpla esta restriccion.

  4. @e(Es dificil dar cabida a nuevos tipos de productos.) Ampliar las fabricas
     abstractas para producir nuevos tipos de productos no es facil. Esto se
     debe a que la interfaz @c(FabricaAbstracta) fija el conjunto de productos
     que se pueden crear. Permitir nuevos tipos de productos requiere ampliar la
     interfaz de la fabrica, lo que a su vez implica cambiar la clase
     @c(FabricaAbstacta) y todas sus subclases. En la seccion de Implementacion
     se analiza una sola solucion a este problema.

*** Abstract Factory Implementacion <> Implementacion

  Estas son algunas tecnicas utiles para implementar el patron Abstract Factory.

  1. @e(Fabricas unicas.) Normalmente una aplicacion solo necesita una instancia
     de @c(FabricaConcreta) por cada familia de productos. Por tanto, suele
     implementarse mejor como un @l(#Singleton).

  2. @e(Crear los productos.) @c(FabricaAbstracta) solo declara una @e(intarfaz)
     para crear productos. Se deja a las subclases @c(ProductoConcreto) el
     crearlos realmente. El modo mas comun de hacer esto es definiendo un metodo
     de fabricacion para cada producto (vease el patron @l(#Factory Method)). Una
     fabrica concreta especificara sus productos redefiniendo el metodo fabrica
     de cada uno. Si bien esta implementacion es sencilla, requiere una nueva
     subclase fabrica concreta para cada familia de productos, incluso aunque
     las familias de productos difieran solo ligeramente.

     En caso de que sea posible tener muchas familias de productos, la fabrica
     concreta puede implementarse usando el patron @l(#Prototype). La fabrica
     concreta se inicializa con una instancia prototipica de cada producto de la
     familia, y crea un nuevo producto clonando su prototipo. El enfoque basado
     en prototipos elimina la necesidad de una nueva clase de fabrica concreta
     para cada nueva familia de productos.

     A continuacion presentaremos un modo de implementar una fabrica basada en
     prototipos en Smalltalk. La fabrica concreta guarda los prototipos a clonar
     en un diccionario llamado @c(catalogoDePartes). El metodo @c(hacer:)
     obtiene el prototipo y lo clona:

     ..src > smalltalk
       hacer: nombre
           ^  (catalogoDePartes at: nombreParte) copy
     < src..

     La fabrica concreta tiene un metodo para añadir partes de catalogo.

     ..src > smalltalk
       anadirParte: plantillaParte nombre: nombreParte
           catalogoDePartes at: nombreParte put: plantillaParte
     < src..

     Los prototipos se añaden a la fabrica identificandolos con un simbolo:

     ..src > smalltalk
       unaFabrica anadirParte: unProtipo nombre: #utilACME
     < src..

     Es posible una variacion del enfoque basado en prototipos en lenguajes que
     tratan a las clases como objetos en toda regla (Smalltalk y Objetive C, por
     ejemplo). En tales lenguajes podemos pensar en una clase como una fabrica
     degenerada que solo crea un tipo de producto. Podemos almacenar @e(clases)
     en variables dentro de una fabrica concreta que crea los distintos productos
     concretos, de manera muy parecida a los prototipos. Estas clases crean nuevas
     instancias en nombre de la fabrica concreta. Definimos una nueva fabrica
     inicializando una instancia de una fabrica concreta con @e(clases) de
     productos en vez de mediante subclases. Este enfoque se aprovecha de
     caracteristicas del lenguaje, mientras que el enfoque basado en prototipos
     puro es independiente del lenguaje.

     Al igual que la fabrica basada en prototipos en Smalltalk que acabamos de
     ver, la version basada en clases tendra una unica variable de instancia
     @c(catalogoDePartes), que es un diccionario cuya clave es el nombre de la
     parte. En vez de guardar los prototipos a ser clonados, @c(catalogoDePartes)
     almacena las clase de los productos. El metodo @c(hacer:) quedaria ahora
     asi:

     ..src > smalltalk
       hacer: nombreParte
           ^  (catalogoDePartes at: nombreParte) new
     < src..

  3. @e(Definir Fabricas extensibles.) @c(FabricaAbstracta) por lo general
     define una operacion diferente para cada tipo de producto que puede
     producir. Los tipos de producto estan codificados en las signaturas de las
     operaciones. Añadir un nuevo tiepo de producto requiere cambiar la interfaz
     de @c(FabricaAbstracta) y todas las clases que dependen de ella.

     Un diseño mas flexible, aunque menos seguro, es añadir un parametro a las
     operaciones que crean objetos. Este parametro especifica el tipo de objeto
     a ser creado. Podria tratarse du un identificador de clase, un entero, una
     cadena de texto o cualquier otra cosa que identifique el tipo de
     producto. De hecho, con este enfoque, @c(FabricaAbstracta) solo necesita
     una unica operacion @"(Hacer) con un parametro que indique el tipo de
     objeto a crear. Esta es la tecnica usada en las fabricas abstractas basadas
     en clases y en prototipos que se examinaron anteriormente. Esta variacion es
     mas facil de usar en un lenguaje dinamicamente tipado, como Smalltalk, que
     en uno estaticamente tipado, como C++. Podemos aplicarla en C++ solo cuando
     todos los objetos tienen la misma clase base abstracta o cuando los objetos
     produco pueden ser convertidos con seguridad al tipo concreto por el objeto
     que los solicita. La seccion de implementacion del patron @l(#Factory
     Method) muestra como implementar dichas operaciones parametrizadas en
     C++. Pero incluso cuando no es necesaria la conversion de tipos, tadavia
     subyace un problema inherente: todos los productos se devuelven al cliente
     con la @e(misma) interfaz abstracta que el tipo de retorno. El ciente no
     podra por tanto distinguir o hacer suposiciones seguras acerca de la clase
     de un producto. En caso de que los clientes necesiten realizar operaciones
     especificas de las subclases, estas no estaran accesibles a traves de la
     interfaz abstracta. Aunque el cliente podria hacer una conversion al tipo
     de una clase hija (esto es, un @e(downcast)) (por ejemplo, con
     @c(dynamic_cast) en C++), eso no siempre resulta viable o seguro, porque la
     conversion de tipos puede fallar. Este es el inconveniente tipico de una
     interfaz altamente flexible y extensible.

*** Abstract Factory Codigo de Ejemplo <> Codigo de Ejemplo

  Aplicaremes el patron Abstract Factory para crear los laberintos de los que
  hablamos al principo de este capitulo.

  La clase @c(FabricaDeLaberintos) puede crear los componentes de los
  laberintos. Construye habitaciones, paredes y puertas entre las
  habitaciones. Podria ser usada por un programa que lee de un fichero los
  planos de los laberinos y construye el correspodiente laberinto. O tal vez sea
  usada por un programa que construye los laberintos al azar. Los programas que
  construyen loberintes toman una @c(FabricaDeLaberintos) como argumento, de
  manera que el programador puede especificar las clases de habitaciones,
  paredes y puertas a construir

  ..src > c++
    class FabricaDeLaberintos {
    public:
        FabricaDeLaberintos();

        virtual Laberinto* HacerLaberinto() const
            { return new Laberinto; }
        virtual Pared* HacerPared() const
            { return new Pared; }
        virtual Habitacion* HacerHabitacion(int n) const
            { return new Habitacion(n); }
        virtual Puerta* HacerPuerta(Habitacion* h1,
                                    Habitacion* h2) const
            { return new Puerta(h1, h2); }
    };
  < src..

  Recordemos que la funcion @c(CrearLaberinto) construye un pequeño laberinto
  consistente en dos habitaciones con una puerta entre ellas. @c(CrearLaberinto)
  fija en el codigo los nombres de clases, dificultando asi la posibilidad de
  crear laberintos con otros componentes.

  Presentamos una version de @c(CrearLaberinto) que remedia esta deficiencia
  tomando como parametro una @c(FabricaDeLaberintos):

  ..src > c++
    Laberinto* JuegoDelLaberinto::CrearLaberinto (FabricaDeLaberintos& fabrica) {
        Laberinto* unLaberinto = fabrica.HacerLaberinto();
        Habitacion* h1 = fabrica.HacerHabitacion(1);
        Habitacion* h2 = fabrica.HacerHabitacion(2);
        Puerta* unaPuerta = fabrica.HacerPuerta(h1, h2);

        unLaberinto->AnadirHabitacion(h1);
        unLaberinto->AnadirHabitacion(h2);

        h1->EstablecerLado(Norte, fabrica.HacerPared());
        h1->EstablecerLado(Este, unaPuerta);
        h1->EstablecerLado(Sur, fabrica.HacerPared());
        h1->EstablecerLado(Oeste, fabrica.HacerPared());

        h2->EstablecerLado(Norte, fabrica.HacerPared());
        h2->EstablecerLado(Este, fabrica.HacerPared());
        h2->EstablecerLado(Sur, fabrica.HacerPared());
        h2->EstablecerLado(Oeste, unaPuerta);

        return unLaberinto;
    }
  < src..

  Podemos crear @c(FabricaDeLaberintosEncantados), una fabrica para laberintos
  encantados, como una subclase de @c(FabricaDeLaberintos).
  @c(FabricaDeLaberintosEncantados) redefinira diferentes funciones miembro y
  devolvera diferentes subclases de @c(Habitacion), @c(Pared), etc.

  ..src > c++
    class FabricaDeLaberintosEncantados : public FabricaDeLaberintos {
    public:
        fabricaDeLaberintosEncantados();

        virtual Habitacion* HacerHabitacion(int n) const
            { return new HabitacionEncantada(n, Hechizar()); }

        virtual Puerta* HacerPuerta(Habitacion* h1,
                                    Habitacion* h2) const
            { return new PuertaQueNecesitaHechizo (h1, h2); }

    protected:
        Hechizo* Hechizar() const;
    };
  < src..

  Supongamos ahora que queremos hacer un juego del laberinto en el que una
  habitacion puede tener puesta una bomba. Si la bomba explota, como minimo
  dañara las paredes. Podemos hacer una subclase de @c(Habitacion) que compruebe
  si la habitacion tiene una bomba y si ha explotado. Tambien necesitamos una
  subclase de @c(Pared) para saber el daño causado en ella. Llamaremos a estas
  clases @c(HabitacionConUnaBomba) y @c(ParedExplosionada).

  la ultima clase que definiremos es @c(FabricaDeLaberintosConBombas), una
  subclase de @c(FabricaDeLaberintos) que garantiza que las parades son de la
  clase @c(ParedExplosionada) y que las habitaciones son de la clase
  @c(HabitacionConBomba). @c(FabricaDeLaberintosConBombas) solo necesita
  refedinir dos funciones:

  ..src > c++
    Pared* FabricaDeLaberintosConBombas::HacerPared () const {
        return new ParedExplosionada;
    }

    Habitacion* FabricaDeLaberintosConBombas::HacerHabitacion(int n) const {
        return new HabitacionConBomba(n);
    }
  < src..

  Para construir un laberinto que pueda contener bombas, simplemente llamamos a
  @c(CrearLaberinto) con una @c(FabricaDeLaberintosConBombas).

  ..src > c++
    JuegoDelLaberinto juego;
    FabricaDelLaberintosConBombas fabrica;

    juego.CrearLaberinto(fabrica);
  < src..

  @c(CrearLaberinto) puede recibir igualmente una instancia de
  @c(FabricaDeLaberintosEncantados) para construir laberintos encantados.

  Notese que @c(FabricaDeLaberintos) no es mas que una coleccion de metodos de
  fabricacion. Esta es la forma mas normal de implementar el patron Abstract
  Factory. Ademas, @c(FabricaDeLaberintos) no es una clase abstracta, de manera
  que hace tanto de @c(FabricaAbstracta) @e(como) de @c(FabricaConcreta).
  Tambien este es la implementacion mas comun del patron Abstract Fartory para
  aplicaciones sencillas. Al ser @c(FabricaDeLaberintos) una clase concreta que
  consiste solamente en metodos de fabricacion, es facil hacer una nueva
  @c(FabricaDeLaberintos) creando una subclase y redefiniendo las operacions que
  se necesite cambiar. @c(CrearLaberinto) usa la operacion @c(EstablecerLado) de
  las habitaciones para especificar sus lados. Si se crean habitaciones con un
  @c(FabricaDeLaberintosConBombas) el laberinto estara formado por objetos
  @c(HabitacionConBomba) que tendran objetos @c(ParedExplosionada) como lados. En
  caso de que @c(HabitacionConBomba) tuviera que acceder a un miembro de
  @c(ParedExplosionada) especifico de la subclase, tendria que convertir una
  referencia a sus paredes de @c(Pared*) a @c(paredExplosionada*). Esta
  conversion de tipos (@e(downcasting)) es seguro siempre y cuando el argumento
  sea realmente una @c(ParedExplosionada), lo que esta garantizado si las
  paredes se costruyen unicamente mediante una @c(FabricaDeLaberintosConBombas).

  Por supuesto, en el caso de los lenguajes dinamicamente tipados, como
  Smalltalk, no es necesaria la conversion de tipos, pero podrian producirse
  errores en tiempo de ejecucion si encuentran una @c(Pared) donde esperaban una
  @e(subclase) de @c(Pared). Usar una Fabrica Abstracta para crear las paredes
  ayuda a evitar estos errores de tiempo de ejecucion al garantizar que solo se
  pueden crear ciertos tipos de paredes.

  Veamos una version de @c(FabricaDeLaberintos) en Smalltalk, con una unica
  operacion @c(hacer) que recibe como parametro el tipo de objeto a
  construir. Ademas, la fabrica concreta almacena las clases de los productos
  que crea.

  En primer lugar, escribiremos un @c(CrearLaberinto) equivalente en Smalltalk:

  ..src > smalltalk
    crearLaberinto: unaFabrica
        | habitacion1 habitacion2 unaPuerta |
        habitacion1 := (unaFabrica hacer: #habitacion) numero: 1.
        habitacion2 := (unaFabrica hacer: #habitacion) numero: 2.
        unaPuerta   := (unaFabrica hacer: #puerta) de: habitacion1 a: habitacion2.
        habitacion1 lado: #norte put: (unaFabrica hacer: #pared).
        habitacion1 lado: #este  put: unaPuerta.
        habitacion1 lado: #sur   put: (unaFabrica hacer: #pared).
        habitacion1 lado: #oeste put: (unaFabrica hacer: #pared).
        habitacion2 lado: #norte put: (unaFabrica hacer: #pared).
        habitacion2 lado: #este  put: (unaFabrica hacer: #pared).
        habitacion2 lado: #sur   put: (unaFabrica hacer: #pared).
        habitacion2 lado: #oeste put: unaPuerta.
        ^ Laberinto new anadirHabitacion: habitacion1;
    anadirHabitacion: habitacion2; yourself
  < src..

  Como ya dijimos en la seccion de Implementacion, @c(FabricaDeLaberintos) solo
  necesita una unica varible de instancia @c(catalogoDePartes), que consiste en
  un diccionario cuya clave es la clase del componente. Recordemos tambien
  como implementamos el metedo @c(hacer:):

  ..src > smalltalk
    hacer: nombreParte
        ^ (catalogoDePartes at: nombreParte) new
  < src..-

  Ahora podemos crear una @c(FabricaDeLaberintos) y usarla para implementar
  @c(crearLaberinto). Crearemos la fabrica usando el metodo
  @c(crearFabricaDeLaberintos) de la clase @c(JuegoDelLaberinto).

  ..src > smalltalk
    crearFabricaDeLaberintos
        ^ (FabricaDeLaberintos new
            anadirParte: Pared nombre: #pared;
            anadirParte: Habitacion nombre: #habitacion;
            anadirParte: Puerta nombre: #puerta;
            yourself)
  < src..

  Una @c(FabricaDeLaberintosConBombas) o una @c(FabricaDeLaberintosEncantados)
  se crean asociando diferentes clases con las claves. Por ejemplo, un
  @c(FabricaDeLaberintosEncantados) se podria crear como sigue:

  ..src > smalltalk
    crearFabricaDeLaberintos
        ^ (FabricaDeLaberintos new
            anadirParte: Pared nombre: #pared;
            anadirParte: HabitacionEncantada nombre: #habitacion;
            anadirParte: PuertaQueNecesitaHechizo nombre: #puerta;
            yourself)
  < src..

*** Abstract Factory Usos Conocidos <> Usos Conocidos

  InterViews usa el sufijo @"(Kit) [@l(#Lin92)] para denotar las clases
  @c(FabricaAbstracta). Define las fabricas abstractas @c(WidgetKit) y
  @c(DialogKit) para generar objetos especificos de la interfaz de
  usuario. InterViews tambien incluye un LayoutKit que genera diferentes objetos
  de composicion dependiendo de la disposicion deseada. Asi por ejemplo, una
  distribucion horizontal puede necesitar diferentes objetos de composicion
  dependiendo de la orientacion del documento (vertical o apaisado).

  ET++ [@l(#WGM88)] usa el patron Abstract Factory para lograr portabilidad entre
  varios sistemas de ventanas (por ejemplo, X, Windows y SunView). La clase base
  abstracta @c(WindowSystem) define la interfaz para crear objetos que
  representan recursos del sistema de ventanas (por ejemplo, @c(MakeWindow),
  @c(MakeFont), @c(MakeColor)). Las subclases concretas implementan las
  interfaces para un determinado sistema de ventanas. En tiempo de ejecucion,
  ET++ crea una instancia de una subclase concreta de @c(WindowSystem) que es la
  encargada de crear objetos concretos de recursos del sistema.

*** Abstract Factory Patrones Relacionados <> Patrones Relacionados

  Las clases @c(FabricaAbstracta) suelen implementarse con metodos de
  fabricacion (patron @l(#Factory Method)), pero tambien se pueden implementar
  usando prototipos (patron @l(#Prototype)).

  Una fabrica concreta suele ser un @l(#Singleton).

** Builder
*** Builder Proposito <> Proposito

  Separa la construccion de un objeto complejo de su representacion, de forma
  que el mismo proceso de construccion pueda crear diferentes representaciones.

*** Builder Motivacion <> Motivacion

  Un lector del formato de intercambio de documentos RTF (@e(Ritch Text format))
  deberia poder convertir RTF a muchos formatos de texto. Podria conrevtir
  documentos RTF a texto ASCII o a un util@n(29) de texto que pueda editarse de
  forma interactiva. El problema, no obstante, es que el numero de conversiones
  posibles es indefinido. Por tanto, tendria que ser facil añadir una nueva
  conversion sin modificar el lector.

  Una solucion es configurar la clase @c(LectorRTF) con un objeto
  @c(ConvertidorDeTexto) que convierta RTF a otra representacion textual. Cuando
  el @c(LectorRTF) analiza el documento RTF; usa el @c(ConvertidorDeTexto) para
  realizar la conversion. Cada vez que el @c(LectorRTF) reconozca un token RTF
  (ya sea texto normal o una palabra de control de RTF), envia una peticion al
  @c(ConvertidorDeTexto) para que lo convierta. Los objetos
  @c(ConvertidorDeTexto) son reponsables de realizar la conversion de datos y de
  representar el token en un determinado formato.

  Las subclases de @c(ConvertidorDeTexto) estan especializadas en diferentes
  coversiones y formatos. Por ejemplo, un @c(ConversorASCII) hace caso omiso de
  las peticiones de conversion de cualquier otra cosa que no sea texto sin
  formato. Por otro lado, un @c(ConversorTeX), implementara operaciones para todas
  las peticiones, con el objetivo de producir una representacion TeX con toda la
  informacion de estilo que haya en el texto. Un @c(ConvertidorUtilDeTexto)
  producira un objeto de interfaz de usuario que permita al usuario ver y editar
  el texto.

  ..img > img/035.png

  La clase de cada tipo de convertidor toma el mecanismo de creacion y
  ensamblaje de un objeto complejo y lo oculta tras una interfaz abstracta. El
  convertidor se separa del lector, que es el responsable de analizar un
  documento RTF.

  El patron Builder expresa todas estas relaciones. Cada clase de convertidor se
  denomina @b(constructor), en el contexto de este patron, y al lector se le
  llama @b(director). Aplicado a este ejemplo, el patron Builder separa el
  algoritmo para interpretar un formato textual (es decir, el analizador de
  documentos RTF) de la manera en que se crea y se representa el formato de
  destino. Esto permite reutilizar el algoritmo de analisis de @c(LectorRTF)
  para crear diferentes representaciones de texto a partir de decumentos RTF
  @-(basta con configurar el @c(LectorRTF) con diferentes subclases de
  @c(ConvertidoDeTexto)).

*** Builder Aplicabilidad <> Aplicabilidad

  Use el patron Builder cuando

  - el algoritmo para crear un objeto complejo deberia ser independiente de las
    partes de que se compone dicho objeto y de como se ensablan.

  - el proseso de costruccion debe permitir diferentes representaciones del objeto
    que esta siendo construido.

*** Builder Estructura <> Estructura

  ..img > img/036.png

*** Builder Participantes <> Participantes

  - @c(Constructor) (@c(ConvertidorDeTexto))

    - especifica una interfaz abstracta para crear las partes de un objeto
      @c(Producto).

  - @c(ConstructorConcreto) (@c(ConvertidorASCII), @c(ConvertidorTeX),
    @c(ConvertidorUtilDeTexto))

    - implementa la interfaz @c(Constructor) para construir y ensamblar las
      partes del producto.

    - define la representacion a crear.

    - proporciona una interfaz para devolver el producto (p. ej.,
      @c(ObtenerTextoASCII), @c(ObtenerUtilDeTexto)).

  - @c(Director) (@c(LectorRTF))

    - construye un objeto usando la interfaz @c(Constructor).

  - @c(Producto) (@c(TextoASCII), @c(TextoTeX), @c(UtilDeTexto))

    - representa el objeto complejo en construccion. El @c(ConstructorConcreto)
      construye la representacion interna del producto y define el proceso de
      ensamblaje.

    - incluye las clases que definen sus partes constituyentes, incluyendo
      interfaces para ensamblar las partes en el resultado final.

*** Builder Colaboraciones <> Colaboraciones

  - El cliente crea el objeto @c(Director) y lo configura con el objeto
    @c(Constructor) deseado.

  - El @c(Director) notifica al constructor cada vez que hay que construir una
    parte de un producto.

  - El @c(Constructor) maneja las peticiones del director y las añade al producto.

  - El cliente obtiene el producto del constructor.

  El siguiente diagrama de interaccion ilustra como cooperan con un cliente el
  @c(Constructor) y el @c(Director).

  ..img > img/037.png

*** Builder Consecuencias <> Consecuencias

  Estas son las consecuencias del patron Builder.

  1. @e(Permite variar la representacion interna de un producto.) El objeto
     @c(Costructor) proporciona al director una interfaz abstracta para
     construir el producto. La interfaz permite que el constructor oculte la
     representacion y la estructura interna del producto. Tambien oculta el modo
     en que este es ensamblado. Dado que el producto se construye a traves de
     una interfaz abstracta, todo lo que hay que hacer para cambiar la
     representacion interna del producto es definir un nuevo tipo de
     constructor.

  2. @e(Aisla el codigo de construccion y representacion.) El patron Builder
     aumenta la modularidad al encapsular como se construyen y se representan
     los objetos complejos. Los clientes no necesitan saber nada de las clases
     que definen la estructura interna del producto; dichas clases no aparecen
     en la interfaz del @c(Constructor).

     Cada @c(ConstructorConcreto) contiene todo el codigo para crear y ensamblar
     un determinado tipo de producto. El codigo solo se escribe una vez;
     despues, los diferentes @c(Directores) pueden reutilizarlo para construir
     variantes de @c(Producto) a partir del mismo conjunto de partes. En el
     ejemplo anterior de RTF, podriamos definir un lector para otro formato
     distinto de RTF, como por ejemplo un @c(LectorSGML), y usar los mismos
     objetos @c(ConvertidorDeTexto) para generar representaciones
     @c(TextoASCII), @c(TextoTeX) y @c(UtilDeTexto) de documentos @c(SGML).

  3. @e(Proporciona un control mas fino sobre el proseso de construccion.) A
     diferencia de los patrones de creacion que construyen los productos de una
     vez, el patron Builder construye el producto paso a paso, bajo el control
     del director. El director solo obtiene el producto del costructor una vez
     que este esta terminado. Por tanto, la interfaz @c(Constructor) refleja el
     proceso de construccion del producto mas que otros patrones de creacion.
     Esto da un control mas fino sobre el proceso de contruccion y, por tanto,
     sobre la estructura interna del producto resultante.

*** Builder Implementacion <> Implementacion

  Normalmente hay una clase abstracta @c(Builder) que define una operacion para
  cada componente que puede ser creado. La implementacion predeterminada de
  estas operaciones no hace nada. Una clase @c(ConstructorConcreto) redefine las
  operaciones para los componentes que esta interesado en crear.

  Estas son otras cuestiones de implementacion que hay que considerar:

  1. @e(Interfaz de ensamblaje y construccion.) Los constructores construyen
     sus productos paso a paso. Por tanto, la interfaz de la clase
     @c(Constructor) debe ser lo suficientemente general como para permitir
     construir productos por parte de todos los tipos de constructores
     concretos.

     Una cuestion de diseño fundamental tiene que ver con el modelo del proceso
     de construccion y ensamblaje. Normalmente basta con un modelo segun el cual
     los resultados de las peticiones de construccion simplemente se van
     añadiendo al producto. En el ejemplo de RTF, el constructor convierte y
     añade el siguiente token al texto que ha convertido hasta la fecha. Pero a
     veces podriamos necesitar acceder a las partes del producto que ya fueron
     construidas.

     En el ejemplo del laberinto que presentamos en el Codigo de Ejemplo, la
     interfaz de @c(ConstructorLaberinto) permite añadir una puerta entre
     habitacions existentes. Otro ejemplo son las estructuras arboreas, como los
     arboles sintacticos que se crean de abajo a arriba. En ese caso, el
     constructor devolveria nodos hijos al director, el cual los devolveria al
     constructor para construir los nodos padre.

  2. @e(¿Por que no usar clases abstractas para los productos?) En general, los
     productos creados por los constructores concretos tienen representaciones
     tan diferentes que seria de poca ayuda definir una clase padre comun para
     los diferentes productos. En el ejemplo de RTF, es poco probable que los
     objetos @c(TextoASCII) y @c(UtilDeTexto) tengan una interfaz comun. Como el
     cliente suele configurar al director con el constructor concreto adecuado,
     sabe que subclase concreta de @c(Constructor) se esta usando, y puede
     manjar sus productos en consecuencia.

  3. @e(Metodos vacios de manera predeterminada en el costructor.) En C++, los
     metodos de creacion no se declaran como funciones miembro virtuales puras a
     proposito. En ves de eso, se definen como metodos vacios, lo que permite
     que los clientes redefinan solo las operaciones en las que estan interesados.

*** Builder Codigo de Ejemplo <> Codigo de Ejemplo

  Definiremos una variante de la funcion miembro @c(CrearLaberinto) que tomo
  como argumento un constructor de la clase @c(ContructorLaberinto).

  La clase @c(ConstructorLaberinto) define la siguiente interfaz para construir
  laberintos:

  ..src > c++
    class ConstructorLaberinto {
    public:
        virtual void ConstruirLaberinto() {}
        virtual void ConstruirHabitacion(int habication) {}
        virtual void ConstruirPuerta(int habitacionDesde, int habitacionHasta) {}

        virtual Maze* ObtenerLaberinto() { return 0; }
    protected:
        ConstructorLaberinto();
    };
  < src..

  Esta interfaz puede crear tres tipos de cosas: (1) el laberinto, (2)
  habitaciones con un determinado numero de habitacion y (3) puertas entre
  habitaciones numeradas. La operacion @c(ObteterLaberinto) devuelve el
  laberinto al cliente. Las subclases de @c(ConstructorLaberinto) redefiniran
  esta operacion para devolver el laberinto que construyen.

  Todas las operaciones para construir el laberinto de @c(ConstructorLaberinto)
  por omision no hacen nada. No se declaran como virtuales puras para permitir
  que las clases derivadas redefinan solo aquellos metodos en los que esten
  interesadas.

  Dada la interfaz de @c(ConstructorLaberinto), podemos cambiar la funcion
  miembro @c(CrearLaberinto) para que tome como parametro este constructor.

  ..src > c++
    Laberinto* JuegoDelLaberinto::CrearLaberinto (CostructorLaberinto& constructor)
    {
      constructor.ConstruirLaberinto();

      constructor.ConstruirHabitacion(1);
      constructor.ConstruirHabitacion(2);
      constructor.ConstruirPuerta(1,2);

      return constructor.ObtenerLaberinto();
    }
  < src..

  Compare esta version de @c(CrearLaberinto) con la original. Fijese en como el
  constructor oculta la representacion interna de @c(Laberinto) @-(esto, es las
  clases que definen habitaciones, puertas y paredes) y como se ensamblan estas
  partes para completar el laberinto final. Alguien pobria preguntarse por que
  hay clases que representan habitaciones y puertas, pero no hay rastro de
  ninguna para las paredes. Esto facilita la manera de representar un laberinto,
  ya que no hay que cambiar ninguno de los clientes de @c(ConstructorLaberinto).

  Al igual que con los otros patrones de creacion, el patron Builder encapsula
  como se crean los objetos, en este caso a traves de la interfaz definida por
  @c(constructorLaberinto). Eso significa que podemos reutilizar
  @c(ConstructorLaberinto) para construir diferentes tipos de laberintos. Un
  ejemplo de esto es la operacion @c(CrearLaberintoCompleto):

  ..src > c++
    Laberinto* JuegoDelLaberinto::CrearLaberintoComplejo (ConstructorLaberinto& constructor ) {
      constructor.ConstruirHabitacion(1);
      // ...
      constructor.ConstruirHabitacion(1001);

      return constructor.ObtenerLaberinto();
    }
  < src..

  Notese que @c(ConstructorLaberinto) no crea el laberinto en si; su principal
  proposito es simplemente definir una interfaz para crear laberintos. Define
  implementaciones vacias mas que nada por comodidad. Son las subclases de
  @c(ConstructorLaberinto) las que hacen el trabajo real.

  La subclase @c(ConstructorLaberintoEstandar) es una implementacion que
  construye laberintos simples. Sabe que laberinto esta siendo creado gracias a
  la variable @c(_laberintoActual).

  ..src > c++
    class ConstructorLaberintoEstandar : public ConstructorLaberinto {
    public:
        ConstructorLaberintoEstandar();

        virtual void ConstruirLaberinto();
        virtual void ConstruirHabitacion(int);
        virtual void ConstruirPuerta(int, int);

        virtual Laberinto* ObtenerLaberinto();
    private:
        Direccion ParedNormal(Habitacion*, Habitacion*);
        Laberinto* _laberintoActual;
    };
  < src..

  @c(ParedNormal) es una operacion auxiliar que calcula la direccion de la pared
  normal entre dos habitaciones.

  El constructor de @c(ConstructorLaberintoEstandar) simplemente inicializa
  @c(_laberintoActual).

  ..src > c++
    ConstructorLaberintoEstandar::ConstructorLaberintoEstandar () {
        _laberintoActual = 0;
    }
  < src..

  @c(ConstruirLaberinto) crea una instancia de un @c(Laberinto) que otras
  operaciones ensamblaran y al final devolveran al cliente (mediante
  @c(ObtenerLaberinto).

  ..src > c++
    void ConstructorLaberintoEstandar::ConstruirLaberinto () {
        _laberintoActual = new Laberinto;
    }

    Laberinto* ConstructorLaberintoEstandar::ObtenerLaberinto () {
        return _laberintoActual;
    }
  < src..

  La operacion @c(ConstruirHabitacion) crea una habitacion y construye sus
  paredes adyacentes:

  ..src > c++
    void ConstruirLaberintoEstandar::ConstruirHabitacion (int n) {
        if (!_laberintoActual->NumeroDeHabitacion(n)) {
            Habitacion* habitacion = new Habitacion(n);
            _laberintoActual->AnadirHabitacion(habitacion);

            habitacion->EstablecerLado(Norte , new Pared);
            habitacion->EstablecerLado(Sur , new Pared);
            habitacion->EstablecerLado(Este , new Pared);
            habitacion->EstablecerLado(Oeste , new Pared);
        }
    }
  < src..

  Para construir una puerta entre dos habitaciones,
  @c(ConstructorLaberintoEstandar) busca ambas habitaciones en el laberinto y
  encuentra su pared adyacente:

  ..src > c++
    void ConstructorLaberintoEstandar::ConstruirPuerta (int n1, int n2) {
        Habitacion* h1 = _laberintoActual->NumeroDeHabitacion(n1);
        Habitacion* h2 = _laberintoActual->NumeroDeHabitacion(n2);
        Puerta* p = new Puerta(h1, h2);

        h1->EstablecerLado(ParedNormal(h1, h2), p);
        h2->EstablecerLado(ParedNormal(h2, h1), p);
    }
  < src..

  Ahora los clientes pueden usar @c(CrearLaberinto) junto con
  @c(ConstructorLaberintoEstandar) para crear un laberinto:

  ..src > c++
    Laberinto* laberinto;
    JuegoDelLaberinto juego;
    ConstructorLaberintoEstandar constructor;

    juego.CrearLaberinto(constructor);
    laberinto = constructor.ObtenerLaberinto();
  < src..

  Podriamos haber puesto todas las operaciones de
  @c(ConstructorLaberintoEstandar) en @c(Laberinto) y dejar que cada
  @c(Laberinto) se construyese a si mismo. Pero al hacer a @c(Laberinto) mas
  pequeña es mas facil entenderla y modificarla, y
  @c(ConstructorLaberintoEstandar) es facil de separar de @c(Laberinto). Lo que
  es mas importante, separar ambas clases permite tener varios objetos
  @c(ConstructorLaberinto), usando cada uno clases diferentes para las
  habitaciones, paredes y puertas.

  Un @c(ConstructorLaberinto) mas exotico es @c(ConstructorLaberintoContador).
  Este constructor no crea un laberinto; simplemente cuenta los distintas tipos
  de componentes que han sido creados.

  ..src > c++
    class ConstructorLaberintoContador : public ConstructorLaberinto {
    public:
        ConstructorLaberintoContador();

        virtual void ConstruirLaberinto();
        virtual void ConstruirHabitacion(int);
        virtual void ConstruirPuerta(int, int);
        virtual void AnadirPared(int, Direccion);

        void ObtenerConteo(int&, int&) const;
    private:
        int _puertas;
        int _habitaciones;
    };
  < src..

  El constructor inicializa los contadores, y las operaciones redefinidas de
  @c(ConstructorLaberinto) los incrementan en cosecuancia.

  ..src > c++
    ConstructorLaberintoContador::ConstructorLaberintoContador () {
        _habitaciones = _puertas = 0;
    }

    void ConstructorLaberintoContador::ConstruirHabitacion (int) {
        _habitaciones++;
    }

    void ConstructorLaberintoContador::ConstruirPuerta (int, int) {
      _puertas++;
    }

    void ConstructorLaberintoContador::GetCounts (
        int& habitaciones, int& puertas
    ) const {
        habitaciones = _habitaciones;
        puertas = _puertas;
    }
  < src..

  Asi es como un cliente podria usar un @c(ConstructorLaberintoContador):

  ..src > c++
    int habitaciones, puertas;
    JuegoDelLaberinto juego;
    ConstructorLaberintoContador constructor;

    juego.CrearLaberinto(constructor);
    constructor.ObtenerConteo(habitaciones, puertas);

    cout << "El laberinto tiene "
         << habitaciones << " habitaciones y "
         << puertas << " puertas" << endl;
  < src..

*** Builder Usos Conocidos <> Usos Conocidos

  La aplicacion que convierte RTF es de ET++ [@l(#WGM88)]. Su bloque de
  construccion de texto usa un constructor para procesar texto almacenado en
  formato RTF.

  Builder es un patron comun en Smalltalk-80 [@l(#Par90)]:

  - La clase @c(Parser) en el subsistema del compilador es un @c(Director) que toma
    un objeto @c(ProgramNodeBuilder) como argumento. Un objeto @c(Parser)
    notifica a su objeto @c(ProgramNodeBulider) cada vez que reconoce una
    construccion sintactica. Cuando finaliza el analisis, le pide al constructor
    el arbol de analisis sintactico y se lo devuelve al cliente.

  - @c(ClassBuilder) es un constructor que usan los objetos @c(Class) para crear
    subclases de si mismas. En este caso un @c(Class) es tanto el @c(Director)
    como el @c(Producto).

  - @c(ByteCodeStream) es un constructor que crea un metodo compilado como un
    array de bytes. @c(ByteCodeStream) es un uso no estandar del patron
    Builder, ya que el objeto complejo que construye esta codificado como un
    array de bytes en vez de como un objeto Smalltalk normal. Pero la interfaz
    de @c(ByteCodeStream) es tipica de un contructor, y seria facil sustituir
    @c(ByteCodeStream) por una clase diferente que represente programas como un
    objeto compuesto.

  El framework Service Configurator de Adaptive Communications Environment usa
  un constructor para construir componentes de servicio de red que estan
  enlazados a un servidor en tiempo de ejecucion [@l(#SS94)]. Los componentes se
  describen con un lenguaje de configuracion que es analizado por un analizador
  LALR(1). Las aciones semanticas del analizador realizan operacion sobre el
  constructor que añaden informacion al componente de servicios. En este caso,
  el analizador es el @c(Director).

*** Builder Patrones Relacionados <> Patrones Relacionados

  El patron @l(#Abstract Factory) se parece a un Builder en que tambien puede
  construir objetos complejos. La principal diferencia es que el patron Builder
  se centra en construir un objeto complejo paso a paso. El Abstract Factory
  hace hincapie en familias de objetos producto (simples o complejos). El Builder
  devuelve el producto como paso final, mientras que el Abstract Factory lo
  devuelve inmediatamente.

  Muchas veces lo que construye el constructor es un @l(#Composite).

** Factory Method
*** Factory Method Proposito <> Proposito

  Define una interfaz para crear un objeto, pero deja que sean las subclases
  quienes decidan que clase instanciar. Permite que una clase delegue en sus
  subclases la creacion de objetos.

*** Factory Method Tambien Conocido Como <> Tambien Conocido Como

  Virtual Constructor (Constructor Virtual)

*** Factory Method Motivacion <> Motivacion

  Los @e(frameworks) usan clases abstractas para definir y mantener relaciones
  entre objetos y tambien son muchas veces responsables de crear esos mismos
  objetos.

  Pensemos en un framewokr de aplicaciones que pueda presentar varios documentos
  al usuario. Dos abstraccciones clave de este framework son las clase
  @c(Aplicacione) y @c(Documento). Ambas son abstractas, y los clientes tienen que
  heredar de ellas para llevar a cabo sus implementaciones especificas de la
  aplicacion. Por ejemplo, para crear una aplicacion de dibujo, definimos las
  clases @c(AplicacionDeDibujo) y @c(DocumentoDeDibujo). La clase @c(Aplicacion)
  se encarga de gestionar @c(Documentos) y los creara cuando sea necesario, por
  ejemplo, cuando el usuario selecciona Abrir o Nuevo en el menu.

  Dado que la subclase @c(Documento) concreta a instanciar es especifica de la
  aplicacion, la clase @c(Aplicacion) no puede predecir que subclase de
  @c(Documento) debe instanciar @-(la clase @c(Aplicacion) solo sabe @e(cuando)
  deberia crearse un nuevo documento, no @e(que) tipo de @c(Documento)
  crear). Esto causa un dilema: el framework debe crear instancias de clases,
  pero solo conoce clases abstractas, las cuales no pueden ser instanciadas.

  El patron Factory Method ofrece una solucion al dilema. Encapsula el
  conocimiento acerca de que subclases de @c(Documento) crear y saca ese
  conocimeinto fuera del framework.

  ..img > img/038.png

  Las subclases de @c(Aplicacion) redefinen su operacion abstracta
  @c(CrearDocumente) para que devuelva la subclase de @c(Documento)
  adecuada. Una vez que se crea una instancia de la subclase de @c(Aplicacion),
  esta puede crear instancias de Documentos especificos de la aplicacion sin
  conocer sus clases. Llamaremos a @c(CrearDocumento) un @b(metodo de
  fabricacion) porque es el responsable de @"(fabricar) un objeto.

*** Factory Method Aplicabilidad <> Aplicabilidad

  Usese el patron @c(Factory Method) cuando

  - una clase no puede prever la clase de objetos que debe crear.

  - una clase quiere que sean sus subclases quienes especifiquen los objetos que
    esta crea.

  - las clases delegan las responsabilidad en una de entre varias clases
    auxiliares, y queremos localizar que subclase de auxiliar concreta es en la
    que se delega.

*** Factory Method Estructura <> Estructura

  ..img > img/039.png

*** Factory Method Participantes <> Participantes

  - @c(Producto) (@c(Documento))

    - define la interfaz de los objetos que crea el metodo de fabricacion.

  - @c(ProductoConcreto) (@c(MiDocumento))

    - implementa la interfaz @c(Producto).

  - @c(Creador) (@c(Aplicacion))

    - declara el metodo de fabricacion, el cual devuelve un objeto de tipo
      @c(Producto). Tambien puede definir una implementacion predeterminada del
      metodo de fabricacion que devuelve un objeto @c(ProductoConcreto).

    - puede llamar al metodo de fabricacion para crear un objeto @c(Producto).

  - @c(CredorConcreto) (@c(MiAplicacion))

    - redefine el metodo de fabricacion para devolver una instancia de un
      @c(ProductoConcreto).

*** Factory Method Colaboraciones <> Colaboraciones

  El @c(Creador) se apoya en sus subclases para definir el metodo de fabricacion
  de manera que este devuelva una instancia del @c(ProductoConcreto) apropiado.

*** Factory Method Consecuencias <> Consecuencias

  Los metodos de fabricacion eliminan la necesidad de ligar clases especificas
  de la aplicacion a nuestro codigo. El codigo solo trata con la interfaz
  @c(Producto); ademas, puede funcionar con cualquier clase @c(ProductoConcreto)
  definida por el usuario.

  Un inconveniente potencial de los metodos de fabricacion es que los clientes
  pueden tener que heredar de la clase @c(Creador) simplemente para crear un
  determinado objeto @c(ProductoConcreto). La herencia esta bien cuando el
  cliente tiene que heredar de todos los modos de la clase @c(Creador), pero si
  no es asi estariamos introduciendo una nueva via de futuros cambios.

  Estas son dos consecuencias mas del patron Factory Method:

  1. @e(Proporciona enganches para las subclases.) Crear objetos dentro de una
     clase con un metodo de fabricacion es siempre mas flexible que hacerlo
     directamente. El Factory Method les da a las subclases un punto de enganche
     para proveer una version extendida de un objeto.

     En el ejemplo del documento, la clase @c(Documento) podria definir un
     metodo de fabricacion llamado @c(CrearDialogoDeFichero) que crea un objeto
     de dialogo predeterminado para abrir un documento existente. Una subclase
     de @c(Documento) puede definir dialogos de ficheros especificos de la
     aplicacion redefiniendo este metodo. En este caso el metodo de fabricacion
     no es abstracto, sino que proporciona una implementacion predeterminada
     razonable.

  2. @e(Conecta jerarquias de clases paralelas.) En los ejemplos vistos hasta
     ahora, al metodo de fabricacion solo lo llaman los objetos @c(Creador).
     Pero esto no tiene por que ser siempre asi; los clientes pueden encontrar
     utiles los metodos de fabricacion, especialmente en el caso de jerarquias
     de clase paralelas.

     Las jerarquias de clases paralelas se producen cuando una clase delega
     alguna de sus responsabilidades a una clase separada. Pensemos en figuras
     graficas que pueden manipularse interactivamente; es decir, que pueden
     alargarse, moverse y girarse usando el raton. Implementar estas
     interacciones no siempre es facil. Muchas veces requiere almacenar y
     actualizar informacion que guarda el estado de la manipulacion en un
     momento dado. Este estado es necesario solo mientras dura la manipulacion;
     por tanto, no necesita ser almacenado en el objeto @c(figura). Es mas,
     figuras diferentes se comportan de manera diferente cuando son maninpuladas
     por el usuario. Por ejemplo, alargar una linea puede tener el efecto de
     mover un extremo, mientras que alargar una figura de texto puede cambiar su
     espaciado entre lineas.

     Con estas restricciones, es mejor usar un objeto @c(Manipulador) separado
     que implemente la interaccion y mantenga cualquier estado especifico de la
     manipulacion que sea necesario. Figuras diferentes usaran distintas
     subclases de @c(Manipulador) para manejar las interacciones. La jerarquia
     de clases de @c(Manipulador) resultante (al menos en parte) a la jerarquia
     de clases de @c(Figura):

     ..img > img/040.png


   La clase @c(Figura) proporciona un metodo de fabricacion @c(CrearManipulador)
   que permite que los clientes creen el @c(Manipulador) correspondiente a una
   figura. Las subclases de @c(Figura) redefinen este metodo para que devuelva
   una instancia de la subclase de @c(Manipulador) adecuada para cada una de
   ellas. Otra posibilidad es que la clase @c(Figura) implemnte
   @c(CreacManipulador) para que devuelva una instancia predeterminada de
   @c(Manipulador), y las subclases de @c(Figura) pueden simplemente heredar ese
   comportamiento predeterminado. Esas clases @c(Figura) no necesitan su
   correspondiente subclase de @c(Manipulador) @-(de hay que las jerarquias sean
   paralelas solo en parte).

   Es importante notar como el metodo de fabricacion define la conexion entre
   las dos jerarquias de clases, localizando que clases van juntas.

*** Factory Method Implementacion <> Implementacion

  A la hora de aplicar el patron Factory Method hemos de tener en cuenta las
  siguientes cuestiones:

  1. @e(Dos variantes principales.) Las dos principales variantes del patron
     Factory Method son (1) cuando la clase @c(Creador) es una clase abstracta y
     no proporciona una implementacion para el metodo de fabricacion que declara
     y (2) cuando el @c(Creador) es una clase concreta y proporciona una
     implementacion predeterminada del metodo de fabricacion. Tambien es posible
     tener una clase abstracta que defina una implementacion predeterminada,
     pero esto es menos comun.

     El primer caso @e(requiere) que las subclases definan una implementacion
     porque no hay nungun comportamiento predeterminado razonable. Esto lleva al
     dilema de tener que crear instancias de clase imprevisibles. En el segundo
     caso, el @c(Creador) concreto usa el metodo de fabricacion principalmente
     por flexibilidad. Lo hace siguiendo una regla que dice: @"(Crear objetos en
     una operacion aparte, para que las subclases puedan redefinir el modo en
     que son creados). Esta regla asegura que los diseñadores de las subclases
     puedan cambiar la clase de objetos que instancia su clase padre si es
     necesario.

  2. @e(Metodos de fabricacion parametrizados.) Otra variante del patron permite
     que los metodos de fabricacion creen varios tipos de productos. El metodo
     de fabricacion recibe un parmetro que identifica el tipo de objeto a
     crear. Todos los objetos creados por el metodo compartiran la interfaz
     @c(Producto). En el ejemplo del documento, @c(Aplicacion) puede soportar
     diferentes tipos de Documentos. Pasando un parametro extra a
     @c(CrearDocumento) se especifica el tipo de docuemnto a crear. El framework
     de edicion grafica  Unidraw [@l(#VL90)] usa este enfoque para reconstruir
     objetos guardados en disco. Unidraw define una clase @c(Creator) con un
     metodo de fabricacion @c(Create) que recibe como argumento un identificador
     de clase. Cuando Unidraw guarda un objeto en disco, primero escribe el
     identificador de la clase y luego sus variables de instancia. Cuando se
     reconstruye el objeto desde el disco, primero lee el identificador de la
     clase.

     Una vez que ha leido el identificador de la clase, el framework llama a
     @c(Create), pasandole el identificador como el parametro. @c(Create) busca
     el constructor de la clase correspondiente y lo usa para crear una instancia
     del objeto. Por ultimo, @c(Create) llama a la operacion @c(Read) del objeto,
     que lee la informacion restante del disco e inicializa las variables de
     instancia del objeto.

     un metodo de fabricacion parametrizado tiene la siguiente forma general,
     donde @c(MiProducto) y @c(TuProducto) son subclases de @c(Producto):

     ..src > c++
       class Creador {
       public:
         virtual Producto* Crear(IdProducto);
       };

       Producto* Creador::Crear (IdProducto id) {
         if (id == MIO)  return new MiProducto;
         if (id == TUYO) return new TuProducto;
         // repetir para los productos restantes...

         return 0;
       }
     < src..

     Redefiniendo un metodo de fabricacion parametrizado se puede extender o
     cambiar facilmente y de manera selectiva los productos fabricados por un
     @c(Creador). Se pueden introducir nuevos identificadores para nuevos tipos
     de productos, o asociar identificadores existentes con productos
     diferentes.

     Por ejemplo, una subclase de @c(MiCreador) podria cambiar @c(MiProducto)
     por @c(TuProducto) y admitir una nueva subclase @c(SuProducto):

     ..src > c++
       Producto* MiCreador::Crear (IdProducto id) {
         if (id == TUYO)  return new MiProducto;
         if (id == MIO)   return new TuProducto;
         // Nota: intercambiados TUYO y MIO

         if (id == SUYO)  return new SuProducto;

         return Creador::Crear(id); // llamado cuanda falla todo lo demas
       }
     < src..

     Notese que lo ultimo que hace esta operacion es llamar a @c(Crear) de la
     clase padre. Eso es debido a que @c(MiCreador::Crear) solo trata @c(TUYO),
     @c(MIO) y @c(SUYO) de forma diferente a la clase padre. No esta interesada
     en otras clases. Por tanto @c(MiCreador) @e(extiende) los tipos de
     productos creados, y delega en su padre la responsabilidad de crear todos
     los productos excepto unos pocos.

  3. @e(Variantes y cuestiones especificas del lenguaje.) Lenguajes diferentes
     se prestan a otras interesantes variaciones.

     Los programas en Smalltalk suelen usar un metodo que devuelve la clase del
     objeto a crear. Un metodo de fabricacion en @c(Creador) puede usar este
     valor para crear un producto, y un @c(CreadorConcreto) puede almacenar o
     procesas dicho valor. El resultado es un enlace todavia mas tardio al tipo
     de @c(ProductoConcreto) a crear.

     Una version en Smalltalk del ejemplo del @c(Documento) puede definir un
     metodo @c(claseDocumento) en @c(Aplicacion). El metodo @c(claseDocumento)
     devuelve la clase de @c(Documento) apropiada para crear instancias de
     documentos. La implementacion de @c(claseDocumento) en @c(MiAplicacion)
     devuelve la clase @c(MiDocumento). Asi, en la clase @c(Aplicacion) tenemos

     ..src > smalltalk
       metodoCliente
           documento := self claseDocumento new.

       claseDocumento
           self subclaseResponsibility
     < src..

     y en la clase @c(MiAplicacion) tenemos

     ..src > smalltalk
       claseDocumento
           ^ MiDocumento
     < src..

     que devuelve la clase @c(MiDocumento) que debe ser instanciada por
     @c(Aplicacion).

     Un enfoque aun mas flexible que esta estrechamente relacionado con los
     metodos de fabricacion parametrizados es guardar la clase a crear como una
     variable de clase de @c(Aplicaciones). De esa forma no tenemos que heredar
     de @c(Aplicaicon) para cambiar el producto.

     Los metodos de fabricacion en C++ son siempre funciones virtuales y a
     menudo virtuales puras. Hay que tener cuidado de no llamar a los metodos de
     fabricacion en el constructor del @c(Creador) @-(el metodo de fabricacion
     del @c(CreadorConcreto) todavia no estara disponible).

     Podemos evitar esto teniendo la precaucion de acceder a los productos solo
     a traves de operaciones de acceso que crean el producto cuando es necesario.
     En vez de crear el producto concreto en el constructor, este simplemte lo
     inicializa a 0. Es el metodo de acceso el que devuelve el producto, pero
     primero comprueba que exista, y si no es asi lo crea. A esta tecnica se le
     llama a veces @b(inicializacion perezosa).@n(30) El siguiente codigo
     muestra una implementacion tipica:

     ..src > c++
       class Creador {
       public:
           Producto* ObtenerProducto();
       protected:
           virtual Producto* CrearProducto();
       private:
           Producto* _producto;
       };

       Producto* Creador::ObtenerProducto () {
           if (_producto == 0) {
               _producto = CrearProducto();
           }
           return _producto;
       }
     < src..

  4. @e(Usar plantillas para evitar la herencia.) Como ya hemos mencionado, otro
     potencial problema de los metodos de fabricacion es que pueden obligar a
     usar la herencia solo para crear los objetos @c(Producto) apropiados. Otra
     forma de hacer esto en C++ es proporcionar una subclase plantilla de
     @c(Creador) que esta parametrizada con la clase de @c(Producto):

     ..src > c++
       class Creador {
       public:
           virtual Producto* CreadorProducto() = 0;
       };

       template <class ElProducto>
       class CreadorEstandar: public Creador {
       public:
           virtual Producto* CrearProducto();
       };

       template <class ElProducto>
       Producto* CreadorEstandar<ElProducto>::CrearProducto () {
           return new ElProducto;
       }
     < src..

     Con esta plantilla el cliente unicamente proporciona la clase del producto
     @-(no se necesita heredar de @c(Creador)).

     ..src > c++
       class MiProducto : public Producto {
       public:
           MiProducto();
           // ...
       };

       CreadorEstandar<MiProducto> miCreador;
     < src..

  5. @e(Convenios de nominacion.) Es una buena practica usar convenios de
     nominacion que dejan claro que estamos usando metodos de fabricacion. Por
     ejemplo, el framework de aplicaciones para Macintosh MacApp [@l(#App89)] siempre
     declara la operacion abstracta que define el metodo de fabricacion como
     @c[Class* DoMakeClass()], donde @c(class) es la clase @c(Producto).

*** Factory Method Codigo de Ejemplo <> Codigo de Ejemplo

  La funcion @l(#Capitulo 3<>@c(CrearLaberinto)) construye y devuelve un
  laberinto. Un problema de esta funcion es que fija en el codigo la clase del
  laberinto y de las habitaciones, puertas y paredes. Introduciremos metodos de
  fabricacion para permitir que las subclases elijan estos componentes.

  Primero definiremos metodos de fabricacion de @c(JuegoDelLaberinto) para
  crear los objetos laberinto, habitacion, pared y puerta:

  ..src > c++
    class JuegoDelLaberinto {
    public:
        Laberinto* CrearLaberinto();

    // metodos de fabricacion

        virtual Laberinto* FabricarLaberinto() const
            { return new Laberinto; }
        virtual Habitacion* FabricarHabitacion(int n) const
            { return new Habitacion(n); }
        virtual Pared* FabricarPared() const
            { return new Pared; }
        virtual Puerta* FabricarPuerta(Habitacion* h1, Habitacion* h2) const
            { return new Habitacion(h1, h2); }
    };
  < src..

  Cada metodo de fabricacion devuelve un componente laberinto de un tipo
  dado. @c(JuegoDelLaberinto) proporciona implementaciones predetermindas que
  devuelven los tipos mas simples de laberintos, habitaciones, paredes y
  puertas.

  Ahora podemos redefinir @c(CrearLaberinto) para que use estos metodos de
  fabricacion:

  ..src > c++
    Laberinto* JuegoDelLaberinto::CrearLaberinto () {
        Laberinto* unLaberinto = FabricarLaberinto();

        Habitacion* h1 = FabricarHabitacion(1);
        Habitacion* h2 = FabricarHabitacion(2);
        Puerta* laPuerta = FabricarPuerta(h1, h2);

        unLaberinto->AnadirHabitacion(h1);
        unLaberinto->AnadirHabitacion(h2);

        h1->EstablecerLado(Norte, FabricarPared());
        h1->EstablecerLado(Este, laPuerta);
        h1->EstablecerLado(Sur, FabricarPared());
        h1->EstablecerLado(Oeste, FabricarPared());

        h2->EstablecerLado(Norte, FabricarPared());
        h2->EstablecerLado(Este, FabricarPared);
        h2->EstablecerLado(Sur, FabricarPared());
        h2->EstablecerLado(Oeste, laPuerta);

        return unLaberinto;
    }
  < src..

  Juegos diferentes pueden heredar de @c(JuegoDelLaberinto) para especializar
  partes del laberinto. Las subclases de @c(JuegoDelLaberinto) pueden redefinir
  algunos de los metodos de fabricacion o todos para especificar variantes de
  los productos. Por ejemplo, un @c(JuegoDelLaberintoConBombas) puede redefinir
  los productos @c(Habitacion) y @c(Pared) para devolver sus variantes con
  bomba:

  ..src > c++
    class JuegoDelLaberintoConBombas : public JuegoDelLaberinto {
    public:
        JuegoDelLaberintoConBombas();

        virtual Pared* FabricarPared() const
            { return new ParedExplosionada; }

        virtual Habitacion* CrearHabitacion(int n) const
            { return new HabitacionConBomba(n); }
    };
  < src..

  se podria definir una variante @c(JuegoDelLaberintoEncantado) como sigue:

  ..src > c++
    class JuegoDelLaberintoEncantado : public JuegoDelLaberinto {
    public:
        JuegoDelLaberintoEncantado();

        virtual Habitacion* FabricarHabitacion(int n) const
            { return new HabitacionEncantada(n, Hechizar()); }

        virtual Puerta* FabricarPuerta(Habitacion* h1, Habitacion* h2) const
            { return new PuertaQueNecesitaHechizo(h1, h2); }
    protected:
        Hechizo* Hechizar() const;
    };
  < src..

*** Factory Method Usos Conocidos <> Usos Conocidos

  Los toolkits y frameworks estas plagados de metodos de fabricacion. El
  anterior ejemplo del documento es un tipico uso de MacApp y ET++ [@l(#WGM88)]. El
  ejemplo del manipulador viene de Unidraw.

  La clase @c(View) en el framework Modelo/Vista/Controlador de Smalltalk-80
  tiene un metodo @c(defaultController) que crea un controlador, lo que puede
  parecer un metodo de fabricacion [@l(#Par90)]. Pero las subclases de @c(View)
  especifican la clase de su controlador predeterminado definiendo
  @c(defaultControllerClass), que devuelve la clase a partir de la cual
  @c(defaultController) crea las instancias. Por tanto es
  @c(defaultControllerClass) quien es realmente el metodo de fabricacion, es
  decir, el metodo que deberian redefinir las subclases.

  Un ejemplo mas oculto en Smalltalk-80 es el metodo de fabricacion
  @c(paperClass) definido por @c(Behavior) (una superclase de todos los objetos
  que representan clases). Esto permite que una clase use un analizador
  personalizado para su codigo fuente. Por ejemplo, un cliente puede definir una
  clase SQLParser para analizar el codigo fuente de una clase con sentencias SQL
  insertadas. La clase @c(Behaviour) implementa @c(parserClass) para devolver la
  clase @c(Parser) estandar en Smalltalk. Una clase que incluya sentencias SQL
  insentadas redefine este metodo (como un metodo de clase) y devuelve la clase
  @c(SQLParser).

  El sistema ORB Orbix de IONA Technologies [@l(#ION94)] usa el patron Factory Method
  para generar un tipo adecuado de proxy (vease el patron @l(#Proxy)) cuando un
  objeto solicita una referencia a un objeto remoto. El patron Factory Method
  facilita reemplazar el proxy predeterminado con otro que use cache en el lado
  del cliente, por ejemplo.

*** Factory Method Patrones Relacionados <> Patrones Relacionados

  El patron Abstract Factory suele implementarse con metodos de fabricacion. El
  ejemplo que aparece en la seccion @l(#Abstract Factory Motivacion<>Motivacion)
  del patron Abstract Factory ilustra tambien un metodo de fabricacion.

  Los metodos de fabricacion generalmente son llamados desde el interior de
  @l(#Template Method<>Metodos Plantilla). En el ejemplo del documento,
  @c(NuevoDocumento) es un metodo plantilla.

  El @l(#Prototype) no necesita heredar de @c(Creador). Sin embargo, suelen
  requerir una operacion @c(Inicializar) en la clase @c(Producto). El
  @c(Creador) usa @c(Inicializar) para inicializar el objeto. El patron
  Factory Method no requiere dicha operacion.

** Prototype
*** Prototype Proposito <> Proposito

  Especifica los tipos de objetos a crear por medio de una instancia prototipica,
  y crea nuevos objetos copiando dicho prototipo.

*** Prototype Motivacion <> Motivacion

  Podriamos construir un editor de partituras musicales adaptando un framework
  general para editores graficos y añadiendo nuevos objetos que representan
  notas, silencios y pentagramas. El framework puede tener una paleta de
  herramientas para añadir estos objetos musicales a la partitura. La paleta
  tambien incluira herramientas para seleccionar, mover y realizar otras
  manipulaciones de objetos musicales. Los usuarios haran clic en la herramienta
  de negras y la usaran para añadir negras a la partitura. O pueden usar la
  herramienta de movimiento para mover una nota arriba o abajo en el pentagrama
  cambiando asi su tono.

  Supongamos que el framewor proporciona una clase abstracta @c(Grafico) para
  componentes graficos, como notas y pentangramas. Ademas, proporcionara una
  clase abstracta @c(Herramienta) para definir herramientas como las de la
  paleta. El framework tambien predefine una subclase @c(HerramientaGrafica)
  para herramientas que crean instancias de objetos graficos y los añaden al
  documento.

  Pero @c(HerramientaGrafica) representa un problema para el diseñador del
  framework. Las clases para notas y pentagramas son especificas de nuestra
  aplicacion, pero la clase @c(HerramientaGrafica) pertenece al framework, por lo
  que no sabe como crear instancias de nuestras clases musicales para añadirlas a
  la partitura. Podriamos crear una subclase de @c(HerramientaGrafica) para cada
  tipo de objeto musical, pero eso produciria muchas subclases que se
  diferenciarian solamente en el tipo de objeto musical que crean. Sabemos que
  la composicion de objetos es una alternativa flexible a la herencia. La
  cuestion es ¿como puede usarla el framework para parametrizar instancias de
  @c(HerramientaGrafica) con la @e(clase) de @c(Grafico) que deben crear?

  La solucion consiste en hacer que @c(HerramientaGrafica) cree un nuevo
  @c(Grafico) copiando o @"(clonando) una instancia de una subclase
  @c(Grafico). Llamaremos a esta instancia un @b(prototipo).
  @c(HerramientaGrafica) esta paramentrizada con el prototipo que
  deberia clonar y añadir al documento. Si todas las subclases de @c(Grafico)
  admiten una operacion @c(Clonar), la @c(HerramientaGrafica) puede clonar
  cualquier tipo de @c(Grafico).

  Por tanto, en nuestro editor musical, cada herramienta para crear un objeto
  musical es una instancia de @c(HerramientaGrafica) que esta inicializada con
  un prototipo diferente. Cada instancia de @c(HerramientaGrafica) producira un
  objeto musical clonando su prototipo y añadiendo el clon a la partitura.

  Podemos usar el patron @b(Prototype) para reducir aun mas el numero de
  clases. Tenemos clases separadas para redondas y negras, pero eso probablemente
  no sea necesario. En vez de eso podrian ser instancias de la misma clase
  inicilizadas con diferentes mapas de bits y duraciones. Una herramienta para
  crear redondas pasa a ser simplemente una @c(HerramientaGrafica) cuyo
  prototipo es una @c(NotaMusical) inicialazada para que sea una redonda. Esto
  puede reducir drasticamente el numero de clases del sistema. Tambien hace que
  sea mas facil añadir un nuevo tipo de nota al editor.

  ..img > img/041.png

*** Prototype Aplicabilidad <> Aplicabilidad

  Usese el patron Prototype cuando un sistema deba ser independiente de como se
  crean, se componen y se representan sus productos y

  - cuando las clases a instanciar sean especificadas en tiempo de ejecucion
    (por ejemplo, mediante carga dinamica); o

  - para evitar construir una jerarquia de clases de fabricas paralela a la
    jerarquia de clases de los productos; o

  - cuando las instancias de una clase puedan tener uno de entre solo unos
    cuantos estados diferentes. Puede ser mas adecuado tener un numero
    equivalente de prototipos y clonarlos, en vez de crear manualmente
    instancias de la clase cada vez con el estado apropiado.

*** Prototype Estructura <> Estructura

  ..img > img/042.png

*** Prototype Participantes <> Participantes

  - @c(Prototipo) (@c(Grafico))

    - declara una interfaz para clonarse.

  - @c(PrototipoConcreto) (@c(Pentagrama), @c(Redonda), @c(Blanca))

    - implementa una operacion para clonarse.

  - @c(Cliente) (@c(HerramientaGrafica))

    - crea un nuevo objeto pidiendole a un prototipo que se clone.

*** Prototype Colaboraciones <> Colaboraciones

  Un cliente le pide a un prototipo que se clone.

*** Prototype Consecuencias <> Consecuencias

  Muchas de las consecuencias del Prototype son las mismas que las de los
  patrones @l(#Abstract Fartory) y @l(#Builder): oculta al cliente las clases
  producto concretas, reduciendo asi el numero de nombres que conocen los
  clientes. Ademas, estos patrones permiten que el cliente use clases
  especificadas de la aplicacion sin cambios.

  A continuacion se enumeran algunos beneficios adicionales del patron
  Prototype.

  1. @e(Añadir y eliminar productos en tiempo de ejecucion.) Permite incorporar
     a un sistema una nueva clase concreta de producto simplemente registrando
     una instancia prototipica con el cliente. Esto es algo mas flexible que
     otros patrones de creacion, ya que un cliente puede instalar y eliminar
     prototipos en tiempo de ejecucion.

  2. @e(Especificar nuevos objetos modificando valores.) Los sistemas altamente
     dinamicos permiten definir comportamiento nuevo mediante la composicion de
     objetos @-(por ejemplo, especificando valores para las variables de un
     objeto) y no definiendo nuevas clases. Podemos definir nuevos tipos de
     objetos creando instancias de clases existentes y registrando esas
     instancias como prototipos de los objetos cliente. Un cliente puede exhibir
     comportamiento nuevo delegando responsabilidad en su prototipo.

     Este tipo de diseño permite que los usuarios definan nuevas @"(clases) sin
     programacion. De hecho, clonar un prototipo es parecido a crear una
     instancia de una clase. El patron Prototipe puede reducir en gran medida el
     numero de clases necesarias en un sistema. En nuestro editor de musica, una
     clase @c(HerramientaGrafica) puede crear una gran variedad de objetos.

  3. @e(Especificar nuevos objetos variando la estructura.) Muchas aplicaciones
     construyen objetos a partir de partes y subpartes. Los editores de diseño de
     circuitos, por ejemplo, construyen circuitos a partir de subcircuitos. A
     menudo, por comodidad, dichas aplicaciones permiten crear instancias de
     estructuras complejas definidas por el usuario, por ejemplo, para usar un
     determinado subcircuito una y otra vez.

     El patron Prototype tambien permite esto. Simplemente añadimos ese
     subcircuito como prototipo a la paleta de circuitos disponibles. Siempre y
     cuando el objeto circuito compuesto implemente @c(Clonar) como una copia
     profunda, los circuitos con varias estructuras tambien pueden ser
     prototipos.

  4. @e(Reduce la herencia.) El patron @l(#Factory Method) suele producir una
     jerarquia de clases @c(Creador) que es paralela a la jerarquia de clases de
     productos. El patron Prototype permite clonar un prototipo en vez de
     decirle a un metodo de fabricacion que cree un nuevo objeto. Por tanto, no
     es en absoluto necesaria una jerarquia de clases @c(Creador). Este beneficio
     es aplicable principalmente a lenguajes como C++, que no tratan a las clase
     como objetos en toda regla.

     En los lenguajes que si lo hacen, como Smalltalk y Objetive C, resulta un
     beneficio menor, puesto que siempre podemos usar un objeto clase como
     creador. Los objetos clase ya funcionan en estos lenguajes como prototipos.

  5. @e(Configurar dinamicamente una aplicacion con clases.) Algunos entornos de
     tiempo de ejecucion permiten cargar clases en una aplicacion dinamicamente.
     El patron Prototype es la clave para explotar dichas facilidades en un
     lenguaje como C++.

     Una aplicacion que quiere crear instancias de una clase cargada
     dinamicamente no podra hacer referencia al constructor de esta
     estaticamente. En vez de eso, el entorno en tiempo de ejecucion crea
     automaticamente una instancia de cada clase cada vez que es cargada, y la
     registra con un gestor de prototipos (vease la Seccion de @l(#Prototype
     Implementacion<>Implementacion)). Despues, la aplicacion puede solicitar al
     gestor de prototipos instancias de nuevas clases cargadas, es decir, clases
     que no fueron enlazadas con el programa originalmente. El framework de
     aplicacion ET++ [@l(#WGM88)] tiene un sistema de tiempo de ejecucion que usa
     este esquema.


  El principal inconveniente del patron Prototype es que cada subclase de
  @c(Prototipo) debe implementar la operacion @c(Clonar), lo cual puede ser
  dificil . Por ejemplo, añadir @c(Clonar) es dificil cuando las clases ya
  existen. Igualmente, puede ser dificil implementar @c(Clonar) cuando sus
  interioridades incluyen objetos que no pueden copiarse o que tienen
  referencias circulares.

*** Prototype Implementacion <> Implementacion

  El Prototype es particularmente util con lenguajes estaticos como C++, donde
  las clases no son objetos, y en los que poca o ninguna informacion de tipos
  esta disponible en tiempo de ejecucion. Es menos importante en lenguajes como
  Smalltalk y Objetive C, que proporcionan lo que viene a ser un prototipo (es
  decir, un objeto clase) para crear instancias de cada clase.

  Este patron lo incorporan los lenguajes basados en prototipos, como Self
  [@l(#US87)], en los cuales toda creacion de objetos tiene lugar clonando un
  prototipo.

  Hemos de tener en cuenta las siguientes cuestiones a la hora de implementar
  prototipos:

  1. @e(Usar un gestor de prototipos.) Cuando el numero de prototipos de un
     sistema no es fijo (es decir, cuando pueden crearse y destruirse
     dinamicamente), mantiene un registro de los prototipos disponibles. Los
     clientes no gestionaran ellos mismos los prototipos, sino que los guardaran
     y recuperaran del registro. Un cliente le pedira al registro un prototipo
     antes de clonarlo. Llamaremos a este registro un gestor de prototipos.

     Un gestor de prototipos es un almacen asociativo que devuelve el prototipo
     que concuerda con una determinada clave. Tiene operaciones para registrar
     un prototipo con una clave y para desregistrarlo. Los clientes pueden
     cambiar el registro o incluso navegar por el en el tiempo de ejecucion.
     Esto permite que los clientes extiendan el sistema y lleven un inventario
     del mismo sin necesidad de escribir codigo.

  2. @e(Implementar la operacion @c(Clonar).) La parte mas completa del patron
     Prototype es implementar correctamente la operacion @c(Clonar). Es
     particularmente delicado cuando las estructuras de objetos contienen
     referencias circulares.

     La mayoria de los lenguajes proporcionan algun tipo de ayuda para clonar
     objetos. Por ejemplo, Smalltalk proporciona una implementacion de @c(copy)
     que es heredada por todas las subclases de @c(Object). C++ proporciona un
     constructor de copia. Pero estas facilidades no resuelven el problema de la
     @"(copia superficial frente a la copia profunda) [@l(#GR83)]. Es decir, ¿clonar
     un objeto clona a su vez sus variables de instancia, o el objeto clonado y
     el original simplemente comparten sus variables?

     Una copia superficial es simple y a menudo suficiente, y es lo que
     Smalltalk proporciona de manera predeterminada. El constructor de copia por
     omision en C++ hace una copia de miembro, lo que significa que la copia y
     el original compartiran sus punteros. Pero clonar prototipos con estructuras
     complejas normalmente requiere una copia profunda, porque el clon y el
     original deben ser independientes. Por tanto debemos garantizar que los
     componentes del clon son clones de los componentes del prototipo. La
     clonacion nos obliga a decidir que sera compartido, si es que lo sera algo.

     Si los objetos del sistema proporcionan operaciones @c(Guardar) y
     @c(Cargar), entonces podemos usarlas para proporcionar una implementacion
     predeterminada de @c(Clonar), simplemente guardando el objeto y cargandolo
     de nuevo a continuacion. La operacion @c(Guardar) guarda el objeto en un
     bufer en memoria, y @c(Cargar) crea un duplicado reconstruyendo el objeto a
     partir del bufer.

  3. @c(Inicializar los clones.) Mientras que a algunos clientes les sirve el
     clon tal cual, otros querran unicializar parte de su estado interno, o
     todo, con valores de su eleccion. Generalmente no pasamos dichos valores en
     la operacion @c(Clonar), porque su numero variara de unas clases de
     prototipos a otras. Algunos prototipos pueden necesitar multiples
     parametros de inicializacion; otros no necesitan ninguno. Pasar parametros
     en la operacion @c(Clonar) impide tener una interfaz de clonacion uniforme.

     Puede darse el caso de que nuestras clases prototipo ya definan operaciones
     para establecer las partes principales de su estado. Si es asi, los
     clientes pueden usar estas operaciones inmediatamente despues de la
     clonacion. Si no, quizas tengamos que introducir una operacion
     @c(Inicializar) (vease la Seccion @l(#Prototype Codigo de Ejemplo<>Codigo
     de Ejemplo)) que tome parametros de inicializacion como argumentos y
     establezca el estado interno del clon. Hemos de tener cuidado con las
     operacones @c(Clonar) que hacen una copia profunda @-(quiza tengamos que
     borrar las copias (ya sea explicitamente o desde dentro de @c(Inicializar))
     antes de reinicializarlas).

*** Prototype Codigo de Ejemplo <> Codigo de Ejemplo

  Definiremos @c(FabricaDePrototiposLaberinto) como subclase de la clase
  @c(FabricaDeLaberintos). @c(FabricaDePrototiposLaberinto) sera inicializada
  con prototipos de los objetos que creara, de manera que no habra que heredar
  de ella solo para cambiar las clases de paredes o habitaciones que crea.

  @c(FabricaDePrototiposLaberinto) aumenta la interfaz @c(FabricaDeLaberintos)
  con un constructor que toma como argumentos los prototipos:

  ..src > c++
    class FabricaDePrototiposLaberinto : public FabricaDeLaberintos {
    public:
        FabricaDePrototiposLaberinto(Laberinto*, Pared*, Habitacion*, Puerta*);

        virtual Laberinto* HacerLaberinto() const;
        virtual Habitacion* HacerHabitacion(int) const;
        virtual Pared* HacerPared() const;
        virtual Puerta* HacerPuerta(Habitacion*, Habitacion*) const;

    private:
        Laberinto* _prototipoLaberinto;
        Habitacion* _prototipoHabitacion;
        Pared* _protipoPared;
        Puerta* _prototipoPuerta;
    };
  < src..

  El nuevo constructor simplemente inicializa sus prototipos:

  ..src > c++
    FabricaDePrototiposLaberinto::FabricaDePrototiposLaberinto (
        Laberinto* l, Pared* p, Habitacion* h, Puerta* pu
    ) {
        _prototipoLaberinto  = l;
        _prototipoPared      = p;
        _prototipoHabitacion = h;
        _prototipoPuerta     = pu;
    }
  < src..

  Las funciones miembro para crear paredes, habitaciones y puertas son parecidas:
  cada una clona un prototipo y luego lo inicializa. A continuacion se presentan
  las definiciones de @c(HacerPared) y @c(HacerPuerta):

  ..src > c++
    Pared* FabricaDePrototiposLaberinto::HacerPared () const {
        return _prototipoPared->Clonar();
    }

    Puerta* FabricaDePrototiposLaberinto::HacerPuerta (
        Habitacion* h1, Habicacion* h2
    ) const {
        Puerta* puerta = _prototipoPuerta->Clonar();
        puerta->Inicializar(h1, h2);
        return puerta;
    }
  < src..

  Podemos usar @c(FabricaDePrototiposLaberinto) para crear un @c(Laberinto)
  prototipico o predeterminado simplemente inicializandolo con prototipos de los
  componentes basicos de @c(Laberinto):

  ..src > c++
    JuegoDelLaberinto juego;
    FabricaDePrototiposLaberinto FabricaDeLaberintosSimples(
        new Laberinto, new Pared, new Habitacion, new Puerta
    );

    Laberinto* Laberinto = juego.CrearLaberinto(FabricaDeLaberintosSimples);
  < src..

  Para cambiar el tipo de laberinto, inicializamos @c(FabricaDePrototiposLaberinto) con
  un conjunto diferente de prototipos. La siguiente llamada crea un
  @c(Laberinto) con una puerta @c(PuertaExplonionada) y una @c(HabitacionConBomba):

  ..src > c++
    FabricaDePrototiposLaberinto FabricaDeLaberintosConBomba(
        new Laberinto, new ParedExplosionada,
        new HabitacionConBomba, new Puerta
    );
  < src..

  Un objeto que pueda ser usado como prototipo, como por ejemplo una instancia
  de @c(Pared), debe admitir la operacion @c(Clonar). Tambien tiene que tener un
  constructor de copia para la clonacion. Puede necesitar tambien otra operacion
  para reinicializar su estado interno. Añadiremos la operacion @c(Inicializar)
  a @c(Puerta) para que los clientes puedan inicializar los clones de
  @c(Habitacion).

  Comparese la siguiente definicion de @c(Puerta) con la del @l(#Capitulo 3);:

  ..src > c++
    class Puerta : public LugarDelMapa {
    public:
        Puerta();
        Puerta(const Puerta&);

        virtual void Inicializar(Habitacion*, Habitacion*);
        virtual Puerta* Clonar() const;

        virtual void Entrar();
        Habitacion* OtroLadeDe(Habitacion*);
    private:
        Habitacion* _habitacion1;
        Habitacion* _habitacion2;
    };

    Puerta::Puerta (const Puerta& otra) {
        _habitacion1 = otra._habitacion1;
        _habitacion2 = otra._habitacion2;
    }

    void Puerta::Inicializar (Habitacion* h1, Habitacion* h2) {
        _habitacion1 = h1;
        _habitacion2 = h2;
    }

    Puerta* Puerta::Clonar () const {
        return new Puerta(*this);
    }
  < src..

  La subclase @c(ParedExplosionada) debe redefinir @c(Clonar) e implementar su
  correspondiente constructor de copia.

  ..src > c++
    class ParedExplosionada : public Pared {
    public:
        ParedExplosionada();
        ParedExplosionada(const ParedExplosionada&);

        virtual Pared* Clonar() const;
        bool TieneBomba();
    private:
        bool _bomba;
    };

    ParedExplosionada (const ParedExplosionada& otra) : Pared(otra) {
        _bomba = otra._bomba;
    }

    Pared* ParedExplosionada::Clonar () const {
        return new ParedExplosionada(*this);
    }
  < src..

  Aunque @c(ParderExplosionada::Clonar) devuelve @c(Pared*), su implementacion
  devuelve un puntero a una nueva instancia de una subclase, es decir,
  @c(ParedExplosionada*). Definimos @c(Clonar) de ese modo en la clase base para
  asegurar que los clientes que clonan el prototipo no tienen que conocer a sus
  subclases concretas. Los clientes nunca deberian necesitar convertir el valor
  devuelto por @c(Clonar) al tipo deseado.

  En Smalltalk podemos reutilizar el metodo estandar @c(copy) heredado de
  @c(Object) para clonar cualquier @c(LugarDelMapa). Podemos usar
  @c(FabricaDeLaberintos) para producir los prototipos necesarios; por ejemplo,
  podemos crear una @c(Habitacion) suministrando el nombre @c(#Habitacion).
  @c(LaFabricaDeLaberintos) tiene un diccionario que hace corresponder nombres
  con prototipos. Su metodo @c(hacer:) se parece a esto:

  ..src > smalltalk
    hacer: nombreParte
        ^ (catalogoDePartes at: nombreParte) copy
  < src..

  Dados los metodos apropiados para inicializar la @c(FabricaDeLaberintos) con
  prototipos, podremos crear un @c(Laberinto) simple con el codigo siguiente:

  ..src > smalltalk
    CrearLaberinto
        on: (FabricaDeLaberintos new
            with: Puerta new named: #puerta;
            with: Pared new named: #pared;
            with: Habitacion new named: #habitacion;
            yourself)
  < src..

  donde la definicion del metodo de clase @c(on:) para @c(CrearLaberinto) seria

  ..src > smalltalk
    on: unaFabrica
        | Habitacion1 Habitacion2 |
        Habitacion1 := (unaFabrica hacer: #habitacion)
                       ubicacion: 1@1.
        Habitacion2 := (unaFabrica hacer: #habitacion)
                       ubicacion: 2@1.
        puerta := (unaFabrica hacer: #puerta) de: habitacion1 a: habitacion2.

        Habitacion1
            lado; #norte  put: (unafabrica hacer: #pared);
            lado; #este   put: puerta;
            lado; #sur    put: (unafabrica hacer: #pared);
            lado; #oeste  put: (unafabrica hacer: #pared);
        Habitacion2
            lado; #norte  put: (unafabrica hacer: #pared);
            lado; #este   put: (unafabrica hacer: #pared);
            lado; #sur    put: (unafabrica hacer: #pared);
            lado; #oeste  put: puerta;
        Laberinto new
            anadirHabitacion: habitacion1;
            anadirHabitacion: habitacion2;
            yourself
  < src..

*** Prototype Usos Conocidos <> Usos Conocidos

  Quizas el primer ejemplo del patron Prototipo fue en el sistema Sketchpad de
  Ivan Sutherland [@l(#Snt63)]. La primera aplacion ampliamente conocida del patron
  en un lenguaje orientado a objetos fue en ThingLab, donde los usuarios podian
  formar un objeto compuesto y luego promocionarlo a un prototipo instalandolo
  en una biblioteca de objetos reutilizables [@l(#Bor81)]. Goldberg y Robson
  mencionan prototipos como patron [@l(#GR83)], pero Coplien [@l(#Cop92)] da una
  descripcion mucho mas completa, incluyendo idiomas para C++ relacionados con
  el patron Prototype, con muchos ejemplos y variaciones.

  Etgdb es @e(front-end) de un depurador basado en ET++ que proporciona una
  interfaz basada en raton para diferentes depuradores de lineas. Cada depurador
  tiene su correspondiente subclase @c(DebugerAdaptor). Por ejemplo,
  @c(GdbAdaptor) adapta etgdb a la sintaxis de las ordenes de GNU gdb, mientras
  que SunDbxAdaptor adapta etgdb al depurador dbx de Sun. Etgdb no tiene una
  serie de clases @c(DebuggerAdaptor) incrustadas en el codigo, sino que lee el
  nombre del adaptador a usar de una variable de entorno, busca un prototipo con
  el nombre especificado en la tabla global y luego clona el prototipo. Se
  pueden añadir nuevos prototipos a etgdb enlazados con el @c(DebuggerAdaptor)
  que funcione con ese depurador.

  La @"(biblioteca de tecnicas de interaccion) en Mode Composer almacena
  prototipos de objetos que soportan varias tecnicas de interaccion [@l(#Sha90)].
  Cualquier tecnica de interaccion creada por el Mode Composer puede usarse como
  prototipo poniendola en esta biblioteca. El patron Prototype permite que Mode
  Composer soporte un conjunto ilimitado de tecnicas de interaccion.

  El ejemplo del editor musical examinado anteriormente esta basado en el
  framework de dibujo Unidraw [@l(#VL90)].

*** Prototype Patrones Relacionados <> Patrones Relacionados

  Prototype y @l(#Abstract Factory) son patrones rivales en algunos aspectos,
  como se analiza al final de este capitulo. No obstante, tambien pueden usarse
  juntos. Una fabrica abstracta puede almacenar un conjunto de prototipos a
  partir de los cuales clonar y devolver objetos producto.

  Los diseños que hacen un uso intensivo de los patrones @l(#Composite) y
  @l(#Decorator) suelen beneficiarse del Prototype.

** Singleton
*** Singleton Proposito <> Proposito

  Garantiza que una clase solo tenga una instancia, y proporciona un punto de
  acceso global a ella.

*** Singleton Motivacion <> Motivacion

  Es importante que algunas clases tengan exactamente una instancia. Aunque
  puede haber muchas impresoras en un sistema, solo deberia haber una cola de
  impresion. Igualmente, solo deberia haber un sistema de ficheros y un gestor
  de ventanas. Un filtro digital tendra un convertidor A/D. Un sistema de
  contabilidad estara dedicado a servir a una unica compañia.

  ¿Como podemos asegurar que una clase tenga una unica instancia y que esta sea
  facilmente accesible? Una varible global hace accesible a un objeto, pero no
  nos previene de crear multiples instancias de objetos.

  Una solucion mejor es hacer que sea la propia clase la responsable de su unica
  instancia. La clase puede garantizar que no se puede crear ninguna otra
  instancia (interceptando las peticiones para crear nuevos objetos), y puede
  proporcionar un modo de acceder a la instancia. En eso consiste el patron
  Singleton.

*** Singleton Aplicabilidad <> Aplicabilidad

  Usaremos el patron Singleton cuando

  - debe haber exactamente una instancia de una clase, y esta debe ser accesible
    a los clientes desde un punto de acceso conocido.

  - la unica instancia deberia ser extensible mediante herencia, los clientes
    deberian ser capaces de usar una instancia extendida sin modificar su
    codigo.

*** Singleton Estructura <> Estructura

  ..img > img/043.png

*** Singleton Participantes <> Participantes

  - @c(Singleton)

    - define una operacion @c(Instancia) que permite que los clientes accedan a
      su unica instancia. @c(Instancia) es una operacion de clase (es decir, un
      metodo de clase en Smalltalk y una funcion miembro estatica en C++).

    - Puede ser responsable de crear su unica instancia.

*** Singleton Colaboraciones <> Colaboraciones

  Los clientes acceden a la instancia de un Singleton exclusivamente a traves de
  la operacion @c(Instancia) de este.

*** Singleton Consecuencias <> Consecuencias

  El patron Singleton proporciona varios beneficios:

  1. @e(Acceso controlado a la unica instancia.) Puesto que la clase
     @c(Singleton) encapsula su unica instancia, puede tener un control estricto
     sobre como y cuando acceden a ella los clientes.

  2. @e(Espacio de nombres reducido.) El patron Singleton es una mejora sobre
     las variables globales. Evita contaminar el espacio de nombres con
     variables globales que almacenan las instancias.

  3. @e(Permite el refinamiento de operaciones y la representacion.) Se puede
     crear una subclase de la clase @c(Singleton), y es facil configurar una
     aplicacion con una instancia de esta clase extendida. Podemos configurar la
     aplicacion con una instancia de la clase necesaria en tiempo de ejecucion.

  4. @e(Permite un numero variable de instancias.) El patron hace que sea facil
     cambiar de opinion y permitir mas de una instancia de la clase
     @c(Singleton). Ademas, podemos usar el mismo enfoque para controlar el
     numero de instancias que usa la aplicacion, Solo se necesitara cambiar la
     operacion que otorga acceso a la instancia del Singleton.

  5. @e(Mas flexible que las operaciones de clase.) Otra forma de empaquetar la
     funcionalidad de un Singleton es usar operaciones de clase (es decir,
     funciones miembro estaticas en C++ o metodos de clase en Smalltalk). Pero
     ambas tecnicas de estos lenguajes dificultan cambiar un diseño para
     permitir mas de una instancia de una clase. Ademas, las funciones miembro
     estaticas en C++ nunca son virtuales, por lo que las subclases no las pueden
     redefinir polimorficamente.

*** Singleton Implementacion <> Implementacion

  A continuacion se presentan unas cuestiones de implementacion a tener en
  cuenta a la hora de usar el patron Singleton.

  1. @e(Garantiza una unica instancia.) El patron Singleton hace que la unica
     instancia sea una instancia normal de la clase, pero dicha clase se escribe
     de forma que solo se pueda crear una instancia. Una forma usual de hacer
     esto es ocultar la operacion que crea la instancia tras una operacion de
     clase (es decir, una funcion miembro estatica o un metodo de clase) que
     garantice que solo se crea una unica instancia. Esta operacion tiene acceso
     a la variable que contiene la instancia, y se asegura de que la varible
     este inicializada con dicha instancia antes de devolver su valor. Este
     enfoque garantiza que un Singleton se cree e inicialice antes de su primer
     uso.

     Podemos definir la operacion de clase en C++ mediante una funcion miembro
     estatica @c(Instancia) de la clase @c(Singleton). @c(Singleton) tambien
     define una variable miembro estatica @c(_instancia) que contiene un
     puentero a su unica instancia.

     La clase @c(Singleton) se declara como

     ..src > c++
       class Singleton {
       public:
           static Singleton* Instancia();
       protected:
           Singleton();
       private:
           static Singleton* _instancia;
       };
     < src..

     La correspondiente implementacion es

     ..src > c++
       Singleton* Singleton::_instancia = 0;

       Singleton* Singleton::Instancia () {
           if (_instancia == 0) {
               _instancia = new Singleton;
           }
           return _instancia;
       }
     < src..

     Los clientes acceden al Singleton exclusivamente a traves de la funcion
     miembro @c(Instancia). La variable @c(_instancia) se inicializa a 0, y la
     funcion miembro estatica @c(Instancia) devuelve su valor, inicializandola
     con la unica instancia en caso de que sea 0. @c(Instancia) usa
     unicializacion perezosa; el valor que develve no se crea y se almacena
     hasta que se acceda a el por primera vez.

     Notese que el constructor se declara como protegido. Un cliente que trate de
     crear una instancia de @c(Singleton) directamente obtendra un error en
     tiempo de compilacion. Esto garantiza que solo se puede crear una
     instancia.

     Ademas, puesto que @c(_instancia) es un puntero a un objeto @c(Singleton),
     la funcion miembro @c(Instancia) puede asignar a esta variable un puentero
     a una subclase de @c(Singleton). Daremos un ejemplo de esto en el Codigo de
     Ejemplo.

     Hay otra cosa en que fijarse en la implementacion C++. No basta con definir
     el @c(Singleton) como un objeto global o estatico y luego confiar en la
     inicializacion automatica. Hay trez razones para ello:

     a. No podemos garantizar que solo se declarar una unica instancia de un
        objeto estatico.

     b. Podriamos no tener la informacion necesaria para crear una instancia de
        cada Singleton en el momento de la inicialzacion estatica. Un Singleton
        puede necesitar valores que se calculan despues en la ejecucion del
        programa.

     c. C++ no define el orden en que se llama a los constructores de objetos
        globales cuando hay varias unidades de traduccion [@l(#ES90)]. Esto significa
        que no pueden existir dependencias entre objetos Singleton; si hay
        alguna, es inevitable que se produzcan errrores.

     Una desventaja (si bien es cierto que pequeña) añadida al enfoque de un
     objeto global o estatico es que obliga a que se creen todos los objetos
     Singleton, independientemente de que se usen o no. Usar una funcion miembro
     estatica evita estos problemas.

     En Smalltalk, la funcion que devuelve la unica instancia se implementa como
     un metodo de clase de la clase @c(Singleton). Para asegurar que solo se
     crea una instancia, redefine la operacion @c(new). La clase @c(Singleton)
     resultante podria tener los siguientes dos metodos de clase, donde
     @c(UnicaInstancia) es una variable de clase que no se usa en ningun otro
     sitio.

     ..src > smalltalk
       new
           self error: 'no se puede crear un nuevo objeto'

       default
           UnicaInstancia isNill ifTrue: [UnicaInstancia := super new].
           ^ UnicaInstancia
     < src..

  2. @e(Crear una subclase de @c(Singleton).) El principal problema no es
     definir la subclase sino instalar su unica instancia de manera que los
     clientes la puedan usar. En esencia, la variable que hace referencia a la
     unica instancia debe ser inicializada con una instancia de la subclase. La
     tecnica mas sencilla es determinar que Singleton queremos usar en la
     operacion @c(Instancia) de Singleton. Uno de los ejemplos del Codigo de
     Ejemplo muestra como implementar esta tecnica con variables de entorno.

     Otro modo de elegir la subclase de @c(Singleton) es sacar la implementacion
     de @c(Instancia) fuera de la clase padre (por ejemplo,
     @c(FabricaDeLaberintos) y ponerla en la subclase. Eso permite que un
     programador de C++ decida la clase del Singleton durante el enlazado (por
     ejemplo, enlazandola con un fichero objeto que contenga una implementacion
     diferente) pero la oculta a los clientes del Singleton.

     Este enfoque fija la eleccion de la clase del Singleton durante el
     enlazado, lo que dificulta elegir la clase del Singleton en tiempo de
     ejecucion. Usar instrucciones condicionales para determinar la subclase es
     mas flexible, pero fija el conjunto de posibles clases Singleton. Ninguno
     de los dos enfoques es lo suficientemente flexible para todos los casos.

     Un enfoque mas flexible usa un @b(registro de objetos Singleton). En vez de
     que sea @c(Instancia) quien defina el conjunto de posibles clases
     @c(Singleton), las clases @c(Singleton) pueden registrar su unica instancia
     por su nombre en un registro que sea conocido por todos.

     El registro establece una correspondencia entre nombres y objetos
     @c(Singleton). Cuando @c(Instancia) necesita un @c(Singleton), consulta el
     registro, pidiendo un @c(Singleton) por su nombre. El registro busca el
     Singleton correspondiente (si existe) y lo devuelve. Este enfoque libra a
     @c(Instancia) de tener que conocer todas las posiles clases o instancias de
     @c(Singleton). Todo lo que necesita es una interfaz comun para todas las
     clases @c(Singleton) que incluya operaciones para el registro:

     ..src > c++
       class Singleton {
       public:
           static void Registrar(const char* nombre, Singleton*);
           static Singleton* Instancia();
       protected:
           static Singleton* Buscar(const char* nombre);
       private:
           static Singleton* _instancia;
           static List<ParNombreSingleton>* _registro;
       };
     < src..

     @c(Registrar) registra la instancia del @c(Singleton) con el nombre
     especificado. Para mantener el registro simple, haremos que guarde una
     lista de objetos @c(ParNombreSingleton). Cada @c(ParNombreSingleton) hace
     corresponder un nombre con un @c(Singleton). La operacion @c(Buscar) busca
     un @c(Singleton) dado su @c(nombre). Supondremos que una variable de
     entorno especifica el nombre del Singleton que desea.

     ..src > c++
       Singleton* Singleton::Instancia () {
           if (_instancia == 0) {
               const char* nombreSingleton = getenv("SINGLETON");
               // proporcionada por el usuario o el entorno al principio

               _instancia = Buscar(nombreSingleton);
               // Buscar devuelve 0 si no existe tal Singleton
           }
           return _instancia;
       };
     < src..

     ¿Donde se registan las propias clases Singleton? Una posibilidad es en
     su constructor. Por ejemplo, una subclase @c(MiSingleton) podria hacer lo
     siguiente:

     ..src > c++
       MiSingleton::MiSingleton() {
           // ...
           Singleton::Registrar("MiSingleton", this);
       }
     < src..

     Por supuesto, el constructor no sera llamado al menos que alguien cree una
     instancia de la clase, ¡lo que reproduce el problema que el patron
     Singleton esta tratando de resolver! Podemos evitar este problema en C++
     definiendo una instancia estatica de @c(MiSingleton). Por ejemplo podemos
     definir

     ..src > c++
       static MiSingleton elSingleton;
     < src..

     en el fichero que contiene la implementacion de @c(MiSingleton).

     La clase @c(Singleton) ya no es la responsable de crear el @c(Singleton).
     En vez de eso, su principal responsabilidad es hacer que en el sistema se
     pueda elegir el @c(Singleton) y acceder a el. El enfoque del objeto
     estatico todavia tiene un inconveniente potencial: hay que crear las
     instancias de todas las posibles subclases de @c(Singleton) o, si no, no se
     resgistran.

*** Singleton Codigo de Ejemplo <> Codigo de Ejemplo

  Supongamos que definimos una clase @c(FabricaDeLaberintos) para construir
  laberintos, como se describio en la Seccion @l(#Abstract Factory Codigo de
  Ejemplo<>Codigo De Ejemplo) del patron @l(#Abstract Factory). La clase
  @c(FabricaDeLaberintos) define una interfaz para construir las diferentes
  partes de un laberinto. Las subclases puede redefinir sus operaciones para
  devolver instancias de clases producto especializadas, como objetos
  @c(ParedExplosionada) en vez de simples objetos @c(Pared).

  Lo relevante aqui es que la aplicacion @c(Laberinto) solo necesita una
  instancia de una fabrica de laberintos, y esa instancia deberia estar
  disponible para el codigo que construye cualquier parte del laberinto. Aqui es
  donde entra en juego el patron Singleton. Al hacer a la
  @c(FabricaDeLaberintos) un Singleton, hacemos que el objeto laberinto sea
  accesible globalmente sin depender de variables globales.

  Para Simplificar, supondremos que nunca crearemos subclases de
  @c(FabricaDeLaberintos) (en seguida veremos como seria en ese caso). En C++
  hacemos que sea una clase Singleton, añadiendo una operacion estatica
  @c(Instancia) y un miembro tambien estatico @c(_instancia), la que guarde la
  unica instancia. Tambien debemos declarar al constructor como protegido para
  prevenir la creacion de instancias accidentalmente, lo que podria dar lugar a
  mas de una instancia.

  ..src > c++
    class FabricaDeLaberintos {
    public:
        static FabricaDeLaberintos* Instancia();

        // aqui iria la interfaz existente
    protected:
        FabricaDeLaberintos();
    private:
        static FabricaDeLaberintos* _instancia;
    };
  < src..

  La correspondiente implementacion es

  ..src > c++
    FabricaDeLaberintos* FabricaDeLaberintos::_instancia = 0;

    FabricaDeLaberintos* FabricaDeLaberintos::Instancia () {
        if (_instancia == 0) {
            _instancia = new FabricaDeLaberintos;
        }
        return _instancia;
    }
  < src..

  Pensemos ahora que ocurre cuando hay subclases de @c(FabricaDeLaberintos) y la
  aplicacion tiene que decidir cual usar. Seleccionaremos el tipo de laberinto
  por medio de una variable de entorno y añadiremos codigo que cree una
  instancia de la subclase apropiada de @c(FabricaDeLaberintos), basandose en el
  valor de la variable de entorno. La operacion @c(Instancia) es un buen lugar
  donde poner este codigo, dado que ya crea una instancia de
  @c(FabricaDeLaberintos):

  ..src > c++
    FabricaDeLaberintos* FabricaDeLaberintos::Instancia () {
        if (_instancia == 0) {
            const char* estiloLaberinto = getenv("ESTILOLABERINTO");

            if (strcmp(estiloLaberinto, "conBombas") == 0) {
                _instancia = new FabricaDeLaberintosConBombas;

            } else if (strcmp(estiloLaberinto, "encantado") == 0) {
                _instancia = new FabricaDeLaberintosEncantados;

            // ... otras posibles subclases

            } else {         // por omision
                _instancia = new FabricaDeLaberintos;
            }
        }
        return _instancia;
    }
  < src..

  Notese que debemos modificar @c(Instancia) cada vez que definimos una nueva
  subclase de @c(FabricaDeLaberintos). Eso puede que no sea un problema en esta
  aplicacion, pero podria serlo para fabricas abstractas definidas en un
  framework.

  Una posible solucion seria usar el enfoque del registro descrito en la seccion
  Implementacion. Tambien podria ser util el enlazado dinamico @-(previene a la
  aplicacion de tener que cargar todas las subclases que no se usan).

*** Singleton Usos Conocidos <> Usos Conocidos

  Un ejemplo del patron Singleton en Smalltalk-80 [@l(#Par90)] es el conjunto de
  cambios al codigo, @c(ChangeSet current). Un ejemplo mas util es la relacion
  entre las clases y sus metaclases. Una metaclase es la clase de una clase, y
  cada metaclase tiene una instancia. Las metaclases no tienen nombres (salvo
  indirectamente, a traves de su unica instancia), pero conocen a su unica
  instancia y normalmente no crearan otra.

  El toolkit de interfaces de usuario InterViews [@l(#LCI+92)] usa el patron
  Singleton para acceder a la unica instancia de sus interfaces @c(Session) y
  @c(WidgetKit), entre otras. La clase @c(Session) define el bucle principal de
  despacho de eventos de la aplicacion, almacena la base de datos con las
  preferencias estilisticas del usuario y gestiona las conexiones a uno o mas
  dispositivos fisicos de visualizacion. La clase @c(WidgetKit) es una fabrica
  abstracta para definir el aspecto y el comportamiento de los elementos de la
  interfaz de usuario. La operacion @c[WidgetKit::instance()] determina la
  subclase concreta de @c(WidgetKit) de la que se va a crear una instancia
  basandose en una variable de entorno definida por la clase @c(Session). Una
  operacion parecida en @c(Session) determina si se soportan monitores
  monocromo o en color, y configura segun eso la unica instancia de @c(Session).

*** Singleton Patrones Relacionados <> Patrones Relacionados

  Hay muchos patrones que pueden implementarse usando el patron Singleton. Vease
  el @l(#Abstract Factory), el @l(#Builder) y el @l(#Prototype).

** Discusion sobre los patrones de creacion

  Hay dos formas habituales de parametrizar un sistema con las clases de objetos
  que crea. Una es heredar de la clase que crea los objetos; esto se corresponde
  con el uso del patron @l(Factory Method). El principal inconveniente de este
  enfoque es que puede requerir crear una nueva subclase simplemente para
  cambiar la clase del producto. Dichos cambios pueden tener lugar en
  cascada. Asi, por ejemplo, cuando el creador del producto es a su vez creado
  por un metodo de fabricacion, habra que redefinir tambien a su creador.

  El otro modo de parametrizar un sistema se basa mas en la composicion de
  objetos: consiste en definir un objeto que sea responsable de conocer la clase
  de los objetos producto, y hacer que sea un parametro del sistema. Este es un
  aspecto clave de los patrones @l(#Abstract Factory), @l(#Builder) y
  @l(#Prototype). Los tres implican crear un nuevo @"(objeto fabrica) cuya
  responsabilidad es crear objetos producto. El objeto fabrica del Abstract
  Factory produce objetos de varias clases, mientras que en el caso del Builder
  costruye un producto complejo incrementalmente usando un protocolo de
  complejidad similar. El Prototype, por su parte, hace que su objeto fabrica
  construya un producto copiando un objeto prototipico. En este caso, el objeto
  fabrica y el prototipo son el mismo objeto, ya que el prototipo es el
  responsable de devolver el producto.

  Pensemos en el framework de editores de dibujo descrito en el patron
  Prototype. Hay varias formas de parametrizar una @c(HerramientaGrafica) con la
  clase del producto:

  - Si aplicamos el patron Factory Method, se creara en la paleta una subclase
    de @c(HerramientaGrafica) para cada subclase de @c(Grafico).
    @c(HerramientaGrafica) tendra una operacion @c(NuevoGrafico) que sera
    redefinida por cada una de sus subclases.

  - Si aplicamos el patron @c(Abstract Factory), habra una jerarquia de clases
    de @c(FabricacionDeGraficos), una para cada subclase de @c(Grafico). En este
    caso, cada fabrica crea un solo producto: @c(FabricaDeCirculos) creara
    @c(Circulos), @c(FabricaDeLineas) creara @c(Lineas), y asi sucesivamente.
    Una @c(HerramientaGrafica) estara parametrizada con una fabrica para crear
    el tipo apropiado de @c(Grafico).

  - Si aplicamos el patron Prototype, cada subclase de @c(Grafico) implementara
    la operacion @c(Clonar), y cada @c(HerramientaGrafica) estara parametrizada
    con un prototipo del @c(Grafico) que crea.

  Que patron es mejor depende de muchos factores. En nuestro farmework de
  editores de dibujo, el patron Factory Method es el mas facil de usar al
  principio. Resulta sencillo definir una nueva subclase de
  @c(HerramietaGrafica), y las instancias de @c(HerramientaGrafica) se crean
  solo cuando se define la paleta. El principal inconveniente de esta opcion es
  que proliferan las subclases de @c(HerramientaGrafica), y ninguna de ellas
  hara gran cosa.

  El Abstract Factory no ofrece mucha mejora, ya que requiere una jerarquia de
  clases @c(FabriaDeGraficos) igualmente grande. El Abstract Factory seria
  preferible al Factory Method solo si ya hubiera una jerarquia de clases
  @c(FabricaDeGraficos), ya sea porque la proporcione el compilador de una
  manera automatica (como en Smalltalk o en Objetive C) o porque sea necesaria
  en otra parte del sistema.

  De todos ellos, el patron Prototype es probablemente el mejor para el
  framework de editores de dibujo, ya que solo requiere implementar una
  operacion @c(Clonar) en cada clase de @c(Grafico). Esto reduce el numero de
  clases, y la operacion @c(Clonar) puede usarse para otros propositos ademas de
  la mera creacion de instancias (por ejemplo, para una operacion de menu
  Duplicar).

  El Factory Method hace que un diseño sea mas adaptable a cambio de solo un
  poco mas de complejidad. Otros patrones de diseño requieren clases nuevas,
  mientras que el Factory Method solo necesita una nueva operacion. La gente
  suele usar el Factory Method como la forma estandar de creacion de objetos,
  pero no es necesario cuando la clase de la que se crean instancias no cambia
  nunca o cuando la creacion de instancias tiene lugar en una operacion que
  puede ser redefinida facilmente por las subclases, como en una operacion de
  inicializacion.

  Los diseños que usan los patrones Abstract Factory, Prototype o Bulider son
  tadavia mas flexibles que aquellos que usar el Factory Method, pero tambien
  son mas complejos. Muchas veces, los diseños empiezan usando el Factory Method
  y luego evolucionan hacia los otros patrones de creacion a medida que el
  diseñador descubre donde es necesaria mas flexibilidad. Conocer muchos
  patrones de diseño nos da mas posibilidades de eleccion cuando estamos
  analizando los pros y los contras de un criterio de diseño frente a otro.

* Capitulo 4 <> Patrones Estructurales

  Los patrones estructurales se ocupan de como se combinan las clases y los
  objetos para formar estructuras mas grandes. Los patrones estructurales @e(de
  clases) hacen uso de la herencia para componer interfaces o implementaciones.
  A modo de ejemplo sencillo, pensemos en como la herencia multiple mezcla dos o
  mas clases en una sola. El resultado es una clase que combina las propiedades
  de sus clases padre. Este patron es particularmente util para lograr que
  funcionen juntas bibliotecas de clases desarrolladas de forma independiente.
  Otro ejemplo es la version de clases del patron @l(#Adapter). En general, un
  adaptador hace que una interfaz (la de la clase adaptable) se ajuste a otra,
  proporcionando asi una abstraccion uniforme de interfaces diferentes. La forma
  de lograr esto es un adaptador de clases es heredando privadamente de una
  clase adaptable. A continuacion el adaptador expresa su interfaz en terminos
  de la clase adaptable.

  En vez combinar interfaces o implemenaciones, los patrones estructurales @e(de
  objetos) describen formas de componer objetos para obtener nueva funcionalidad.
  La flexibilidad añadida de la composicion de objetos viene dada por la
  capacidad de cambiar la composicion en tiempo de ejecucion, lo que es
  impolible con la composicion de clases estatica.

  El @l(#Composite) es un ejemplo de patron estructural de objetos. describe
  como construir una jerarquia de clases formada por dos tipos de objetos:
  primitivos y compuestos. Los objetos compuestos permiten combinar objetos
  primitivos, asi como objetos compuestos, para formar estructuras todo lo
  complejas que se quiera. En el patron @l(#Proxy) un objeto proxy actua como
  sustituto o un representante de otro objeto. Se puede usar un proxy de muchas
  formas. Puede hacer de represtante local de un objeto que esta en un espacio
  de direcciones remoto. Puede representar un objeto mas grande que deberia ser
  cargado a peticion. Puede proteger el acceso a un objeto confidencial. Los
  @e(proxies) proporcionan un nivel de indireccion a determinadas propiedades de
  los objetos. Por tanto, pueden restringir, aumentar o alterar dichas
  propiedades.

  El patron @l(#Flyweigh) define una estructura para compartir objetos. Los
  objetos se comparten por al menos dos razones: eficiencia y consistencia. Este
  patron se basa en el compartimiento como mecasinmo para lograr un uso mas
  eficiente del espacio. Las aplicaciones que usan muchos objetos deben prestar
  especial atencion a los costes de cada objeto. Se pueden lograr ahorros
  sustanciales compartiendo objetos en vez de duplicarlos. Pero los objetos
  pueden compartirse solo si no tienen un estado que dependa del contexto. Los
  objetos @e(flyweigh) (peso ligero) no tienen dicho estado. Cualquier
  informacion adicional que necesiten para llevar a cabo su tarea se les pasa en
  el momento que sea necesaria. Asi, sin estado dependiente del contexto, los
  objetos @"(peso ligero) pueden compartirse sin problemas.

  Mientras que el patron Flyweight muestra como crear muchos objetos pequeños,
  el patron @l(#Facade) (fachada) muestra como hacer que un unico objeto
  represente un subsistema completo. Una fachada es un representante de un
  conjunto de objetos. La fachada lleva a cabo sus reponsabilidades reenviando
  mensajes a los objetos que representa. El patron @l(#Bridge) separa la
  abstraccion de un objeto de su implementacion, de manera que ambas puedan ser
  modificadas por separado.

  El patron @l(#Decorator) describe como añadir responsabilidades a objetos
  dinamicamente. Es un patron estructural que compone objetos recursivamente
  para permitir un numero ilimitado de responsabilidades adicionales. Por
  ejemplo, un objeto Decorador que contiene un componente de interfaz de usuario
  puede añadir un adorno, como un borde o un sombreado, al componente, o bien
  añadir funcionalidad, como capacidad de desplazamiento @e(zoom). Podemos
  añadir dos adornos simplemente anidando un objeto Decorador dentro de otro, y
  asi sucesivamente para adornos adicionales. Para levar a cabo esto, cada
  objeto decorador debe ajustarse a la interfaz de su componente y reenviarle
  los mensajes. El Decorador puede hacer su trabajo (como dibujar un borde
  alrededor del componente) antes o despues de reenviar un mensaje.

  Muchos patrones estructurales estan de algna manera relacionados. Trataremos
  dichas relaciones al final del capitulo.

** Adapter
*** Adapter Proposito <> Proposito

  Convierte la interfaz de un clase en otra interfaz que es la que esperan los
  clientes. Permite que cooperen clases que de otra forma no podrian por tener
  interfaces incompatibles.

*** Adapter Tambien Conocido Como <> Tambien Conocido Como

  Wrapper (Envoltorio)

*** Adapter Motivacion <> Motivacion

  A veces una clase de un toolkit que ha sido diseñada para reutilizarse, no
  puede hacerlo porque su interfaz no coincide con la interfaz especifica del
  dominio que requiere la aplicacion.

  Pensemos, por ejemplo, en un editor de dibujo que permita que los usuarios
  dibujen y ubiquen elementos graficos (lineas, poligonos, texto, etc.) en
  dibujos y diagramas. La abstraccion fundamental del editor de dibujo es el
  objeto grafico, que tiene una forma modificable y que puede dibujarse asi
  mismo. La interfaz de los objetos graficos esta definida por una clase llamada
  @c(Forma). El editor define una subclase de @c(Forma) para cada tipo de objeto
  grafico: una clase @c(FormaLinea) para las lineas, otra @c(FormaPoligono) para
  los poligonos, etcetera.

  Las clases de formas geometricas elementales, como @c(FormaLinea) y
  @c(FormaPoligono) son bastante faciles de implementar, ya que sus capacidades
  de dibujado y edicion son intrinsecamente limitadas. Pero una subclase
  @c(Texto) que pueda mostrar y editar texto es considerablemente mas dificil de
  implementar, ya que incluso la edicion basica de texto implica actualizaciones
  de pantalla complicadas y gestion de buferes. A su vez, un toolkit comercial
  de interfaces de usuario podria proporcionar una clase @c(VistaTexto)
  sofisticada para mostrar y editar texto. Lo que nos gustaria seria poder
  reutilizar @c(VistaTexto) para implementar @c(FormaTexto), pero el toolkit no
  se diseño con las clases @c(Forma) en mente. Por tanto, no podemos usar los
  objetos @c(VisualTexto) y @c(Forma) de manera intercambiable.

  ¿Como pueden funcionar clases existentes y no relacionadas, como
  @c(VistaTexto), en una aplicacion que espera clases con una interfaz diferente
  e incompatible? Podriamos cambiar la clase @c(VistaTexto) para que se ajustase
  a la interfaz @c(Forma), pero eso no es una opcion a menos que tengamos el
  codigo fuente del toolkit. Incluso aunque asi fuese, no tendria sentido
  cambiar @c(VistaTexto); el tookit no deberia tener que adoptar interfaces
  especificas del dominio solo para que funcione una aplicacion.

  En vez eso, podriamos definir @c(FormaTexto) para que @e(adapte) la interfaz
  @c(VistaTexto) a la de @c(Forma). Podemos hacer esto de dos maneras: (1)
  heredando la interfaz de @c(Forma) y la implementacion de @c(VistaTexto), o
  (2) componiendo una instancia @c(VistaTexto) dentro de una @c(FormaTexto) e
  implementando @c(FormaTexto) en terminos de la interfaz de @c(Vistatexto).
  Ambos enfoques se corresponden con las versiones de clases y de objetos del
  patron @c(Adapter). Decimos entonces que @c(FormaTexto) es un @b(adaptador).

  El siguiente diagrama ilustra el caso del adaptador de objetos. Muestra como
  las peticiones a @c(CajaLimitrofe), declarada en una clase @c(Forma), se
  convierten en peticiones a @c(ObtenerExtension), definida en @c(VistaTexto).
  Puesto que @c(FormaTexto) adapta @c(VistaTexto) a la interfaz @c(Forma), el
  editor de dibujo puede reutilizar la clase @c(VistaTexto), que de otro modo
  seria incompatible.

  ..img > img/044.png

  Muchas veces el adaptador es responsable de la funcionalidad que la clase
  adaptada no proporciona. El diagrama muestra como un adaptador puede llevar a
  cabo tales responsabilidades. El usuario deberia ser capaz de @"(arrastrar)
  interactivamente cada objeto @c(Forma) a una nueva posicion, pero
  @c(VistaTexto) no esta diseñada para ello. @c(FormaTexto) puede añadir esta
  funcionalidad ausente implementando la operacion de @c(Forma)
  @c(Crearmanipulador), que devuelve una instancia de la subclase
  @c(Manipulador) apropiada.

  @c(Manipulador) es una clase abstracta para objetos que saben como hacer que
  una @c(Forma) reponda a la entrada del usuario, como arrastrar la forma a una
  nueva posicion. Hay subclases de @c(Manipulador) para diferentes formas;
  @c(ManipuladorDeTexto), es la subclase correspondiente a
  @c(FormaText). Devolviendo una instancia de @c(ManipuladorDeTexto),
  @c(FormaTexto) añade la funcionalidad que @c(VistaTexto) no tiene y que es
  requerida por @c(Forma).

*** Adapter Aplicabilidad <> Aplicabilidad

  Deberia usarse el patron Adapter cuando

  - se quiere usar una clase existente y su interfaz no concuerda con la que
    necesita.

  - se quiere crear una clase reutilizable que coopere con clases no
    relacionadas o que no han sido previstas, es decir, clases que no tienen por
    que tener interfaces compatibles.

  - (@e(solamente en el caso de un adaptador de objetos)) es necesario usar
    varias subclases existentes, pero no resulta practico adaptar su interfaz
    heredando de cada una de ellas. Un adaptador de objetos puede adaptar la
    interfaz de su clase padre.

*** Adapter Estructura <> Estructura

  Un adaptador de clases usa la herencia multiple para adaptar una interfaz a
  otra:

  ..img > img/045.png

  Un adaptador de objetos se basa en la composicion de objetos:

  ..img > img/046.png

*** Adapter Participantes <> Participantes

  - @c(Objetivo) (@c(Forma))

    - define la interfaz especifica del dominio que usa el @c(Cliente).

  - @c(Cliente) (@c(EditorDeDebujo))

    - colabora con objetos que se ajustan a la interfaz @c(Objetivo).

  - @c(Adaptable) (@c(VistaTexto))

    - define una interfaz existente que necesita ser adaptada.

  - @c(Adaptador) (@c(FormaTexto))

    - adapta la interfaz de @c(Adaptable) a la interfaz @c(Objetivo)

*** Adapter Colaboraciones <> Colaboraciones

  Los clientes llaman a operaciones de una instancia de @c(Adaptador). A su vez,
  el adaptador llama a operaciones de @c(Adaptable), que son las que satisfacen
  la peticion.

*** Adapter Consecuencias <> Consecuencias

  Los Adaptadores de clases y de objetos tienen diferentes ventajas e
  inconvenientes. Un adaptador de clases

  - adapta una clase @c(Adaptable) a @c(Objetivo), pero se refiere unicamente a
    una clase @c(Adaptable) concreta. Por tanto, un adaptador de clases no nos
    servira cuendo lo que queremos es adaptar una clase y todas sus subclases.

  - permite que @c(Adaptador) redefina parte del comportamiento de
    @c(Adaptable), por ser @c(Adaptador) una subclase de @c(Adaptable).

  - introduce un solo objeto, y no se necesita ningun puntero de indireccion
    adicional para obtener el objeto adaptado.

  Por su parte, un adaptador de objetos

  - permite que un mismo @c(Adaptador) funcione con muchos @c(Adaptables) @-(es
    decir, con el @c(Adaptable) en si y todas sus subclases, en caso de que
    las tenga). El @c(Adaptabor) tambien puede añadir funcionalidades a todos los
    @c(Adaptadores) a la vez.

  - hace que sea mas dificil redefinir el comportamiento de @c(Adaptable). Se
    necesitara crear una subclase de @c(Adaptable) y hacer que el @c(Adaptador)
    se refiera a la subclase en vez de a la clase @c(Adaptable) en si.

  Estas son otras cuestiones a tener en cuenta al usar el patron Adaptador:

  1. @e(¿Cuanta adaptacion hace el @c(Adaptador)?) Los adaptadores difieren en
     la cantidad de trabajo necesario para adaptar @c(Adaptable) a la interfaz
     @c(Objetivo). Hay una amplia gama de tareas posibles, que van desde la
     simple conversion de interfaces @-(por ejemplo, cambiar los nombres de las
     operaciones) a permitir un conjunto completamente nuevo de operaciones. La
     cantidad de trabajo que hace el @c(Adaptador) depende de lo parecida que
     sea la interfaz de @c(Objetivo) a la de @c(Adaptable).

  2. @e(@c(Adaptadores) conectables.) Una clase es mas reutilizable cuando
     minimizamos las asunciones que deben hacer otras clase para usarla. Al
     hacer la adaptacion de interfaces en una clase estamos eliminando la
     asuncion de que otras clases ven la misma interfaz. Dicho de otro modo, la
     adaptacion de interfaces nos permite incorporar nuestra clase a sistemas
     existentes que podrian esperar interfaces diferentes a la de la
     clase. ObjectWorks\Smalltalk [@l(#Par90)] usa el termino @b(adaptador
     conectable) para describir clases con adaptacion de interfaces incorporada.

     Pensemos en un util@n(31) @c(VisualizadorDeArboles) que puede mostrar estructuras
     arboreas graficamente. Si este fuera un util de proposito especial para
     usar en una unica aplicacion podriamos obligar a los objetos que representa
     a que tuviesen una interfaz concreta; es decir, que todos descendiesen de
     una clase abstracta @c(Arbol). Pero si quisieramos hacer a
     @c(VisualizadorDeArboles) mas reutilizable (supongamos que quisieramos
     hacerlo parte de un toolkit de utiles), entonces ese requisito seria poco
     razonable. Las aplicaciones definiran sus propias clases para estructuras de
     arbol. No deberian estar obligadas a utilizar nuestra clase abstracta
     @c(Arbol). Estructuras arboreas diferentes tendran diferentes interfaces.

     Por ejemplo, en una jerarquia de directorios podria accederse a los hijos
     con una operacion @c(ObtenerSubdirectorios), mientras que en una jerarquia
     de clases la operacion correspondiente podria llamarse @c(ObtenerSubclases).
     Un util @c(VisualizadorDeArboles) reutilizable debe ser capaz de
     representar ambos tipos de jerarquias, incluso aunque usen diferentes
     interfaces. En otras palabras, el @c(VisualizadorDeArboles) deberia tener
     la adaptacion de interfaces incorporada.

     En la seccion de Implementacion veremos diferentes modos de incorporar la
     adaptacion de interfaces a las clases.

  3. @e(Usar adaptadores bidireccionales para proporcionar transparencia.) Un
     problema potencial de los adaptadores es que no son transparentes a todos
     los clientes. Un objeto adaptador ya no se ajusta a la interfaz
     @c(Adaptable), por lo que no puede usarse tal cual en donde pudiera ir un
     objeto @c(Adaptable). Los @e(adaptadores bidireccionales) pueden
     proporcionar esta transparencia. En concreto, resultan utiles cuando dos
     clientes distintos necesitan ver un objeto de distinta forma. Pensemos en
     el adaptador bidireccional que incorpora Unidraw, un framework para
     editores graficos [@l(#VL90)], y QOCA, un toolkit de resolucion de problemas
     [@l(#HHMV92)]. Ambos sistemas tienen clases que representan variables
     explicitamente: Unidraw tiene @c(StateVariable), y QOCA tiene
     @c(ConstrainVariable). Para hacer que Unidraw funcione con QOCA, hay que
     adaptar @c(ConstraintVariable) a @c(StateVariable); para que QOCA propague
     soluciones a Unidraw, hay que adaptar @c(StateVariable) a
     @c(ConstraintVariable).

     La solucion consiste en un adaptador de clases bidireccional
     @c(ConstraintStateVariable), una subclase de @c(StateVariable) y
     @c(ConstraintVariable), que adapta cada una de las dos interfaces a la
     otra. La herencia multiple es una solucion viable en este caso porque las
     interfaces de las clases adaptadas son sustancialmente diferentes. El
     adaptador de clases bidireccional se ajusta a las dos clases adaptadas y
     puede trabajar en cualquiera de los dos sistemas.

     ..img > img/047.png

*** Adapter Implementacion <> Implementacion

  Aunque la implementacion del patron Adapter suele ser sencilla, estas son
  algunas cuestiones que hay que tener en cuenta:

  1. @e(Implementacion de adaptadores de clases en C++.) Es una implementacion
     C++ de un adaptador de clases, @c(Adaptador) deberia heredar publicamente
     de @c(Objeto) y privadamente de @c(Adaptable). Asi, @c(Adaptador) seria un
     subtipo de @c(Objetivo), pero no de @c(Adaptable).

  2. @e(Adaptadores conectables.) Veamos tres formas de implementar adaptadores
     conectables para el util @c(VisualizadorDeArboles) descrito anteriormente,
     el cual puede mostrar una estructura jerarquica automaticamente.

  El primer paso, que es comun a las tres implementaciones estudiadas aqui,
  consiste en encontrar una interfaz @"(reducida) para @c(Adaptable), es decir,
  el subconjunto mas pequeño de operaciones que nos permita hacer la
  adaptacion. Una interfaz reducida consistente en solo un par de operaciones es
  mas facil de adaptar que una interfaz con docenas de operaciones. Para
  @c(VisualizadorDeArboles), el adaptable es cualquier estructura
  jerarquica. Una interfaz minimalista podria incluir dos operaciones, una que
  defina como presentar un nodo graficamente en la estructura, y otra que
  recupere los hijos del nodo.

  La interfaz reducida nos lleva a tres enfoques de implementacion:

  a) @e(Usar operaciones abstractas.) Definir las correspondientes operaciones
     abstractas para la interfaz reducida de @c(Adaptable) en la clase
     @c(VisualizadorDeArboles.) Las subclases deben implementar las operaciones
     abstractas y adaptar el objeto estructurado jerarquicamente. Por ejemplo,
     una subclase @c(VisualizadorDeArbolDeDirectorios) implementara estas
     operaciones accediendo a la estructura de directorios.

     ..img > img/048.png

     @c(VisualizaorDeArbolDeDirectorios) especializa la interfaz reducida
     de manera que pueda representar y mostrar estructuras de directorio formadas
     por objetos @c(EntidadDelSistemaDeFicheros).

  b) @e(Usar objetos delegados.) Con este enfoque, @c(VisualizadorDeArboles)
     reenvia las peticiones para acceder a la estructura jerarquica a un objeto
     @b(delegado). @c(VisualizadorDeArboles) puede usar una estrategia de
     adaptacion diferente cambiando el objeto delegado.

     Por ejemplo, supongamos que exinte un @c(ExploradorDeDirectorios) que usa
     un @c(VisualizadorDeArboles). @c(ExploradorDeDirectorios) podria ser un
     buen delegado para adaptar @c(VisualizadorDeArboles) a la estructura
     jerarquica de directorios. En lenguajes dinamicamente tipados, como
     Smalltalk u Objetive C, este enfoque solo necesita una interfaz para
     registrar el delegado con el adaptador. A continuacion,
     @c(VisualizadorDeArboles) simplemente reenvia las peticiones al
     delegado. NEXTSTEP [@l(#Add94)] usa este enfoque intensivamente para reducir el
     uso de subclases.

     Los lenguajes estaticamente tipados, como C++, necesitan una definicion de
     interfaz explicita para el delegado. Podemos especificar dicha interfaz
     poniendo la interfaz reducida que necesita @c(VisualizadorDeArboles) en una
     clase abstracta @c(DelegadoDeAccesoAlArbol). A continuacion podemos
     combinar esta interfaz con el delegado de nuestra eleccion
     @-(@c(ExploradorDeDirectorios), en este caso) a traves de la herencia. Usaremos
     herencia simple si el @c(ExploradorDeDirectorios) no tiene ninguna clase
     padre, y herencia multiple en caso de que la tenga. Combinar clases de esta
     forma es mas facil que introducir una nueva subclase
     @c(VisualizadorDeDirectorios) e implementar sus operaciones
     individualmente.

     ..img > img/049.png

  c) @e(Adaptadores parametrizados.) La forma mas comun de permitir adaptadores
     conectables en Smalltalk es parametrizar un adaptador con uno o mas
     bloques. La construccion @e(block) permite la adaptacion sin necesidad de
     subclases. Un bloque puede adaptar una peticion y el adaptador puede
     almacenar un bloque para cada peticion individual. En nuestro ejemplo, esto
     quier decir que @c(VisualizadorDeArboles) guarda un bloque para convertir
     un nodo en un @c(NodoGrafico) y otro bloque para acceder a los hijos de un
     nodo.

     Por ejemplo, para crear @c(VisualizadorDeArboles) en una jerarquia de
     directorios, escribimos

     ..src > smalltalk
       VisualizadorDeDirectorios :=
           (VisualizadorDeArboles on: raiz)
               obtenerBloquesHijos:
                   [:nodo | nodo obtenerSubdirectorios]
               crearBloqueNodoGrafico:
                   [:nodo | nodo crearNodoGrafico].
     < src..

     si estamos adaptando una interfaz a una clase, este enfoque ofrece una
     buena alternativa a la herencia.

*** Adapter Codigo de Ejemplo <> Codigo de Ejemplo

  Daremos un breve esbozo de la implementacion de adaptadores de clases y de
  objetos para el ejemplo de la seccion de Motivacion, comenzando con las clases
  @c(Forma) y @c(VistaTexto).

  ..src > c++
    class Forma {
    public:
        Forma();
        virtual void CajaLimitrofe(
            Punto& inferiorIzquierdo, Punto& superiorDerecho
        ) const;
        virtual Manipulador* CrearManipulador() const;
    };

    class VistaTexto {
    public:
        VistaTexto();
        void ObtenerOrigen(Coord& x, Coord& y) const;
        void ObtenerArea(Coord& ancho, Coord& alto) const;
        virtual bool EstaVacia() const;
    };
  < src..

  @c(Forma) determina sus limites mediante una caja definida por sus esquinas
  opuestas. @c(VistaTexto), por el contrario, esta definida por un @c(origen),
  un @c(alto) y un @c(ancho). @c(Forma) tambien define una operacion
  @c(CrearManipulador) para crear un @c(Manipulador),@n(32) el cual sabe como
  mover una forma cuando esta es manipulada por el usuario. @c(VistaTexto) no
  tiene una operacion equivalente. La clase @c(FormaTexto) es un adaptador entre
  estas interfaces diferentes.

  un adaptador de clases usa la herencia multiple para adaptar interfaces. La
  clave de los adaptadores de clases es usar una rama de la herencia para
  heredar la interfaz y otra para heredar la implementacion. La forma normal de
  hacer esta dintincion en C++ es heredar publicamente la interfaz y
  privadamente la implementacion. Usaremos este convenio para definir el
  adaptador @c(FormaTexto).

  ..src > c++
    class FormaTexto : public Forma, private VistaTexto {
    public:
        FormaTexto();

        virtual void CajaLimitrofe(
            Punto& inferiorIzquierdo, Punto& superiorDerecho
        ) const;
        virtual bool EstaVacia() const;
        virtual Manipulador* CrearManipulador() const;
    };
  < src..

  La operacion @c(CajaLimitrofe) convierte la interfaz de @c(VistaTexto) para
  que se ajuste a la de @c(Forma).

  ..src > c++
    void FormaTexto::CajaLimitrofe (
        Punto& inferiorIzquierdo, Punto& superiorDerecho
    ) const {
        Coord inferior, izquierda, ancho, alto;

        ObtenerOrigen(inferior, izquierda);
        ObtenerArea(ancho, alto);

        inferiorIzquierdo = Punto(inferior, izquierda);
        superiorDerecho   = punto(inferior + alto, isquierda + ancho);
    }
  < src..

  La operacion @c(EstaVacia) ilustra el reenvio directo de peticiones que es
  comun en las implementaciones de adaptadores:

  ..src > c++
    bool FormaTexto::EstaVacia () const {
        return VistaTexto::EstaVacia();
    }
  < src..

  Por ultimo, definiremos @c(CrearManipulador) (que no es admitida por
  @c(VistaTexto)) desde cero. Suponemos que ya hemos implementado una clase
  @c(ManipuladorDeTexto) que permite que la manipulacion de una @c(FormaTexto).

  ..src > c++
    Manipulador* FormaTexto::CrearManipulador () const {
        return new ManipuladorDeTexto(this);
    }
  < src..

  El objeto adaptador usa composicion de objetos para combinar clases con
  diferentes interfaces. Con este enfoque, el adaptador @c(FormatoTexto)
  mantiene un puntero a @c(VistaTexto).

  ..src > c++
    class FormaTexto : public Forma {
    public:
        FormaTexto(VisitaTexto*);

        virtual void CajaLimitrofe(
            Punto& inferiorIzquierdo, Punto& superiorDerecho
        ) const;
        virtual bool EstaVacia() const;
        virtual Manipulador* CrearManipulador() const;
    private:
        VistaTexto* _texto;
    };
  < src..

  @c(FormaTexto) debe inicializar el puntero a la instancia de @c(VistaTexto), y
  lo hace en el constructor. Tambien tiene que llamar a las operaciones de su
  objeto @c(VistaTexto) cada vez que se llama a las suyas propias. En este
  ejemplo suponemos que el cliente crea el objetivo @c(VistaTexto) y lo pasa al
  constructor de @c(FormaTexto):

  ..src > c++
    FormaTexto::FormaTexto (VisitaTexto* t) {
        _texto = t;
    }

    void FormaTexto::CajaLimitrofe (
        Punto& inferiorIzquierdo, Punto& superiorDerecho
    ) const {
        Coord inferior, izquierda, ancho, alto;

        _texto->ObtenerOrigen(inferior, izquierda);
        _texto->ObtenerArea(ancho, alto);

        inferiorIzquierdo = Punto(inferior, izquierda);
        superiorDerecho = Punto(inferior + alto, izquierda + ancho);
    }

    bool FormaTexto::EstaVacia () const {
        return _texto->EstaVacia();
    }
  < src..

  La implementacion de @c(CrearManipulador) no cambia respecto de la version del
  adaptador de clases, ya que esta implementado desde cero y no reutiliza nada
  de la funcionalidad existente de @c(VistaTexto).

  ..src > c++
    Manipulador* FormaTexto::CrearManipulador () const {
        return new ManipuladorDeTexto(this);
    }
  < src..

  Comparese este codigo con el caso del adaptador de clases. El adaptador de
  objetos requiere un poco mas de esfuerzo a la hora de escribirlo, pero tambien
  es mas flexible. Por ejemplo, la version del adaptador de objetos de
  @c(FormaTexto) funcionara igualmente bien con subclases de @c(VisitaTexto)
  @-(el cliente simplemente pasa una instancia de una subclase de
  @c(VisitaTexto) al constructor de @c(FormatoTexto)).

*** Adapter Usos Conocidos <> Usos Conocidos

  El ejemplo de la seccion Motivacion viene de ET++Draw, una aplicacion de
  dibujo basada en ET++ [@l(#WGM88)]. ET++Draw reutiliza las clases de ET++ para
  editar texto mediante una clase adaptadora @c(TextShape).

  InterViews 2.6 define una clase abstracta @c(Interactor) para elementos de la
  interfaz de usuario como barras de desplazamiento, botones y menus [@l(#VL88)].
  Tambien define una clase abstracta @c(Graphic) para objetos graficos
  estructurados, tales como lineas, circulos, poligonos y @e(splines). Tanto
  @c(Interactor) como @c(Graphic) tienen representacion visual, pero ambos
  tienen diferentes interfaces e implementaciones (no comparten una clase padre
  comun) y son por tanto incompatibles @-(no podemos insertar directamente un
  objeto grafico estructurado en, pongamos por caso, un cuadro de dialogo).

  En vez de eso, InterViews 2.6 define un adaptador de objetos llamado
  @c(GraphicBlock), una subclase de @c(Iteractor) que contiene una instancia de
  @c(Graphic). El @c(GraphicBlock) adapta la interfaz de la clase @c(Graphic) a
  la de @c(Interactor). El @c(GraphicBlock) permite que se pueda mostrar,
  desplazar y hacer @e(zoom) sobre una instancia de @c(Graphic) dentro de una
  estructura @c(Interactor).

  Los adaptadores conectables son frecuentes en ObjectWorks\Smalltalk
  [@l(#Par90)]. El Smalltalk estandar define una clase @c(ValueModel) para las vistas
  que muestran un valor unico. @c(ValueModel) define una interfaz @c(value),
  @c(value:) para acceder al valor. Estos son metodos abstractos. Los
  implementadores de la aplicacion acceden al valor con nombres mas especificos
  del dominio, como @c(ancho) y @c(ancho:), pero no deberian tener que crear
  una subclase de @c(ValueModel) para adaptar dichos nombres especificos del
  dominio a la interfaz @c(ValueModel).

  En lugar de eso, ObjectWorks\Smalltalk incluye una subclase de @c(ValueModel)
  llamada @c(PluggableAdaptor). Un objeto @c(PluggableAdaptor) adapta otros
  objetos a la interfaz de @c(ValueModel) (@c(value), @c(value:)). Puede ser
  parametrizado con bloques para obtener y establecer el valor deseado.
  @c(PluggableAdaptor) utiliza internamente estos bloques para implementar la
  interfaz @c(value), @c(value:). @c(PluggableAdaptor) tambien permite pasar
  nombres directamente en el selector (por ejemplo, @c(ancho), @c(ancho:)) por
  conveniencia sintactica, convirtiendo estos selectores en los bloques
  correspondientes de forma automaticamente.

  ..img > img/050.png

  Otro ejemplo de ObjectWorks\Smalltalk es la clase @c(TableAdaptor). Un
  @c(TableAdaptor) puede adaptar una secuencia de objetos a una representacion
  tabular. La tabla muestra un objeto por fila. El cliente parametriza
  @c(TablaAdaptor) con el conjunto de mensajes que puede usar una tabla para
  obtener de un objeto los valores de las columnas.

  Algunas clases del AppKit de NeXT [@l(#Add94)] usa delegacion de objetos para
  llevar a cabo adaptacion de interfaces. Un ejemplo es la clase @c(NXBrowser)
  que puede mostrar listas jerarquicas de datos. @c(NXBrowser) usa un objeto
  delegado para acceder a los datos y adaptarlos.

  El @"(Matrimonio de Conveniencia) de Meyer [@l(#Mey88)] es una forma de adaptador
  de clases. Meyer describe como una clase @c(PilaFija) adapta la implementacion
  de una clase @c(Array) a la interfaz de una clase @c(Pila). El resultado es una
  pila que contiene un numero fijo de entradas.

*** Adapter Patrones Relacionados <> Patrones Relacionados

  El patron @l[#Bridge] tiene una estructura similar a un adaptador de objetos,
  pero como un proposito diferente: esta pensado para separar una interfaz de su
  implementacion, de manera que ambos puedan cambiar facilmente y de forma
  indepenediente uno del otro, mientras que un adaptador esta pensado para
  cambiar la interfaz de un objeto existente

  El patron @l(#Decorator) decora otro objeto sin cambiar su interfaz. Un
  decorador es por tanto mas transparente a la aplicacion que un adaptador. Como
  resultado, el patron @c(Decorador) permite la composicion recursiva, lo que no
  es posible con adaptadores puros.

  El patron @l(#Proxy) define una representacion o sustituto de otro objeto sin
  cambiar su interfaz.

** Bridge
*** Bridge Proposito <> Proposito

  Desacopla una abstraccion de su implementacion, de modo que ambas puedan
  variar de forma independientemente.

*** Bridge Tambien Conocido Como <> Tambien Conocido Como

  Handle/Body (Manejador/Cuerpo)

*** Bridge Motivacion <> Motivacion

  Cuando una abstraccion puede tener varias implementaciones posibles, la forma
  mas habitual de darles cabida es mediante la herencia. Una clase abstracta
  define la interfaz de la abstraccion, y las subclases concretas la
  implementan de distintas formas. Pero este enfoque no simpre es lo bastante
  flexible. La herencia liga una implementacion a la abstraccion de forma
  permanente, lo que dificulta modificar, extender y reutilizar abstracciones e
  implementaciones de forma independiente.

  Pensemos en la implementacion de una abstraccion portable @c(Ventana) en un
  toolkit de interfaces de usuario. Esta abstraccion deberia permitirnos
  escribir aplicaciones que funcionen, por ejemplo, tanto en el Sistema de
  Ventanas X como en Presentation Manager de IBM (PM). Mediante la herencia
  podriamos definir una clase abstracta @c(Ventana) y subclases @c(VentanaX) y
  @c(VentanaPM) que implementen la interfaz @c(Ventana) para las distintas
  plataformas. Pero este enfoque tiene dos inconvenientes:

  1. No es conveniente extender la abstraccion @c(Ventana) para cubrir
     diferentes tipos de ventanas o nuevas plataformas. Imaginemos una subclase
     @c(VentanaIcono), que especializa la abstraccion Ventana para representar
     iconos. Para admitir este tipo de ventanas en ambas plataformas debemos
     implementar @e(dos) nuevas clases, @c(VentanaIconoX) y @c(VentanaIconoIP).
     Y lo que es peor, tendremos que definir dos clases para @e(cada) tipo de
     ventana. Dar cabida a una tercera plataforma requeriria otra nueva subclase
     de @c(Ventana) para cada tipo de ventana.

     ..img > img/051.png

  2. Hace que el codigo sea dependiente de la plataforma. Cada vez que un
     cliente crea una ventana, se crea una clase concreta que tiene una
     determinada implementacion. Por ejemplo, crear un objeto @c(VentanaX) liga
     la abstraccion @c(Ventana) a la implementacion para X Window, lo que vuelve
     al codigo del cliente dependiente de dicha implementacion. A su vez esto
     hace que sea mas dificil portar el codigo cliente a otras plataformas.

     Los clientes deberian ser capaces de crear una ventana sin someterse a una
     implementacion concreta. Lo unico que tendria que depender de la plataforma
     en la que se ejecuta la aplicacion es la implementacion de la ventana. Por
     tanto, el codigo cliente deberia crear ventanas sin hacer mencion a
     plataformas concretas.

  El patron Bridge resuelve estos problemas situando la abstraccion @c(Ventana)
  y su implementacion en jerarquias de clases separadas. Hay una jerarquia de
  clases para las interfaces de las ventanas (@c(Ventana), @c(Ventanaicono),
  @c(VentanaFlotante)) y otra jerarquia aparte para las implementaciones
  especificas de cada plataforma, teniendo a @c(Ventanaimp)@n(33) como su
  raiz. Por ejemplo, la subclase @c(VentanaImpX) proporciona una implementacion
  basada en el sistema de ventanas X Window.

  ..img > img/052.png

  Todas las operaciones de las subclases de @c(Ventana) se implementan en
  terminos de operaciones abstractas de la interfaz @c(VentanaImp). Esto
  desacopla las abstracciones ventana de las diferentes implementaciones
  especificas de cada plataforma. Nos referiremos a la relacion entre
  @c(Ventana) y @c(VentanaImp) como un @b(puente) @%e(bridge), porque une a la
  abstraccion con su implementacion, permitiendo que ambas varien de forma
  independiente.

*** Bridge Aplicabilidad <> Aplicabilidad

  Use el patron Bridge cuando

  - quiera evitar un enlace permanente entre una abstraccion y su
    implementacion. Por ejemplo, cuando debe seleccionarse o cambiarse la
    implementacion en tiempo de ejecucion.

  - tanto las abstracciones como sus implementaciones deberian ser extensibles
    mediante subclases. En este caso, el patron Bridge permite combinar las
    diferentes abstracciones y sus implementaciones, y extenderlas
    independientemente.

  - los cambios en la implementacion de una abstraccion no deberian tener
    impacto en los clientes; es decir, su codigo no tendria que ser recompilado.

  - (C++) quiera ocultar completamente a los clientes la implementacion de una
    abstraccion. En C++ la representacion de una clase es visible en la interfaz
    de la misma.

  - tenga una proliferacion de clases como la mostrada en el primer diagrama de
    la seccion Motivacion. Una jerarquia de clases tal pone de manifiesto la
    necesidad de dividir un objeto en dos partes. Rumbaugh usa el termino
    @"(generalizaciones anidadas) [@l(#RBP+91)] para referirse a dichas jerarquias de
    clases.

  - quiera compartir una implementacion entre varios objetos (tal vez usando un
    contador de referencias) y este hecho deba permanecer oculto al cliente. Un
    ejemplo sencillo es la clase @c(String) de Coplien [@l(#Cop92)], donde varios
    objetos pueden compartir la misma representacion de una cadena (@c(StringRep)).

*** Bridge Estructura <> Estructura

  ..img > img/053.png

*** Bridge Participantes <> Participantes

  - @c(Abstraccion) (@c(Ventana))

    - define la interfaz de la abstraccion.

    - mantiene una referencia a un objeto de tipo Implementador.

  - @c(AbstraccionRefinada) (@c(VentanaIcono))

    - extiende la interfaz definida por @c(Abstraccion).

  - @c(Implementador) (@c(VentanaImp))

    - define la interfaz de las clases de implementacion. Esta interfaz no tiene
      por que corresponderse exactamente con la de @c(Abstraccion); de hecho,
      ambas interfaces pueden ser muy distintas. normalmente la interfaz
      @c(Implementador) solo proporciona operaciones primitivas, y
      @c(Abstraccion) define operaciones de mas alto nivel basadas en dichas
      primitivas.

  - @c(ImplementadorConcreto) (@c(VentanaImpX), @c(VentanaImpPM))

    - implementa la interfaz @c(Implementador) y define su implementacion concreta.

*** Bridge Colaboraciones <> Colaboraciones

  Abstraccion redirige las peticiones del cliente a su objeto @c(Implementador).

*** Bridge Consecuencias <> Consecuencias

  El patron Bridge tiene las siguientes consecuencias:

  1. @e(Desacopla la interfaz y la implementacion.) No une permanentemente una
     implementacion a una tinterfaz, sino que la implementacion puede
     configurarse en tiempo de ejecucion. Incluso es posible que un objeto
     cambie su implementacion en tiempo de ejecucion.

     Desacoplar @c(Abstraccion) e @c(Implementador) tambien elimina de la
     implementacion dependencias de tiempo de compilacion. Ahora, cambiar una
     clase ya no requiere recompilar la clasa abstraccion y sus clientes. Esta
     propiedad es esencial cuando debemos asegurar la compatibilidad binaria
     entre distintas versiones de una biblioteca de clases.

     Ademas, este desacoplamiento potencia una division en capas que puede dar
     lugar a sistemas mejor estructurados. La parte de alto nivel de un sistema
     solo tiene que conocer a @c(Abstraccion) y a @c(Implementador).

  2. @e(Mejara la extensibilidad.) Podemos extender las jerarquias de
     @c(Abstraccion) y de @c(Implementador) de forma independiente.

  3. @e(Oculta detalles de implementacion a los clientes.) Podemos aislar a los
     clientes de los detalles de implementacion, como el compartimiento de
     objetos implementadores y el correspondiente mecanismo de conteo de
     referencias (si es que hay alguno).

*** Bridge Implementacion <> Implementacion

  Al aplical el patron Bridge hemos de tener en cuenta las siguientes cuestiones
  de implementacion:

  1. @e(Un unico implementador.) En situaciones en las que solo hay una
     implementacion, no es necesario crear un aclase abstracta
     @c(Implementador). Este es un caso degenerado del patron Bridge, cuando hay
     una relacion uno-a-uno entre @c(Abstraccion) e @c(Implementador). Sin
     embargo, esta separacion sigue siendo util cuando un cambio en la
     implementacion de una clase no debe afectar a sus clientes existentes, es
     decir, que estos no deberian tener que ser recompilados, sino solo vueltos
     a enlazar.

     Carolan [@l(#Car89)] usa la expresion @"(Gato de Cheshire) para describir dicha
     separacion. En C++ se puede definir la interfaz de la clase
     @c(Implementador) en un fichero de cabecera privado que no se proporciona a
     los clientes.

  2. @e(Crear el objeto @c(Implementador) apropiado.) ¿Como, cuando y donde se
     decide de que clase @c(Implementador) se van a crear las instancias cuando
     hay mas de una? Si @c(Abstraccion) conoce a todas las clases
     @c(ImplementadorConcreto), puede crear una instancia de una de ellas en su
     constructor; puede decidir de cual basandose en los parametros pasados a su
     constructor. Por ejemplo, si la clase de una coleccion admite varias
     implementaciones, la desicion puede estar basada en el tamaño de la
     coleccion. Se puede usar una lista enlazada para colecciones pequeñas y una
     tabla de dispersion (@e(hash)) para coleccione grandes.

     Otro enfoque consiste en elegir inicialmente una implemenacion
     predeterminada y cambiarla despues en funcion de su uso, Si, por ejemplo,
     la coleccion crece mas alla de cierto limite, puede cambiar su
     implementacion por otra que resulte mas apropiada para un gran numero de
     elementos.

     Tambien es posible delegar totalmente la desicion en otro objeto. En el
     ejercicio de la @c(Ventena)/@c(VentanaImp) se puede introducir un objeto
     fabrica (vease el patron @l(#Abstract Factory)) cuya unica mision sea
     encapsular detalles de implementacion. La fabrica sabe que tipo de objeto
     @c(VentanaImp) crear para la plataforma en uso; una @c(Ventana) simplemente
     solocita una @c(VentanaImp), y devuelve el tipo adecuado de esta. Una
     ventaja de este enfoque es que @c(Abstraccion) no esta acoplada
     directamente a ninguna de las clases @c(Implementador).

  3. @e(Compartimiento de Implementadores.) Coplien ilustra como se puede usar
     el modismo de C++ Handle/Body @%e(Manjador/Cuerpo) para compartir
     implementaciones entre varios objetos [@l(#Cop92)]. El @c(Cuerpo) tiene un
     contador de referencias que es incrementado y disminuido por la clase
     @c(Manejador). El codigo para asignar manejadores con cuerpos compartidos
     tiene la siguiente forma general:

     ..src > c++
       Manejador& Manejador::operator= (const Manejador& otro) {
           otro._cuerpo->Ref();
           _cuerpo->QuitarRef();

           if (_cuerpo->ContadorReferencias() == 0) {
               delete _cuerpo;
           }
           _cuerpo = otro._cuerpo;

           return *this;
       }
     < src..

  4. @e(Uso de la herencia multiple.) Se puede utilizar herencia multiple en C++
     para combinar una interafaz con su implementacion [@l(#Mar91)]. Por ejemplo, una
     clase puede heredar publicamente de @c(Abstraccion) y privadamente de
     @c(ImplementadorConcreto). Pero dado que este enfoque se basa en la
     herencia estatica, esta asociando permanentemente una implementacion a su
     interfaz. Por tanto, no se puede implementar un verdadero Bridge usando
     herencia estatica, al menos no en C++.

*** Bridge Codigo de Ejemplo <> Codigo de Ejemplo

  El siguiente codigo C++ implementa el ejemplo @c(Ventana)/@c(VentanaImp) de la
  seccion de @c(Motivacion). La clase @c(Ventana) define la abstraccion de
  ventana para las aplicaciones clientes:

  ..src > c++
    class Ventana {
    public:
        Ventene(Vista* contenido);

        // peticiones manejadas por la ventana
        virtual void DibujarContenido();
        virtual void Abrir();
        virtual void Cerrar();
        virtual void Minimizar();
        virtual void Maximizar();

        // peticiones reenviadas a su implementacion
        virtual void EstablecerOrigen(const Punto& en);
        virtual void EstablecerArea(const Punto& area);
        virtual void TraerAlFrente();
        virtual void EnviarAlFondo();

        virtual void DibujarLinea(const Punto&, const Punto&);
        virtual void DibujarRect(const Punto&, const Punto&);
        virtual void DibujarPoligono(const Punto[], int n);
        virtual void DibujarTexto(const char*, const Punto&);

    protected:
        VentanaImp* ObtenerVentanaImp();
        Vista* ObtenerVista();

    private:
        VentenaImp* _imp;
        Vista* _contenido; // el contenido de la ventana
    };
  < src..

  @c(Ventana) mantiene una referencia a @c(VentanaImp), la clase abstracta que
  declara una interfaz para el sistema de ventanas subyacente.

  ..src > c++
    class VentanaImp {
    public:
        virtual void ImpSuperior() = 0;
        virtual void ImpInferior() = 0;
        virtual void ImpEstablecerArea (const Punto&) = 0;
        virtual void ImpEstablecerOrigen(const Punto&) = 0;

        virtual void DispositivoRect(Coord, Coord, Coord, Coord) = 0;
        virtual void DispositivoTexto(const char*, Coord, Coord) = 0;
        virtual void DispositivoMapaDeBits(const char*, Coord, Coord) = 0;
        // muchas mas funciones para dibujar en las ventanas...
    protected:
        VentanaImp();
    };
  < src..

  Las subclases de @c(Ventana) definen los diferentes tipos de ventanas que
  puede usar la aplicacion, como ventas de aplicacion, iconos, ventanas
  flotantes para los dialogos, paletas de herramientas flotantes, etcetera.

  Por ejemplo, @c(VentanaAplicacion) implementa @c(DibujarContenido) para que
  dibujo su instancia de @c(Vista):

  ..src > c++
    class VentanaAplicacion : public Ventana {
    public:
        // ...
        virtual void DibujarContenido();
    };

    void VentanaAplicacion::DibujarContenido () {
        ObtenerVista()->DibujarEn(this);
    }
  < src..

  @c(VentanaIcono) almacena el nombre de un mapa de bits con el icono que
  muestra...

  ..src > c++
    class VentanaIcono : public Ventana {
    public:
        // ...
        virtual void DibujarContenido();
    private:
        const char* _nombreMapaDeBits;
    };
  < src..

  ...e implementa @c(DibujarContenido) para que dibuje el mapa de bits en la
  ventana:

  ..src > c++
    void VentanaIcono::DibujarContenido() {
        VentanaImp* imp = ObtenerVentanaImp();
        if (imp != 0) {
            imp->DispositivoMapaDeBits(_nombreMapaDeBits, 0.0, 0.0);
        }
    }
  < src..

  Hay muchas otras posibles variantes de @c(Ventana). Una @c(VentanaFlotante)
  puede necesitar comunicarse con la ventana principal que la creo; de hay que
  contenga una referencia a dicha ventana. Una @c(VentanaPaleta) siempre flota
  sobre otras ventanas. Una @c(VentanaDeIconos) contiene objetos
  @c(Ventanaicono) y los coloca como es debido.

  Las operaciones de @c(Ventana) se definen en terminos de la interfaz
  @c(VentanaImp). Por ejemplo, @c(DibujarRect) extrae cuatro coordenadas a
  partir de sus dos parametros @c(Punto) antes de llamar a la operacion de
  @c(VentanaImp) que dibuja el rectangulo en la ventana:

  ..src > c++
    void Ventana::DibujarRect (const Punto& p1, const Punto& p2) {
        VentanaImp* imp = ObtenerVentanaImp();
        imp->DispositivoRect(p1.X(), p1.Y(), p2.X(), p2.Y());
    }
  < src..

  Las subclases concretas de @c(VentanaImp) admiten diferentes sistemas de
  ventanas. La subclase @c(VentanaImpX) admite el sistema de ventanas X:

  ..src > c++
    class VentanaImpX : public VentanaImp {
    public:
        VentanaImpX();

        virtual void DispositivoRect(Coord, Coord, Coord, Coord);
        // el resto de la interfaz publica...
    private:
        // estado especifico del sistema de ventanas X, incluyendo:
        Display* _pantalla;
        Drawable _idVentana;  // identificador de ventana
        GC _cg;               // contexto grafico de la ventana
    };
  < src..

  Para Presentation Manager (PM) definimos la clase @c(VentanaImpPM):

  ..src > c++
    class VentanaImpPM : public VentanaImp {
    public:
        VentanaImpPM();
        virtual void DispositivoRect(Coord, Coord, Coord, Coord);

        // el resto de la interfaz publica...
    private:
        // estado especifico del sistema de ventanas PM, incluyendo:
        HPS _hps;
    };
  < src..

  Estas subclases implementan las operaciones de @c(VentanaImp) en terminos de
  las primitivas del sistema de ventanas. Por ejemplo, @c(DispositivoRect) se
  implementa para X como sigue:

  ..src > c++
    void VentanaImpX::DispositivoRect (
        Coord x0, Coord y0, Coord x1, Coord y1
    ) {
        int x = round(min(x0, x1));
        int y = round(min(y0, y1));
        int ancho = round(abs(x0 - x1));
        int alto  = round(abs(y0 - y1));
        XDrawRectangle(_pantalla, _idVentana, _cg, x, y, ancho, alto);
    }
  < src..

  La implemantacion para PM podria parecerse a:

  ..src > c++
    void VentanaImpPM::DispositivoRect (
        Coord x0, Coord y0, Coord x1, Coord y1
    ) {
        Cord izquierda = min(x0, x1);
        Cord derecha   = max(x0, x1);
        Cord abajo     = min(y0, y1);
        Cord arriba    = max(y0, y1);

        PPOINTL punto[4];

        punto[0].x = izquierda; punto[0].y = arriba;
        punto[1].x =   derecha; punto[1].y = arriba;
        punto[2].x =   derecha; punto[2].y =  abajo;
        punto[3].x = izquierda; punto[3].y =  abajo;

        if (
            (GpiBeginPath(_hps, 1L) == false) ||
            (GpiSetCurrentPosition(_hps, &punto[3]) == false) ||
            (GpiPolyLine(_hps, 4L, punto) == GPI_ERROR) ||
            (GpiEndPath(_hps) == false)
        ) {
            // notificar error
        } else {
            GpiStroquePath(_hps, 1L, 0L);
        }
    }
  < src..

  ¿Como obtiene una ventana una instancia de la subclase correcta de
  @c(VentanaImp)? En este ejemplo, supondremos que es @c(Ventana) quien tiene
  esa responsabilidad. Su operacion @c(ObtenerVentanaImp) obtiene la instancia
  correcta de una fabrica abstracta (vease el patron @l(Abstract Factory)) que
  encapsula todos los detalles del sistema de ventanas.

  ..src > c++
    VentanaImp* Ventana::ObtenerVentanaImp () {
        if (_imp == 0) {
            _imp = FabricaSistemaDeVentanas::Instancia()->HacerWindowImp();
        }
        return _imp;
    }
  < src..

  @c[FabricaSistemaDeVentanas::Instancia()] devuelve una fabrica abstracta que
  produce todos los objetos especificos del sistema de ventanas. Por simplicidad
  hemos hecho que sea un @l(#Singleton) y  hemos dejado que la clase @c(Ventana)
  acceda directamente a la fabrica.

*** Bridge Usos Conocidos <> Usos Conocidos

  El ejemplo de @c(Ventana) que acabamos de ver proviene de ET++ [@l(#WGM88)]. En
  ET++ una @c(VentanaImp) se denomina @"(WindowPort) y tiene subclase tales como
  @c(XWindowPort) y @c(SunWindowPort). El objeto @c(Window) crea su correspondiente
  objeto @c(Implementador) pidiendoselo a una factoria abstracta llamada
  @"c(WindowSystem). @c(WindowSystem) proporciona una interfaz para crear
  objetos dependientes de la plataforma, como fuentes, cursores, mapas de bits,
  etcetera.

  El diseño @c(Window)/@c(WindowPort) de ET++ extiende el patron Bridge en el
  sentido de que @c(WindowPort) usa dicha referencia para notificar a @c(Window)
  eventos especificos de @c(WindowPort): la llegada de eventos de entrada,
  cambios del tamaño de pantalla, etc.

  Both Coplien [@l(#Cop92)] y Stroustrup [@l(#Str91)] mencionan las clases @c(Manejador)
  @%e(Handler) y dan algunos ejemplos de ellas. Sus ejemplos hacen hincapie en
  aspectos de la gestion de memoria, como compartir representaciones de cadenas y
  permitir objetos de tamaño variable. Nuestra atencion se centra mas en
  permitir que se puedan extender la abstraccion y la implemenatacion
  independientemente una de la otra.

  libg++ [@l(#Lea88)] define clases que implementan estructuras de datos comunes,
  tales como @c(Set), @c(LinkedSet), @c(HashSet), @c(LinketList) y @c(HashTable).
  @c(Set) es una clase abstracta que define una abstraccion de un conjunto,
  mientras que @c(LinketList) y @c(HashTable) sos implementadores concretos de
  una lista enlazada y una tabla de dispersion, respectivamente. @c(LinkedSet) y
  @c(HashSet) son implementadores de @c(Set) que unen a @c(Set) con sus
  equivalentes concretos @c(LinkedList) y @c(HashTable). Este es un ejemplo de
  un puente degenerado, porque no hay una clase abstracta @c(Implementador).

  El AppKit de NeXT [@l(#Add94)] usa el patron Bridge en la implementacion y
  visualizacion de imagenes graficas. Una imagen se puede representar de varias
  formas diferentes. La representacion optima de una imagen depende de las
  caracteristicas de un dispositivo de visualizacion, concretamente de su
  capacidad de color y de su resolucion. Sin la ayuda de AppKit los
  desarrolladores tendrian que determinar que implementacion usar bajo varias
  circunstancias en cada aplicacion.

  Para aliviar a los desarrolladores de esta responsabilidad, AppKit proporciona
  un puente para @c(NXImage)/@c(NXImageRep). @c(NXImage) define la interfaz para
  manipular imagenes. La implementacion de las imagenes se define en una
  jerarquia de clases separada @c(NXImageRep) que tiene subclases como
  @c(NXEPSImageRep), @c(NXCachedImageRep) y @c(NXBitMapImageRep). @c(NXImage)
  mantiene una referencia a uno o mas objetos @c(NXImageRep). Si hay mas de una
  implementacion de una imagen, @c(NXImage) selecciona la mas apropiada para el
  dispositivo de visualizacion actual. @c(NXImage) es incluso capaz de convertir
  una implementacion en otra si es necesario. El aspecto interesante de esta
  variante de Bridge es que @c(NXImage) puede almacenar mas de una implementacion
  de @c(NXImageRep) al mismo tiempo.

*** Bridge Patrones Relacionados <> Patrones Relacionados

  El patron @l(#Abstract Factory) puede crear y configurar un Bridge.

  El patron @l(#Adapter) esta orientado a conseguir que trabajen juntas clases
  que no estan relacionadas. Normalmente se aplica a sistemas que ya han sido
  diseñados. El patron Bridge, por otro lado, se usa al comenzar un diseño para
  permitir que abstracciones varien independientemente unas de otras.

** Composite
*** Composite Proposito <> Proposito

  Compone objetos en estructuras de arbol para representar jerarquias de
  parte-todo. Permite que los clientes traten de manera unforme a los objetos
  individuales y a los compuestos.

*** Composite Motivacion <> Motivacion

  Las aplicacions graficas como los editores de dibujo y los sistemas de diseño
  de circuitos permiten a los usuarios construir diagramas complejos a partir de
  componentes simples. El usuario puede agrupar componentes para formar
  componentes mas grandes, que a su vez pueden agruparse para formar componentes
  aun mayores. Una implementacion simple podria definir clases para primitivas
  graficas como @c(Texto) y @c(Linea), mas otras clases que actuen como
  contenedoras de estas primitivas.

  Pero hay un problema con este enfoque: el codigo que usa estas clases debe
  tratar de forma diferente a los objetos primitivos y a los contenedores,
  incluso aunque la mayor parte del tiempo el usuario los trate de forma
  identica. Tener que distinguir entre estos objetos hace que la aplicacion sea
  mas compleja. El patron Composite describe como usar la composicion recursiva
  para que los clientes no tengan que hacer esta distincion.

  La clave del patron Composite es una clase abstracta que representa @e(tanto)
  a primitivas @e(como) a sus contenedores. Para el sistema grafico, esta clase
  es @c(Grafico). @c(Grafico) declara operaciones como @c(Dibujar) que son
  especificas de objetos graficos. Tambien declara operaciones que comparten
  todos los objetos compuestos, tales como operaciones para acceder a sus hijos
  y para gestionarlos.

  Las subclases @c(Linea), @c(Rectangulo) y @c(Texto) (vease el diagrama de
  clases siguiente) definen objetos graficos primitivos. Estas clases
  implementan @c(Dibujar) para dibujar lineas, rectangulos y texto,
  respectivamente. Como los graficos primitivos no tienen graficos hijos,
  ninguna de estas clases implementa operaciones relacionadas con los hijos.

  ..img > img/054.png

  La clase @c(Dibujo) define una agregacion de objetos @c(Grafico). @c(Dibujo)
  implementa @c(Dibujar) para que llame al @c(Dibujar) de sus hijos, y añade
  operaciones relacionadas con los hijos. Como la interfaz de dibujo se ajusta a
  la interfaz de @c(Grafico), los objetos @c(Dibujo) pueden componer
  recursivamente otros @c(Dibujos).

  El siguiente diagrama muestra una tipica estructura de objetos compuestos
  recursivamente por otros objetos @c(Grafico) compuestos:

  ..img > img/055.png

*** Composite Aplicabilidad <> Aplicabilidad

  Use el patron @c(Composite) cuando

  - quiera representar jerarquias de objetos parte-todo.

  - quiera que los clientes sean capaces de obviar las diferencias entre
    composicion de objetos y los objetos individuales. Los clientes trataran a
    todos los objetos de la estructura compuesta de manera uniforme.

*** Composite Estructura <> Estructura

  ..img > img/056.png

  Una estructura de objetos Compuestos tipica puede parecerse a esto:

  ..img > img/057.png

*** Composite Participantes <> Participantes

  - @c(Componente) (@c(Grafico))

    - declara la interfaz de los objetos de la composicion.

    - implementa el comportamiento predeterminado de la interfaz que es comun a
      todas las clases.

    - declara una interfaz para acceder a sus componentes hijos y gestionarlos.

    - (opcional) define una interfaz para acceder al padre de un componente en
      la estructura recursiva y, si es necesario, la implementa.

  - @c(Hoja) (@c(Rectangulo), @c(Linea), @c(Texto), etc.)

    - representa objetos hoja en la composicion. Una hoja no tiene hijos.
    - define el comportamiento de los objetos primitivos de la composicion.

  - @c(Compuesto) (@c(Dibujo))

    - define el comportamineto de los componentes que tinen hijos.
    - almacena componentes hijos.
    - implementa las operaciones de la interfaz @c(Componente) relacionadas con
      los hijos.

  - @c(Cliente)

    - manipula objetos en la composicion a traves de la interfaz @c(Componente)

*** Composite Colaboraciones <> Colaboraciones

  Los @c(Clientes) usan la interfaz de la clase @c(Componente) para interactuar
  con los objetos de la estructura compuesta. Si el recipiente es una @c(Hoja),
  la peticion se trata correctamente. Si es un @c(Compuesto), normalmente
  redirige las peticiones a sus componentes hijos, posiblemente realizando
  operaciones adicionales antes o despues.

*** Composite Consecuencias <> Consecuencias

  El patron @c(Composite)

  - define jerarquias de clases formadas por objetos primitivos y compuestos.
    Los objetos primitivos pueden componerse en otros objetos mas complejos, que
    a su vez pueden ser compuestos, y asi de manera recurrente. Alli donde el
    codigo espere un objeto primitivo, tambien podra recibir un objeto
    compuesto.

  - simplifica el cliente. Los clientes pueden tratar uniformemente a las
    estructuras compuestas y a los objetos individuales. Los clientes
    normalmente no conocen (y no les deberia importar) si estan tratando con una
    hoja o con un componente compuesto. Esto simplifica el codigo del cliente,
    puesto que evita tener que escribir funciones con instrucciones @c(if)
    anidadas en las clases que definen la composicion.

  - facilita añadir nuevos tipos de componentes. Si se definen nuevas subclases
    @c(Compuesto) u @c(Hoja), estas funcionaran automaticamente con las
    estructuras y el codigo cliente existentes. No hay que cambiar los clientes
    para las nuevas clases @c(Componentes).

  - puede hacer que un diseño sea demasiado general. La desventaja de facilitar
    añadir nuevos componentes es que hace mas dificil restringir los componentes
    de un compuesto. A veces queremos que un compuesto solo tenga ciertos
    componentes. Con el patron Composite, no podemos confiar en el sistema de
    tipos para que haga cumplir estas restricciones por nosotros. En vez de eso,
    tendremos que usar comprobaciones en tiempo de ejecucion.

*** Composite Implementacion <> Implementacion

  Hay muchas cuestiones a tener en cuenta al implementar el patron Composite:

  1. @e(Referencias explicitas al padre.) Mantener referencias de los
     componentes hijos a sus padres puede simplificar el recorrido y la gestion
     de una estructura compuesta. La referencia al padre facilita ascender por
     la estructura y borrar un componente. Las referencias al padre tambien
     ayudan a implementar el patron @l(#Chain of Responsibility).

     El lugar habitual donde definir la referencia al padre es en la clase
     @c(Componente). Las clases @c(Hoja) y @c(Compuesto) puede heredar la
     referencia y las operaciones que la gestionan.

     Con referencias al padre, es esencial mantener el invariante de que todos
     los hijos de un compuesto tienene como padre al compuesto que a su vez los
     tiene a ellos como hijos. El modo mas facil de garantizar esto es cambiar
     el padre de un componente @e(solo) cuando se añade o se elimina a este de
     un compuesto. Si se puede implementar una vez en las operaciones @c(Añadir)
     y @c(Elimina) de la clase @c(Compuesto) entonces puede ser heredado por
     todas las subclases, conservando autamaticamente el invariante.

  2. @e(Compartir componentes.) Muchas veces es util compartir componentes, por
     ejemplo para reducir los requisitos de almacenamiento. Pero cuando un
     componente no puede tener mas de un padre, compartir componentes se hace
     mas dificil.

     Una posible solucion es que los hijos almacenen multiples padres. Pero eso
     puede llevarnos a ambiguedades cuando se propoga una peticion hacia arriba
     en la estructura. El patron @l(#Flyweight) muestra como adaptar un diseño
     para evitar guardar los padres. Funciona en casos en los que los hijos
     pueden evitar enviar peticiones al padre externalizando parte de su estado,
     o todo.

  3. @e(Maximizar la interfaz @c(Componente).) Uno de los objetivos del patron
     Composite es hacer que los clientes se despreocupen de las clases @c(Hoja)
     o @c(Compuesto) que estan usando. Para conseguirlo, la clase @c(Componente)
     deberia definir tantas operaciones comunes a las clases @c(Compuesto) y
     @c(Hoja) como sea posible. La clase @c(Componente) normalmente proporciona
     implementaciones predeterminadas para estas operaciones, que sean
     redefinidas por las subclases @c(Hoja) y @c(Compuesto).

     No obstante, este objetivo a veces entra en conflicto con el principio de
     diseño de jerarquias de clases que dice que una clase solo deberia definir
     operaciones que tienen sentido en sus subclases. Hay muchas operaciones
     permitidas por @c(Componente) que no parecen tener sentido en las clases
     @c(Hoja). ¿Como puede @c(Componente) proporcionar una implementacion
     predeterminada para ellas?

     A veces un poco de creatividad muestra como una operacion que podria
     parecer que solo tiene sentido en el caso de los @c(Compuestos) puede
     implementarse para todos los @c(Componentes), moviendola a la clase
     @c(Componente). Por ejemplo, la interfaz para acceder a los hijos es una
     parte fundamental de la clase @c(Compuesto), pero no de las clases
     @c(Hoja). Pero si vemos a una @c(Hoja) como un @c(Componente) que @e(nunca)
     tiene hijos, podemos definir una operacion predeterminada en la clase
     @c(Componente) para acceder a los hijos que nunca @e(devuelve) ningun
     hijo. Las clases @c(Hoja) pueden usar esa implementacion predeterminada,
     pero las clases @c(Compuesto) la reimplementaran para que devuelva sus
     hijos.

     Las operaciones de gestion de los hijos son mas problematicas, y se tratan
     en el siguiente punto.

  4. @e(Declarar las operaciones de gestion de los hijos.) Aunque la clase
     @c(Compuesto) @e(implementa) las operaciones @c(Añadir) y @e(Eliminar) para
     controlar los hijos, un aspecto importante del patron @c(Compuesto) es que
     clases declaran estas operaciones en la jerarquia de clases @c(Compuesto).
     ¿Deberiamos declarar estas operaciones en el @c(Componente) y hacer que
     tuvieran sentido en las clases @c(Hoja), o deberiamos declararlas y
     definirlas solo en @c(Compuesto) y sus subclases?

     La decision implica un equilibrio entre seguridad y transparencia:

     - Definir la interfaz de gestion de los hijos en la raiz de la jerarquia de
       clases nos da trasparencia, puesto que podemos tratar a todos los
       componentes de manera uniforme. Sin embargo, sacrifica la seguridad, ya
       que los clientes pueden intentar hacer cosas sin sentido, como añadir y
       eliminar objetos de las hojas.

     - Definir la gestion de los hijos en la clase @c(Compuesto) nos proporciona
       seguridad, ya que cualquier intento de añadir o eliminar objetos de
       las hojas sera detectado en tiempo de compilacion en un lenguaje
       estaticamente tipado, como C++. Pero perderemos transparencia, porque las
       hojas y los compuestos tienen interfaces diferentes.

     En este patron hemos dado mas importancia a la transparencia que a la
     seguridad. Si se opta por la seguridad, habra ocaciones en las que
     perderemos informacion sobre el tipo y tendremos que convertir un
     componente en un compuesto. ¿Como podemos hacerlo sin recurrir a una
     conversion que no sea segura con respecto al tipo?

     Una posibilidad es declarar una operacion @c[Compuesto* ObtenerCompuesto()]
     en la clase @c(Componente). El @c(Componente) proporciona una operacion por
     omision que devuelve un puntero nulo. La clase @c(Compuesto) redefine esta
     operacion para devolverse a si misma a traves de su puntero @c(this):

     ..src > c++
       class Compuesto;

       class Componente {
       public:
           // ...
           virtual Compuesto* ObtenerCompuesto() { return 0; }
       };

       class Compuesto : public Componente {
       public:
           void Anadir(Componente*);
           // ...
           virtual Compuesto* ObtenerCompuesto() { return this; }
       };

       class Hoja : public Componente {
           // ...
       };
     < src..

     @c(ObtenerCompuesto) nos permite consultar a un componente para ver si es
     un compuesto. Podemos ejecutar @c(Anadir) y @c(Eliminar) con seguridad
     sobre el compuesto que devuelve.

     ..src > c++
       Compuesto* unCompuesto = new Compuesto;
       Hoja* unaHoja = new Hoja;

       Componente* unComponente;
       Compuesto*  prueba;

       unComponente = unCompuesto;
       if (prueba = unComponente->ObtenerCompuesto()) {
           prueba->Anadir(new Hoja);
       }

       unComponente = unaHoja;

       if (prueba = unComponente->ObtenerCompuesto()) {
           pruba->Anadir(new Hoja); // no añadira a una hoja
       }
     < src..

     Se pueden hacer comprobaciones similares para un @c(Compuesto) usando la
     costruccion de C++ @c(dynamic_cast).

     Por supuesto, el problema aqui es que no tratamos a todos los componentes
     de manera uniforme. Tenemos que volver a realizar comprobaciones para
     diferentes tipos antes de empreder la accion apropiada.

     La unica forma de proporcionar transparencia es definir operaciones
     predeterminadas @c(Anadir) y @c(Eliminar) en @c(Componente). Eso creara un
     nuevo problema: no hay modo de implementar @c(Componente::Anadir) sin
     introducir asi mismo la posibilidad de que falle. Podriamos no hacer nada,
     pero eso omite una consideracion importante, es decir, un intento de añadir
     algo a una hoja probablemente este indicando un error. En ese caso, la
     operacion @c(Anadir) produce basura. Podriamos hacer que borrara su
     argumento, pero eso no es lo que los clientes esperan.

     Normalmente es mejor hacer que @c(Anadir) y @c(Eliminar) fallen de manera
     predeterminada (tal vez lanzando una excepcion) si el componente no puede
     tener hijos o si el argumento de @c(Eliminar) no es un hijo del componente.

     Otra posibilidad es cambiar ligeramente el significado de @"(eliminar). Si
     el componente mantiene una referencia al padre podriamos redefinir
     @c(Componente::Eliminar) para eliminarse asi mismo de su padre. No
     obstante, sigue sin haber una interpretacion con sentido para @c(Anadir).

  5. @e(¿Deberia implementar el @c(Componente) una lista de @c(Componentes)?)
     Podriamos estar tentados de definir el conjunto de hijos como una variable
     de instancia de la clase @c(Componente) en la que se declaren las
     operaciones de acceso y gestion de los hijos. Pero poner el puntero al hijo
     en la clase base incurre en una penalizacion de espacio para cada hoja,
     incluso aunque una hoja nunca tenga hijos. Esto solo merece la pena si hay
     relativamente pocos hijos en la estructura.

  6. @e(Ordenacion de los hijos.) Muchos diseños especifican una ordenacion de
     los hijos de @c(Compuesto). En el ejemplo del @c(Grafico), la ordenacion
     puede reflejar el orden desde el frente hasta el fondo. Si los objetos
     @c(Compuesto) representan arboles de analisis, entonces las instrucciones
     compuestas pueden ser instancias de un @c(Compuesto) cuyos hijos deben
     estar ordenados de manera que reflejen el programa.

     Cuando la ordenacion de los hijos es una cuestion a tener en cuenta,
     debemos diseñar las interfaces de acceso y gestion de hijos cuidadosamente
     para controlar la secuencia de hijos. El patron @l(#Iterator<>Iterador)
     puede servirnos de guia.

  7. @e(Cache para mejorar el rendimiento.) Si necesitamos recorrer
     composiciones o buscar en ellas con frecuencia, la clase @c(Compuesto)
     puede almacenar informacion sobre sus hijos que facilite el recorrido o la
     busqueda. El @c(Compuesto) puede guardar resultados o simplemente
     informacion que le permita evitar parte del recorrido o de la busqueda. Por
     ejemplo, la clase @c(Dibujo) del ejemplo de la seccion de @c(Motivacion)
     podria guardar la caja limitrofe de su hijos. Mientras se dibuja o es
     seleccionado, esta caja previamente guardada permite que @c(Dibujo) no
     tenga que dibujar o realizar busquedas cuando sus hijos no son visibles en
     la ventana actual.

     Los cambios en un componente requeriran invalidar la cache de sus
     padres. Esto funciona mejor cuando los componentes conocen a sus
     padres. Por tanto, si se va a usar almacenamiento cache se necesita definir
     una interfaz para decirle a los compuestos que su cache ya no es valida.

  8. @e(¿Quien deberia borrar los componentes?) En lenguajes sin recolector de
     basura, normalmente es mejor hacer que un @c(Compuesto) sea el responsable
     de borra sus hijos cuando es destruido. Una excepcion a esta regla es cuando
     los objetos @c(Hoja) son inmutables y pueden por tanto ser compartidos.

  9. @e(¿Cual es la mejor estructura de datos para almacenar los componentes?)
     Los objetos @c(Compuesto) pueden usar muchas estructuras de datos
     diferentes para almacenar sus hijos, incluyendo listas enlazadas, arboles,
     arrays y tablas de dispersion. La eleccion de la estructura de datos
     depende (como siempre) de la eficiencia. De hecho, ni siquiera es necesario
     usar una estructura de datos de proposito general. A veces los
     compuestos tienen una variable para cada hijo, aunque esto requiere que cada
     subclase de @c(Compuesto) implemente su propia interfaz de gestion. Vease
     el patron @l(#Interpreter) para un ejemplo.

*** Composite Codigo de Ejemplo <> Codigo de Ejemplo

  Determinados equipos, como computadores y componentes estereo, suelen estar
  organizados en jerarquias de parte-todo o de pertenencia. Por ejemplo, un
  chasis puede contener unidades y placas base, un bus puede contener tarjetas y
  un armario puede contener chasis, buses, etcetera. Dichas estructuras pueden
  modelarse de manera natural con el patron Composite.

  La clase @c(Equipo) define una interfaz para todos los equipos de la jerarquia
  de pante-todo.

  ..src > c++
    class Equipo {
    public:
        virtual ~Equipo();

        const char* Nombre() { return _nombre; }

        virtual Vatio Potencia();
        virtual Moneda PrecioNeto();
        virtual Moneda PrecioConDescuento();

        virtual void Anadir(Equipo*);
        virtual void Eliminar(Equipo*);
        virtual Iterador<Equipo*>* CrearIterador();
    protected:
        Equipo(const char*);
    private:
        const char* _nombre;
    };
  < src..

  @c(Equipo) declara operaciones que devuelven los atributos de un equipo, como
  su consumo y coste. Las subclases implementan estas operaciones para
  determinados tipos de equipos. @c(Equipo) tambien declara una operacion
  @c(CrearIterador) que devuelve un @c(Iterador) (vease el @l(#Apendice C)) para
  acceder a sus partes. La implementacion predeterminada de estas operaciones
  devuelve un @c(IteradorNulo), que itera sobre el conjunto vacio.

  Las subclases de @c(Equipo) podrian incluir clases @c(Hoja) que representen
  unidades de disco, circuitos intergrados e interruptores:

  ..src > c++
    class Disquetera : public Equipo {
    public:
        Disquetera(const char*);
        virtual ~Disquetera();

        virtual Vatio Potencia();
        virtual Moneda PrecioNeto();
        virtual Moneda PrecioConDescuento();
    };
  < src..

  @c(EquipoCompuesto) es la clase base de los equipos que contienen otros
  equipos. Es tambien una subclase de @c(Equipo).

  ..src > c++
    class EquipoCompuesto : public Equipo {
    public:
        virtual ~EquipoCompuesto();

        virtual Vatio Potencia();
        virtual Moneda ProcioNeto();
        virtual Moneda PrecioConDescuente();

        virtual void Anadir(Equipo*);
        virtual void Eliminar(Equipo*);
        virtual Iterador<Equipo*>* CrearIterador();

    protected:
        EquipoCompuesto(const char*);
    private:
        Lista<Equipo*> _equipo;
    };
  < src..

  @c(EquipoCompuesto) define las operaciones para acceder a sus componentes y
  recorrerlos. Las operaciones @c(Anadir) y @c(Eliminar) insertan y borran
  equipos en la lista de equipos almacenados en el miembro @c(_equipo). La
  operacion @c(CrearIterador) devuelve un iterador (concretamente, una instancia
  de @c(IteradorLista) para recorrer la lista.

  Una implementacion predeterminada de @c(PrecioNeto) podria usar
  @c(CrearIterador) para sumar los precios netos de los equipos que lo
  componen:@n(34)

  ..src > c++
    Moneda EquipoCompuesto::PrecioNeto () {
        Iterador<Equipo*>* i = CrearIterador();
        Moneda total = 0;

        for (i->Primero(); !i->Haterminado(); i->Siguiente()) {
            total += i->ElementoActual()->PrecioNeto();
        }
        delete i;
        return total;
    }
  < src..

  Ahora podemos representar un chasis de computadora como una subclase de
  @c(EquipoCompuesto) llamada @c(Chasis). @c(Chasis) hereda las operaciones
  relativas a los hijos de @c(EquipoCompuesto).

  ..src > c++
    class Chasis : public EquipoCompuesto {
    public:
        Chasis(const char*);
        virtual ~Chasis();

        virtual Vatio Potencia();
        virtual Moneda PrecioNeto();
        virtual Moneda PrecioConDescuento();
    };
  < src..

  Podemos definir otros contenedores de equipos tales como @c(Armario) y @c(Bus)
  de forma similar. Eso nos da todo lo necesario para ensamblar componentes en
  una computadora personal (bastante sencillo):

  ..src > c++
    Armario* armario = new Armario("Armario de PC");
    Chasis* chasis = new Chasis("Chasis de PC");

    armario->Anadir(chasis);

    Bus* bus = new Bus("Bus MCA");
    bus->Anadir(new Tarjeta("Token Ring de 16 Mbs "));

    chasis->Anadir(bus);
    chasis->Anadir(new Disquetera("Disquetera de 3,5 pulgadas"));

    count << "El precio neto es " << chasis->PrecioNeto() << endl;
  < src..

*** Composite Usos Conocidos <> Usos Conocidos

  Se pueden encontrar ejemplos del patron Composite en casi todos los sistemas
  orientados a objetos. La clase @c(Vista) del Modelo/Vista/Controlador de
  Smalltalk [@l(#KP88)] era un Compuseto, y practiamente todos los toolkits o
  frameworks de interfaces de usuario han seguido sus pasos, incluyendo ET++
  (con VObjects [@l(#WGM88)]) e InterViews (Styles [@l(#LCI+92)], Graphics
  [@l(#VL88)] y Glyphs [@l(#CL90)]). Merece la pena destacar que la Vista
  original del Modelo/Vista/Controlador tenia un conjunto de subvistas; en otras
  palabras, la clase @c(View) era tanto la clase Componente como la
  Compuesto. La version 4.0 de Smalltalk-80 reviso el Modela/Vista/Controlador
  con una clase @c(VisualComponent) que tenia como subclases @c(View) y
  @c(CompositeView).

  El framework para compiladores de Smalltalk RTL [@l(#JML92)] hace un uso intensivo
  del patron Composite. @c(RTLExpression) es una clase Componente para
  arboles de analisis. Tiene subclases, tales como @c(BinaryExpression), que
  contienen objetos @c(RTLExpression) como hijos. Dichas clases definen una
  estructura compuesta para arboles de analisis. @c(RegistrerTransfer) es la
  clase Componente para un programa en la forma intermedia de Single Static
  Assignment (SSA). Las subclases @c(Hoja) de @c(RegisterTransfer) definen
  diferentes asignaciones estaticas, como

  - asignaciones primitivas que realizan una operacion en dos registros y
    asignan el resultado a un tercero;

  - una asignacion con un registro fuente pero sin registro destino, que indica
    que el registro se usa despues del retorno de una rutina; y

  - una asignacion con un registro destino pero sin origen, lo que indica que al
    registro se le asigna un valor antes de que empiece la rutina.

  Otra subclase, @c(RegisterTransferSet), es una clase Compuesto que representa
  asignaciones que modifican varios registros a la vez.

  Otro ejemplo de este patron tiene lugar en el dominio de las finanzas, donde
  una cartera de acciones agrupa valores individuales. Se pueden permitir
  agregaciones complejas de valores implementando una cartera como un Compuesto
  que se ajusta a la interfaz de un valor individual [@l(#BE93)].

  El patron @l(#Command) describe como se pueden componer y secuenciar objetos
  @c(Orden) con una clase Compuesto @c(OrdenMacro).

*** Composite Patrones Relacionados <> Patrones Relacionados

  Muchas veces se usa el enlace al componente pardre para implementar el patron
  @l(#Chain of Responsibility)

  El patron @l(#Decorator) suele usarse junto con el Composite. Cuando se usan
  juntos decoradores y compuestos, normalmente ambos tendran una clase padre
  comun. Por tanto, los decoradores tendran que admitir la intrefaz
  @c(Componente) con operaciones como @c(Anadir), @c(Eliminar) y
  @c(ObtenerHijo).

  El patron @l(#Flyweight) permite compartir componentes, si bien en ese caso
  estos ya no pueden referirse a sus padres.

  Se suele usar el patron @l(#Iterator) para recorrer las estructuras definidas
  por el patron Composite.

  El patron @l(#Visitor) localiza operaciones y comportamientos que de otro modo
  estaria distribuida en varias clases @c(Compuesto) y @c(Hoja).

** Decorator
*** Decorator Proposito <> Proposito

  Asigna responsabilidades adicionales a un objeto dinamicamente, proporcionando
  una alternativa flexible a la herencia para extender la funcionalidad.

*** Decorator Tambien Conocido Como <> Tambien Conocido Como

  Wrapper (Envoltorio)

*** Decorator Motivacion <> Motivacion

  A veces queremos añadir responsabilidades a objetos individuales en vez de a
  toda una clase. Por ejemplo, un toolkit de interfaces de usuario deberia
  permitir añadir propiedades (como bordes) o comportamientos (como capacidad de
  desplazamiento) a cualquier componente de la interfaz de usuario.

  Un modo de añadir responsabilidades es a traves de la herencia. Heredar un
  borde de otra clase pondria un borde alrededor de todas las instancias de la
  subclase. Sin embargo, esto es inflexible, ya que la eleccion del borde se
  hace estaticamente. Un cliente no puede controlar como y cuando decorar el
  componente con un borde.

  Un enfoque mas flexible es encerrar el componente en otro objeto que añada el
  borde. Al objeto confinante se le donomina @b(decorador). El decorador se
  ajusta a la interfaz del componente que decora de manera que su presencia es
  transparente a sus clientes. El decorador reenvia las peticiones al componente
  y puede realizar acciones adicionales (tales como dibujar un borde) antes o
  despues del reevio. Dicha transparencia permite anidar decoradores
  recursivamente, permitiendo asi un numero ilimitado de responsabilidades
  añadidas.

  ..img > img/058.png

  Por ejemplo, supongamos un objeto @c(VistaTexto) que muestra texto en una
  ventana. @c(VistaTexto) no tiene barras de desplazamiento de manera
  predeterminada, ya que puede que no sean siempre necesarias. Cuando las
  necesitemos, podemos usar un @c(DecoradorDesplazamiento) para añadirlas.
  Supongamos que queremos añadir un borde negro, grueso, alrededor de
  @c(VistaTexto). Podremo usar un @c(DecoradorBorde) para añadir tambien un
  borde. Basta con componer los decoradores con @c(VistaTexto) para producir el
  resultado deseado.

  El siguiente diagrama de objetos muestra como componer una objeto
  @c(VistaTexto) con objetos @c(DecoradorBorde) y @c(DecoradorDeplazamiento) para
  producir una vista de texto con borde y desplazamiento:

  ..img > img/059.png

  Las clases @c(DecoradorDesplazamiento) y @c(DecoradorBorde) son subclases de
  @c(Decorador), una clase abstracta para componentes visuales que decoran otros
  componentes visuales.

  ..img > img/060.png

  @c(ComponenteVisual) es la clase abstracta de los objetos visuales. Define su
  interfaz para dibujarse y para el manejo de eventos. Notese como la clase
  @c(Decorador) simplemente redirige las peticiones para que se dibuje su
  componente, y como las subclases de @c(Decorador) pueden extender dicha
  operacion.

  Las subclases de @c(Decorador) son libres de añadir operaciones para
  determinadas funcionalidades. Por ejemplo, la operacion @@c(DesplazarA) de
  @c(DecoradorDesplazamiento) permite que otros objetos deplacen la interfaz
  @e(si) saben que la interfaz incluye un objeto @c(DecoradorDesplazamiento).
  Lo imporante de este patron es que permite que los decoradores aparezcan en
  cualquier lugar en el que pueda ir un @c(ComponenteVisual). De esa forma los
  clientes generalmente no pueden distinguir entre un componente decorado y otro
  que no lo esta, por lo que no dependen en absoluto de la decoracion.

*** Decorator Aplicabilidad <> Aplicabilidad

  Use el Decorador

  - para añadir objetos individuales de forma dinamica y transparente, es decir,
    sin afectar a otros objetos.

  - para responsabilidades que pueden ser retiradas.

  - cuando la extension mediante la herencia no es viable. A veces es posible
    tener un gran numero de extensiones independientes, produciendose una
    explosion de subclases para permitir todas las combinacinoes. O puede ser
    que una definicion de una clase este oculta o que no este disponible para
    ser heredada.

*** Decorator Estructura <> Estructura

  ..img > img/061.png

*** Decorator Participantes <> Participantes

  - @c(Componente) (@c(ComponenteVisual))

    - define la interfaz para objetos a los que se puede añadir
      responsabilidades dinamicamente.

  - @c(ComponenteConcreto) (@c(VistaTexto))

    - define un objeto al que se pueden añadir responsabilidades adicionales.

  - @c(Decorador)

    - mantiene una referencia a un objeto @c(Componente) y define una interfaz
      que se ajusta a la interfaz del @c(Componente).

  - @c(DecoradorConcreto) (@c(DecoradorBorde), @c(DecoradorDesplazamiento))

    - añade responsabilidades al componente.

*** Decorator Colaboraciones <> Colaboraciones

  El Decorador redirige peticiones a su objeto @c(Componente). Opcionalmente
  puede realizar operaciones adicionales antes y despues de reenviar la peticion.

*** Decorator Consecuencias <> Consecuencias

  El patron Decorador tiene al menos dos ventajas y dos inconvenientes
  fundamentales:

  1. @e(Mas flexibilidad que la herencia estatica.) El patron Decorador
     proporciona una manera mas flexible de añadir responsabilidades a los
     objetos que la que podia obtenerse a traves de la herencia (multiple)
     estatica. Con los decoradores se pueden añadir y elminar responsabilidades
     en tiempo de ejecucion simplemente poniendolas y quitandolas. Por el
     contrario, la herencia requiere crear una nueva clase para cada
     responsabilidad adicional (como @c(VistaTextoDesplazableConBorde) o
     @c(VistaTextoConBorde)). Esto da lugar a muchas clases diferentes e
     incrementa la complejidad de un sistema. Por otro lado, proporcionar
     diferentes clases Decorador para una detereminada clase @c(Componente)
     permite mezclar responsabilidades.

     Los decoradores tambien facilitan añadir una propiedad dos veces. Por
     ejemplo, para dar un borde doble a @c(VistaTexto), basta con añadir dos
     objetos @c(DecoradorBorde). Heredar dos veces de una clase @c(Borde)
     resulta, cuado menos, propenso a errores.

  2. @e(Evita clases cargadas de funciones en la parte de arriba de la
     jerarquia.) El Decorador ofrece un enfoque para añadir responsabilidades
     que consiste en pagar solo por aquello que se necesita. En vez de tratar de
     permitir todas las funcionalidades inimaginables en una clase compleja y
     adaptable, podemos definir primero una clase simple y añadir luego
     funcionalidad incrementalmente con objetos Decorador. La funcionalidad puede
     obtenerse componiendo partes simples. Como resultado, una aplicacion no
     necesita pagar por caracteristicas que no usa. Tambien resulta facil
     definir nuevos tipos de Decoradores independientemente de las clases de
     objetos de las que hereden, incluso para extensiones que no hubieran sido
     previstas. Extender una clase compleja tiende a exponer detalles no
     relacionados con las responsabilidades que estamos añadiendo.

  3. @e(Un decorador y su componente no son identicos.) Un decorador se comporta
     como un revestimiento transparente. Pero desde el punto de vista de la
     identidad de un objeto, un componente decorado no es identico al componente
     en si. Por tanto, no deberiamos apoyarnos en la identidad de objetos cuando
     estamos usando decoradores.

  4. @e(Muchos objetos pequeños.) Un diseño que usa el patron Decorador suele
     dar como resultado sistemas formados por muchos objetos pequeños muy
     parecidos. Los objetos solo se diferencian en la forma en que estan
     interconectados, y no en su clase o en el valor de sus variables. Aunque
     dichos sistemas son faciles de adaptar por parte de quienes los comprenden
     bien, pueden ser dificiles de aprender y depurar.

*** Decorator Implementacion <> Implementacion

  Hay que tener en cuenta varias cuestiones al aplicar el patron Decorador:

  1. @e(Concordancia de interfaces.) La interfaz de un objeto decorador debe
     ajustarse a la interfaz del componente que decora. Las clases
     @e(DecoradorConcreto) deben  por tanto heredar de una clase comun (al menos
     en C++).

  2. @e(Omision de la clase abstracta Decorador.) No hay necesidad de definir
     una clase abstracta Decorador cuando solo necesitamos añadir una
     responsabilidad. Eso es lo que suele ocurrir cuando estamos tratando con
     una jerarquia de clases existente y no diseñando una nueva. En ese caso,
     podemos obtener la responsabilidad del Decorador reenviando peticiones al
     componente en el @c(DecoradorConcreto).

  3. @e(Mantener ligeras las clases @c(Componente).) Para garantizar una
     interfaz compatible, los componentes y los decoradores deben descender de
     una clase @c(Componente) comun. Es importante que esta clase comun se mantenga
     ligera; es decir, deberia centrarse en definir una interfaz, no en guardar
     datos. La definicion de como se representan los datos deberia delegarse en
     las subclases; de no ser asi, la complejidad de la clase @c(componente)
     puede hacer que los decoradores sean demasiado pesados como para usar un
     gran gnumero de ellos. Poner mucha funcionalidad en el @c(Componente)
     tambien incrementa la probabilidad de que las subclases concretas esten
     pagando por caracteristicas que no necesitan.

  4. @e(Cambiar la piel de un objeto en vez de sus tripas.) Podemos pensar en un
     decorador como un revestimiento de un objeto que cambia su comportamiento.
     Una alternativa es cambiar las interioridades del objeto. El patron
     @l(#Strategy) es un buen ejemplo de patron para cambiar las tripas. Las
     estrategias son una mejor eleccion en aquellas situaciones en las que la
     clase @c(Componente) es intrinsecamente pesada, lo que hace que el patron
     Decorator sea demasiado costoso de aplicar. En el patron Strategy, el
     componente delega parte de su responsabilidad en un objeto estrategia
     aparte. El patron Strategy nos permite alterar o extender la funcionalidad
     del componente cambiando el objeto estrategia.

     Por ejemplo, podemos permitir diferentes estilos de bordes haciendo que el
     componente delegue el dibujado del borde en un objeto @c(Borde) aparte. El
     objeto @c(Borde) es un objeto @c(Estrategia) que encapsula un algoritmo
     para dibujar bordes. Al ampliar el numero de estrategias de una a una lista
     ilimitada conseguimos el mismo efecto que anidando recursivamente
     decoradores.

     Por ejemplo, en MacApp 3.0 [@l(#App89)] y Bedrock [@l(#Sym93a)] los componentes
     graficos (denominados @"(vistas)) mantienen una lista de objetos @"(adorno)
     que pueden añadir adornos adicionales, como bordes a un componente vista.
     Si una vista tiene algunos adornos, les da una posibilidad de dibujar
     adornos adicionales. MacApp y Bedrock deben usar este enfoque debido a que
     la clase @c(View) es pesada, por lo que seria demasiado costoso usarla solo
     para añadir un borde.

     Puesto que el patron Decorator solo cambia la parte exterior de un objeto,
     el componente no tiene que saber nada de sus decoradores; es decir, los
     decoradores son transparentes para el componente:

     ..img > img/062.png

     Con estrategias, el componente conoce sus posibles extensiones. Por tanto
     tiene que referenciar y mantener las estrategias correspondientes:

     ..img > img/063.png

     El enfoque basado en estrategias puede requerir modificar el componetne
     para permitir nuevas extensiones. Por otro lado, una estrategia puede tener
     su propia interfaz especializada, mientras que la interfaz de un decorador
     debe ajustarse a la del componente. Una estrategia para dibujar un borde,
     por ejemplo, solo necesita definir la interfaz para dibujar el borde
     (@c(DibujarBorde), @c(ObtenerAncho), etc.), lo que significa que la
     estrategia puede ser ligera incluso aunque la clase componente sea pesada.

     MacApp y Bedrock usan este enfoque para algo mas que simplemente adornar
     vistas. Tambien la usan para aumentar el comportamiento de manejo de eventos
     de los objetos. En ambos sistemas, una vista mantiene una lista de objetos
     de @"(comportamiento) que pueden modificar e interceptar eventos. La vista
     da la posibilidad de manejar el evento a cada uno de los objetos de
     comportamiento registrados antes que a los no registrados. Podemos decorar
     una vista para que admita el manejo de eventos, por ejemplo, registrando un
     objeto comportamiento que intercepte y maneje los eventos de teclado.

*** Decorator Codigo de Ejemplo <> Codigo de Ejemplo

  El codigo siguiente muestra como implementar decoradores de interfaz de
  usuario en C++. Supondremos que hay una clase @c(Componente) llamada
  @c(ComponenteVisual).

  ..src > c++
    class ComponenteVisual {
    public:
        ComponenteVisual();

        virtual void Dibujar();
        virtual void CambiarTamano();
        // ...
    };
  < src..

  definiremos una subclase de @c(ComponenteVisual) llamada @c(Decorador), de la
  cual heredaremos para obtener diferentes decoraciones.

  ..src > c++
    class Decorador : public ComponenteVisual {
    public:
        Decorator(ComponenteVisual*);

        virtual void Dibujar();
        virtual void CambiarTamano();
        // ...
    private:
        ComponenteVisual* _componente;
    };
  < src..

  @c(Decorador) decora el @c(ComponenteVisual) referenciado por la variable de
  instancia @c(_componente), la cual es inicializada en el constructor. Para cada
  operacion de la interfaz @c(ComponenteVisual), @c(Decorador) define una
  implementacion predeterminada que pasa la peticion a @c(_componente):

  ..src > c++
    void Decorador::Dibujar () {
        _componente->Dibujar();
    }

    void Decorador::CambiarTamano () {
        _componente->CambiarTamano();
    }
  < src..

  Las subclases de @c(Decorador) definen decoraciones concretas. Por ejemplo, la
  clase @c(DecoradorBorde) añade un borde a su componente. @c(DecoradorBorde) es
  una subclase de @c(Decorador) que redefine la operacion @c(Dibujar) para
  dibujar el borde. @c(DecoradorBorde) tambien define una operacion privada
  auxiliar @c(DibujarBorde) que se encarga de dibujarlo. La subclase hereda de
  @c(Decorador) la implementacion de todas las otras operaciones.

  ..src > c++
    class DecoradorBorde : public Decorator {
    public:
        DecoradorBorde(ComponenteVisual*, int anchoBorde);

        virtual void Dibujar();
    private:
        void DibujarBorde(int);
    private:
        int _ancho;
    };

    void DecoradorBorde::Dibujar () {
        Decorator::Dibujar();
        DibujarBorde(_ancho);
    }
  < src..

  Aqui vendria una implementacion parecida para @c(DecoradorDesplazamiento) y
  @c(DecoradorSombra), que añadirian capacidades de desplazamiento y sombra a un
  componente visual.

  Ahora podemos combinar instancias de estas clases para proporcionar diferentes
  decoraciones. El codigo siguiente ilustra como podemos usar decoradores para
  crear una @c(VistaTexto) desplazable y con borde.

  En primer lugar, necesitamos un modo de poner un objeto visual en un objeto
  ventana. Supondremos que nuestra clase ventana proporciona una operacion
  @c(EstablecerContenido) para este proposito:

  ..src > c++
    void Ventana::EstablecerContenido (ComponenteVisual* contenido) {
        // ...
    }
  < src..

  Ahora podemos crear la vista de texto y una ventana donde ponerla:

  ..src > c++
    Ventana* ventana = new Ventana;
    VistaTexto* vistaTexto = new VistaTexto;
  < src..

  @c(VistaTexto) es un @c(ComponenteVisual), lo que nos permite ponerla en la
  ventana:

  ..src > c++
    ventana->EstablecerContenido(vistaTexto);
  < src..

  Pero queremos una @c(VistaTexto) con borde y que se pueda desplazar, por lo
  que hemos de decorarla de manera apropiada antes de ponerla en la ventana.

  ..src > c++
    ventana->EstablecerContenido(
        new DecoradorBorde(
            new DecoradorDesplazamiento(vistaTexto), 1
        )
    );
  < src..

  Dado que @c(Ventana) accede a su contenido a traves de la interfaz
  @c(ComponenteVisual), no se percata de la presencia del decorador. Nosotros
  como clientes, todavia podemos utilizar la vista de texto si tenemos que
  interactuar con ella directamente, por ejemplo cuando necesitamos invocar
  operaciones que no son parte de la interfaz de @c(ComponenteVisual). Los
  clientes que se basan en la identinad del componente tambien deberian referirse
  a ella directamente.

*** Decorator Usos Conocidos <> Usos Conocidos

  Muchos toolkits de interfaces de usuario orientados a objetos usan decoradores
  para añadir adornos graficos a los utiles.@n(28) Algunos ejemplos son
  InterViews [@l(#LVC98), @l(#LCI+92)], ET++ [@l(#WGM88)] y la biblioteca de clases
  ObjectWorks\Smalltalk [@l(#Par90)]. Aplicaciones mas exoticas del patron Decorator
  son el DebuggingGlyph de InterViews y el PassivityWrapper de ParcPlace
  Smalltalk. Un DebuggingGlyph muestra informacion de depuracion antes y despues
  de reenviar una peticion a su componente para que se ubique en pantalla. Esta
  informacion de traza puede usarse para analizar y depurar el comportamiento de
  como se diponen los objetos en una composicion compleja. El PassivityWrapper
  puede activar o desctivar las interacciones del usuario con el componente.

  Pero el patron Decorator no se limita en absoluto a las interfaces graficas de
  usuario, como demuestra el siguiente ejemplo (basado en las clases de flujos
  de ET++ [@l(#WGM88)]).

  Los flujos son una abstraccion fundamental en la mayoria de mecanismos de
  E/S. Un flujo puede proporcionar una interfaz para convertir objetos en una
  secuencia de bytes o caracteres. Eso nos permite transcribir un objeto a un
  fichero o a una cadena en memoria para recuperarlo posteriormente. Un modo
  sencillo de llevar esto a cabo es definiendo una clase abstracta @c(Flujo) con
  subclases como @c(FlujoMemoria) y @c(FlujoFichero). Pero supongamos que
  tambien queremos poder hacer lo siguiente:

  - Comprimir el flujo de datos usando diferentes algoritmos de compresion
    (run-length encoding, Lempel-Ziv, etc.).

  - Reducir el flujo de datos a caracteres ASCII de 7 bits, de manera que puedan
    transmitirse sobre un canal de comunicacion ASCII.

  El patron decorador nos ofrece un modo elegante de añadir estas
  responsabilidades a los flujos. El siguiente diagrama muestra una solucion al
  problema:

  ..img > img/064.png

  La clase abstracta @c(Flujo) mantiene un bufer interno y proporciona
  operaciones para almacenar datos en el flujo (@c(MeterEntero),
  @c(MeterCadena)). Cuando se llene el bufer, @c(Flujo) llamara a la operacion
  @c(ManejarBuferLleno), que lleva a cabo la transferencia real de datos. La
  version @c(FlujoFichero) de esta operacion la redefine para transferir el
  bufer a un fichero.

  La clase fundamental aqui es @c(DecoradorFlujo), que mantiene una referencia a
  un componente flujo y le reenvia peticiones. Las subclases de
  @c(DecoradorFlujo) redefinen @c(ManejarBuferLleno) y llevan a cabo acciones
  adicionales llamando a la operacion @c(ManejarBuferLleno) de
  @c(DecoradorFlujo).

  Por ejemplo, la subclase @c(FlujoDeCompresion) comprime los datos, y
  @c(FlujoASCII7) convierte los datos en ASCII de 7 bits. Ahora, para crear un
  @c(FlujoFichero) que comprima sus datos y convierta los datos binarios
  comprimidos en ASCII de 7 bits, decoramos un @c(FlujoFichero) con un
  @c(FlujoDeCompresion) y un @c(FlujoASCII7):

  ..src > c++
    Flujo* unFlujo = new FlujoCompresion(
        new FlujoASCII7(
            newFlujoFichero("unNombreDeFichero")
        )
    };
    unFlujo->MeterEntero(12);
    unFlujo->MeterCadena("unaCadena");
  < src..

*** Decorator Patrones Relacionados <> Patrones Relacionados

  @l(#Adapter): un decorador se diferencia de un adaptador en que el decorador
  solo cambia las responsabilidades de un objeto, no su interfaz, mientras que
  un adaptador le da a un objeto una interfaz completamente nueva.

  @l(#Composite): podemos ver a un decorador como un compuesto degenerado que
  solo tiene un componente. No obstante, un decorador añade responsabilidades
  adicionales @-(no esta pensado para la agregacion de objetos).

  @l(#Strategy): un decorador permite cambiar el exterior de un objeto; una
  estrategia permite cambiar sus tripas. Son dos formas alternativas de
  modificar un objeto.

** Facade
*** Facade Proposito <> Proposito

  Proporciona una interfaz unificada para un conjunto de interfaces de un
  subsistema. Define una interfaz de alto nivel que hace que el subsistema sea
  mas facil de usar.

*** Facade Motivacion <> Motivacion

  Estructurar un sistema en subsistemas ayuda a reducir la complejidad. Un
  tipico objetivo de diseño es minimizar la comunicacion y dependencias entre
  subsistemas. Un modo de lograr esto es introduciendo un objeto @b(fachada) que
  proporciene una interfaz unica y simplificada para los servicios mas generales
  del subsistema.

  ..img > img/065.png

  Pensemos, por ejemplo, en un entorno de programacion que permita a las
  aplicaciones acceder a su subsistema de compilacion. Este subsistema contendra
  clases tales como @c(Lexico), @c(Sintactico), @c(NodoPrograma),
  @b(FlujoDeCodigoBinario) y @c(ConstructorNodoPrograma) que implementan el
  compilador. Algunas aplicaciones especializadas podrian encesitar acceder a
  estas clases directamente, pero la mayoria de los clientes de un compilador no
  suelen preocuparse de detalles como el analisis sintactico y la generacion de
  codigo, sino que simplemente quieren compilar un codigo determinado. Para
  estas aplicaciones, las potentes interfaces de bajo nivel del subsistema de
  compilacion solo complicarian su labor.

  Para proporcionar una interfaz de mas alto nivel que aisle a estas clases de
  los clientes el subsistema de compilacion tambien incluye una clase
  @c(Compilador). Esta clase define una interfaz uniforme para la funcionalidad
  del compilador. La clase @c(compilador) funciona como una fachada: ofrece a
  los clientes una interfaz unica y simple para el subsistema de compilacion.
  Esta clase aglutina las clases que implementan la funcionalidad del compilador
  sin ocultarlas por completo. La fachada del compilador facilita la vida a la
  mayoria de los programadores, sin ocultar la funcionalidad de mas bajo nivel
  para aquellos pocos que la necesiten.

  ..img > img/066.png

*** Facade Aplicabilidad <> Aplicabilidad

  Usaremos el patron Facade cuando

  - queramos proporcionar una interfaz simple para un subsistema complejo. Los
    subsistemas suelen volverse mas complicados a medida que van
    evolucionando. La mayoria de los patrones, cuando se aplican, dan como
    resultado mas clases y mas pequeñas. Esto hace que el subsistema sea mas
    reutilizable y facil de personalizar, pero eso tambien lo hace mas dificil
    de usar para aquellos clientes que no necesitan personalizarlo. Una fachada
    puede proporcionar, por omision, una vista simple del subsistema que resulta
    adecuada para la mayoria de clientes. Solo aquelllos clientes que necesitan
    mas personalizacion necesitaran ir mas alla de la fachada.

  - hay muchas dependencias entre los clientes y las clases que implementan una
    abstraccion. Se introduce una fachada para desacoplar el subsistema de sus
    clientes y de otros subsistemas, promoviendo asi la independencias entre
    subsistemas y la portabilidad.

  - queramos dividir en capas nuestros subsistemas. Se usa una fachada para
    definir un punto de entrada en cada nivel del subsistema. Si estos son
    dependientes, se pueden simplificar las dependencias entre ellos haciendo
    que se comuniquen entre si unicamente a traves de sus fachadas.

*** Facade Estructura <> Estructura

  ..img > img/067.png

*** Facade Participantes <> Participantes

  - @c(Fachada) (@c(Compilador))

    - sabe que clases del subsistema son las responsables ante una peticion.

    - delega las peticiones de los clientes en los objetos apropiados del
      subsistema.

  - @b(clases del subsistema) (@c(Lexico), @c(Sintactico), @c(NodoPrograma), etc.)

    - implementan la funcionalidad del subsistema.

    - realizan las labores encomendadas por el objeto @c(Fachada).

    - no conocen a la fachada; es decir, no tienen referencias a ella.

*** Facade Colaboraciones <> Colaboraciones

  - Los clientes se comunican con el subsistema enviando peticiones al objeto
    @c(Fachada), el cual las reenvia a los objetos apropiados del
    subsistema. Aunque son los objetos del subsistema los que realizan el
    trabajo real, la fachada puede tener que hacer algo de trabajo para pasar de
    su interfaz a las del subsistema.

  - Los clientes que usan la fachada no tienen que acceder directamente a los
    objetos del subsistema.

*** Facade Consecuencias <> Consecuencias

  El patron Facade proporciona las siguientes ventajas:

  1. Oculta a los clientes los componentes del subsistema, reduciondo asi el
     numero de objetos con los que tratan los clientes y haciendo que el
     subsistema sea mas facil de usar.

  2. Promueve un debil acoplamiento entre el subsistema y sus clientes. Muchas
     veces los componentes de un subsistema estan fuertemente acoplados. Un
     acoplamiento debil nos permite modificar los componentes del subsistema sin
     que sus clientes se vean afectados. Las fachadas ayudan a estructurar en
     capas un sistema y las dependencias entre los objetos. Tambien pueden
     eliminar dependencias complejas o circulares. Esto puede ser una
     consecuencia importante cuando el cliente y el subsistema se implementan
     por separado.

     En los grande sistemas software es vital reducir las dependencias de
     compilacion. Queremos ahorrar tiempo minimizando la recompilacion cuando
     cambien las clases del subsistema. Reducir las dependencias de compilacion
     con fachadas puede limitar la recompilacion necesaria para un pequeno
     cambio en un subsistema con fachadas puede limitar la recompilacion
     necesaria para un pequeño cambio en un subsistema importante. Una fachada
     tambien puede simplificar portar sistemas a otras plataformas, ya que es
     menos probable que construir un subsistema requiera volver a construir
     todos los otros.

  3. No impide que las aplicaciones usen las clases del subsistema en caso de que
     sea necesario. De este modo se puede elegir entre facilidad de uso y
     generalidad.

*** Facade Implementacion <> Implementacion

  A la hora de implementar una fachada deben tenerse en cuenta los siguientes
  aspectos:

  1. @e(Reduccion del acoplamiento cliente-subsistema.) El acoplamiento entre
     clientes y el subsistema puede verse reducido todavia mas haciendo que
     Fachada sea una clase abstracta con subclases concretas para las diferentes
     implementaciones de un subsistema. De esa manera los clientes pueden
     comunicarse con el subsistema a traves de la interfaz de una clase
     abstracta Fachada. Este acoplamiento abstracto evita que los clientes
     tengan que saber que implementacion de un subsistema estan usando.

     Una alternativa a la herencia es configurar un objeto Fachada con
     diferentes objetos del subsistema. Para personalizar la fachada basta con
     reemplazar uno o varios de tales objetos.

  2. @e(Clases del subsistema publicas o privadas.) Un subsistema se parece a
     una clase en que ambos tienen interfaces y los dos encapsulan algo @-(una
     clase encapsula estado y operaciones, mientras que un subsistema encapsula
     clases). Y del mismo modo que resulta util pensar en la interfaz publica y
     privada de una clase, tambien podemos pensar en la interfaz publica y
     privada de un subsistema.

     La interfaz publica de un subsistema consiste en una serie de clases a las
     que acceden todos los clientes; la interfaz privada es solo para quienes
     vayan a ampliar el subsistema. La clase @c(Fachada) es parte de la interfaz
     publica, por supuesto, pero no es la unica. Otras clases del subsistema
     tambien suelen ser publicas. Por ejemplo, las clases @c(Lexico) y
     @c(Sintactico) del subsistema de compilacion son parte de la interfaz
     publica.

     Seria interesante poder hacer privadas a las clases de un subsistema, pero
     hay pocos lenguajes orientados a objetos que lo permitan. Tanto C++ como
     Smalltalk han tenido tradicionalmente un espacio de nombre global para las
     clases. No obstante, recientemente, el comite de estandarizacion de C++
     añadio espacios de nombres al lenguaje [@l(#Str94)], lo que nos permitira hacer
     visibles solo las clases publicas del subsistema.

*** Facade Codigo de Ejemplo <> Codigo de Ejemplo

  Veamos mas en detalle como introducir una fachada en un subsistema de
  compilacion.

  El subsistema de compilacion define una clase @c(FlujoDeCodigoBinario) que
  implementa un flujo de objetos @c(instruccionBinaria). Un objeto
  @c(InstruccionBinaria) encapsula un codigo binario, que puede especificar las
  instrucciones en lenguaje maquina. El subsistema tambien define una clase
  @c(Token) para los objetos que encapsula tokens del lenugaje de programacion.

  La clase @c(Lexico) toma un flujo de caracteres y produce un flujo de tokens,
  un token cada vez.

  ..src > c++
    class Lexico {
    public:
        Lexico(istream&);
        virtual ~Lexico();

        virtual Tokens& Analizar();
    private:
        istream& _flujoDeEntrada;
    };
  < src..

  La clase @c(Sintactico) usa un @c(ConstructorNodoPrograma) para construir un
  arbol de analisis sintactico a partir de los tokens del @c(Lexico).

  ..src > c++
    class Sintanctico {
    public:
        Sintactico();
        virtual ~Sintactico();

        virtual void Analizar(Lexico&, ConstructorNodoPrograma&);
    };
  < src..

  @c(Sintactico) realiza llamadas a @c(ConstructorNodoPrograma) para crear
  incrementalmente el orbol de analisis sintactico. Estas clases interactuan
  segun el patron @l(#Builder).

  ..src > c++
    class ConstructorNodeProgramas {
    public:
        ConstructorNodoPrograma();

        virtual NodoPrograma* NuevaVariable(
            const char* nombreVariable
        ) const;

        virtual NodoPrograma* NuevaAsignacion(
            NodoPrograma* variable, NodoPrograma* expresion
        ) const;

        virtual NodoPrograma* NuevaExpresionReturn (
            NodoPrograma* valor
        ) const;

        virtual NodoPrograma* NuevaCondicion(
            NodoPrograma* condicion,
            NodoPrograma* parteTrue, NodoPrograma* parteFalse
        ) const;
        // ...

        NodoPrograma* ObtenerNodoRaiz();
    private:
        NodoPrograma* _nodo;
    };
  < src..

  El arbol de analisis se compone de instancias de subclases de @c(NodoPrograma)
  tales como @c(NodoInstruccion), @c(NodoExpresion) y asi sucesivamente. La
  jerarquia de @c(NodoPrograma) es un ejemplo de patron @l(#Composite).
  @c(NodoPrograma) define una interfaz para manipular un nodo de programa y sus
  hijos, en caso de que existan.

  ..src > c++
    class NodoPrograma {
    public:
        // manipulacion del nodo de programa
        virtual void ObtenerPosicionFuente(int& linea, int& indice);
        // ...

        // manipulacion de los hijos
        virtual void Insertar(NodoPrograma*);
        virtual void Borrar(NodoPrograma*);
        // ...

        virtual void Recorrer(GeneradorDeCodigo&);
    protected:
        NodoPrograma();
    };
  < src..

  La operacion @c(Recorrer) toma un objeto @c(GenerardorDeCodigo). Las subclases
  de @c(NodoPrograma) usan este objeto para generar codigo maquina, empleando
  para ello objetos @c(InstruccionBinaria) sobre un @c(FlujoDeCodigoBinario). La
  clase @c(GeneradorDeCodigo) es un visitante (vease el patron @l(#Visitor)).

  ..src > c++
    class GeneradorDeCodigo {
    public:
        virtual void Visitar(NodoInstrucccion*);
        virtual void Visitar(NodoExpresion*);
        // ...
    protected:
        GeneradorDeCodigo(flujoDeCodigoBinario&);
    protected:
        FlujoDeCodigoBinario& _salida;
    };
  < src..

  @c(GeneradorDeCodigo) tiene subclases como @c(GeneradorDeCodigoMaquinaDePila)
  y @c(GeneradorDeCodigoRISC), que generan codigo maquina para distintas
  arquitecturas hardware.

  Cada subclase de @c(NodoPrograma) implementa @c(Recorrer) como una llamada a
  @c(Recorrer) sobre sus objetos hijo @c(NodoPrograma). A su vez, cada hijo hace
  lo mismo para sus hijos, y asi sucesivamente, de forma recursiva. Por ejemplo,
  @c(NodoExpresion) define @c(Recorre) de la siguiente manera:

  ..src > c++
    void NodoExpresion::Recorrer (GeneradorDeCodigo& gc) {
        gc.Visitar(this);

        IteradorLista<NodoPrograma*> i(_hijos);

        for (i.Primero(); !i.HaTerminado(); i.Siguiente()) {
            i.ElementoActual()->Recorrer(gc);
        }
    }
  < src..

  Las clases descritas hasta ahora forman el subsistema de compilacion. Ahora
  introduciremos una clase @c(Compilador), una fachada que junta todas estas
  piezas. @c(Compilador) proporciona una interfaz simple para compilar codigo
  fuente y generar codigo para una determinada maquina.

  ..src > c++
    class Compilador {
    public:
        Compilador();

        virtual void Compilar(istream&, FlujoDeCodigoBinario&);
    };

    void Compilar::Compilar (
        istream& entrada, FlujoDeCodigoBinario& salida
    ) {
        Lexico lexico(entrada);
        ConstructorNodoPrograma constructor;
        Sintactico sintactico;

        sintactico.Analizar(lexico, constructor);
        GeneradorDeCodigoRISC generador(salida);
        NodoPrograma* arbolDeAnalisis = constructor.ObtenerNodoRaiz();
        arbolDeAnalisis->Recorrer(generador);
    }
  < src..

  Esta implementacion liga al codigo el tipo de generador de codigo a utilizar,
  de manera que los programadores no necesitan especificar la arquitectura de
  destino. Eso podria ser razonable si siempre fuera a haber una unica
  arquitectura. Si ese no es el caso, tal vez queremos cambiar el constructor de
  @c(Compilador) para que tome un parametro @c(GeneradorDeCodigo). De ese modo
  los programadores pueden especificar el generador a usar cuando crean una
  instancia de @c(Compilador). La fachada del compilador puede parametrizar
  otros participantes, como @c(Lexico) y @c(ConstructorNodoPrograma), lo que
  añade flexibilidad, pero tambien se aparta de la mision del patron @c(Facade),
  que es simplificar la interfaz para el caso general.

*** Facade Usos Conocidos <> Usos Conocidos

  El ejemplo del compilador de la seccion Codigo de Ejemplo esta inspirado en el
  sistema de compilacion ObjectWorks\Smalltalk [@l(#Par90)].

  en el framework de aplicaciones ET++ [@l(#WGM88)], una aplicacion puede tener
  incorporadas herramientas de inspeccion de objetos en tiempo de
  ejecucion. Estas herramientas estan implementadas en un subsistema aparte que
  incluye una clase @c(Fachada) denominada @"(ProgrammingEnvironment). Esta
  fachada define operaciones tales como @c(InspectObject) e @c(InspectClass)
  para acceder a las herramientas de inspeccion.

  Una aplicacion ET++ tambien puede prescindir de las capacidades de inspeccion
  proporcionadas. En ese caso, @c(ProgrammingEnvironment) implementa estas
  peticiones como operaciones nulas; es decir, no hacen nada. Solo la subclase
  @c(ETProgrammingEnvironment) implementa estas peticiones con operaciones que
  muestran los correspondientes inspectores. La aplicacion no sabe si esta o no
  disponible un entorno de inspeccion; hay un acoplamiento abstracto entre la
  aplicacion y el subsistema de inspeccion de objetos.

  Es sistema operativo Choices [@l(#CIRM93)] usa fachadas para combinar varios
  frameworks en uno solo. Las abstracciones clave en Choices son los procesos,
  el almacenamiento y los espacios de direcciones. Para cada una de estas
  abstracciones existe su correspondiente subsistema, impleentado como un
  framework, lo que permite portar Choises a diversas paltaformas hardware. Dos
  de estos subsistemas tienen un @"(representante) (es decir, una
  fachada). Estos representantes son @c(FileSystemInterface) (para el
  almacenamiento) y @c(Domain) (para los espacios de direcciones).

  Por ejemplo, el framework de memoria virtual tiene como fachada a la clase
  @c(Domain) (dominio). Un dominio representa un espacio de direcciones, y
  proporciona una correspondencia entre las direcciones virtuales y los
  desplazamientos, por un lado, y los objetos en la memoria, ficheros y copias
  de seguridad, por otro. Las operaciones principales de @c(Domain) permiter
  añadir un objeto en la memoria a una determinada direccion, eliminar un objeto
  de la memoria y procesar los fallos de pagina.

  Como se muestra en el siguiente diagrama, el subsistema de memoria virtual usa
  internamente los siguientes componentes:

  - @c(MemoryObject) representa un almacenamiento de datos.

  - @c(MemoryObjectCache) guarda en la memoria fisica los datos de varios
    @c(MemoryObject). @c(MemoryObjectCache) es realmente una
    @l(#Strategy<>Estrategia) que localiza la politica de cache.

  - @c(AddressTranslation) encapsula el hardware de traduccion de direcciones.

  Cada vez que tiene lugar una interrupcion por fallo de pagina se llama a la
  operacion @c(RepairFault). el objeto @c(Domain) busca el objeto de memoria de
  la direccion causante del fallo de pagina y delega la operacion @c(Repairfault)
  en la cache asociada a ese objeto de memoria. Los dominios pueden
  personalizarse cambiando sus componentes.

  ..img > img/068.png

*** Facade Patrones Relacionados <> Patrones Relacionados

  El patron @l(#Abstract Factory) puede usarse para proporcionar una interfaz
  para crear el subsistema de objetos de forma independiente a otros
  subsistemas. Las fabricas abstractas tambien pueden ser una alternativa a las
  fachadas para ocultar clases especificas de la plataforma.

  El patron @l(#Mediator) es parecido al Facade en el sentido de que abstrae
  funcionalidad a partir de unas clases existentes. Sin embargo, el proposito
  del Mediador es abstraer cualquier comunicacion entre objetos similares, a
  menudo centralizando la funcionalidad que no pertenece a niguno de ellos. Los
  colegas de un mediador solo se preocupan de comunicarse con el y no entre
  ellos directamente. Por el contrario, una fachada simplemente abstrae una
  interfaz para los objetos del subsistema, haciendolos mas facil de usar; no
  define una nueva funcionalidad, y las clases del subsistema no saben de su
  existencia.

  Normalmente solo necesita un objeto Fachada. Por tanto, suelen implementarse
  como @l(#Singleton<>Sigletons).

** Flyweight
*** Flyweight Proposito <> Proposito

  Usa comportamiento para permitir un gran numero de objetos de grano fino de
  forma eficiente.

*** Flyweight Motivacion <> Motivacion

  Si bien algunas aplicaciones podrian beneficiarse de un diseño en el que se
  empleasen objetos para todo, una implementacion simplista haria que este fuese
  prohibitivamente caro.

  Por ejemplo, la mayoria de las implementaciones de editores de documentos
  tienen funciones de formateado y edicion de texto que son hasta cierto punto
  modulares. Los editores de documentos orientados a objetos normalmente emplean
  objetos para representar los elementos insertados, como tablas y figuras. Sin
  embargo, no suelen hacer uso de un objeto para cada uno de los caracteres del
  documento, a pesar de que de esa manera se lograria una gran flexibilidad en
  la aplicacion. En ese caso se podria tratar de manera uniforme a los
  caracteres y a los elementos insertados con respecto a como se dibujan y
  formatean estos. La aplicacion podria ampliarse para permitir nuevos juegos de
  caracteres sin afectar al resto de su funcionalidad. La estructura de objetos
  de la aplicacion podria mimetizar la estructura fisica del documento. El
  siguiente diagrama muestra como puede usar objetos un editor de documentos
  para representar los caracteres.

  ..img > img/069.png

  El inconveniente de este diseño es su coste. Incluso documentos de un tamaño
  moderado podrian necesitar cientos o miles de objetos de caracteres, los
  cuales consumirian mucha memoria y podrian sufrir un coste en tiempo de
  ejecucion inaceptable. El patron Flyweight describe como compartir objetos
  para permitir su uso con granularidades muy finas sin un coste prohibitivo.

  Un peso ligero es un objetivo compartido que puede usarse a la vez en varios
  contextos. El peso ligero es un objeto independiente en cada contexto @-(no se
  puede distinguir de una instancia del objeto que no este compartida). Los
  pesos ligeros no pueden hacer suposiciones sobre el contexto en el cual
  operan. Lo fundamental aqui es la distincion entre estado @b(intrinseco) y
  @b(extrinseco). El estado intrinseco se guarda con el propio objeto; consiste
  en informacion que es independiente de su contexto y que puede ser, por tanto,
  compartida. El estado extrinseco depende del contexto y cambia con el, por lo
  que no puede ser compartido. Los objetos cliente son responsables de pasar al
  peso ligero su estado extrinseco cuando lo necesite.

  Los pesos ligeros modelan conceptos o entidades que normalmente son demasiado
  numerosos como para ser representados como objetos. Por ejemplo, un editor de
  documentos puede crean un peso ligero para cada letra del alfabeto. Cada peso
  ligero guarda un codigo de caracter, mientras que las coordenadas con su
  posicion en el documento y su estilo tipografico pueden obtenerse a partir de
  los algoritmos de maquetacion del texto y las ordenes de formateado activas
  alli donde aparezca dicho caracter. El codigo del caracter es su estado
  intrinseco, mientras que el resto de la informacion es extrinseca.

  Deste un punto de vista logico, hay un objeto por cada aparicion en el
  documento de un determinado caracter:

  ..img > img/070.png


  Fisicamente, no obstante, hay un solo objeto peso ligero compartido por cada
  caracter, el cual aparece en diferentes contextos de la estructura del
  documento. Cada aparicion de un caracter concreto se refiere a la misma
  instancia del almacen@n(35) compartido de objetos peso ligero:

  ..img > img/071.png

  A continuacion se muestra la estructura de clases de estos objetos. @c(Glifo)
  es la clase abstracta para los objetos graficos, algunos de los cuales pueden
  ser pesos ligeros. Las operaciones que pueden depender del estado extrinseco
  reciben este como parametro. Por ejemplo, @c(Dibujar) e @c(Interseca) deben
  saber en que contexto esta el glifo antes de que puedan hacer su trabajo.

  ..img > img/072.png

  Un peso ligero que represente la letra @"(a) unicamente guarda el codigo de
  caracter correspondiente; no necesita guardar su posicion ni tipo de fuente.
  Los clientes proporcionan la informacion dependiente del contexto que el peso
  ligero necesita para dibujarse a si mismo. Por ejemplo, una @c(Fila) sabe
  donde deberian dibujarse sus hijos para que se dispongan horizontalmente. Por
  tanto, puede pasar a cada hijo su posicion cuando les pida que se dibujen.

  Puesto que el numero de objetos de caracter diferentes es bastante menor que
  el numero de caracteres del documento, el numero total de objetos es
  notablemente menor que los que usaria una implementacion simplista. Un
  documento en el que todos los caracteres aparezcan con la misma fuente y color
  tendria del orden de 100 objetos caracter (aproximadamente el tamaño del juego
  de caracteres ASCII), independientemente de cual sea su longitud. Por otro
  lado, dado que la mayoria de los documentos no usan mas de 10 combinaciones
  diferentes de fuentes y colores, este numero no crecera demasiado en la
  practica. Emplear un objeto como abstraccion para los caracteres individuales
  es, por tanto, practico.

*** Flyweight Aplicabilidad <> Aplicabilidad

  La efectividad del patron Flyweight depende enormemente de como y donde se
  use. Deberia aplicarse el patron cuando se cumpla @e(todo) lo siguiente:

  - Una  aplicacion utiliza un gran numero de objetos.

  - Los costes de almacenamiento son elevados debido a la gran cantidad de
    objetos.

  - La mayor parte del estado del objeto puede hacerse extrinseco.

  - Muchos grupos de objetos pueden reemplazarse por relativamente pocos objetos
    compartidos, una vez que se ha eliminado el estado extrinseco.

  - La aplicacion no depende de la identidad de un objeto. Puesto que los
    objetos peso ligero pueden ser compartidos, las comprobaciones de identidad
    devolveran verdadero para objetos conceptualmente distintos.

*** Flyweight Estructura <> Estructura

  ..img > img/073.png

  El siguiente diagrama de objetos muestra como se comparten los pesos ligeros:

  ..img > img/074.png

*** Flyweight Participantes <> Participantes

  - @c(PesoLigero) (@c(Glifo))

    - declara una interfaz a travez de la cual los pesos ligeros pueden recibir
      un estado extrinseco y actual sobre el.

  - @c(PesoLigeroConcreto) (@c(Caracter))

    - Implementa la interfaz @c(PesoLigero) y permite almacenar el estado
      intrinseco, en caso de que lo haya. Un objeto @c(PesoLigeroConcreto) debe
      poder ser compartido, por lo que cualquier estado que almacene debe ser
      intrinseco, esto es, debe ser independiente del contexto del objeto
      @c(PesoLigeroConcreto).

  - @c(PesoLigeroConcretoNoCompartido) (@c(Fila), @c(Columna))

    - no todas las subclases de @c(PesoLigero) necesitan ser compartidas. La
      interfaz @c(PesoLigero) @e(permite) el compartimiento, no fuerza a el.
      Los objetos @c(PesoLigeroConcretoNoCompartido) suelen tener objetos
      @c(PesoLigeroConcreto) como hijos en algun nivel de la estructura de
      objetos (como es el caso de @c(Fila) y @c(Columna)).

  - @c(FabricaDePesosLigeros)

    - crea y controla objetos pesos ligeros.

    - garantiza que los pesos ligeros se compartan de manera adecuada. Cuando un
      cliente solicita un peso ligero, el objeto @c(FabricaDePesosLigeros)
      proporciona una instancia concreta o crea uno nuevo, en caso de que no
      exista ninguno.

  - @c(Cliente)

    - mantiene una referencia a los pesos ligeros.

    - calcula o guarda el estado extrinseco de los pesos ligeros.

*** Flyweight Colaboraciones <> Colaboraciones

  - El estado que un peso ligero necesita para funcionar debe ser caracterizado
    como intrinseco o extrinseco. El estado intrinseco se guarda en el objeto
    @c(PesoLigeroConcreto), mientras que el estado extrinseco lo guardan o lo
    calculan los objetos @c(Cliente). Los clientes pasan este estado al peso
    ligero cuando invocan sus operaciones.

  - Los clientes no deberian crear instancias de @c(PesoLigeroConcreto)
    directamente, sino que deben obtener los objetos @c(PesoLigeroConcreto) solo
    a partir del objetos @c(FabricaDePesosLigeros) para garantizar que se puedan
    compartir adecuadamente.

*** Flyweight Consecuencias <> Consecuencias

  Los pesos ligeros pueden introducir costes en tiempo de ejecucion asociados
  con la transferencia, busqueda y calculo del estado extrinseco, especialmente
  si este se almaceno en primer lugar como estado intrinseco. En cualquier caso,
  dichos costes se ven compensados por el ahorro de espacio de almacenamiento,
  que se incrementa a medida que se comparten mas objetos.

  El ahorro de almacenamiento esta en funcion de varios factores:

  - La reduccion en el numero total de instancias lograda mediante el compartimiento
  - la cantidad de estado intrinseco por objeto
  - si el estado extrinseco se calcula o se almacena.

  Cuantos mas objetos peso ligero se compartan, mayor sera el ahorro de
  almacenamiento. Este ahorro aumentara a medida que se comparta mas cantidad de
  estado. El mayor ahorro tendra lugar cuando los objetos tengan gran cantidad
  de estado, tanto intrinseco como extrinseco, y cuando el estado extrinseco
  pueda calcularse en vez de tener que ser guardado. De esa manera se ahorra
  espacio de almacenamiento de dos formas: el compartimiento reduce el coste del
  estado intrinseco, y se cambia estado extrinseco por tiempo de calculo.

  El patron Flyweight suele combinarse con el patron Composite para representar
  una estructura jerarquica como un grafo con nodos hojas compartidos. Una
  consecuencia del compartimiento es que los nodos hojas pesos ligeros no pueden
  tener un puntero a su padre. En vez de eso, el puntero al padre se le pasa al
  peso ligero como parte de su estado extriseco. Esto tiene un impacto desicivo
  en la forma en que se comunican los objetos de la jerarquia.

*** Flyweight Implementacion <> Implementacion

  A la hora de implementar el patron Peso Ligero han de tenerse presentes las
  siguientes cuestiones:

  1. @e(Eliminar el estado extrinseco.) La aplicabilidad del patron viene dada
     en gran medida por lo facil que sea identificar el estado extrinseco y
     eliminarlo de los objetos compartidos. Eliminar el estado extrinseco no
     ayudara a reducir los costes de almacenamiento en caso de que haya tantos
     tipos diferentes de estados extrinsecos como objetos hubiera antes del
     compartimiento. Lo ideal seria que el estado extrinseco pudiera ser
     calculado a partir de una estructura de objetos separada que tuviera
     requisitos de almacenamiento mucho menores.

     En nuestro editor de documentos, por ejemplo, podemos almacenar un
     diccionario con informacion tipografica en una estructura aparte en vez de
     almacenar la fuente y el estilo con cada objeto caracter. Dicha estructura
     de datos almacena series de caracteres con los mismos atributos
     tipograficos. Cuando un caracter se dibuja a si mismo recibe sus atributos
     tipograficos como un efecto lateral de la operacion de dibujado. Como los
     documentos normalmente solo hacen uso de unas pocas fuentes y estilos
     diferentes, almacenar esta informacion fuera de cada objeto de caracter es
     mucho mas eficiente que si se almacenace internamente.

  2. @e(Gestionar los objetos compartidos.) Dado que los objetos estan
     compartidos, los clientes no deberian crear instancias de ellos
     directamente. La @c(FabricaDePesosLigeros) permite que los clientes
     obtengan un peso ligero concreto. Para ello, suelen utilizar un almacen
     asociativo donde los clientes pueden buscar los objetos pesos ligeros de su
     interes. Por ejemplo, la fabrica de pesos ligeros del ejemplo del editor de
     documentos podria mantener una tabla con objetos pesos ligeros indexados
     por codigos de caracter. El administrador devuelve el objeto peso ligero
     apropiado para un codigo dado, creando el objeto peso ligero en caso de que
     este no existiese.

     El compartimiento tambien implica alguna forma de conteo de referencias o
     de recoleccion de basura para recuperar el espacio de almacenamiento de un
     peso ligero cuando este ya no sea necesario. Sin embargo, ninguna de estas
     cosas es necesaria si hay un numero fijo y pequeño de tales objetos (por
     ejemplo, los pesos ligeros para el juego de caracteres ASCII). En ese caso,
     vale la pena mantener los pesos ligeros de forma permatente.

*** Flyweight Codigo de Ejemplo <> Codigo de Ejemplo

  Volviendo a nuestro codigo de ejemplo del formateador de documentos, podemos
  definir una clase base @c(Glifo) base para los objetos graficos. Como es
  logico, los glifos son Compuestos (vease el patron @l(#Composite)) que tienen
  atributos graficos y que pueden dibujarse a si mismos. Aqui nos centraremos
  simplemente en el atributo para la fuente, pero podria seguirse el mismo
  enfoque para cualquiera de los otros atrtibutos graficos que pudiera tener un
  glifo.

  ..src > c++
    class Glifo {
    public:
        virtual ~Glifo();

        virtual void Dibujar(Ventana*, ContextoGlifo&);
        virtual void EstablecerFuente(Fuente*, ContextoGlifo&);
        virtual Fuente* ObtenerFuente(ContextoGlifo&);

        virtual void Primero(ContextoGlifo&);
        virtual void Siguiente(ContextoGlifo&);
        virtual bool HaTerminado(ContextoGlifo&);
        virtual Glifo* Actual(ContextoGlifo&);

        virtual void Insertar(Glifo*, ContextoGlifo&);
        virtual void Borrar(ContextoGlifo&);
    protected:
        Glifo();
    };
  < src..

  La subclase @c(Caracter) simplemente almacena un codigo de caracter:

  ..src > c++
    class Caracter : public Glifo {
    public:
        Caracter(char);

        virtual void Dibujar(Ventana*, ContextoGlifo&);
    private:
        char _codigocaracter;
    };
  < src..

  Para evitar reservar espacio en cada glifo para el atributo de la fuente,
  almacenaremos dicho atributo extrinsicamente en un objeto @c(ContextoGlifo),
  el cual sirve de repositorio para el estado extrinseco, manteniendo una
  correspondencia entre un glifo y su fuente (y otros atributos graficos
  cualesquiera que pudiera tener) en diferentes contextos. Cualquier operacion
  que necesite saber la fuente del glifo en un contexto dado recibira como
  parametro una instancia de un objeto @c(ContextoGlifo). La operacion puede
  entonces pedirle a @c(ContextoGlifo) cual es la fuente en ese contexto. El
  contexto depende de la posicion del glifo en la estructura. Por tanto, las
  operaciones de iteracion y manipulacion sobre los hijos del @c(Glifo) deben
  actuarizar el @c(ContextoGlifo) cada vez que se usan.

  ..src > c++
    class ContextoGlifo {
    public:
        ContextoGlifo();
        virtual ~ContextoGlifo();

        virtual void Siguiente(int incremento = 1);
        virtual void Insertar(int cantidad = 1);

        virtual Fuente* ObtenerFuente();
        virtual void EstablecerFuente(Fuente*, int span = 1);
    private:
        int _indice;
        ArbolB* _fuentes;
    };
  < src..

  El @c(ContextoGlifo) debe permanecer informado de la posicion actual en la
  estructura de glifos durante el recorrido. @c(ContextoGlifo::Siguiente)
  incrementa @c(_indice) a medida que se avanza en el recorrido. Las subclases
  de @c(Glifo) que tienen hijos (como @c(Fila) y @c(Columna)) deben implementar
  @c(Siguiente) para que llame a @c(ContextoGlifo::Siguiente) en cada punto del
  recorrido.

  @c(ContextoGlifo::ObtenerFuente) usa el indice como clave de una estructura
  @c(ArbolB) que guarda la correspondencia entre glifos y fuentes. Cada nodo del
  arbol se etiqueta con la longitud de la cadena para la que se proporciona
  informacion sobre la fuente. Las hojas del arbol apuntan a una fuente,
  mientras que los nodos interiores separan la cadena en subcadenas, una para
  cada hijo.

  Sea el siguiente extracto de una composicion de glifos:

  ..img > img/075.png

  La estructura @c(ArbolB) para la informacion sobre la fuente podria parecer a
  esto:

  ..img > img/076.png

  Los nodos interiores definen intervalos de indices de glifos. El @c(ArbolB) se
  actualiza en respuesta a los cambios de fuentes y cada vez que se añaden o se
  eliminan glifos de la estructura. Por ejemplo, suponiendo que nos encontramos
  en el indice 102 durante un recorrido, el siguiente codigo establece la fuente
  de cada caracter de la palabra @"(expect) como la misma que la del contexto
  adyacente (es decir, @c(times12), una instania de @c(Fuente) para Times Roman
  de 12 puntos):

  ..src > c++
    ContextoGlifo contexto;
    Fuente* times12 = new Fuente("Times-Roman-12");
    Fuente* timesItalic12 = new Fuente("Times-Italic-12");
    // ...

    gc.EstablecerFuente(times12, 6);
  < src..

  La nueva estructura @c(ArbolB) (con los cambios resaltados en negro) se
  pareceria a

  ..img > img/077.png

  Supongamos que añadimos la palabra @"(don't ) (incluyendo el espacio en
  blanco) en Times Italic de 12 puntos antes de @"(expect). El codigo siguiente
  informa al @c(contexto) de este evento, suponiendo que todavia se encuentre en
  el indice 102:

  ..src > c++
    contexto.Insertar(6);
    contexto.EstablecerFuente(timesItalic12, 6);
  < src..

  La estructura @c(ArbolB) se convierte en lo que aparece en la figura de la
  pagina siguiente.

  Cuando se le pide a @c(ContextoGlifo) la fuente del glifo actual, este
  desciende por el @c(ArbolB), añadiendo indices hasta que encuentra la fuente
  para el indice actual. Dado que la frecuencia de los cambios de fuente es
  relativamente baja, el arbol se mantiene pequeño en comparacion con el tamaño
  de la estructura de glifos. Esto mantiene bajos los costes de almacenamiento
  sin un amuento desorbitado de tiempo de busqueda.@n(36)

  ..img > img/078.png

  El ultimo objeto que necesitamos es una @c(FabricaDePesosLigeros) que cree
  glifos y garantice que se comparten de manera adecuada. La clase
  @c(FabricaDeGlifos) crea instancias de @c(Caracter) y otros tipos de
  glifos. Nosotros solo compartimos objetos @c(Caracter); los glifos compuestos
  son mas raros y, en cualquier caso, su estado importante (es decir, sus hijos)
  es intrinseco.

  ..src > c++
    const int NCODIGOSCARACTER = 128;

    class FabricaDeGlifos {
    public:
        FabricaDeGlifos();
        virtual ~FabricaDeGlifos();

        virtual Caracter* CrearCaracter(char);
        virtual Fila* CrearFila();
        virtual Columna* CrearColumna();
        // ...
    private:
        Caracter* _caracter[NCODIGOSCARACTER];
    };
  < src..

  El array @c(_caracter) contiene punteros a glifos @c(Caracter) indexados por
  el codigo de caracter. Este array es inicializado a cero en el constructor.

  ..src > c++
    FabricaDeGlifos::FabricaDeGlifos () {
        for (int i = 0; i < NCODIGOSCARACTER; ++i) {
            _caracter[i] = 0;
        }
    }
  < src..

  @c(CrearCaracter) busca un caracter en los glifos de caracter del array, y
  devuelve el glifo correspondiente, si existe. entonces @c(CrearCaracter) crea
  el glifo, lo mete en el array y lo devuelve:

  ..src > c++
    Caracter* FabricaDeGlifos::CrearCaracter (char c) {
        if (!_caracter[c]) {
            _caracter[c] = new Caracter(c);
        }

        return _caracter[c];
    }
  < src..

  El resto de operaciones simplemente crean un nuevo objeto cada vez que son
  llamadas, dado que los glifos que no sean caracteres no seran compartidos:

  ..src > c++
    Fila* FabricaDeGlifos::CrearFila () {
        return new Fila;
    }

    Columna* FabricaDeGlifos::CrearColumna () {
        return new Columna;
    }
  < src..

  Podriamos omitir estas operaciones y dejar que los clientes crearan instancias
  de glifos no compartidos directamente. Sin embargo, en caso de que mas tarde
  decidiesemos hacer dichos glifos compartidos, tendriamos que cambiar el codigo
  cliente que los crea.

*** Flyweight Usos Conocidos <> Usos Conocidos

  El concepto de objetos pesos ligeros se describio e investigo por primera vez
  como una tecnica de diseño en InterViews 3.0 [@l(#CL90)]. Sus desarrolladores
  construyeron un potente editor de documentos llamado Doc para demostrar el
  concepto [@l(#CL92)]. Doc usa objetos glifo para representar cada caracter del
  documento. El editor crea una instancia de Glifo para cada caracter que tenga
  un determinado estilo (el cual define sus atributos graficos); por tanto el
  estado intrinseco de un caracter consiste en el codigo del caracter y su
  informacion de estilo (un indice en la tabla de estilos).@n(37) eso significa
  que unicamente la posicion es extrinseca, lo que hace que Doc sea rapido. Los
  documentos se representan por una clase @c(Document), que tambien hace las
  veces de @c(FabricaDePesosLigeros). Las mediciones hechas sobre Doc muestran
  que el compartimiento de caracteres resulta efectivo. Un documento tipico de
  180.00 caracteres requirio solamente 480 objetos caracter.

  ET++ [@l(#WGM88)] usa pesos ligeros para permitir la independencia de la
  interfaz de usuario.@n(9)@n(38) El estandar de interfaz de usuario afecta a la
  disposicion de los elementos de la interfaz de usuario (por ejemplo, barras de
  desplazamiento, botones y menus @-(lo que se conoce con el nombre colectivo de
  @"(utiles)))@n(28) y sus adornos (sombras, borde, etc.). Un util delega todo
  su comportamiento de posicionamiento y dibujado en otro objeto @c(Layout).
  Cambiar el objeto @c(Layout) cambia el aspecto de la interfaz incluso en
  tiempo de ejecucion.

  Para cada clase de util hay su correspondiente clase @c(Layout) (por ejemplo,
  @c(ScrollbarLayout), @c(MenubarLayout), etc.). Un problema evidente con este
  enfoque es que usar diferentes objetos layout duplica el numero de objetos de
  interfaz de usuario: para cada objeto de interfaz de usuario hay un objeto
  @c(Layout) adicional. Para evitar esta penalizacion, los objetos @c(Layout) se
  implementan como pesos ligeros. Dichos objetos son buenos pesos ligeros porque
  su principal mision es definir comportamiento, y es facil pasarles el poco
  estado extrinseco que necesitan para colocar o dibujar un objeto.

  Los objetos @c(Layout) son creados y gestionados por objetos @c(Look). La
  clase @c(Look) es una @l(#Abstract Factory<>Fabrica Abstracta) que recupera un
  determinado objeto @c(Layout) con operaciones como @c(GetButtonLayout),
  @c(GetMenuBarLayout) y otras. Para cada estandar de interfaz de usuario existe
  la correspondiente subclase de @c(Look) (como @c(MotifLook) u @c(OpenLook)) que
  proporciona los objetos @c(Layout) apropiados.

  Por cierto, los objetos @c(Layout) son, en esencia, estrategias, (vease el
  patron @l(#Strategy)). Son un ejemplo de objeto estrategia implementado como
  un peso ligero.

*** Flyweight Patrones Relacionados <> Patrones Relacionados

  El patron Flyweight suele combinarse con el patron @l(#Composite) para
  implementar una estructura logica jerarquica en terminos de un grafo dirigido
  aciclico con nodos hojas compartidos.

  Suele ser mejor implementar los objetos @l(#State) y @l(#Strategy) como pesos
  ligeros.

** Proxy
*** Proxy Proposito <> Proposito

  Proporciona un representante o sustituto de otro objeto para controlar el
  acceso a este.

*** Proxy Tambien Conocido Como <> Tambien Conocido Como

  Surrogate (Sustituto)

*** Proxy Motivacion <> Motivacion

  Una razon para controlar el acceso a un objeto es retrasar todo el coste de su
  creacion e inicializacion hasta que sea realmente necesario usarlo. Pensemos
  en un editor de documentos que puede insertar objetos graficos en un
  documento. Algunos de estos objetos graficos, como las grandes imagenes
  @e(raster), pueden ser costosos de crear. Sin embargo, abrir un documento
  deberia ser una operacion que se efectue rapidamente, por lo que se deberia
  evitar crear todos los objetos costosos a la vez en cuanto se abre el
  documento. Por otro lado, tampoco es necesario, ya que no todos esos objetos
  seran visibles en el documento al mismo tiempo.

  Estas restricciones sugieren que cada objeto concreto se cree a @e(peticion),
  lo que en este caso tendra lugar cuando la imagen se hace visible. Pero, ¿que
  ponemos en el documento en lugar de la imagen? ¿Y como puede ocultarse el
  hecho de que la imagen se crea a peticion sin que se complique la
  implementacion del editor? Esta optimizacion no deberia influir, por ejemplo,
  en el codigo de visualizacion y formateado.

  La solucion es utilizar otro objeto, un @b(proxy) de la imagen, que actue como
  un sustituto de la imagen real. El proxy se comporta igual que la imagen y se
  encarga de crearla cuando sea necesario.

  ..img > img/079.png

  El proxy de la imagen crea la imagen real solo cuando el editor de documentos
  le pide que se dibuje, invocando a su operacion @c(Dibujar). El proxy redirige
  las siguientes peticiones directamente a la imagen. Debe guardar, por tanto,
  una referencia a la imagen despues de crear esta.

  Supongamos que las imagenes se guardan en ficheros aparte. En este caso
  podemos usar el nombre del fichero como la referencia al objeto real. El proxy
  tambien almacena su extension, esto es, su ancho y su alto. La extension
  permite que el proxy pueda responder a las preguntas sobre su tamaño que le
  haga el formateador sin crear realmente la imagen.

  El siguiente diagrama de clases ilustra este ejemplo mas en detalle.

  ..img > img/080.png

  El editor de documentos accede a las imagenes insertadas a traves de la
  interfaz definida por la clase abstracta @c(Grafico). @c(ProxyImagen) es una
  clase para las imagenes que se crea a peticion. @c(ProxyImagen) tiene como
  referencia a la imagen en el disco el nombre del fichero, el cual recibe como
  parametro el constructor de la clase.

  @c(ProxyImagen) tambien guarda la caja que circunscribe la imagen y una
  referencia a la instancia de la @c(Imagen) real, la cual no sera valida hasta
  que el proxy cree dicha imagen real. La operacion @c(Dibujar) se asegura de
  que la imagen ha sido creada antes de enviarle la peticion.
  @c(ObtenerExtension) redirige la peticion a la imagen solo si esta ha sido
  creada; en caso contrario, es @c(ProxyImagen) quien devuelve su extension.

*** Proxy Aplicabilidad <> Aplicabilidad

  Este patron es aplicable cada vez que hay necesidad de una referencia a un
  objeto mas versatil o sofisticada que un simple puntero. Estas son varias
  situaciones comunes en las que es aplicable el patron Proxy:

  1. Un @b(proxy remoto) proporciona un representante local de un objeto situado
     en otro espacio de direcciones. NEXTSTEP [@l(#Add94)] usa la clase @c(NXProxy)
     con este proposito. Coplien [@l(#Cop92)] llama @"(Embajador) a este tipo de
     proxy.

  2. Un @b(proxy virtual) crea objetos costosos por encargo. El @c(ProxyImagen)
     descrito en la seccion de Motivacion es un ejemplo de este tipo de proxy.

  3. Un @b(proxy de proteccion) controla el acceso al objeto original. Los proxies
     de proteccion son utiles cuando los objetos debieran tener diferentes
     permisos de acceso. Por ejemplo, los @c(KernelProxy) del sistema operativo
     Choices [@l(#CIRM93)] proporcionan un acceso protegido a los objetos del sistema
     operativo.

  4. Una @b(referencia inteligente) es un sustituto de un simple puntero que lleva
     a cabo operaciones adicionales cuando se accede a un objeto. Algunos
     ejemplos de usos tipicos son:

     - contar el numero de referencias al objeto real, de manera que este puede
       liberarse automaticamente cuando no haya ninguna referencia apuntandole
       (tambien se conocen con el nombre de @b(punteros inteligentes) [@l(#Ede92)]).

     - cargar un objeto persistente en la memoria cuando es referenciado por
       primera vez.

     - comprobar que se bloquea el objeto real antes de acceder a el para
       garantizar que no pueda ser modificado por ningun otro objeto.

*** Proxy Estructura <> Estructura

  ..img > img/081.png

  Este es un posble diagrama de objetos de una estructura de proxies en tiempo
  de ejecucion:

  ..img > img/082.png

*** Proxy Participantes <> Participantes

  - @c(Proxy) (@c(ProxyImagen))

    - mantiene una referencia que permite al proxy acceder al objeto real. El
      proxy puede referirse a un @c(Sujeto) en caso de que las interfaces de
      @c(SujetoReal) y @c(Sujeto) sean la misma.

    - porporciona una interfaz identica a la de @c(Sujeto), de manera que un
      proxy pueda ser sustituido por el sujeto real.

    - controlar el acceso al sujeto real, y puede ser responsable de su creacion
      y borrado.

    - otras responsabilidades dependen del tipo de proxy:

      + los @e(proxies remotos) son reponsables de codificar una peticion y sus
        argumento para enviar la peticion codificada al sujeto que se encuentra
        en un espacio de direcciones diferente.

      + los @e(proxies virtuales) pueden guardar informacion adicional sobre el
        sujeto real, por lo que pueden retardar el acceso al mismo. Por ejemplo,
        el @c(ProxyImagen) de la seccion de @c(Motivacion) guarda la extension
        de la imagen real.

      + los @e(proxies de proteccion) comprueban que el llamador tenga los
        permisos de acceso necesarios para realizar una peticion.

  - @c(Sujeto) (@c(Grafico))

    - define la interfaz comun para el @c(SujetoReal) y el @c(Proxy), de modo
      que pueda usarse un Proxy en cualquier sitio en el que se espere un @c(SujetoReal).

  - @c(SujetoReal) (@c(Imagen))

    - define el objeto real representado.

*** Proxy Colaboraciones <> Colaboraciones

  El proxy redirige peticiones al @c(SujetoReal) cuando sea necesario,
  dependiendo del tipo de proxy.

*** Proxy Consecuencias <> Consecuencias

  El patron @c(Proxy) introduce un nivel de indireccion al acceder a un
  objeto. esta indireccion adicional tiene muchos posibles usos, dependiendo del
  tipo de proxy:

  1. Un proxy remoto puede ocultar el hecho de que un objeto reside en un
     espacio de direccions diferentes.

  2. Un proxy virtual puede llevar a cabo optimizaciones tales como crear un
     objeto por encargo.

  3. Tanto los proxies de proteccion, como las referencias inteligentes,
     permiten realizar tareas de mantenimiento adicionales cuando se accede a un
     objeto.

  Hay otra optimizacion que el patron Proxy puede ocultar al cliente. Se
  denomina @b(copia-de-escritura), y esta relacionada con la cleacion por
  encargo. Copiar un objeto grande y complejo puede ser una operacion costosa.
  Si dicha copia no se modifica nunca, no hay necesidad de incurrir en ese
  gasto. Al utilizar un proxy para posponer el proceso de copia nos estamos
  asegurando de que solo pagamos el precio de copiar el objeto en caso de que
  este sea modificado.

  Para realizar una copia-de-escritura el sujeto debe tener un contador de
  referencias. Copiar el proxy no sera mas que incrementar dicho contador. Solo
  cuando el cliente solicita una operacion que modifica el sujeto es cuando el
  proxy realmente lo copia. En este caso el proxy tambien tiene que disminuir el
  contador de referencias del sujeto. Cuando este llega a cero se borra el
  sujeto.

  La copia-de-escritura puede reducir significativamente el coste de copiar
  sujetos pesados.

*** Proxy Implementacion <> Implementacion

  El patron Proxy puede explotar las siguientes caracteristicas de los
  lenguajes:

  1. @e(Sobrecargar el operador de acceso a miembros en C++.) C++ admite la
     sobrecarga de @c(operator->), el operador de acceso a miembros. Sobrecargar
     este operador permite realizar tareas adicionales cada vez que se
     desreferencia un objeto, lo que puede resultar util para implementar
     algunos tipos de proxies; el proxy se comporta igual que un puntero.

     El siguiente ejemplo ilustra como usar esta tecnica para implementar un
     proxy virtual llamado @c(PunteroImagen).

     ..src > c++
       class Imagen;
       extern Imagen* CargarUnFicheroDeImagen(const char*);
           // funcion externa

       class PunteroImagen {
       public:
           PunteroImagen(const char* FicheroDeImagen);
           virtual ~PunteroImagen();

           virtual Imagen* operator->();
           virtual Imagen& operator*();
       private:
           Imagen* CargarImagen();
       private:
           Imagen* _imagen;
           const char* _ficheroDeImagen;
       };

       PunteroImagen::PunteroImagen (const char* elFicheroDeImagen) {
           _ficheroDeImagen = elFicheroDeImagen;
           _imagen = 0;
       }

       Imagen* PunteroImagen::CargarImagen () {
           if (_imagen == 0) {
               _imagen = CargarUnFicheroDeImagen(_ficheroDeImagen);
           }
           return _imagen;
       }
     < src..

     Los operadores sobrecargados @c(->) y @c(*) usan @c(CargarImagen) para
     devolver @c(_imagen) a sus llamadores (cargando la imagen si es necesario).

     ..src > c++
       Imagen* PunteroImagen::operator-> () {
           return CargarImagen();
       }

       Imagen& PunteroImagen::operator* () {
           return *CargarImagen();
       }
     < src..

     Este enfoque permite llamar a las operaciones de @c(Imagen) a travez de
     objetos @c(PunteroImagen) sin el problema de hacer a esas operaciones parte
     de la interfaz de @c(PunteroImagen):

     ..src > c++
       PunteroImagen imagen = PunteroImagen("nombreDeUnFicheroDeImagen");
       imagen->Dibujar(Punto(50, 100));
           // (Imagen.operator->())->Dibujar(Punto(50, 100))
     < src..

     Notese como el proxy de @c(imagen) funciona como un puntero, pero no esta
     declarado como un puntero a @c(Imagen). Eso significa que no se puede usar
     exactamente igual que un puntero real a @c(Imagen). Por tanto, con este
     enfoque los clientes deben tratar de forma diferente a los objetos
     @c(Imagen) y @c(PunteroImagen).

     Sobrecargar el operador de acceso a miembros no es una buena solucion para
     todos los tipos de proxies. Algunos necesitan saber exactamente @e(que)
     operacion es llamada, y en esos casos no sirve sobrecargar el operador de
     acceso a miembros.

     Piensese en el ejemplo del proxy virtual de la seccion de Motivacion. La
     imagen deberia cargarse en un determinado instante @-(en concreto, cuando
     se llama a la operacion @c(Dibujar)), y no cada vez que se hace referencia
     a la imagen. Sobrecargar el operador de accceso no permite realizar esta
     distincion. En ese caso debemos implementar manualmente cada operacion del
     proxy que redirige la peticion al sujeto.

     Estas operaciones sulen ser muy parecidas unas a otras, como se demuestra
     en el Codigo de Ejemplo. Normalmente todas las operaciones verifican que la
     peticion es legal, que existe el objeto original, etc., antes de redirigir
     la peticion al sujeto. Escribir este codigo una y otra vez es una labor
     tediosa. Por ese motivo, es frecuente usar un preprocesador para generarlo
     automaticamente.

  2. @e(Usar @c(doesNotUnderstand) en Smalltalk.) Smalltalk proporciona un
     enganche que se puede usar para permitir el reenvio automatico de
     peticiones. Smalltalk llama a @c(doesNotUnderstand:unMensaje) cuondo un
     cliente envia un mensaje a un receptor que no tiene el metodo
     correspondiente. La clase Proxy puede redefinir @c(doesNotUnderstand) para
     que el mensaje sea reenviado a su sujeto.

     Para garantizar que una peticion se redirge al sujeto y no es absorbida en
     silencio por su proxy, puede definirse una clase Proxy que no entienda
     @e(ningun) mensaje. Smalltalk permite hacer esto definiendo Proxy como una
     clase sin superclase.@n(39)

     El principal inconveniente de @c(doesNotUnderstand:) es que la mayoria de
     sistemas Smalltalk tienen unos pocos mensajes especiales que no son
     manejados directamente por la maquina virtual, y para estos no se lleva a
     cabo la habitual busqueda de metodos. El unico que suele estar implementado
     en Object (y que puede por tanto afectar a los proxies) es la operacion de
     identidad, @c(==).

     Si se decide usar @c(doesNotUnderstand:) para implementar Proxy sera
     necesario hacer un diseño que tenga en cuenta este problema. No se debe
     suponer que la identidad entre proxies significa que sus sujetos reales son
     tambien identicos. Un inconveniente añadido es que @c(doesNotUnderstand:)
     fue desarrollado para el tratamiento de errores, no para crear proxies, por
     lo que no suele ser demasiado rapida.

  3. @e(Los proxies no siempre tienen que conocer el tipo del sujeto real.) Si
     una clase Proxy puede tratar con su sujeto solo a traves de una interfaz
     abstracta, entonces no hay necesidad de hacer una clase Proxy para cada
     clase de @c(SujetoReal); el proxy puede tratar de manera uniforme a todas
     las clases @c(SujetoReal). Pero si los objetos Proxy van a crear instancias
     de @c(SujetoReal) (como en los casos de los proxies virtuales), entonces
     tienen que conocer la clase concreta.

  Otra cuestion de implementacion tiene que ver como referirse al sujeto antes
  de que se cree una instancia de este. Algunos proxies tienen que referirse a
  su sujeto independientemnete de que este en disco o en memoria. Eso significa
  que deben usar alguna forma de identificadores de objetos independientes del
  espacio de direcciones. En la seccion de Motivacion se uso un nombre de
  fichero para tal fin.

*** Proxy Codigo de Ejemplo <> Codigo de Ejemplo

  El siguiente codigo implementa dos tipos de proxies: el proxy virtual descrito
  en la seccion de Motivacion y un proxy implementado con
  @c(doesNotUnderstand:).@n(40)

  1. @e(Un proxy virtal.) La clase @c(Grafico) define la interfaz de los objetos
     graficos:

     ..src > c++
       class Grafico {
       publico:
           virtual ~Grafico();

           virtual void Dibujar(const Punto& en) = 0;
           virtual void ManejarRaton(Evento& evento) = 0;

           virtual const Punto& ObtenerExtension() = 0;

           virtual void Cargar(istream& desde) = 0;
           virtual void Guardar(ostream& en) = 0;
       protected:
           Grafico();
       };
     < src..

     La clase @c(Imagen) implementa la interfaz @c(Grafico) para mostrar
     ficheros de @c(Imagen). @c(Imagen) redefine @c(ManejarRaton) para que los
     usuarios puedan cambiar interactivamente el tamaño de la @c(Imagen).

     ..src > c++
       class imagen : public Grafico {
       public:
           imagen(const char* fichero);  // carga una Imagen desde un fichero
           virtual ~Imagen();

           virtual void Dibujar(const Punto& en);
           virtual void ManejarRaton(Evento& evento);

           virtual const Punto& ObtenerExtension();

           virtual void Cargar(istream& desde);
           virtual void Guardar(ostream& en);
       private:
           // ...
       };
     < src..

     @c(ProxyImagen) tiene la misma interfaz que @c(Imagen):

     ..src > c++
       class ProxyImagen : public Grafico {
       public:
           ProxyImagen(const char* FicheroDeImagen);
           virtual ~ProxyImagen();

           virtual void Dibujar(const Punto& en);
           virtual void ManejarRaton(Evento& evento);

           virtual const Punto& ObetenerExtension();

           virtual void Cargar(istream& desde);
           virtual void Guardar(ostream& en);
       protected:
           Imagen* ObtenerImagen();
       private:
           Imagen* _imagen;
           Punto _extension;
           char* _nombreDeFichero;
       };
     < src..

     El constructor guarda una copia local del nombre de fichero que contiene la
     @c(Imagen), e inicializa @c(_extension) e @c(_imagen):

     ..src > c++
       ProxyImagen::ProxyImagen (const char* nombreDeFichero) {
           _nombreDeFichero = strdup(nombreDeFichero);
           _extension = Punto::Cero; // todavia no se conoce la extension
           _imagen = 0;
       }

       Imagen* ProxyImagen::GetImagen() {
           if (_imagen == 0) {
               _imagen = new Imagen(_nombreDeFichero);
           }
           return _imagen;
       }
     < src..

     La implementacion de @c(ObtenerExtension) devuelve, si es posible, la
     extension guardada por el proxy; en otro caso se carga la @c(Imagen) desde
     el fichero. @c(Dibujar) carga la @c(Imagen), y @c(ManejarRaton) reenvia el
     evento a la @c(Imagen) real.

     ..src > c++
       const Punto& ProxyImagen::ObtenerExtension () {
           if (_extension == Punto::Cero) {
               _extension = ObtenerImagen()->ObtenerExtension();
           }
           return _extension;
       }

       void ProxyImagen::Dibujar (const Punto& en) {
           ObtenerImagen()->Dibujar(en);
       }

       void ProxyImagen::ManejarRaton (Evento& evento) {
           ObtenerImagen()->ManejarRaton(evento);
       }
     < src..

     La operacion @c(Guardar) graba en un flujo de salida la extension y el
     nombre del fichero de @c(Imagen) almacenados en el proxy. @c(Cargar)
     recupera esta informacion e inicializa los miembros correspondientes.

     ..src > c++
       void ProxyImagen::Guardar (ostream& en) {
           en << _extension << _nombreDeFichero;
       }

       void ProxyImagen::Cargar (istream& desde) {
           desde >> _extension >> _nombreDeFichero;
       }
     < src..

     Por ultimo, supongamos que tenemos una clase @c(DocumentoDeTexto) que puede
     contener obetos @c(Grafico):

     ..src > c++
       class DocumentoDeTexto {
       public:
           DocumentoDeTexto();

           void Insertar(Grafico*);
           // ...
       };
     < src..

     Podemos insertar un @c(ProxyImagen) en un documento de texto como se
     muestra a continuacion:

     ..src > c++
       DocumentoDeTexto* texto = new DocumentoDeTexto;
       // ...
       texto->Insertar(new ProxyImagen("nombreDeUnFicheroDeImagen"));
     < src..

  2. @e(Proxies que usan @c(doesNotUnderstand).) Se pueden crear proxies
     genericos en Smalltalk definiendo clases cuya superclase sea @c(nil)@n(41)
     y definiendo el metodo @c(doesNotUnderstand:) para manejar los mensajes.

     El siguiente metodo presupone que el proxy tiene un metodo @c(sujetoReal)
     que devuelve su sujeto real. En el caso de @c(ProxyImagen), este metodo
     comprobaria si se habia creado la @c(Imagen), la crearia si fuese necesario
     y finalmente la devolveria. Hace uso de @c(perform:withArguments:) para
     responder al mensaje que ha sido atrapado en el sujeto real.

     ..src > smalltalk
       doesNotUnderstand: unMensaje
           ^ self sujetoReal
               perform: unMensaje selector
               withArguments: unMensaje arguments
     < src..

     El argumento de @c(doesNotUnderstand:) es una instancia de @c(Message) que
     representa el mensaje que no entiende el proxy. Por tanto, el proxy
     responde a todos los mensajes asegurandose que existe el sujeto real antes
     de reenviarle el mensaje.

     Una de las ventajas de @c(doesNotUnderstand:) es que puede realizar un
     procesamiento arbitrario. Por ejemplo, podriamos obtener un proxy de
     proteccion especificando un conjunto @c(mensajesLegales) con los mensajes
     que deben ser aceptados y dandole al proxy el metodo siguiente:

     ..src > smalltalk
       doesNotUnderstand: unMensaje
           ^ (mensajesLegales includes: unMensaje selector)
               ifTrue: [self sujetoReal
                   perform: unMensaje selector
                   withArguments: unMensaje arguments]
               ifFalse: [self error: 'Operador ilegal']
     < src..

     Este metodo comprueba que un mensaje sea legal antes de redirigirlo al
     sujeto real. En caso de que no lo sea, enviara error: al proxy, lo que
     daria como resultado un bucle infinito de errores a menos que el proxy
     defina @c(error:). Por tanto, deberia copiarse la definicion de @c(error:)
     de la clase Object junto con cualquier metodo que use.

*** Proxy Usos Conocidos <> Usos Conocidos

  El proxy virtual de la seccion Motivacion esta tomado de las clases de ET++
  para construccion de bloques de texto.

  NEXTSTEP [@l(#Add94)] usa proxies (instancias de clase NXProxy) como proxies
  locales de objetos que pueden ser distribuidos. Un servidor crea proxies de
  objetos remotos cuando los solucitan lo clientes . Al recebir un mensaje, el
  proxy lo codifica junto con sus argumentos y envia el mensaje codificado al
  sujeto remoto. De forma similar, el sujeto codifica los resultados a devolver
  y los envia devuelta al objeto NXProxy.

  MeCullough [@l(#McC87)] examina el uso de proxies en Smalltalk para acceder a
  objetos remotos. Pascoe [@l(#Pas86)] describe como proporcionar efectos laterales y
  control de acceso en las llamadas a metodos mediante @"(Encapsuladores).

*** Proxy Patrones Relacionados <> Patrones Relacionados

  @l(#Adapter): un adaptador proporciona una interfaz diferente para el objeto
  que adapta. Por el contrario, un proxy tiene la misma interfaz que su
  sujeto. No obstante, un proxy utilizado para proteccion de acceso podria
  rechazar una operacion que el sujeto si realiza, de modo que su interfaz puede
  ser realmente un subconjunto de la del sujeto.

  @l(#Decorator): si bien los decoradores pueden tener una implementacion
  parecida a los prexies, tienen un proposito diferente. Un decorador añade una
  o mas responsabilidades a un objeto, mientras que un proxy controla el acceso
  a un objeto.

  Los proxies difieren en el grado de similitud entre su implementacion y la de
  un decorador. Un proxy de proteccion podria implementarse exactamente como un
  decorador. Por otro lado un proxy remoto no contendra una referencia directa a
  su sujeto real sino solo una referencia indirecta, como @"(un ID de maquina y
  la direccion local en dicha maquina). Un proxy virtual empezara teniendo una
  referencia indirecta como un nombre de fichero, pero podra al final obtener y
  utilizar una referencia directa.

** Discusion sobre los patrones estructurales

  Tal vez haya notado similitudes entre los patrones estructurales,
  especialmente en sus participantes y colaboradores. Esto es debido a que los
  patrones estructurales se basan en un mismo pequeño conjunto de mecanismos del
  lenguaje para estructurar el codigo y los objetos: herencia simple y herencia
  multiple para los patrones basados en clases, y composicion de objetos para
  los patrones de objetos. Pero estas similitudes ocultan los diferentes
  propositos de estos patrones. En esta seccion se comparan y contrastan grupos
  de patrones estructurales para ofrecerle una vision de los meritos de cada uno
  de ellos.

*** Adapter frente a Bridge

  Los patrones @l(#Adapter) y @l(#Bridge) tienen algunos atributos
  comunes. Ambos promueven la flexibilidad al proporcionar un nivel de
  indireccion a otro objeto. Ambos implican reenviar peticiones a este objeto
  desde una interfaz distinta de la suya propia.

  La diferencia fundamental entre estos patrones radica en su proposito. El
  patron Adapter se centra en resolver incompatibilidades entre dos interfaces
  existentes. No presta atencion a como se implementan dichas interfaces, ni
  tiene en cuenta como podrian evolucionar de forma independiente. Es un modo de
  lograr que dos clases diseñadas independientemente trabajen sin tener que
  volver a implementar una u otra. Por otro lado, el patron Bridge une una
  implementacion con sus implementaciones (que pueden ser numerosas).
  Proporciona una interfaz estable a los clientes permitiendo, no obstante, que
  cambien las clases que la implementan. Tambien permite incorporar nuevas
  implementaciones a medida que evoluciona el sistema.

  Como resultado de estas diferencias, los patrones Adapter y Bridge suelen
  usarse en diferentes puntos del ciclo de vida del software. Un adaptador suele
  hacerse necesario cuando se descubre que deberian trabajar juntas dos clases
  incompatibes, generalmente para evitar duplicar codigo, y este acoplamiento no
  habia sido provisto. Por el contrario, el usuario de un puente sabe de
  antemano que una abstraccion debe tener varias implementaciones, y que una y
  otras pueden variar independientemente. El patron Adapter hace que las cosas
  funcionen @e(despues) de que han sido diseñadas; el Bridge lo hace
  @e(antes). Eso no significa que el Adapter sea en modo alguno inferior al
  @c(Bridge); simplemente, cada patron resuelve un problema distinto.

  Podemos ver una fachada (vease el patron @l(#Facade)) como un adaptador para
  un conjunto de objetos. Pero esa implementacion obvia el hecho de que una
  fachada define una @e(nueva) interfaz, mientras que un adaptador reutiliza una
  interfaz existente. Recuerdese que un adaptador hace que trabajen juntos dos
  interfaces @e(existentes) en vez de tener que definir una completamente nueva.

*** Composite frente a Decorator y a Proxy

  Los patrones @l(#Composite) y @l(#Decorator) tienen diagramas de estructura
  parecidos, lo que refleja el hecho de que ambos se basan en la composicion
  recursiva para organizar un numero identerminado de objetos. Esta
  caracteristica en comun puede tentar a pensar en un objeto decorador como un
  compuesto degenerado, pero eso no representa la esencia del patron
  Decorator. El parecido termina en la composicion recursiva, al tratarse de
  nuevo de propositos diferentes.

  El patron Decorator esta diseñado para permitir añadir responsabilidades a
  objetos sin crear subclases. Esto evita la explosion de subclases a la que
  puede dar lugar al intentar cubrir cada combinacion de responsabilidades
  estaticamente. El patron Composite tiene un proposito diferente. Consiste en
  estructurar subclases para que se puedan tratar de manera uniforme muchos
  objetos relacionados, y que multiples objetos puedan ser tratados como uno
  solo. Es decir, no se centra en la decoracion sino en la representacion.

  Estos propositos son distintos pero complementarios. Por tanto, los patrones
  Composite y Decorador suelen usarse conjuntamente. Ambos llevan a la clase de
  diseño en la que se pueden construir aplicaciones simplemente poniendo juntos
  objetos sin definir ninguna clase nueva. Habra una clase abstracta con algunas
  subclases que son compuestos, otras que son decoradores y otras que
  implementan los principales bloques de construccion del sistema. En este caso,
  tanto compuestos como decoradores tendran una interfaz comun. Desde el punto
  de vista del patron Decorador, un compuesto es un @c(ComponenteConcreto).
  Desde el punto de vista del patron Composite, un decorador es una @c(Hoja).
  Por supuesto, no tienen por que ser usados juntos, y, como hemos visto, sus
  propositos son bastante distintos.

  Otro patron con una estructura similar al Decorador es el @l(#Proxy). Ambos
  patrones describen como proporcionar un nivel de indireccion a un objeto, y
  las implemenaciones de los objetos proxy y decorador mantienen una referecia a
  otro objeto, al cual reenvian peticiones. Una vez mas, no obstante, estan
  pensados para propositos diferentes.

  Al igual que el Decorador, el patron Proxy compone un objeto y proporciona una
  interfaz identica a los clientes. A diferencia del Decorator, el patron Proxy
  no tiene que ver con asignar o quitar propiedades dinamicamente, y tampoco
  esta diseñado para la composicion recursiva. Su proposito es proporcionar un
  sustituto para un sujeto cuando no es conveniente o deseable acceder
  directamente a el, debido, por ejemplo, a residir en una maquina remota, tener
  acceso restringido o ser persintente.

  En el patron Proxy, el sujeto define la principal funcionalidad, y el proxy
  proporciona (o rechaza) el acceso al mismo. En el Decorador, el componente
  proporciona solo parte de funcionalidad, y uno o mas decoradores hacen el
  resto. El patron Decorator se encarga de aquellas situaciones en las que no se
  puede determinar toda la funcionalidad de un objeto en tiempo de compilacion,
  o al menos no resulta conveniente hacerlo. Ese no es el caso del Proxy, ya que
  este se centra en una relacion @-(entre el proxy y su sujeto) y dicha relacion
  puede expresarse estaticamente.

  Estas diferencias son significativas, ya que representan soluciones a
  problemas concretos y recurrentes en el diseño orientado a objetos. Pero eso
  no significa que estos patrones no puedan combinarse. Podriamos pensar en un
  proxy-decorador que añadiese funcionalidad a un proxy, o en un decorador-proxy
  que adornase un objeto remoto. Si bien tales hibridos @e(pueden) ser utiles
  (no tenemos ejemplos reales a mano), pueden dividirse en patrones que
  @e(realmente) son utiles.

* Capitulo 5 <> Patrones de Comportamiento

  Los patrones de comportamiento tienen que ver con algoritmos y con la
  asignacion de responsabilidades a objetos. Los patrones de comportamiento
  describen no solo patrones de clases y objetos, sino tambien patrones de
  comunicacion entre ellos. Estos patrones describen el flujo de control
  complejo que es dificil de seguir en tiempo de ejecucion, lo que nos permite
  olvidarnos del flujo de control para centrarnos simplemente en el modo en que
  se interconectan los objetos.

  Los patrones de comportamiento basados en clases usan la herencia para
  distribuir el comporatamiento entre clase. Este capitulo incluye dos de estos
  patrones. El patron @l(#Template Method) es el mas simple y comun de los
  dos. Un metodo plantilla es una definicion abstracta a una operacion
  primitiva. Una subclase es la encargada de completar el algoritmo definiendo
  las operaciones abstractas. El patron de comportamiento basado en clases es el
  @l(Interpreter), que representa una gramatica como una jerarquia de clases e
  implementa un interprete como una operacion sobre las instancias de dichas
  clases.

  Los patrones de comportamiento basados en objetos usan la composicion de
  objetos en vez de la herencia. Algunos describen como cooperan un grupo de
  objetos parejos para realizar una tarea que ningun objeto individual puede
  llevar a cabo por si solo. Una cuestion importante es como los objetos saben
  unos de otros. Cada uno podria mantener referencias explicitas al resto, pero
  eso incrementaria su acoplamiento. Llevado al limite, cada objeto conoceria a
  todos los demas. El patron @l(#Mediator) evita esto introduciendo un objeto
  mediador entre todos los objetos parejos. El mediador proporciona la
  indireccion necesaria para un bajo acoplamiento.

  El patron @l(#Chain of Responsibility) proporciona un acoplamiento aun mas
  bajo. Permite enviar peticiones a un objeto implicitamente, a traves de una
  cadena de objetos candidatos. Cualquier candidato puede satisfacer la peticion
  dependiendo de una serie de condiciones en tiempo de ejecucion. El numero de
  candidatos es indeterminado, y se puede seleccionar en tiempo de ejecucion que
  candidatos participan en la cadena.

  El patron @l(#Observer) define y mantiene una dependencia entre objetos. El
  ejemplo clasico de @l(#Observer) tiene lugar en el Modelo/Vista/Controlador de
  Smalltalk, donde todas las vistas del modelo son avisadas cada vez que cambia
  el estado del mismo.

  Otros patrones de comportamiento basados en objetos estan relacionados con la
  encapsulacion de comportamiento en un objeto, delegando las peticiones a dicho
  objeto. El patron @l(#Strategy) encapsula un algoritmo en un objeto,
  facilitando especificar y cambiar el algoritmo que usa un objeto. El patron
  @l(#Command) encapsula una peticion en un objeto de modo que pueda ser pasada
  como parametro, guardada en un historia o manipulada de alguna otra forma. El
  patron @l(#State) encapsula los estados de un objeto para que este pueda
  cambiar su comportamiento cuando cambia su estado. El @l(#Visitor) encapsula
  comportamiento que de otro modo estaria distribuido en varias clases, y el
  @l(#Iterator) abstrae el modo en que accede y se recorren los objetos de una
  agrecacion.

** Chain of Responsibility
*** Chain of Responsibility Proposito <> Proposito

  Evita acoplar el emisor de una peticion a su receptor, dando a mas de un
  objeto la posibilidad de responder a la peticion. Encadena los objetos
  receptores y pasa la peticion a traves de la cadena hasta que es procesada por
  algun objeto.

*** Chain of Responsibility Motivacion <> Motivacion

  Supongamos un servicio de ayuda sensible al contexto para una interfaz grafica
  de usuario. El usuaria puede obtener informacion de ayuda en cualquier parte
  de la interfaz simplemente pulsando con el raton sobre ella. La ayuda
  proporcionada depende de la parte de la interfaz que se haya seleccionado asi
  como de su contexto; por ejemplo, un boton de un cuadro de dialogo puede tener
  diferente informacion de ayuda que un boton similar de la ventana principal.
  Si no existe informacion de ayuda especifica para esa parte de la interfaz el
  sistema de ayuda deberia mostrar un mensaje de ayuda mas general sobre el
  contexto inmediato, por ejemplo, sobre el cuadro de dialogo en si.

  De hay que sea natural organizar la informacion de ayuda de acuerdo con su
  generalidad @-(de lo mas especifico a lo mas general). Ademas, esta claro que
  una peticion de ayuda es manejada por un objeto entre varios de la interfaz de
  usuario; el objeto concreto depende del contexto y de la especificidad de la
  ayuda disponible.

  El problema es que el objeto que en ultima instancia @e(proporciona) la ayuda
  no conoce explicitamente al objeto (por ejemplo, el boton) que @e(inicializa)
  la peticion de ayuda. Necesitamos un modo de desacoplar el boton que da lugar
  a la peticion de ayuda de los objetos que podrian proporcionar dicha
  informacion. El patron Chain of Responsibility define como hacer esto.

  La idea de este patron es desacoplar a los emisores y a los receptores dandole
  a varios objetos la posibilidad de tratar una peticion. La peticion se pasa a
  travez de una cadena de objetos hasta que es procesada por uno de ellos.

  ..img > img/083.png

  El primer objeto de la cadena recibe la peticion y, o bien la procesa o bien
  la redirie al siguiente candidato en la cadena, el cual hace lo mismo. El
  objeto que hizo la peticion no tien un conocimiento explicito de quien la
  tratara @-(decimos que la peticion tiene un @b(receptor implicito)).

  Supongamos que el usuario solicita ayuda sobre un boton denominado
  @"(Imprimir). El boton se encuentra en una instancia de
  @c(DialogoDeImpresion), que sabe a que objeto de aplicacion pertenece @(vease
  el diagramade objetos precedente). El siguiente diagrama de interaccion ilustra
  como la peticion de ayuda se reenvia a travez de la cadena.

  ..img > img/084.png

  En este caso, la peticion no es procesada ni por @c(unBotonDeImpresion) ni por
  @c(unDialogoDeImpresion); se detiene en @c(unaAplicacion), quien puede
  procesarla u obviarla. El cliente que dio origen a la peticion no tiene niguna
  referencia directa al objeto que finalmente la satisface.

  Para reenviar la peticion a lo largo de la cadena, y para garantizar que los
  receptores permanecen implicitos, cada objeto de la cadena comparte una
  interfaz comun para procesar peticiones y para acceder a su @b(sucesor) en la
  cadena. Por ejemplo, el sistema de ayuda podria definir una clase
  @c(ManejadorDeAyuda) con su correspondiente operacion @c(ManejarAyuda).
  @c(ManejadorDeAyuda) puede ser la clase padre de las clases de objetos
  candidatos, o bien puede ser definida como una clase mezclable. Entonces las
  clases que quieran manejar peticiones de ayuda pueden hacer que
  @c(ManejadorDeAyuda) sea uno de sus padres:

  ..img > img/085.png

  Las clases @c(Boton), @c(Dialogo) y @c(Aplicacion) usan las operaciones de
  @c(ManejadorDeAyuda) para tratar peticiones de ayuda. La operacion
  @c(ManejarAyuda) de @c(ManejadorDeAyuda) reenvia la peticion al sucesor de
  manera predeterminada. Las subclases pueden redefinir esta operacion para
  proporcionar ayuda en determinadas circunstancias; en caso contrario, pueden
  usar la implementacion predeterminada para reenviar la peticion.

*** Chain of Responsibility Aplicabilidad <> Aplicabilidad

  Usese el patron Chain of Responsibility cuando

  - hay mas de un objeto que pueden manejar una peticion, y el manejador no
    se conoce @e(a priori), sino que deberia determinarse automaticamente

  - se quiere enviar una peticion a un objeto entre varios sin especificar
    explicitamente el receptor.

  - el conjunto de objetos que pueden tratar una peticion deberia ser
    especificado dinamicamente

*** Chain of Responsibility Estructura <> Estructura

  ..img > img/086.png

  Una estructura de objetos tipica podria parecerse a esta:

  ..img > img/087.png

*** Chain of Responsibility Participantes <> Participantes

  - @c(Manejador) (@c(ManejadorDeAyuda))

    - define una interfaz para tratar las peticiones.

    - (opcional) implementa el enlace al sucesor.

  - @c(ManejadorConcreto) (@c(BotonDeImpresion), @c(DialogoDeImpresion))

    - trata las peticiones de las que es responsable.

    - puede acceder a su sucesor.

    - si el @c(ManejadorConcreto) puede manejar la peticion, lo hace; en caso
      contrario la reenvia a su sucesor.

  - @c(Cliente)

    - inicializa la peticion a un objeto @c(ManejadorConcreto) de la cadena.

*** Chain of Responsibility Colaboraciones <> Colaboraciones

  Cuando un cliente envia una peticion, esta se propaga a traves de la cadena
  hasta que un objeto @c(ManejadorConcreto) se hace responsable de procesarla.

*** Chain of Responsibility Consecuencias <> Consecuencias

  Este patron tiene las siguientes ventajas e inconvenientes:

 1. @e(Reduce el acoplamiento.) El patron libera a un objeto de tener que saber
    que otro objeto maneja una peticion. Un objeto solo tiene que saber que una
    peticion sera manejada @"(de forma apropiada). Ni el receptor ni el emisor
    se conocen explicitamente entre ellos, y un objeto de la cadena tampoco
    tiene que conocer la estructura de esta.

    Como resultado, la Cadena de Responsabilidad puede simplificar las
    interconecciones entre objetos. En vez de que los objetos mantengan
    referencias a todos los posibles receptores, solo tienen una unica
    referencia a su sucesor.

 2. @e(Añade flexibilidad para asignar responsabilidades a objetos.) La Cadena
    de Responsabilidad ofrece una flexibilidad añadida para repartir
    responsabilidades entre objetos. Se pueden añadir o cambiar
    responsabilidades para tratar una peticion modificando la cadena en tiempo
    de ejecucion. Esto se puede combinar con la herencia para especializar los
    manejadores estaticamente.

 3. @e(No se garantiza la recepcion.) Dado que las peticiones no tienen un
    receptor explicito, no hay garantia de que sean manejadas @-(la peticion
    puede alcanzar el final de la cadena sin haber sido procesada). Una peticion
    tambien puede quedar sin tratar cuardo la cadena no esta configurada
    correctamente.

*** Chain of Responsibility Implementacion <> Implementacion

  Estos son algnos detalles de implementacion a tener en cuenta sobre la Cadena
  de Responsabilidad:

  1. @e(Implementacion de la cadena sucesora.) Hay dos formas posibles de
     implementar la cadena sucesora:

     a. Definir nuevos enlaces (normalmente en el @c(Manejador), pero
        tambien podria ser en los objetos @c(ManejadorConcreto)).

     b. Usar los enlaces existentes.

     Los ejemplos mostrados hasta ahora definen nuevos enlaces, pero muchas
     veces se pueden usar referencias a objetos existentes para formar la cadena
     sucesora. Por ejemplo, las referencias al padre en una jerarquia de
     parte-todo pueden definir el sucesor de una parte. Una estructura de
     utiles@n(28) puede que ya tenga dichos enlaces. El patron @l(Composite)
     describe las referencias al padre con mas detalle.

     Usar enlaces existetes funciona bien cuando los enlaces permiter la cadena
     que necesitamos. Nos evita tener que definir explicitamente nuevos enlaces
     y ahorra espacio. Pero si la estructura no refleja la cadena de
     responsabilidad que necesita nuestra aplicacion habra que definir enlaces
     redundantes.

  2. @e(Conexion de los sucesores.) Si no hay referencias preexistentes para
     definir una cadena, entoces tendremos que introducirlas nosotros mismos. En
     ese caso, el @c(Manejador) no solo define la interfaz para las peticiones,
     sino que normalmente tambien se encarga de matener el sucesor. eso permite
     que el manejador proporcione una implementacion predeterminada de
     @c(ManejarPeticion) que reenvia la peticion al sucesor (si hay alguno). Si
     una subclase de @c(ManejadorConcreto) no esta interesada en dicha peticion,
     no tiene que redefinir la operacion de reenvio, puesto que la
     implementacion predeterminada la reenvia incondicionalmente.

     A continuacion se muestra una clase base @c(ManejadorDeAyuda) que mantiene
     un enlace al sucesor:

     ..src > c++
       class ManejadorDeAyuda {
       public:
           ManejadorDeAyuda(ManejadorDeAyuda* s) : _sucesor(s) { }
           virtual void ManjarAyuda();
       private:
           ManejadorDeAyuda* _sucesor;
       };

       void ManjadorDeAyuda::ManejarAyuda () {
           if (_sucesor) {
               _sucesor->ManejarAyuda();
           }
       }
     < src..

  3. @e(Representacion de las peticiones.) Hay varias opciones para representar
     las peticiones. En su forma mas simple, una peticion es una invocacion a
     una operacion insertada en el codigo, como en el caso de @c(ManejarAyuda).
     Esto resulta conveniente y seguro, pero entonces solo se pueden reenviar el
     conjunto prefijado de peticiones que define la clase @c(Manejador).

     Una alternativa es usar una unica funcion manejadora que reciba un codigo
     de peticion (por ejemplo, una constante entera o una cadena) como
     parametro. Esto permite un numero arbitrario de peticiones. El unico
     requisito es que el emisor y el receptor se pongan de acuerdo sobre como
     debe codificarse la peticion.

     Este enfoque es mas flexible, pero requiere sentencias condicionales para
     despachar la peticion en funcion de su codigo. Y, lo que es peor, no hay un
     modo de pasar los parametros seguro con respecto al tipo, por lo que estos
     deben ser empaquetados y desempaquetados manualmente. Obviamente, esto es
     menos seguro que invocar una operacion directamente.

     Para resolver el problema del paso de parametros, podemos usar para las
     peticiones @e(objetos) aparte que incluyan los parametros de la
     peticion. Una clase @c(Peticion) puede representar peticiones
     explicitamente, y se pueden definir nuevos tipos de peticiones mediante
     herencia. Las subclases pueden definir diferentes parametros. Los
     manejadores deben conocer el tipo de peticion (esto es, que subclase de
     @c(Peticion) estan usando) para acceder a estos parametros.

     Para identificar la peticion, @c(Peticion) puede definir una funcion de
     acceso que devuelva un identificador para la clase. Por otro lado, el
     receptor puede usar informacion de tipos en tiempo de ejecucion en caso de
     que el lenguaje de implementacion lo permita.

     A continuacion se muestra un esbozo de una funcion de despacho que usa
     objetos peticion para identificar las peticiones. Una operacion
     @c(ObtenerTipo) definida en la clase base @c(Peticion) identifica el tipo
     de peticion:

     ..src > c++
       void Manejador::ManejarPeticion (Peticion* laPeticion) {
           switch (laPeticion->ObjetoTipo()) {
           case Ayuda:
               // convierte el argumento al tipo apropiado
               ManejarAyuda((PeticionDeAyuda*) laPeticion);
               break;

           case Impresion:
               ManejarImpresion((PeticionDeImpresion*) laPeticion);
               // ...
               break;

           default:
               // ...
               break;
           }
       }
     < src..

     Las subclases pueden extender el despacho redefiniendo @c(ManejarPeticion).
     La subclase maneja solo aquellas peticiones en las que esta interesada;
     otras peticiones son reenviadas a la clase padre. De esta forma, las
     subclases efectivamente extienden (en vez de redefinir) la operacion
     @c(ManejarPeticion). Por ejemplo, asi es como una subclase
     @c(ManejadorExtendido) extiende la version de @c(ManejarPeticion) de
     @c(Manejador):

     ..src > c++
       class ManejadorExtendido : public Manejador {
       public:
           virtual void ManejarPeticion(Peticion* laPeticion);
           // ...
       };

       void ManejadorExtendido::ManejarPeticion (Peticion* laPeticion) {
           switch (laPeticion->ObtenerTipo()) {
           case VistaPreliminar:
               // trata la operacion VistaPreliminar
               break;

           default:
               // permite que Manejador trate otras peticiones
               Manejador::ManejarPeticion(laPeticion);
           }
       }
     < src..

  4. @e(Reenvio automatico en Smalltalk.) Podemos usar el mecanismo de Smalltalk
     @c(doesNotUnderstand) para reenviar peticiones. Los mensajes que no tienen su
     metodo correspondiente son atrapados en la implementacion de
     @c(doesNotUnderstand), que puede ser redefinida para reenviar el mensaje a
     un sucesor del objeto. De esa manera no es necesario implementar
     manualmente el reenvio; la clase maneja solo la peticion en la que esta
     interesada, y deja a @c(doesNotUnderstand) el reenvio de todas las demas.

*** Chain of Responsibility Codigo de Ejemplo <> Codigo de Ejemplo

  El siguiente ejemplo ilustra como una cadena de responsabilidad puede manejar
  peticiones para un sistema de ayuda en linea como el descrito anteriormente.
  La peticion de ayuda es una operacion explicita. Usaremos las referencias al
  padre existentes en la jerarquia de utiles para propagar peticiones extre
  utiles de la cadena, y definiremos una referencia en la clase @c(Manejador)
  para propagar las peticiones de ayuda entre los elementos de la cadena que no
  sean utiles.

  La clase @c(ManejadorDeAyuda) define la interfaz para manejar peticiones de
  ayuda. Mantiene un tema de ayuda (que, de manera predeterminada, siempre esta
  vacio) y guarda una referencia a su sucesor en la cadena de manejadores de
  ayuda. La operacion principal es @c(ManejarAyuda), la cual es redefinida por
  las subclase. @c(TieneAyuda) es una operacion de conveniencia para comprobar
  si existe un tema de ayuda asociado.

  ..src > c++
    typedef int Tema;
    const Tema SIN_TEMA_DE_AYUDA = -1;

    class ManejadorDeAyuda {
    public:
        ManejadorDeAyuda(ManejadorDeAyuda* = 0, Tema = SIN_TEMA_DE_AYUDA);
        virtual bool TieneAyuda();
        virtual void EstablecerManejador(ManejadorDeAyuda*, Tema);
        virtual void ManejarAyuda();
    private:
        ManejadorDeAyuda* _sucesor;
        Tema _tema;
    };

    ManejadorDeAyuda::ManejadorDeAyuda (
        ManejadorDeAyuda* m, Tema t
    ) : _sucesor(m), _tema(t) { }

    bool ManejadorDeAyuda::TieneAyuda () {
        return _tema != SIN_TEMA_DE_AYUDA;
    }

    void ManejadorDeAyuda::ManejarAyuda () {
        if (_sucesor != 0) {
            _sucesor->ManejarAyuda();
        }
    }
  < src..

  Todos los utiles son subclases de la clase abstracta @c(Util.Util) es una
  subclase de @c(ManejadorDeAyuda), ya que todos los elementos de la interfaz de
  usuario pueden tener ayuda asociada a ellos (tambien podriamos haber usado una
  implementacion basada en una clase mezclable).

  ..src > c++
    class Util : public ManejadorDeAyuda {
    protected:
        Util(Util* padre, Tema t = SIN_TEMA_DE_AYUDA);
    private:
        Util* _padre;
    };

    Util::Util (Util* u, Tema t) : ManejadorDeAyuda(u, t) {
        _padre = u;
    }
  < src..

  En nuestro ejemplo de boton es el primer manejador de la cadena. La clase
  @c(Boton) es una subclase de @c(Util). El constructor de @c(Boton) toma dos
  parametros: una referencia al util que lo contiene y el tema de ayuda.

  ..src > c++
    class Boton : public Util {
    public:
        Boton(Util* d, Tema t = SIN_TEMA_DE_AYUDA);

        virtual void ManejarAyuda();
        // Las operaciones de Util redefinidas por Boton...
    };
  < src..

  La version de @c(ManejarAyuda) de @c(Boton) en primer lugar comprueba si hay
  un tema de ayuda para los botones. Si el desarrollador no ha definido ninguno,
  entonces la peticion es reenviada al sucesor usando la operacion
  @c(ManejarAyuda) de @c(ManejadorDeAyuda). Si @e(hay) un tema de ayuda el boton
  muestra y termina la busqueda.

  ..src > c++
    Boton::Boton (Util* h, Tema t) : Util(h, t) { }

    void Boton::ManejarAyuda () {
        if (TieneAyuda()) {
            // ofrecer ayuda sobre el boton
        } else {
            ManejadorDeAyuda::ManejarAyuda();
        }
    }
  < src..

  @c(Dialogo) implementa un esquema similar, salvo que su sucesor no es un util,
  sino @e(cualquier) manejado de ayuda. En nuestra aplicacion este sucesor sera
  una instancia de @c(Aplicacion).

  ..src > c++
    class Dialogo : public Util {
    public:
        Dialogo(ManejadorDeAyuda* m, Tema t = SIN_TEMA_DE_AYUDA);
        virtual void ManejarAyuda();

        // las operaciones de Util redefinidas por Dialogo...
        // ...
    };

    Dialogo::Dialogo (ManejadorDeAyuda* m, Tema t) : Util(0) {
        EstablecerManejador(m, t);
    }

    void Dialogo::ManejadorAyuda() {
        if (TieneAyuda()) {
            // ofrecer ayuda sobre el dialogo
        } else {
            ManejadorDeAyuda::ManejarAyuda();
        }
    }
  < src..

  Al final de la cadena hay una instancia de @c(Aplicacion). La aplicacion no
  es un util, por lo que @c(Aplicacion) hereda directamente de
  @c(ManejadorDeAyuda). Cuando una peticion de ayuda se propaga hasta este
  nivel, la aplicacion puede proporcionar informacion sobre la aplicacion en
  general, o puede ofrecer una lista con los distintos temas de ayuda:

  ..src > c++
    class Aplicacion : public ManejadorDeAyuda {
    public:
        Aplicacion(Tema t) : ManejadorDeAyuda(0, t) { }

        virtual void ManejarAyuda();
        // operaciones especificas de la aplicacion...
    };

    void Aplicacion::ManejarAyuda () {
        // muestra una lista de temas de ayuda
    }
  < src..

  El siguiente codigo crea estos objetos y los conecta. En este caso el dialogo
  es sobre la impresion, y por tanto los objetos tienen asignados temas
  relacionados con la impresion.

  ..src > c++
    const Tema TEMA_IMPRESION = 1;
    const Tema TEMA_ORIENTACION_PAPEL = 2;
    const Tema TEMA_APLICACION = 3;

    Aplicacion* aplicacion = new Aplicacion(TEMA_APLICACION);
    Dialogo* dialogo = new Dialogo(aplicacion, TEMA_IMPRESION);
    Boton* boton = new Boton(dialogo, TEMA_ORIENTACION_PAPEL);
  < src..

  Podemos invocar a la peticion de ayuda llamando a @c(ManejarAyuda) en
  cualquier objeto de la cadena. Para comenzar la busqueda en el objeto @c(boton)
  basta con llamar a @c(ManejarAyuda) sobre el:

  ..src > c++
    boton->ManejarAyuda();
  < src..

  En este caso, el boton manejara la peticion inmediatamente. Notese que
  cualquier clase @c(ManejadorDeAyuda) podria ser el sucesor de @c(Dialogo). Mas
  aun, podria cambiarse dinamicamente su sucesor. De modo que no importa donde
  se use un dialogo, siempre se obtendra la informacion de ayuda dependiente del
  contexto apropiada para el.

*** Chain of Responsibility Usos Conocidos <> Usos Conocidos

  Varias bibliotecas de clases usan el patron Chain of Responsibility para
  manejar los eventos de usuario. Aunque usan distintos nombres para la clase
  @c(Manejador), la idea es la misma: cuando el usuario hace clic con el raton o
  pulsa una tecla, se genera un evento y se pasa a lo largo de la cadena. MacApp
  [@l(#App89)] y ET++ [@l(#WGM88)] lo llaman @"c(EventHandler) (manejador de eventos) la
  biblioteca TCL de Symantec [@l(#Sym93b)] lo llama @"c(Bureaucrat) (burocrata) y
  AppKit de NeXT [@l(#Add94)] usa el nombre @"c(Responder) (respondedor).

  El framework de editores graficos Unidraw define objetos @c(Command) que
  encapsulan peticiones a los objetos @c(Component) y @c(ComponentView)
  [@l(#VL90)]. Las ordenes son peticiones en el sentido de que un componente o una
  vista de un componente pueden interpretar una orden para realizar una
  operacion. Esto se corresponde con el enfoque de @"(peticiones como objetos)
  descrito en la seccion de Implementacion. Los componentes y las vistas de
  componentes se pueden estructurar jerarquicamente. Un componente o una vista
  de componente pueden reenviar interpretaciones de ordenes a su padre, quien a
  su vez puede reenviarlas a su padre y asi sucesivamente, formando asi una
  cadena de responsabilidad.

  ET++ usa una Cadena de Responsabilidad para tratar la actualizacion de
  graficos. Un objeto @c(grafico) llama a la operacion @c(InvalidateRect) cada vez
  que debe actualizarse una parte de su represantacion. Un objeto grafico no
  puede manejar @c(InvalidateRect) el mismo, ya que no sabe lo suficiente sobre
  su contexto. Por ejemplo, un objeto grafico puede formar parte de objetos como
  barras de desplazamiento o @e(zooms) que transforman su sistema de
  coordenadas. Eso significa que podemos desplazarnos o hacer @e(zoom) sobre el
  objeto, de manera que este quede parcialmente oculto. Por tanto la
  implementacion predeterminada de @c(InvalidateRect) reenvia la peticion al
  objeto contenedor. El ultimo objeto de la cadena de reenvio es una instancia
  de @c(Window). En el momento en que @c(Window) recibe la peticion, se
  garantiza que el rectangulo de invalidacion se transforma correctamente. El
  objeto @c(Window) trata @c(InvalidateRect) notificando a la interfaz del
  sistema de ventanas y solicitando actualizarse.

*** Chain of Responsibility Patrones Relacionados <> Patrones Relacionados

  Este patron se suele aplicar conjuntamente con el patron @l(#Composite). En
  el, los padres de los componentes pueden actuar como sucesores.

** Command
*** Command Proposito <> Proposito

  Encapsula una peticion en un objeto, permitiendo asi parametrizar a los
  clientes con diferentes peticiones, hacer cola o llevar un registro de las
  peticiones, y poder deshacer las operaciones.

*** Command Tambien Conocido Como <> Tambien Conocido Como

  Action (Accion), Transaction (Transaccion)

*** Command Motivacion <> Motivacion

  A veces es necesario enviar peticiones a objetos sin saber nada acerca de la
  operacion solicitada o de quien es el receptor de la peticion. Por ejemplo,
  los toolkits de interfaces de usuario incluyen objetos como botones y menus
  que realizan una peticion en ruespuesta a una entrada de usuario. Pero el
  toolkit no puede implementar la peticion explicitamente en el boton o el menu,
  ya que solo las aplicaciones que usan el toolkit saben que deberia hacerse y
  sobre que objeto. Como diseñadores de toolkits no tenemos modo de conocer al
  receptor de la peticion ni de saber que operaciones se efectuaran.

  El patron Command permite que los objetos del toolkit hagan peticiones a
  objetos de la aplicacion no especificados, convirtiendo a la propia peticion
  en un objeto, el cual se puede guardar y enviar exactamente igual que
  cualquier otro objeto. La clave de este patron es una clase abstracta
  @c(Orden), que declara una interfaz para ejecutar operaciones. En su forma mas
  simple, esta interfaz incluye una operacion abstracta @c(Ejecutar). Las
  subclases concretas de @c(Orden) especifican un par receptor-accion, guardando
  el receptor como una variable de instancia e implementando @c(Ejecutar) para
  que invoque a la peticon. El receptor posee el conocimiento necesario para
  llevar a cabo la peticion.

  ..img > img/088.png

  Los menus se pueden implementar facilmente con objetos @c(Orden). Cada opcion
  de un @c(Menu) es una instancia de una clase @c(ElementoDeMenu). La clase
  @c(Aplicacion) es la encargada de crea estos menus y sus elementos de menu
  junto con el resto de la interfaz de usuario. Tambien es esta clase quien sabe
  que objetos @c(Documento) han sido abiertos por un usuario.

  La aplicacion configura cada @c(ElementoDeMenu) con una instancia de una
  subclase concreta de @c(Orden). Cuando el usuario selecciona un
  @c(ElementoDeMenu), este llama al metodo @c(Ejecutar) de su orden, quien
  lleva a cabo la operacion. Los objetos @c(ElementoDeMenu) no saben que
  subclase de @c(Orden) usan. Las subclases de @c(Orden) almacenan el receptor de
  la peticion e invocan sobre el una o mas operaciones.

  Por ejemplo, @c(OrdenPegar) permite pegar texto del portapapeles en un
  @c(Documento). El receptor de @c(OrdenPegar) es el objeto @c(Documento)
  proporcionado cuando se crea una instancia de aquella. La operacion
  @c(Ejecutar) llama a @c(Pegar) sobre el @c(Documento) receptor.

  ..img > img/089.png

  La operacion @c(Ejecutar) de @c(OrdenAbrir) es diferente: le pregunta al
  usuario el nombre de un documento, crea el correspondiente objeto
  @c(Documento), lo añade a la aplicacion receptora y abre el documento.

  ..img > img/090.png

  A veces un @c(ElementoDeMenu) necesita ejecutar una @e(secuencia) de
  ordenes. Por ejemplo, podria construirse un @c(ElementoDeMenu) para centrar
  una pagina a tamaño normal a partir de un objeto @c(OrdenCentrarDocumento) y
  de otro objeto @c(OrdenTamanoNormal). Dado que es habitual concatenar ordenes
  de este modo, podemos definir una clase @c(OrdenMacro) para permitir que un
  @c(ElementoDeMenu) ejecute un numero indefinido de ordenes. @c(OrdenMacro) es
  una subclase concreta de @c(Orden) que simplemente ejecuta una secuencia de
  ordenes. @c(OrdenMacro) no tiene ningun receptor explicito, sino que son las
  ordenes que contiene las que definen su propio receptor.

  ..img > img/091.png

  Notese como, en cada uno de los ejemplos anteriores, el patron @c(Orden)
  desacopla el objeto que invoca la operacion de aquel que posee el conocimiento
  para realizarla. Esto nos da mucha flexibilidad para diseñar nuestra interfaz
  de usuario. Una aplicacion puede proporcionar un menu y un boton como
  interfaces para una misma funcion simplemente haciendo que ambos compartan una
  instancia de la misma subclase concreta de @c(Orden). Podemos reemplazar
  ordenes dinamicamente, lo que sera util para implementar menus sencibles al
  contexto. Tambien podemos permitir la creacion de ondenes mediante la
  composicion de unas ordenes en otras mas grandes. Todo esto es posible debido
  a que el objeto que emite la peticion solo necesita saber como enviarla; no
  necesita saber como se ejecutara la peticion.

*** Command Aplicabilidad <> Aplicabilidad

  Usese el patron Command cuando se quiera

  - parametrizar objetos con una accion a realizar, como ocurriria con los
    objetos @c(ElementoDeMenu) anteriores. En un lenguaje de procedimiento se
    puede expresar dicha parametrizacion con una funcion @b(callback), es decir,
    con una funcion que esta registrada en algun sitio para que sea llamada mas
    tarde. Los objetos @c(Orden) son un sustituto orentado a objetos para las
    funciones callback.

  - especificar, poner en cola y ejecutar peticiones en diferentes instantes de
    tiempo. Un objeto @c(Orden) puede tener un tiempo de vida independiente de la
    peticion original. Si se puede representar el receptor de una peticion en
    una forma independiente del espacio de direcciones, entonces se puede
    transferir un objeto @c(Orden) con la peticion a un proceso diferente y llevar a
    cabo la peticion alli.

  - permitir deshacer. La operacion @c(Ejecutar) de @c(Orden) puede guardar en
    la propia orden el estado que anule sus efectos. Debe añadirse a la interfaz
    @c(Orden) una operacion @c(Deshacer) que anule los efectos de una llamada
    anterior a @c(Ejecutar). Las ordenes ejecutadas se guarda en una lista  que
    hace las veces de historial. Se pueden lograr niveles ilimitados de deshacer
    y repetir recorriendo dicha lista hacia atras y hacia delante llamando
    respectivamente a @c(Deshacer) y @c(Ejecutar).

  - permitir registrar los cambios de manera que se puedan volver a aplicar en
    caso de una caida del sistema. Aumentando la interfaz de @c(Orden) con
    operaciones para cargar y guardar se puede mantener un registro persistente
    de los cambios. Recuperarse de una caida implica volver a cargar desde el
    disco las ordenes guardadas y volver a ejecutarlas con la operacion
    @c(Ejecutar).

  - entructurar un sistema alrededor de operaciones de alto nivel construidas
    sobre operaciones basicas. Dicha estructura es comun en los sistemas de
    informacion que permiten @b(transacciones). Una transaccion encapsula un
    conjunto de cambios sobre unos datos. El patron Command ofrece un modo de
    modelar transacciones. Las ordenes tienen una interfaz comun, permitiendo
    asi invocar a todas las transacciones del mismo modo. El patron tambien
    facilita extender el sistema con nuevas transacciones.

*** Command Estructura <> Estructura

  ..img > img/092.png

*** Command Participantes <> Participantes

  - @c(Orden)

    - declara una interfaz para ejecutar una operacion.

  - @c(OrdenConcreta) (@c(OrdenPegar), @c(OrdenAbrir))

    - define un enlace entre un objeto @c(Receptor) y una accion

    - implementa @c(Ejecutar) invocando la correspondiente operacion u
      operaciones del @c(Receptor).

  - @c(Cliente) (@c(Aplicacion))

    - crea un objeto @c(OrdenConcreta) y establece su receptor.

  - @c(Invocador) (@c(ElementoDeMenu))

    - le pide a la orden que ejecute la peticion.

  - @c(Receptor) (@c(Documento), @c(Aplicacion))

    - sabe como llevar a cabo las operaciones asociadas a una
      peticion. Cualquier clase puede hacer actuar como @c(Receptor).

*** Command Colaboraciones <> Colaboraciones

  - El cliente crea un objeto @c(OrdenConcreta) y especifica su receptor.

  - Un objeto @c(Invocador) almacena el objeto @c(OrdenConcreta).

  - El invocador envia una peticion llamando a @c(Ejecutar) sobre la
    orden. Cuando las ordenes se puede deshacer, @c(OrdenConcreta) guarda el
    estado para deshacer la orden antes de llamar a @c(Ejecutar).

  - El objeto @c(OrdenConcreta) invoca operaciones de su receptor para llevara a
    cabo la peticion.

  El siguiente diagrama muestra las interacciones entre estos objetos,
  ilustrando como @c(Orden) desacopla el invocador del receptor (y de la
  peticion que esta lleve a cabo).

  ..img > img/093.png

*** Command Consecuencias <> Consecuencias

  El patron Command tiene las siguientes consecuencias:

  1. Orden desacopla el objeto que invoca la operacion de aquel que sabe como realizarla.

  2. Las ordenes son objetos de primera clase. Pueden ser manipulados y
     extendidos como cualquier otro objeto.

  3. Se pueden esamblar ordenes en una orden compuesta. Un ejemplo lo constituye
     la clase @c(OrdenMacro) que se describio antes. En general, las ordenes
     compuestas son una instacia del patron @l(Composite).

  4. Es facil añadir nuevas ordenes, ya que no hay que cambiar las clases existentes.

*** Command Implementacion <> Implementacion

  A la hora de implementar el patron Command deben tenerse en cuenta las
  siguientes condiciones:

  1. @e(¿Como deberia ser de inteligente una orden?) Una orden puede tener un
     amplio conjunto de habilidades. Por un lado, simplemente define un enlace
     entre un receptor y las acciones que lleva a cabo la peticion. Por el otro,
     lo implementa todo ella misma sin delegar para nada en el receptor. Este
     ultimo extremo resulta util cuando queremos definir ordenes que sean
     idenpendientes de las clases existentes, cuando no existe ningun receptor
     adecuado o cuando una orden conoce implicitamente a su receptor. Por
     ejemplo, una orden que crea otra ventana de aplicacion puede ser tan capaz
     de crear la ventana como cualquier otro objeto. En algun punto entre estos
     dos extremo se encuentran las ordenes que tienen el conocimiento suficiente
     para encontrar dinamicamente sus receptores.

  2. @e(Permitir deshacer y repetir.) Las ordenes pueden permitir capacidades de
     deshacer y repetir si proveen un modo de revertir su ejecucion (por
     ejemplo, mediante una operacion @c(Deshacer)). Una clase @c(OrdenConcreta)
     podria necesitar almacenar informacion de estado adicional para hacer
     esto. Este estado puede incluir

     - el objeto @c(Receptor), el cual es quien realmente realiza las
       operaciones en respuesta a la peticion;

     - los argumentos de la operacion llevada a cabo por el receptor; y

     - cualquier valor original del receptor que pueda cambiar como resultado de
       manejar la peticion. El receptor debe proporcionar operaciones que
       permitan a la orden devolver el receptor a su estado anterior.

     Para permitir un nivel de deshacer, una aplicacion solo necesita guardar la
     ultima orden que se ejecuto. Para multiples niveles de deshacer y repetir, la
     aplicacion necesita un historial de las ordenes que han sido ejecutadas,
     donde la maxima longitud de la lista determina el numero de niveles de
     deshacer/repetir. El historial guarda secuencias de ordenes que han sido
     ejecutadas. Recorrer la lista hacia atras deshaciendo las ordenes cancela
     sus efectos, recorrerla hacia delante ejecutando las ordenes los repite.

     Una orden anulable puede que deba ser copiada antes de que se guarde en el
     historial. Eso es debido a que el objeto orden que llevo a cabo la peticion
     original desde, supongamos, un @c(ElementoDeMenu), mas tarde ejecutara
     otras peticiones. La copia es necesaria para distinguir entre diferentes
     invocaciones de la misma orden si su estado puede variar entre invocaciones
     sucesivas.

     Por ejemplo, una @c(OrdenBorrar) que borra los objetos seleccionados debe
     guardar diferentes conjuntos de objetos cada vez que se ejecuta. Por tanto
     el objeto @c(OrdenBorrar) debera ser copiado despues de su ejecucion y esta
     copia almacenada en el historial. En caso de que el estado de la orden no
     cambie tras su ejecucion y esta copia almacenada en el historial. En caso de
     que el estado de la orden no cambie tras su ejecucion no es necesario
     realizar la copia, basta con guardar en el historial una referencia a la
     orden. Las ordenes que deben ser copiadas antes de ser guardadas en el
     historial funcionan como prototipos (vease el patron @l(#Prototype)).

  3. @e(Evitar la acumulacion de errores en el proceso de deshacer.) La
     histeresis puede ser un problema a la hora de garantizar un mecanismo de
     deshacer/repetir fiable, que preserve la semantica. Los errores se pueden
     acumular a medida que se ejecutan y deshacen las ordenes repetidamente, de
     marera que el estado de una aplicacion finalmente difiera de sus valores
     originales. Por tanto, puede ser necesario guardar mas informacion con la
     orden para asegurar que los objetos son devueltos a su estado
     original. Puede aplicarse el patron @l(#Memento) para dar a la orden acceso
     a esta informacion sin exponer las interioridades de otros objetos.

  4. @e(Uso de plantillas de C++.) Para aquellas ordenes que (1) no se pueden
     deshacer y (2) no necesitan argumentos, podemos usar plantillas de C++ para
     evitar crear una subclase de @c(Orden) para cada clase de accion y
     receptor. Mostraremos como hacer esto en la seccion de Codigo de Ejemplo.

*** Command Codigo de Ejemplo <> Codigo de Ejemplo

  El codigo de C++ que se muestra aqui es un esbozo de las clases @c(Orden) que
  se comentaron en la seccion de Motivacion. Definiremos las clases
  @c(OrdenAbrir), @c(OrdenPegar) y @c(OrdenMacro). Veamos en primer lugar la
  clase abstracta @c(Orden):

  ..src > c++
    class Orden {
    public:
        virtual ~Orden();

        virtual void Ejecutar() = 0;
    protected:
        Orden();
    };
  < src..

  @c(OrdenAbrir) abre un documento cuyo nombre es proporcionado por el
  usuario. Es necesario pasarle un objeto @c(Aplicacion) en su constructor.
  @c(PreguntarAlUsuario) es una rutina de implementacion que le pide al usuario
  el nombre del documento a abrir.

  ..src > c++
    class OrdenAbrir : public Orden {
    public:
        OrdenAbrir(Aplicacion*);

        virtual void Ejecutar();
    protected:
        virtual const char* PreguntarAlUsuario();
    private:
        Aplicacion* _aplicacion;
        char* _respuenta;
    };

    OrdenAbrir::OrdenAbrir (Aplicacion* a) {
        _aplicacion = a;
    }

    void OrdenAbrir::Ejecutar () {
        const char* nombre = PreguntarAlUsuario();

        if (nombre != 0) {
            Documento* documento = new Documento(nombre);
            _aplicacion->Añadir(documento);
            documento->Abrir();
        }
    }
  < src..

  A @c(OrdenPegar) es necesario pasarle un objeto @c(Documento) como su
  receptor. El receptor se pasa como parametro en el constructor de
  @c(OnderPegar).

  ..src > c++
    class OrdenPegar : public Orden {
    public:
        OrdenPegar(Documento*);

        virtual void Ejecutar();
    private:
        Documento* _documento;
    };

    OrdenPegar::OrdenPegar (Documento* doc) {
        _documento = doc;
    }

    void OrdenPegar::Ejecutar () {
        _documento->Pegar();
    }
  < src..

  Para ordenes simples que no se pueden deshacer y que no necesitan argumentos
  podemos usar una clase plantilla para parametrizar el receptor de la
  orden. Definiremos una subclase plantilla @c(OrdenSimple) para dichas
  ordenes. @c(ordenSimple) es parametrizada con el tipo del @c(Receptor) y
  mantiene un enlace entre un objeto receptor y una accion almacenada como un
  puntero a una funcion miembro.

  ..src > c++
    template <class Receptor>
    class OrdenSimple : public Orden {
    public:
        typedef void (Receptor::* Accion)();

        OrdenSimple(Receptor* r, Accion a) :
          _receptor(r), _accion(a) { }

        virtual void Ejecutar();
    private:
        Accion _accion;
        Receptor* _receptor;
    };
  < src..

  El constructor almacena el receptor y la accion las correspondientes variables
  de instancia. @c(Ejecutar) simplemente aplica la accion al receptor.

  ..src > c++
    template <class Receptor>
    void OrdenSimple<Receptor>::Ejecutar () {
        (_receptor->*_accion)();
    }
  < src..

  Para crear una orden que llame a @c(Accion) sobre una instancia de la clase
  @c(MiClase), basta con que el cliente escriba

  ..src > c++
    MiClase* receptor = new MiClase;
    // ...
    Orden* unaOrden =
        new OrdenSimple<MiClase>(receptor, &MiClase::Accion);
    // ...
    unaOrden->Ejecutar();
  < src..

  Hay que tener en cuenta que esta solucion solo sirve para ordenes
  simples. Otras ordenes mas complejas que no solo deban tratar con sus
  receptores sino tambien con argumentos y con informacion de estado para
  deshacer, necesitan una subclase de @c(Orden).

  Una @c(OrdenMacro) gestiona una secuencia de ordenes y proporciona operaciones
  para añadir y eliminar subordenes. No se necesita un receptor explicito, ya
  que las subordenes ya definen su receptor.

  ..src > c++
    class OrdenMacro : public Orden {
    public:
        OrdenMacro();
        virtual ~OrdenMacro();

        virtual void Anadir(Orden*);
        virtual void Eliminar(Orden*);

        virtual void Ejecutar();
    private:
        Lista<Orden*>* _ordenes;
    };
  < src..

  Lo fundamental de @c(OrdenMacro) es su funcion miembro @c(Ejecutar). Esta
  recorre todas las subordenes y llama a @c(Ejecutar) sobre cada una de ellas.

  ..src > c++
    void OrdenMacro::Ejecutar () {
        IteratorLista<Orden*> i(_ordenes);

        for (i.Primero(); !i.HaTerminado(); i.Siguiente()) {
            Orden* o = i.ElementoActual();
            o->Ejecutar();
        }
    }
  < src..

  Notese que si @c(OrdenMacro) debe implementar una operacion @c(Deshacer),
  entoces sus subordenes deben deshacerse en orden @e(inverso) con respecto a la
  implementacion de @c(Ejecutar.)

  Por ultimo, @c(OrdenMacro) debe proporcionar operaciones para gestionar sus
  subordenes. @c(OrdenMacro) es tambien responsable de borrar sus subordenes.

  ..src > c++
    void OrdenMacro::Anadir (Orden* o) {
        _ordenes->Insertar(c);
    }

    void OrdenMacro::Eliminar (Orden* o) {
        _ordenes->Eliminar(c);
    }
  < src..

*** Command Usos Conocidos <> Usos Conocidos

  Tal vez el primer ejemplo de patron Command sea el que aparecio en un articulo
  de Lieberman [@l(#Lie85)]. MacApp [@l(#App89)] popularizo la nocion de ordenes
  para implementar operaciones que podian deshacerse. ET++ [@l(#WGM88)],
  IterViews [@l(#LCI+92)] y Unidraw [@l(#VL90)] tambien definen clases que
  siguen el patron Command. InwerViews define una clase abstracta @c(Action) que
  proporciona la funcionalidad de una orden. Tambien define una plantilla
  @c(ActionCallback), parametrizada con un metodo de accion, que puede crear
  instancias de subclases de ordenes automaticamente.

  La biblioteca de clases THINK [@l(#Sym93b)] tambien usa ordenes para permitir
  acciones que se pueden deshacer. Las ordenes en THINK se denominan @"(Tasks)
  (tareas). Los objetos tarea se pasan a una @l(#Chain of Responsibility<>Cadena
  de Responsabilidad), donde son consumidos.

  Los objetos de ordenes de Unidraw son unicos en el sentido de que pueden
  comportarse como mensajes. Una orden de Unidraw puede enviarse a otro objeto
  para su interpretacion, y el resultado de la interpretacion varia con el
  objeto receptor. Mas aun, el receptor puede delegar la interpretacion a otro
  objeto, normalmente al padre en una estructura mas grande, como en una Cadena
  de Responsabilidad. Asi pues, el receptor de una orden de Unidraw se calcula,
  no se almacena. El mecanismo de interpretacion de Unidraw depende de la
  informacion de tipos en tiempo de ejecution.

  Coplien discribe como implementar @e(funtors), objetos que son funciones, en
  C++ [@l(#Cop92)]. Logra un grado de transparencia en su utilizacion
  sobrecargando el operador de llamada a funcion (@c[operator()]). El patron
  Command es diferente; se centra en mantener un @e(enlace entre) un receptor y
  una funcion (es decir, una accion), no en mantener una funcion.

*** Command Patrones Relacionados <> Patrones Relacionados

  Se puede usar el patron @l(#Composite) para implementar @c(OrdenMacro).

  Un @l(#Memento) puede mantener el estado que necesitan las ordenes para anular
  sus efectos.

  Una orden que debe ser copiada antes de ser guardada en el historial funciona
  como un @l(#Prototype<>Prototipo).

** Interpreter
*** Interpreter Proposito <> Proposito

  Dado un lenguaje, define una representacion de su gramatica junto con un
  interprete que usa dicha representacion para interpretar sentencias del lenguaje.

*** Interpreter Motivacion <> Motivacion

  Si hay un tipo de problemas que ocurren con cierta frecuencia, puede valer la
  pena expresar las apariciones de ese problema como instrucciones de un
  lenguaje simple. A continuacion puede construirse un interprete que resuelva
  el problema interpretando dichas instrucciones.

  Por ejemplo, buscar cadenas que concuerden con un patron es uno de estos
  problemas recurrentes. Las expresiones regulares son un lenguaje estandar para
  especificar patrones de cadenas. En vez de construir algoritmos personalizados
  que comparen cada patron con diferentes cadenas, podriamos tener algoritmos de
  busqueda que interpretasen una expresion regular que especifica el conjunto
  de cadenas a buscar.

  El patron Interpreter describe como definir una gramitaca para lenguajes
  simples, como representar instrucciones de ese lenguaje y como interpretar
  esas instrucciones. En nuestro ejemplo, el patron describe como definir una
  gramatica para expresiones regulares, como representar una expresion regular
  concreta y como interpretar dicha expresion regular.

  Supongamos que las expresiones regulares se definen mediante la siguiente
  gramatica:

  ..example >
    expresion ::= literal | alternativa | secuencia | repeticion | '(' expresion ')'
    alternativa ::= expresion '|' expresion
    secuencia ::= expresion '&' expresion
    repeticion ::= expresion '*'
    literal ::= 'a' | 'b' | 'c' | ... { 'a' | 'b' | 'c' | ... }*
  < example..

  El simbolo inicial es @c(expresion), y @c(literal) es un simbolo terminal que
  define palabras.

  ..img > img/094.png

  El patron @c(Interpreter) usa una clase para representar cada regla de la
  gramatica. Los simbolos del lado derecho de la regla son variables de
  instancia de dichas clases. La gramatica de mas arriba se representa por cinco
  clases: una clase abstracta @c(ExpresionRegular) y sus cuatro subclases
  @c(ExpresionLiteral), @c(ExpresionAlternativa), @c(ExpresionSecuencia) y
  @c(ExpresionRepeticion). Las ultimas tres clases definen variables que
  contienen subexpresiones.

  Cada expresion regular definida por esta gramatica se representa por un arbol
  sintactico abstracto formado por instancias de estas clases. Por ejemplo, el
  arbol sintactico abstracto

  ..img > img/095.png

  representa la expresion regular

  ..example >
    lloviendo & (perros | gatos) *
  < example..

  Podemos crear un interprete para estas expresiones regulares definiendo la
  operacion @c(Interpretar) en cada subclase de @c(ExpresionRegular).
  @c(Interpretar) toma como argumento el contexto en el cual se interpreta la
  expresion. El contexto contiene la cadena de entrada e informacion acerca de
  que parte de ella se ha reconocido hasta el momento. Cada subclase de
  @c(ExpresionRegular) implementa @c(Interpretar) para reconocer la siguiente
  parte de la cadena de entrada en funcion del contexto actual. Por ejemplo,

  - @c(ExpresionLiteral) comprobara si la entrada coincide con el literal que
    ella define,

  - @c(ExpresionAlternativa) comprobara si la entrada coincide con alguna de sus
    alternativas,

  - @c(ExpresionRepeticion) comprobara si la entrada tiene multiples copias de
    la expresion repetida,

  y asi sucesivamente.

*** Interpreter Aplicabilidad <> Aplicabilidad

  Usese el patron Interpreter cuando hay un lenguaje que interpretar y se pueden
  representar las sentacias del lenguaje como arboles de sintactico y
  abstractos. El patron Interpreter funciona mejor cuando

  - la gramatica es simple. Para gramaticas complejas, la jerarquia de clases de
    la gramatica se vuelve grande e inmanejable. Herramientas como los
    generadores de analizadores sintacticos constituyen una alternativa mejor en
    estos casos. Estas pueden interpretar expresiones sin necesidad de construir
    arboles sintacticos abstractos, lo que puede ahorrar espacio y, posiblemente,
    tiempo.

  - la eficiencia no es una preocupacion critica. Los interpretes mas eficientes
    normalmente @e(no) se implementan interpretando arboles de analisis
    sintactico directamente, sino que primero los traducen a algun formato. Por
    ejemplo, las expresiones regulares suelen transformarse en maquinas de
    estados. Pero incluso en ese caso, el @e(traductor) puede implementarse con
    el patron @c(Interpreter), de modo que este sigue siendo aplicable.

*** Interpreter Estructura <> Estructura

  ..img > img/096.png

*** Interpreter Participantes <> Participantes

  - @c(ExpresionAbstracta) (@c(ExpresionRegular))

    - declara una operacion abstracta Interpretar que es comun a todos los nodos
      del arbol de sintaxis abstracto.

  - @c(ExpresionTerminal) (@c(ExpresionLiteral))

    - implementa una operacion @c(Interpretar) asociada con los simbolos
      terminales de la gramatica.

    - se necesita una instancia de esta clase para cada simbolo terminal de una
      sentencia.

  - @c(ExpresionNoTerminal) (@c(ExpresionAlternativa), @c(ExpresionRepeticion),
    @c(ExpresionSecuencia))

    - por cada regla de la gramatica @m(R::= R₁ R₂ … Rₙ) debe haber una de
      estas clases.

    - mantiene variables de instancia de tipo @c(ExpresionAbstracta) para cada
      uno de los simbolos de @m(Rₜ) a @m(Rₙ).

    - implementa una operacion @c(Interpretar) para los simbolos no terminales
      de la gramatica. @c(Interpretar) nolmalmente se llama a si misma
      recursivamente sobre las variables que representan de @m(Rₜ) a @m(Rₙ).

  - @c(Contexto)

    - contiene informacion que es global al interprete.

  - @c(Cliente)

    - construye (o recibe) un arbol sintactico abstracto que representa una
      determinada sentencia del lenguaje definido por la gramatica. Este arbol
      sintactico abstracto esta formado por instancias de las clases
      @c(ExpresionNoTerminal) y @c(ExpresionTerminal).

    - invoca a la operacion @c(Interpretar).

*** Interpreter Colaboraciones <> Colaboraciones

  - El cliente construye (o recibe) la sentencia como un arbol sintactico
    abstracto formado por instancias de @c(ExpresionNoTerminal) y
    @c(ExpresionTerminal). A continuacion el cliente inicializa el contexto e
    invoca a la operacion @c(Interpretar).

  - Cada nodo @c(ExpresionNoTerminal) define @c(Interpretar) en terminos de
    @c(Interpretar) de cada subexpresion. La operacion @c(Interpretar) de cada
    @c(ExpresionTerminal) define el caso base de la recurcion.

  - Las operaciones @c(Interpretar) de cada nodo usa el contexto para almacenar
    y acceder al estado del interprete.

*** Interpreter Consecuencias <> Consecuencias

  El patron @c(Interprete) tiene las siguientes ventajas e inconvenientes:

  1. @e(Es facil cambiar y ampliar la gramatica.) Puesto que el patron usa
     clases para representar las reglas de la gramatica, se puede usar la
     herencia para cambiar o extender esta. Se puede modificar incrementalmente
     las expresiones existentese, y se pueden definir otras nuevas como
     variaciones de las antiguas.

  2. @e(Tambien resulta facil implementar la gramatica.) Las clases que definen
     los nodos del arbol sintactico abstracto tiene implementaciones
     similares. Estas clases son faciles de escribir, y muchas veces se pueden
     generar automaticamete con un compilador o un generador de analizadores
     sintacticos.

  3. @e(Las gramaticas complejas son difiles de mantener.) El patron Interpreter
     define al menos una clase para cada regla de la gramatica (las reglas que
     se hayan definido usando BNF pueden necesitar varias clases). De hay que
     las gramaticas que contienen muchas reglas pueden ser dificiles de
     controlar y mantener. Se pueden aplicar otros patrones de diseño para
     mitigar el problema (vease la seccion de Implementacion). Pero cuando la
     gramatica es muy compleja son mas adecuadas otras tecnicas como los
     generadoles de analizadores sintacticos o de compiladores.

  4. @e(Añadir nuevos modos de interpretar expresiones.) El patron Interpreter
     facilita evaluar una expresion de una manera distinta. Por ejemplo,
     podriamos permitir imprimir con formato una expresion o realizar una
     comprobacion de tipos en ella definiendo una nueva operacion en las clases
     de las expresiones. Si vamos a seguir añadiendo nuevos modos de interpretar
     una expresion, deberiamos considerar la utilizacion del patron @l(#Visitor)
     para evitar cambiar las clases de la gramatica.

*** Interpreter Implementacion <> Implementacion

  Los patrones Interpreter y @l(#Composite) comparten muchos detalles de
  implementacion. Las siguientes cuestiones son especificas del Interpreter:

  1. @e(Crear un arbol sintactico abstracto.) El patron Interpreter no explica
     como @e(crear) un arbol sintactico abstracto. En otras palabras, no se
     encarga del analisis sintactico. El arbol sintactico abstracto puede ser
     creado mediante un analizador sintactico dirigido por una tabla, mediante
     un analizador sintactico (normalmente recursivo descendente) hecho a mano,
     o directamente por el cliente.

  2. @e(Definir la operacion @c(Interpretar)). No tenemos por que definir la
     operacion @c(Interpretar) en las clases de la expresion. Si se van a crear
     nuevos interpretes es mejor usar el patron @l(#Visitor) para poner
     @c(Interpretar) en un objeto @"(visitante) aparte. Por ejemplo, una
     gramatica de un lenguaje de programacion tendra muchas operaciones sobre
     los arboles sintacticos abstractos, tales como la comprobacion de tipos, la
     optimizacion, la generacion de codigo, etcetera. Sera mejor usar un
     visitante para evitar definir estas operaciones en cada clase de la
     gramatica.

  3. @e(Compartir simbolos terminales mediante el patron Flyweight.) Para las
     gramaticas cuyas sentencias contienen muchas repeticiones de un mismo
     simbolo terminal puede ser beneficioso compartir una unica copia de dicho
     simbolo. Las gramaticas para programas de computadora son buenos ejemplos
     @-(cada variable de un programa aparecera en muchos sitios a lo largo del
     codigo). En el ejemplo de la seccion Motivacion, una sentencia puede tener
     el simbolo terminal @c(perro) (modelado mediante la clase
     @c(ExpresionLiteral)) repetido muchas veces.

     Los nodos terminales generalmente no guardan informacion sobre su posicion
     en el arbol sintactico abstracto. Los nodos padre les pasan cualquier
     contexto que pudieran necesitar durante la interpretacion. Por tanto aqui
     se da una distincion entre estado compartido (intrinseco) y estado recibido
     (extrinseco), por lo que es aplicable el patron @l(#Flyweight).

     Por ejemplo, cada instancia de @c(ExpresionLiteral) para @c(perro) recibe
     un contexto que contiene la subcadena reconocida hasta ese instante. Y cada
     una de estas instancias de @c(ExpresionLiteral) hace lo mismo en su
     operacion @c(Interpretar) @-(comprueba si la parte que sigue de la entrada
     contiene un @c(perro)), sin importar en que posicion del arbol aparezca la
     instancia.

*** Interpreter Codigo de Ejemplo <> Codigo de Ejemplo

  A continuacion se mostraran dos ejemplos. El primero de ellos es un codigo
  completo en Smalltalk para comprobar si una secuencia satisface una expresion
  regular. El segundo es un programa en C++ para evaluar expresiones booleanas.

  El reconocedor de expresiones regulares comprueba si una cadena pertenece al
  lenguaje definido por la expresion regular. La expresion regular esta definida
  por la siguiente gramatica:

  ..example >
    expresion ::= literal | alternativa | secuencia | repeticion | '(' expresion ')'
    alternativa ::= expresion '|' expresion
    secuencia ::= expresion '&' expresion
    repeticion ::= expresion 'repetir'
    literal ::= 'a' | 'b' | 'c' | ... { 'a' | 'b' | 'c' | ... }*
  < example..

  Esta gramatica es una ligera modificacion de la del ejemplo de la seccion de
  Motivacion. Hemos cambiando un poco la sintaxis concreta de las expresiones
  regulares, ya que el simbolo @'c(*) no puede ser una operacion postfija en
  Smalltalk. Por este motivo usaremos @c(repetir) en su lugar. Por ejemplo, la
  expresion regular

  ..example >
    (('perro ' | 'gato ') repetir & 'tiempo')
  < example..

  reconocera la cadena de entrada @"c(perro perro gato tiempo).

  Para implementar el reconocedor, definimos las cinco clases descritas en la
  seccion @l(#Interpreter Motivacion<>Motivacion). La clase
  @c(ExpresionSecuencia) tiene las variables de instancia @c(expresion1) y
  @c(expresion2) para sus hijos en el arbol sintactico abstracto.
  @c(ExpresionAlternativa) guarda sus alternativas en las variables de instancia
  @c(alternativa1) y @c(alternativa2), mientras que @c(ExpresionRepeticion)
  guarda en su variable de instancia @c(repeticion) la expresion que se
  repite. @c(ExpresionLiteral) tiene la variable de instancia @c(componentes)
  que contiene una lista de objetos (probablemente caracteres). Estos
  representan la cadena literal con la que debe coincidir la secuencia de
  entrada .

  La operacion @c(reconocer:) implementa un interprete de expresiones
  regulares. Cada una de las clases que define el arbol sintanctico implementa
  esta operacion, que recibe en el parametro @c(estadoEntrada) el estado actual
  del proceso de analisis, tras haber leido parte de la cadena de entrada.

  Dicho estado actual viene dado por una serie de flujos de entrada que
  representan todas las entradas que podria haber aceptado hasta el momento la
  expresion regular. (Esto equivale mas o menos a guardar todos los estado en
  los que estaria el automata de estados finitos equivalente tras haber
  reconocido la cadena de entrada hasta este punto.)

  El estado actual es de vital importancia para la operacion @c(repetir). Por
  ejemplo, si la expresion regular fuera

  ..example >
    'a' repetir
  < example..

  entonces el interprete podria reconocer @"c(a), @"c(aa), @"c(aaa) y asi
  sucesivamente. Si fuera

  ..example >
    'a' repetir & 'bc'
  < example..

  entonces podria reconocer  @"c(abc),  @"c(aabc),  @"c(aaabc), etcetera. Pero
  si la expresion regular fuese

  ..example >
    'a' repetir & 'abc'
  < example..

  entonces comparar la entrada @"c(aabc) con la expresion @"c('a' repetir) daria
  lugar a dos flujos de entrada, uno en el que se reconoceria un caracter de la
  entrada y otro en el que se reconocerian dos caracteres. Solo el flujo que ha
  aceptado un caracter reconocera el @"c(abc) restante.

  Pensemos ahora en las definiciones de @c(reconecer:) para cada clase que
  define una expresion regular. La definicion de esta operacion para
  @c(ExpresionSecuencia) reconoce cada una de sus subexpresiones
  secuencialmente. Normalmente eliminara flujos de entrada de su
  @c(estadoEntrada).

  ..src > smalltalk
    reconocer: estadoEntrada
        ^ expresion2 reconocer: (expresion1 reconocer: estadoEntrada).
  < src..

  Una @c(ExpresionAlternativa) devolvera un estado que consiste en la union de
  estados de cada alternativa. La definicion de @c(reconocer:) para
  @c(ExpresionAlternativa) es

  ..src > smalltalk
    reconocer: estadoEntrada
        | estadoFinal |
        estadoFinal := alternativa1 reconocer: estadoEntrada.
        estadoFinal addAll: (alternativa2 reconocer: estadoEntrada).
        ^ estadoFinal
  < src..

  La operacion @c(reconocer:) de @c(ExpresionRepeticion) trata de encontrar
  tantos estados que pueda reconocer como sea posible:

  ..src > smalltalk
    reconocer: estadoEntrada
        | unEstado estadoFinal |
        unEstado := estadoEntrada.
        estadoFinal := estadoEntrada copy.
        [unEstado isEmpty]
            whileFalse:
                [unEstado := repeticion reconoter: unEstado.
                 estadoFinal addAll: unEstado]
            ^ estadoFinal
  < src..

  Su estado de salida normalmente consiste en mas estados que su estado de
  entrada, ya que @c(ExpresionRepeticion) puede reconocer uno, dos o muchas
  apariciones de @c(repeticion) en el estado de entrada. Los estados de salida
  representan todas estas posibilidades, permitiendo a los siguientes elementos
  de la expresion regular decidir que estado es el correcto.

  Por ultimo, la definicion de @c(reconocer:) para @c(ExpresionLiteral) trata de
  reconocer sus componentes para cada posible flujo de entrada. Solo mantiene
  aquellos flujos de entrada que concuerdan con la expresion:

  ..src > smalltalk
    reconocer: estadoEntrada
        | estadoFinal := tStream |
        estadoFinal := Set new.
        estadoEntrada
            do:
                [:stream | tStream := stream copy.
                     (tStream nextAvailable:
                          components size
                     ) = components
                         ifTrue: [estadoFinal add: tStream]
                ].
            ^ estadoFinal
  < src..

  El mensaje @c(siguienteDisponible:) hace que avance el flujo de entrada. Esta
  es la unica operacion @c(reconocer:) que hace avanzar al flujo. Notese como el
  estado que devuelve contiene una copia del flujo de entrada, garantizando asi
  que reconocer un literal nunca cambie el flujo de entrada. Esto es importante
  porque todas las alternativas de una @c(ExpresionAlternativa) deberian ver
  copias identicas del flujo de entrada.

  Ahora que hemos definido las clases de las que se compone un arbol sintactico
  abstracto, estamos en condicines de describir como construirlo. En vez de
  escribir un analizador sintactico de expresiones regulares, definiremos
  algunas operaciones en las clases @c(ExpresionRegular) de forma que evaluar
  una expresion en Smalltalk produzca un arbol sintactico abstracto para la
  correspondiente expresion regular. Eso nos permite usar el compilador
  incorporado de Smalltalk como si fuese un analizador sintactico de expresiones
  regulares.

  Para construir el arbol sintactico abstracto necesitaremos definir @"c(|),
  @"c(repetir) y @"c(&) como operacienos de @c(ExpresionRegular). Estas
  operaciones se definen en la clase @c(ExpresionRegular) como sigue:

  ..src > smalltalk
    & unNodo
        ^ ExpresionSecuencia new
            expresion1: self expresion2: unNodo comoExpReg

    repetir
        ^ ExpresionRepeticion new repeticion: self

    | unNodo
        ^ ExpresionAlternativa new
        alternativa1: self alternativa2: unNodo comoExpReg

    comoExpReg
        ^ self
  < src..

  La operacion @c(comoExpReg) convertira literales en objetos
  @c(ExpresionRegular). Estas operaciones se definen en la clase @c(String:)

  ..src > smalltalk
    & unNodo
        ^ ExpresionSecuencia new
            expresion1: self comoExpReg expresion2: unNodo comoExpReg

    repetir
        ^ ExpresionRepeticion new repeticion: self

    | unNodo
        ^ ExpresionAlternativa new
        alternativa1: self comoExpReg alternativa2: unNodo comoExpReg

    comoExpReg
        ^ ExpresionLiteral new componentes: self
  < src..

  Si definieramos estas operaciones mas arriba en la jerarquia de clases
  (@c(SequenceableCollection) en Smalltalk-80, @c(IndexedCollection) en
  Smalltalk/V), entonces tambien estarian definidas para clases como @c(Array) y
  @c(OrderedCollection). Esta haria que las expresiones regulares reconociesen
  secuencias de objetos de cualquier tipo.

  El segundo ejemplo es un sistema para manipular y evaluar expresiones
  booleanas, implementado en C++. Los simbolos terminales del lenguaje son
  variables de tipo Boolean, es decir, las constantes @c(true) y @c(false). Los
  simbolos no terminales representan expresiones que contienen los operadores
  @c(and), @c(or), y @c(not). La gramatica se define como sigue:@n(42)

  ..example >
    ExpBooleana ::= ExpVariable | Constante | ExpOr | ExpAnd | ExpNot | '(' ExpBooleana ')'
    ExpAnd ::= ExpBooleana 'and' ExpBooleana
    ExpOr ::= ExpBooleana 'or' ExpBooleana
    ExpNot ::= 'not' ExpBooleana
    Constante ::= 'true' | 'false'
    ExpVariable := 'A' | 'B' | ... | 'X' | 'Y' | 'Z'
  < example..

  Definiremos dos operaciones para las expresiones booleanas. La primera,
  @c(Evaluar), evaluaria una expresion Booleana en un contexto que asigna un
  valor verdadero o falso a cada variable. La segunda operacion, @c(Sustituir),
  produce una nueva expresion booleana al sustituir una variable por una
  expresion. @c(Sustituir) muestra como se puede usar el patron Interpreter para
  algo mas que simplemente evaluar expresiones. En este caso, para manipular la
  propia expresion.

  A continuacion se detallaran las clases @c(ExpBooleana), @c(ExpVariable) y
  @c(ExpAnd). Las clases @c(ExpOr) y @c(ExpNot) son parecidas a @c(ExpAnd). La
  clase @c(Constante) representa las constantes logicas.

  @c(ExpBooleana) define la interfaz para todas las clases que definen una
  expresion booleana:

  ..src > c++
    class ExpBooleana {
    public:
        ExpBooleana();
        virtual ~ExpBooleana();

        virtual bool Evaluar(Contexto&) = 0;
        virtual ExpBooleana* Sustituir(const char*, ExpBooleana&) = 0;
        virtual ExpBooleana* Copiar() const = 0;
    };
  < src..

  La clase @c(Contexto) define una correspondencia entre variables y valores
  booleanos, los cuales se representan mediante las constantes de C++ @c(true) y
  @c(false). @c(Contexto) tiene la siguiente interfaz:

  ..src > c++
    class Contexto {
    public:
        bool Buscar(const char*) const;
        void Asignar(ExpVariable*, bool);
    };
  < src..

  Una @c(ExpVariable) representa una variable con nombre:

  ..src > c++
    class ExpVariable : public ExpBooleana {
    public:
        ExpVariable(const char*);
        virtual ~ExpVariable();

        virtual bool Evaluar(Contexto&);
        virtual ExpBooleana* Sustituir(const char*, ExpBooleana&);
        virtual ExpBooleana* Copiar() const;
    private:
        char* _nombre;
    };
  < src..

  El constructor recibe como parametro el nombre de la variable:

  ..src > c++
    ExpVariable::ExpVariable (const char* nombre) {
        _nombre = strdop(nombre);
    }
  < src..

  Evaluar una variable devuelve su valor en el contexto actual.

  ..src > c++
    bool ExpVariable::Evaluar (Contexto& unContexto) {
        return unContexto.Buscar(_nombre);
    }
  < src..

  Copiar una variable devuelve una nueva @c(ExpVariable):

  ..src > c++
    ExpBooleana* ExpVariable::Copiar () const {
        return new ExpVariable(_nombre);
    }
  < src..

  Para sustituir una variable por una expresion hemos de compobar si la variable
  tiene el mismo nombre que la que se recibe como parametro:

  ..src > c++
    ExpBooleana* ExpVariable::Sustituir (
        const char* nombre, ExpBooleana& exp
    ) {
        if (strcmp(nombre, _nombre) == 0) {
            return exp.Copiar();
        } else {
            return new ExpVariable(_nombre);
        }
    }
  < src..

  Por otro lado, @c(ExpAnd) representa una expresion resultado de unir dos
  expresiones booleanas por ala operacion @"(y) logica.

  ..src > c++
    class ExpAnd : public ExpBooleana {
    public:
        ExpAnd(ExpBooleana*, ExpBooleana*);
        virtual ~ExpAnd();

        virtual bool Evaluar(Contexto&);
        virtual ExpBooleana* Sustituir(const char*, ExpBooleana&);
        virtual ExpBooleana* Copiar() const;
    private:
        ExpBooleana* _operando1;
        ExpBooleana* _operando2;
    };

    ExpAnd::ExpAnd (ExpBooleana* op1, ExpBooleana* op2) {
        _operando1 = op1;
        _operando2 = op2;
    }
  < src..

  Evaluar una @c(ExpAnd) consiste en evaluar sus operandos y devolver el @"(y)
  logico de los resultados.

  ..src > c++
    bool ExpAnd::Evaluar (Contexto& unContexto) {
        return
            operando1->Evaluar(unContexto) &&
            operando2->Evaluar(unContexto);
    }
  < src..

  Una @c(ExpAnd) implementa @c(Copiar) y @c(Sustituir) haciendo llamadas
  recursivas sobre sus operandos:

  ..src > c++
    ExpBooleana* ExpAnd::Copiar () const {
        return
            new ExpAnd(_operando1->Copiar(), _operando2->Copiar());
    }

    ExpBooleana* ExpAnd::Sustituir (const char* nombre, ExpBooleana& exp) {
        return
            new ExpAnd(
                       _operando1->Sustituir(nombre, exp),
                       _operando2->Sustituir(nombre, exp)
                       );
    }
  < src..

  Ahora podemos definir la expresion booleana

  ..example >
    (true and x) or (y and (not x))
  < example..

  y evaluarla asignando @c(true) o @c(false) a las variables @c(x) e @c(y):

  ..src > c++
    ExpBooleana* expresion;
    Contexto contexto;

    ExpVariable* x = new ExpVariable("X");
    ExpVariable* y = new ExpVariable("Y");

    expresion = new ExpOr(
        new ExpAnd(new Constante(true), x),
        new ExpAnd(y, new ExpNot(x))
    );

    contexto.Asignar(x, false);
    contexto.Asignar(y, true);

    bool resultado = expresion->Evaluar(context);
  < src..

  La expresion se evalua a @c(true) para estos valores de @c(x) e @c(y). Podemos
  evaluar la expresion dandoles diferentes valores a las variables simplemente
  cambiando el contexto.

  Por ultimo, podemos sustituir la variable @c(y) con una nueva expresion y luego
  volver a evaluarla:

  ..src > c++
    ExpVariable* z = new ExpVariable("Z");
    ExpNot not_z(z);

    ExpBooleana* sustitucion = expresion->Sustituir("Y", not_z);

    contexto.Asignar(z, true);

    resultado = sustitucion->Evaluar(context);
  < src..

  Este ejemplo ilustra un aspecto importante del patron Interpreter: hay muchos
  tipos de operaciones que pueden @"(interpretar) una sentencia. De las tres
  operaciones definidas para @c(ExpBooleana), @c(Evaluar) es la que mas se
  ajusta a nuestra idea de lo que deberia hacer un interprete @-(interpretar un
  programa o expresion y devolver un resultado simple).

  No obstante, @c(Sustituir) tambien puede verse como un interprete. Es un
  interprete cuyo contexto es el nombre de la variable que esta siendo
  sustituida junto con la expresion que la sustituye, y cuyo resultado es una
  nueva expresion. Incluso podria pensarse en @c(Copiar) como un interprete con
  un contexto vacio. Puede parecer un poco extraño considerar a @c(Sustituir) y
  @c(Copiar) como interpretes, dado que estas son operaciones basicas sobre
  arboles. Los ejemplos del patron @l(#Visitor) muestran como estas tres
  operaciones pueden refectarizarse en un @"(interprete) visitante aparte,
  revelando asi una profunda similitud.

  El patron interpreter es mas que una simple operacion distribuida sobre una
  jerarquia de clases que usa el patron @l(#Composite). Si consideramos a
  @c(Evaluar) como un interprete es porque pensamos en la jerarquia de clases
  de @c(ExpBooleana) como la representacion de un lenguaje. Supuesta una
  jerarquia de clases similar para representar el ensablaje de partes de
  automoviles, no es probable que hubieramos considerado interpretes a
  operaciones como @c(Peso) y @c(Copiar), aunque esten distribuidas sobre una
  jerarquia de clases que usa el patron Composite @-(no pensamos en las partes
  de un automovil como un lenguaje). Es una cuestion de perspectiva; si
  empezasemos a publicar gramaticas de partes de automoviles, entoces se podria
  considerar a las operaciones sobre esas partes como formas de interpretar el
  lenguaje.

*** Interpreter Usos Conocidos <> Usos Conocidos

  El patron Interpreter esta muy extendido en los compiladores implementados con
  lenguajes orientados a objetos, como los compiladores de Smalltalk. SPECTalk
  usa este patron para interpretar descripciones de formatos de ficheros de
  entrada [@l(#Sza92)]. El toolkit de resolucion de problemas QOCA lo usa para
  evaluar los problemas [@l(#HHMV92)].

  Concebido en su forma mas general (es decir, como una operacion distribuida
  sobre una jeraquia de clases basada en el patron Composite), casi cualquier
  uso del patron Composite tambien contendra el patron Interpreter. Pero este
  patron deberia reservarse para aquellos casos en los que tiene sentido pensar
  en la jerarquia de clases como la definicion de un lenguaje.

*** Interpreter Patrones Relacionados <> Patrones Relacionados

  @l(#Composite): el arbol sintactico abstracto es una instancia del patron
  Composite.

  El patron @l(#Flyweight) muestra como compartir simbolos terminales dentro del
  arbol sintactico abstracto.

  @l(Iterator): el interprete puede usar un Iterator para recorrer la
  estructura.

  Puede usarse el patron @l(Visitor) para mantener el comportamiento de cada
  nodo del arbol sintactico abstracto en una clase.

** Iterator
*** Iterator Proposito <> Proposito

  Proporciona un modo de acceder secuencialmente a los elementos de un objeto
  agredado sin exponer su representacion interna.

*** Iterator Tambien Conocido Como <> Tambien Conocido Como

  Cursor

*** Iterator Motivacion <> Motivacion

  Un objeto agregado, como por ejemplo una lista, deberia darnos una forma de
  acceder a sus elementos sin exponer su estructura interna. Mas aun, tal vez
  queramos recorrer la lista de diferentes formas, dependiendo de lo que
  queramos realizar. Pero probablemente no queremos plagar la interfaz de
  @c(Lista) con operaciones para diferentes recorridos, incluso en el caso de
  que pudiramos prever cuales se van a necesitar. Por otro lado, tambien puede
  necesitarse hacer mas de un recorrido simultaneamente sobre la misma lista.

  El patron Iterator nos permite hacer todo esto. La idea clave de este patron
  es tomar la responsabilidad de acceder y recorrer el objeto lista y poner
  dicha responsabilidad en un objeto @b(iterador). La clase @c(Iterador) define
  una interfaz para acceder a los elementos de la lista. Un objeto iterador es el
  responsable de saber cual es el elemento actual; es decir, sabe que elementos ya
  han sido recorridos.

  Por ejemplo, una clase @c(Lista) pediria un @c(IteradorLista) con la siguiente
  relacion entre ambos:

  ..img > img/097.png

  Antes de que pueda crearse una instancia de @c(IteradorLista) debemos
  proporcionarle la @c(Lista) a recorrer. Una vez que tenemos la instancia de
  @c(IteradorLista), podemos acceder secuencialmente a los elementos de la
  lista. La operacion @c(ElementoActual) devuelve el elemento actual de la
  lista; Primero inicializa el elemento actual al primer elemento; @c(Siguiente)
  hace avanzar el elemento actual al siguiente elemento; y @c(HaTerminado)
  comprueba si se ha avanzado mas alla del ultimo elemento, es decir, si se ha
  finalizado el recorrido.

  Separar el mecanismo de recorrido del objeto @c(Lista) nos permite definir
  iteradores con diferentes politicas de recorrido sin necesidad de enumerarlos
  en la interfaz de @c(Lista). Por ejemplo, @c(IteradorListaConFiltro) podria
  proporcionar acceso solo a aquellos elementos que satisfagan a las normas de
  filtrado.

  Notese que el iterador y la lista estan acoplados, y que el cliente debe saber
  que lo que esta recorriendo es una @e(lista) y no otra estructura agregada.
  Por tanto, el cliente se ajusta a una determinada estructura agregada. Seria
  mejor que pudiesemos cambiar la clase agregada sin cambiar el codigo
  cliente. Podemos hacer esto por generalizacion del concepto de iterador para
  permitir la @b(iteracion polimorfica).

  Como ejemplo, supongamos que ya tenemos una implementacion de una lista
  @c(ListaConSaltos). Una lista con saltos @%e(skiplis) [@l(#Pug90)] es una
  estructura de datos con caracteristicas similares a los arboles
  equilibrados. Nos gustaria poder escribir codigo que funsionase tanto para
  objetos @c(Lista) como para objetos @c(ListaConSaltos).

  Definimos una clase @c(ListaAbstracta) que proporciona una interfaz comun para
  manipular listas. Igualmente, necesitamos una clase abstracta @c(Iterador) que
  defina una interfaz de iteracion comun. Entonces podemos definir las subclases
  concretas de @c(Iterador) para las diferentes implementaciones de listas. Como
  resultado, el mecanismo de iteracion se vuelve independiente de las clases
  concretas.

  ..img > img/098.png

  Nos queda el problema de como crear el iterador. Puesto que queremos escribir
  codigo que sea independiente de las subclases concretas de @c(Lista), no podemos
  crear simplemente una instancia de una clase determinada. En vez de eso,
  haremos que los objetos lista sean responsables de crear sus correspondientes
  iteradores. Esto requiere una operacion como @c(CrearIterador), mediante la
  cual los clientes soliciten un objeto iterador.

  @c(CrearIterador) es un ejemplo de metodo de fabricacion (vease el patron
  @l(#Factory Method)). Aqui lo usamos para permitir que un cliente le pida a un
  objeto lista el iterador apropiado. El enfoque seguido con el patron Factory
  Method da lugar a dos jerarquias de clases, una para las listas y otra para
  los iteradores. El metodo de fabricacion @c(CrearIterador) @"(conecta) las dos
  jeraquias.

*** Iterator Aplicabilidad <> Aplicabilidad

  Usese el patron Iterador

  - para acceder al contenido de un objeto agregado sin exponer su
    representacion interna.

  - para permitir varios recorridos sobre objetos agregados.

  - para proporcionar una interfaz uniforme para recorrer diferentes estructuras
    agregadas (es decir, para permitir la iteracion polimorfica).

*** Iterator Estructura <> Estructura

  ..img > img/099.png

*** Iterator Participantes <> Participantes

  - @c(Iterador)

    - define una interfaz para recorrer los elementos y acceder a ellos.

  - @c(IteradorConcreto)

    - implementa la interfaz @c(Iterador).

    - mantiene la posicion actual en el recorrido del agregado.

  - @c(Agregado)

    - define una interfaz para crear un objeto @c(Iterador).

  - @c(AgregadorConcreto)

    - implementa la interfaz de creacion de @c(Iterador) para devolver una instancia
      del @c(IteradorConcreto) apropiado.

*** Iterator Colaboraciones <> Colaboraciones

  - Un @c(IteradorConcreto) sabe cual es el objeto actual del agregado y puede
    calcular el objeto siguiente en el recorrido.

*** Iterator Consecuencias <> Consecuencias

  El patron Iterator tiene tres consecuencias importantes:

  1. @e(Permite variaciones en el recorrido de un agregado.) Los agregados
     complejos pueden recorrerse de muchas formas. Por ejemplo, la generacion de
     codigo y la comprobacion de tipos implican recorrer arboles de analisis
     sintactico. La generacion de codigo puede recorrer dicho arbol de analisis
     sintactico en-orden o en pre-orden. Los iteradores facilitan cambiar el
     algoritmo de recorrido: basta con sustituir la instancia de iterador por
     otra diferente. Tambien se pueden definir subclases de @c(Iterador) para
     permitir nuevos recorridos.

  2. @e(Los iteradores simplifican la interfaz @c(Agregado).) La interfaz de
     recorrido de @c(Iterador) elimina la necesidad de una interfaz parecida en
     @c(Agregado), simplificando asi la interfaz del agregado.

  3. @e(Se puede hacer mas de un recorrido a la vez sobre un agregado.) Un
     iterador mantiene su propio estado del recorrido. Por tanto, es posible
     estar realizando mas de un recorrido al mismo tiempo.

*** Iterator Implementacion <> Implementacion

  El patron Iterator tiene muchas variantes y alternativas de implementacion. A
  continuacion se muestran algunas de las mas importantes. Los pros y los contras
  muchas veces dependen de las estructuras de control proporcionadas por el
  lenguaje. Algunos lenguajes (CLU [@l(#LG86)], por ejemplo) llegan a incluir este
  patron directamente.

  1. @e(¿Quien controla la iteracion?) Una cuestion fundamental es decidir que
     participante controla la iteracion, si el iterador o el cliente que lo
     usa. Cuando es el cliente quien controla la iteracion, el iterador se
     denomina iterador externo, y cuando es el iterador quien la controla, se
     dice que el iterador es un iterador interno.@n(43) Los clientes que usan un
     iterador externo deben avanzar en el recorrido y pedirle explicitamente al
     iterador el siguiente elemento. En el caso contrario, el cliente maneja un
     iterador intero y este aplica esa operacion a cada elemento del agregado.

     Los iteradores externos son mas flexibles que los internos. Por ejemplo,
     resulta facil comparar dos colecciones para ver si son iguales usando un
     iterador externo, pero esto misma es practicamente imposible con iteradores
     internos. Los iteradores internos son especialmente debiles en un lenguaje
     como C++, que no proporciona funciones anonimas, cierres o reanudaciones
     como si hacen Smalltalk y CLOS. Pero, por otro lado, los iteradores
     internos son mas faciles de usar, ya que definen la logica de iteracion por
     nosotros.

  2. @e(¿Quien define el algoritmo de recorrido?) El iterador no es el unico
     lugar donde se puede definir el algoritmo de recorrido. El agregado podria
     definir el algoritmo de recorrido y usar el iterador para almacenar solo el
     estado de la iteracion. A este tipo de iterador lo denominamos @b(cursor),
     ya que se limita a apuntar a la posicion actual del agregado. Un cliente
     invocara a la operacion @c(Siguiente) sobre el agregado con el cursor como
     parametro, y la operacion @c(Siguiente) cambiara el estado del cursor.@n(44)

     Si el iterador es el responsable del algoritmo de recorrido, entonces es
     facil usar diferentes algoritmos de iteracion sobre el mismo agregado, y
     tambien puede ser mas facil reutilizar el mismo algoritmo sobre diferentes
     agregados. Por otro lado, el algoritmo de recorrido puede necesitar acceder
     a las variables privadas del agregado. Si es asi, poner el algoritmo de
     recorrido en el iterador violaria la encapsulacion del agregado.

  3. @e(¿Como es de robusto el iterador?) Puede ser peligroso modificar un
     agregado mientras lo estamos recorriendo. Si se añaden o borran elementos
     del iterador podriamos acabar accediendo dos veces a un elemento o a uno
     que ya no existe. Uno solucion sencilla es copiar el agregado y recorrer la
     copia, pero eso es demasiado costoso como para hecerlo siempre.

     Un @b(iterador robusto) garantiza que las inserciones y borrados no
     interfieran con el recorrido, y lo hace sin copiar el agregado. Hay muchas
     formas de implementar iteradores robustos. La mayoria se basan en
     registrar el iterador con el agregado. Al insertar o borrar, el agregado
     ajusta el estado interno de los iteradores que han producido, o mantiene
     informacion internamente para garantizar un recorrido apropiado.

     Kofler proporciona una buena discusion acerca de como estan implementados
     los iteradores robustos en ET++ [@l(#Kof93)]. Murray examina la implemantacion
     de iteradores robustos para la clase @c(List) de USL StandardComponents
     [@l(#Mur93)].

  4. @e(Operaciones adicionales de @c(Iterador).) La interfaz minima de @c(Iterador)
     consiste en las operaciones @c(Primero), @c(Siguiente), @c(HaTerminado) y
     @c(ElementoActual).@n(45) Podrian ser utiles algunas operaciones
     adicionales. Por ejemplo, los ageregados ordenados pueden tener una
     operacion @c(Anterior) que posicione el iterador en el elemento
     anterior. Una operacion @c(IrA) es util para ordenar o indexar
     colecciones. @c(IrA) posiciona el iterador en un objeto que cumpla el
     criterio especificado.

  5. @e(Usar iteradores polimorficos en C++.) Los iteradores polimorficos tienen
     un coste. Necesitan que el objeto iterador sea creado dinamicamente por un
     metodo de fabricacion. Por tanto deberian usarse solo cuando hay necesidad
     de polimorfismo. En caso contrario, es mejor usar iteradores concretos, que
     pueden crearse en la pila.

     Los iterador polimorficos tienen otro inconveniente: el cliente es el
     responsable de borrarlos. Esto es propenso a errores, ya que es facil
     olvidarse de liberar la memoria asignada a un iterador cuando se ha
     terminado de usarlo. Eso es especialmente probable cuando en una operacion
     hay multiples puntos de salida. Y si se lanza una excepcion, el objeto
     iterador nunca se liberara.

     El patron @l(#Proxy) proporciona un remedio para esto. Podemos usar un
     proxy en la memoria de pila como sustituto del iterador real. El proxy
     elimina el iterador en su destructor. Asi, cuando el proxy garantiza una
     limpieza adecuada, incluso en el caso de que se produzcan excepciones. esta
     es una aplicacion de la conocida tecnica de C++ @"(asignacion de recursos
     en inializacion) [@l(#ES90)]. El Codigo de Ejemplo ofrece un ejemplo de esto.

  6. @e(Los iteradores pueden tener un acceso restringido.) Podemos ver a un
     iterador como una extension del agregado que lo crea. El iterador y el
     agregado estan fuertemento acoplados. En C++ se puede expresar esta estrecha
     relacion haciendo que el iterador sea un clase @c(friend) de su agregado.
     En ese caso ya no es necesario definir operaciones en el agregado cuyo
     unico proposito es permitir a los iteradores implementar el recorrido de
     manera eficiente.

     Sin embargo, este acceso restringido puede dificultar la definicion de
     nuevos recorridos, ya que requerira cambiar la interfaz del agregado para
     añadir otra clase de amiga. Para evitar este problema, la clase @c(Iterador)
     puede incluir operaciones de tipo @c(protected) para acceder a los miembros
     importantes, pero no estan disponibles publicamente, del agregado. Las
     subclases de @c(Iterador) (y @e(solo) ellas) pueden usar estas operaciones
     protegidas para obtener un acceso restringido al agregado.

  7. @e(Iteradores en lugar de compuestos.) Los iteradores externos pueden ser
     dificiles de implementar sobre estructuras agregadas recursivas, como las
     del patron @l(#Composite), ya que una posicion de la estructura puede
     abarcar muchos niveles de agregados anidados. Por tanto, un iterador
     externo tiene que guardar una ruta a traves del @c(Compuesto) para saber
     cual es el objeto actual. A veces es mas facil usar un iterador
     interno. Este puede guardar la posicion actual simplemente llamandose a si
     mismo de forma recursiva, por lo que la ruta estara guardada implicitamente
     en la pila de llamadas.

     Si los nodos de un @c(Compuesto) tienen interfaz para ir de un nodo a sus
     hermanos, padres e hijos, entonces un iterador basado en un cursor puede
     ofrecer una alternativa mejor. El cursor solo necesita conocer al nodo
     actual; puede apoyarse en la interfaz del nodo para recorrer el compuesto.

     Los compuestos muchas veces tienen que ser recorridos de mas de una
     manera. Son frecuentes los recorridos en preorden, postorden, enorden y
     primero-en-anchura. Se puede permitir cada tipo de recorrido con una clase
     diferente de iterador.

  8. @e(Iteradores nulos.) Un @c(IteradorNulo) es un iterador degenerado que
     ayuda a manejar las condiciones limite. Por definicion, un @c(IteradorNulo)
     @e(simpre) acaba el recorido; esto es, su operacion @c(HaTerminado) siempre
     se evalua a verdadero.

     @c(IteradorNulo) puede facilitar el recorrido de agregados de estructuras
     de arbol (como los compuestos). En cada punto del recorrido podemos
     pedirle al elemento actual un iterador para sus hijos. Los elementos
     agregados devuelven, como norma general, un iterador concreto. Pero los
     elementos hoja devuelven una instancia de @c(IteradorNulo). Esto nos
     permite implementar el recorrido sobre la estructura completa de un modo
     uniforme.

*** Iterator Codigo de Ejemplo <> Codigo de Ejemplo

  Examinaremos la implementacion de una clase @c(Lista) simple, la cual forma
  parte de nuestra biblioteca basica (@l(#Apendice C)). se mostraran dos
  implementaciones de @c(Iterador), una  para recorrer la @c(Lista) de principio
  a fin y otra para recorrerla hacia atras (la biblioteca solo permite el
  primero de estos recorridos). A continuacion se muestra como usar estos
  iteradores y como evitar atarse a una determinada implementacion. Tras todo
  eso, se cambia el diseño para asegurar que los iteradores se borran
  correctamente. El ultimo ejemplo muestra un iterador interno y lo compara con
  su equivalente externo.

  1. @e(Interfaces @c(Lista) e @c(Iterador).) Veamos en primer lugar la parte de
     la interfaz de @c(Lista) que tiene que ver con la implementacion de los
     iteradores. En el @l#(Apendice C) puede verse la interfaz completa.

     ..src > c++
       template <class Elemento>
       class Lista {
       public:
           Lista(long tamano = CAPACIDAD_PREDETERMINADA_LISTA);

           long Contar() const;
           Elemento& Obtener(long indice) const;
           // ...
       };
     < src..

     La clase @c(Lista) proporciona, mediante su interfaz publica, un modo
     razonablemente eficiente de permitir la iteracion. Basta con implementar
     ambos recorridos. De modo que no hay necesidad de dar a los iteradores un
     acceso restringido a la estructura de datos subyacente; es decir, las
     clases de los iteradores no son amigas de @c(Lista). Para permitir el uso
     transparente de diferentes recorridos definimos una clase abstracta
     @c(Iterador), que define la interfaz del iterador.

     ..src > c++
       template <class Elemento>
       class Iterador {
       public:
           virtual void Primero() = 0;
           virtual void Siguiente() = 0;
           virtual bool HaTerminado() const = 0;
           virtual Elemento ElementoActual() const = 0;
       protected:
           Iterador();
       };
     < src..

  2. @e(Implementaciones de las subclases de @c(Iterador).) @c(IteradorLista) es
     una subclase de @c(Iterador).

     ..src > c++
       template <class Elemento>
       class IteradorLista : public Iterador<Elemento> {
       public:
           IteradorLista(const Lista<Elemento>* unaLista);
           virtual void Primero();
           virtual void Siguiente();
           virtual bool HaTerminado() const;
           virtual Elemento ElementoActual() const;

       private:
           const Lista<Elemento>* _lista;
           long _actual;
       };
     < src..

     La implementacion de @c(IteradorLista) es sencilla. Esta guarda la
     @c(Lista) junto con el indice @c(_actual):

     ..src > c++
       template <class Elemento>
       IteradorLista<Elemento>::IteradorLista (
           const Lista<Elemento>* unaLista
       ) : _lista(unaLista), _actual(0) {
       }
     < src..

     @c(Primero) posiciona el iterador en el primer elemento:

     ..src > c++
       template <class Elemento>
       void IteradorLista<Elemento>::Primero () {
           _actual =  0;
       }
     < src..

     @c(Siguiente) avanza hasta el siguiente elemento:

     ..src > c++
       template <class Elemento>
       void IteradorLista<Elemento>::Siguiente () {
           _actual++;
       }
     < src..

     @c(HaTerminado) comprueba si el indice se refiere a un elemento de la
     @c(Lista):

     ..src > c++
       template <class Elemento>
       bool IteradorLista<Elemento>::HaTerminado () const {
           return _actual >= _lista->Contar();
       }
     < src..

     Por ultimo, @c(ElementoActual) devuelve el elemento situado en la posicion
     dada por el indice actual. Si la iteracion ya ha termindo se lanza una
     excepcion @c(IteradoFueraDeLimites):

     ..src > c++
       template <class Elemento>
       Elemento IteradorLista<Elemento>::ElementoActual () const {
           if (HaTerminado()) {
               throw IteradorFueraDeLimites;
           }
           return _lista->Obtener(_actual);
       }
     < src..

     La implementacion de @c(IteradorListaHaciaAtras) es identica, salvo que su
     operacion @c(Primero) posiciona @c(_actual) en el final de la lista, y
     @c(Siguiente) va disminuyendo @c(_actual) hasta llegar al primer elemento.

  3. @e(Usar los iteradores.) Supongamos que tenemos una @c(Lista) de objetos
     @c(Empleado) y queremos imprimir todos los empleados que contiene. La clase
     @c(Empleado) permite esto con una operacion @c(Imprimir). Para imprimir la
     lista, definimos una operacion @c(ImprimirEmpleados) que toma como
     parametros un iterador, al cual usa para recorrer e imprimir la lista.

     ..src > c++
       void ImprimirEmpleados (Iterador<Empleado*>& i) {
           for (i.Primero(); !i.HaTerminado(); i.Siguiente()) {
               i.ElementoActual()->Imprimir();
           }
       }
     < src..

     Puesto que tenemos iteradores para los recorridos hacia atras y ahacia
     delante, podemos reutilizar esta operacion para que muestre los empleados en
     ambos sentidos.

     ..src > c++
       Lista<Empleado*>* empleados;
       // ...
       IteradorLista<Empleado*> haciaDelante(empleados);
       IteradorListaHaciaAtras<Empleado*> haciaAtras(empleados);

       ImprimirEmpleados(haciaDelante);
       ImprimirEmpleados(haciaAtras);
     < src..

  4. @e(Evitar ajustarse a una implementacion de lista en concreto.) Pensemos en
     como una variante lista con saltos de @c(Lista) afectaria a nuestro codigo
     de iteracion. Una subclase de @c(Lista), @c(ListaConSaltos), debe
     proporcionar un @c(IteradorListaConSaltos) que implemente la interfaz
     @c(Iterator). Internamente, el @c(iteradorListaConSaltos) tiene que
     mantener algo mas que un indice para hacer la iteracion eficientemente.
     Pero, dado que @c(IteradorListaConSaltos) se ajusta a la interfaz de
     @c(Iterator), la operacion @c(ImprimirEmpleados) tambien puede usarse
     cuando los empleados se guardan en un objeto @c(ListaConSaltos).

     ..src > c++
       ListaConSaltos<Empleado*>* empleados;
       // ...

       IteradorListaConSaltos<Empleado*> iterador(empleados);
       ImprimirEmpleados(iterador);
     < src..

     Si bien este enfoque funciona, seria mejor si no tuvieramos que atarnos a
     una determinada implementacion de @c(Lista), como por ejemplo
     @c(ListaConSaltos). Podemos introducir una clase @c(ListaAbstracta) para
     estandarizar la interfaz de lista para diferentes implementaciones de
     listas, convirtiendose @c(Lista) y @c(ListaConSaltos) en subclases de
     @c(ListaAbstracta).

     Para permitir la iteracion polimorfica, @c(ListaAbstracta) define un metodo
     de fabricacion @c(CrearIterador), el cual es redefinido por las subclases
     para devolver su correspondiente iterador:

     ..src > c++
       template <class Elemento>
       class ListaAbstracta {
       public:
           virtual Iterador<Elemento>* CrearIterador() const = 0;
           // ...
       };
     < src..

     Una alternativa seria definir una clase mezclable (@e(mixin)) general,
     @c(Recorrible), que define la interfaz para crear un iterador. Las clases
     agregadas puden combinarse con @c(Recorrible) para permitir la iteracion
     polimorfica.

     @c(Lista) redefine @c(CrearIterador) para devolver un objeto
     @c(IteradorLista):

     ..src > c++
       template <class Elemento>
       Iterador<Elemento>* Lista<Elemento>::CrearIterador () const {
           return new IteradorLista<Elemento>(this);
       }
     < src..

     Ahora nos encontramos en posicion de escribir el codigo para imprimir los
     empleados independientemente de una representacion concreta.

     ..src > c++
       // solo sabemos que tenemos una ListaAbstracta
       ListaAbstracta<Empleado*>* empleados;
       // ...

       Iterador<Empleado*>* iterador = empleados->CrearIterador();
       ImprimirEmpleados(*iterador);
       delete iterador;
     < src..

  5. @e(Asegurarse de que los iteradores son eleminados.) Notese que
     @c(CrearIterador) devuelve un objeto iterador recien creado. Somos
     responsables de borrar dicho objeto. Si nos olvidamos habremos creado un
     agujero de memoria. Para facilitar la vida a los clientes,
     proporcionaremos un @c(PunteroIterador) que hace de proxy de un
     iterador. Se ocupa de limpiar el objeto @c(Iterador) cuando este se sale de
     ambito.

     @c(PunteroIterador) siempre se crea en la pila.@n(46) C++ se encarga de
     llamar automaticamente a su constructor cuando se borra el iterador real.
     @c(PunteroIterador) sobrecarga tanto @c(operator->) como @c(operator*) de
     modo que un @c(PunteroIterador) puede ser tratado exactamente igual que un
     puntero a un iterador. Los miembros de @c(PunteroIterador) se implementan
     todos en linea; de ese modo no disminuyen el rendimiento.

     ..src > c++
       template <class Elemento>
       class PunteroIterador {
       public:
           PunteroIterador(Iterador<Elemento>* i): _i(i) { }
           ~PuenteroIterador() { delete _i; }

           Iterador<Elemento>* operator->() { return _i; }
           Iterador<Elemento>& operator*() { return *_i; }
       private:
           // deshabilita la copia y la asignacion para evitar
           // borrados multiples de _i:

           PunteroIterador(const PunteroIterador&);
           PunteroIterador& operator=(const PunteroIterador&);
       private:
           Iterador<Elemento>* _i;
       };
     < src..

     @c(PunteroIterador) nos permite simplificar nuestro codigo de impresion:

     ..src > c++
       ListaAbstracta<Empleado*>* empleados;
       // ...

       PunteroIterador<Empleado*> iterador(empleados->CrearIterador());
       ImprimirEmpleados(*iterador);
     < src..

  6. @e(Un @c(IteradorLista) interno.) Como ejemplo final, echemos un vistazo a
     una posible implementacion de una clase @c(IteradorLista). En este ejemplo
     es el iterador quien controla la iteracion, y quien aplica una iteracion a
     cada elemento.

     El problema en este caso es como parametrizar el iterador con la operacion
     que queremos realizar sobre cada elemento. C++ no proporciona funciones
     anonimas o cierres que otros lenguajes si proveen para este tipo de
     tareas. Hay al menos dos opciones: (1) pasar un puntero a una funcion
     (global o estatica), o (2) apoyarse en la herencia. En el primer caso, el
     iterador llama a una operacion que una subclase redefine para representar
     el comportamiento especifico.

     Ninguna opcion es perfecta. A menudo queremos acumular el estado durante
     la iteracion, y las funciones no estan pensadas para eso; tendriamos que
     usar variables estaticas para recordar el estado. Una subclase de
     @c(Iterador) nos porporciona un lugar apropiado para guardar el estado
     acumulado, por ejemplo en una variable de instancia. Pero crear una
     subclase para cada recorrido diferente significa mas trabajo.

     Este es un esbozo de la segunda opcion, usando la herencia. Llamaremos al
     iterador interno un @c(RecorredorLista).

     ..src > c++
       template <class Elemento>
       class RecorredorLista {
       public:
           RecorredorLista(Lista<Elemento>* unaLista);
           bool Recorrer();
       protected:
           virtual bool ProcesarElemento(const Elemento&) = 0;
       private:
           IteradorLista<Elemento> _iterador;
       };
     < src..

     @c(RecorredorLista) toma una instancia de @c(Lista) como parametro.
     Interamente usa un @c(IteradorLista) externo para hacer el recorrido.
     @c(Recorrer) comienza el recorrido y llama a @c(ProcesarElemento) para cada
     elemento. El iterador interno puede decidir terminar un recorrido
     devolviendo @c(false) en @c(ProcesarElemento). En caso de que el recorrido
     haya terminad de forma prematura, @c(Recorrer) acaba.

     ..src > c++
       template <class Elemento>
       RecorredorLista<Elemento>::RecorredorLista (
           Lista<Elemento>* unaLista
       ) : _iterador(unaLista) { }

       template <class Elemento>
       bool RecorredorLista<Elemento>::Recorrer () {
           bool resultado = false;

           for (
                _iterador.Primero();
                !_iterador.HaTerminado();
                _iterador.Siguiente();
           ) {
               resultado = ProcesarElemento(_iterador.ElementoActual());

               if (resultado == false) {
                   break;
               }
           }
           return resultado;
       }
     < src..

     Usemos ahora un @c(RecorredorLista) para imprimir los primeros 10 empleados
     de nuestra lista de empleados. Para hacer esto tenemos que heredar de
     @c(RecorredorLista) y redefinir @c(ProcesarElemento). Contamos el numero de
     empleados mostrados en una variable de instancia @c(_contador).

     ..src > c++
       class ImprimirNEmpleados : public RecorredorLista<Empleado*> {
       public:
           ImprimirNEmpleados(Lista<Empleado*>* unaLista, int n) :
               RecorredorLista<Empleado*>(unaLista),
               _total(n), _contador(0) { }
       protected:
           bool ProcesarElemento(Empleado* const&);
       private:
           int _total;
           int _contador;
       };

       bool ImprimirNEmpleados::ProcesarElemento (Empleado* const& e) {
           _contador++;
           e->Imprimir();
           return _contador < _total;
       }
     < src..

     Asi es como @c(ImprimirNEmpleados) imprime los primeros 10 empleados de la
     lista:

     ..src > c++
       Lista <Empleado*>* empleados;
       // ...

       ImprimirNEmpleados pa(empleados, 10);
       pa.Recorrer();
     < src..

     Notese como el cliente no especifica el bucle de iteracion. Toda la logica
     de iteracion puede ser reutilizada. Esta es la principal ventaja de un
     operador interno. Es algo mas de trabajo que con un iterador externo, ya
     que tenemos que definir una nueva clase. Comparese esto con el uso de un
     iterador externo:

     ..src > c++
       IteradorLista<Empleado*> i(empleados);
       int contador = 0;

       for (i.Primero(); !i.HaTerminado(); i.Siguiente()) {
           contador++;
           i.ElementoActual()->imprimir();

           if (contador >= 10) {
               break;
           }
       }
     < src..

     Los iteradores internos pueden encapsular diferentes tipos de iteracion.
     Por ejemplo, @c(RecorredorListaConFiltro) encapsula una iteracion que
     procesa solo aquellos elementos que verifican una comprobacion:

     ..src > c++
       template <class Elemento>
       class RecorredorListaConFiltro {
       public:
           RecorredorListaConFiltro(lista<Elemento>* unaLista);
           bool Recorrer();
       protected:
           virtual bool ProcesarElemento(const Elemento&) = 0;
           virtual bool ComprobarElemento(const Elemento&) = 0;
       private:
           IteradorLista<Elemento> _iterador;
       };
     < src..

     Esta interfaz es la misma que la de @c(RecorredorLista) salvo por una
     funcion miembro añadida, @c(ComprobarElemento), que define la
     comprobacion. Las subclases redefinen @c(ComprobarElemento) para
     especificar la comprobacion.

     @c(Recorrer) decide continuar el recorrido basandose en el resultado de la
     comprobacion:

     ..src > c++
       template <class Elemento>
       void RecorredorListaConFiltro<Elemento>::Recorrer () {
           bool resultado = false;

           for (
                _iterador.Primero();
                !_iterador.HaTerminado();
                _iterador.Siguiente();
           ) {
               if (ComprobarElemento(_iterador.ElementoActual())) {
                   resultado = ProcesarElemento(_iterador.ElementoActual());
                   if (resultado == false) {
                       break;
                   }
               }
           }
           return resultado;
       }
     < src..

     Una variante de esta clase podria definir @c(Recorrer) para que terminase
     si al menos un elemento satisface la comprobacion.@n(47)

*** Iterator Usos Conocidos <> Usos Conocidos

  Los iteradores son frecuentes en los sistemas orientados a objetos. La mayoria
  de las bibliotecas de clases ofrecen iteradores de una forma u otra.

  El siguiente es un ejemplo de los componentes de Booch [@l(#Boo94)], una
  popular biblioteca de clases de colecciones. Proporciona dos implementaciones
  de una cola, una para un tamaño fijo y otra que puede crecer dinamicamente. La
  interfaz de la cola la define una clase abstracta @c(Queue). Para permitir
  iterar polimorficamente sobre las diferentes implementaciones de colas, el
  iterador de la cola se implementa en terminos de la interfaz de la clase
  abstracta @c(Queue). Esta variacion tiene la ventaja de que no se necesita un
  metodo de fabricacion para pedirle a las implementaciones de colas su iterador
  apropiado. No obstante, es necesario que la interfaz de la clase abstracta
  @c(Queue) sea lo bastante potente como para implementar de manera eficiente el
  iterador.

  En Smalltalk no hay que definir explicitamente los iteradores. Las clases de
  colecciones estandar (@c(Bag), @c(Set), @c(Dictionary), @c(OrderedCollection),
  @c(String), etc.) definen un metedo @c(do:) como un iterador interno, el cual
  toma un bloque (es decir, un cierre) como parametro. Cada parametro  de la
  coleccion se liga a la variable local del bloque; a continuacion se ejecuta el
  bloque. Smalltalk tambien incluye un conjunto de clases @c(Stream) que
  permiten una interfaz similar a un iterador. @c(ReadStream) es basicamente un
  iterador, y puede actuar como un iterador externo para todas las colecciones
  secuenciales. No hay iteradores externos estandar para las colecciones no
  secuenciales como @c(Set) y @c(Dictionary).

  Las clases contenedoras de ET++ proporcionan los iteradores polimorficos y el
  Proxy de limpieza descritos anteriormente [@l(#WGM88)]. Las clases del framework de
  editores graficos usan iteradores basados en cursores [@l(#VL90)].

  ObjectWindows 2.0 [@l(#Bor94)] provee una jerarquia de clases de iteradores para
  conectores. Se puede iterar sobre diferentes tipos de conectores del mismo
  modo. La sintaxis de iteracion de ObjectWindow se basa en sobrecargar el
  operader de incremento postfijo, @c(++), para avanzar en la iteracion.

*** Iterator Patrones Relacionados <> Patrones Relacionados

  @l(#Composite): los iteradores suelen aplicarse a estructuras recursivas como
  los compuestos.

  @l(Factory Method): los iteradores polimorficos se basan en metodos de
  fabricacion para crear instancias de las subclases apropiadas de Iterator.

  El patron @l(#Memento) suele usarse conjuntamente con el patron Iterator. Un
  iterador puede usar un memento para representar el estado de una iteracion. El
  iterador almacena el memento internamente.

** Mediator
*** Mediator Proposito <> Proposito

  Define un objeto que encapsula como interactuan una serie de objetos. Promueve
  un bajo acoplamiento al evitar que los objetos se refieran unos a otros
  explicitamente, y permite variar la interaccion entre ellos de forma independiente.

*** Mediator Motivacion <> Motivacion

  los diseñadores orientados a objetos promueven la distribucion de
  comportamientos entre objetos. Dicha distribucion puede dar lugar a una
  estructura de objetos con muchas conexiones entre ellos; en el peor de los
  casos, cada objeto acaba por conocer a todos los demas.

  Aunque dividir un sistema en muchos objetos suele mejorar la reutilizacion, la
  proliferacion de interconexiones tiende a reducir esta de nuevo. Tener muchas
  interconexiones hace que sea menos probable que un objeto pueda funcionar sin
  la ayuda de otros @-(el sistema se comporta como si fuera monolitico). Mas
  aun, puede ser dificil cambiar el comportamiento del sistema de manera
  significativa, ya que el comportamiento se encuentra distribuido en muchos
  objetos. Como resultado, podemos vernos forzados a definir muchas subclases
  para personalizar el comportamiento del sistema.

  Sea, por ejemplo, la implementacion de cuadros de dialogo en una interfaz
  grafica de usuario. Un cuadro de dialgo usa una ventana para presentar una
  coleccion de utiles@n(28) tales como botones, menus y campos de entrada, como
  se muestra a acontinuacion:

  ..img > img/100.png

  Muchas veces hay dependencias entre los utiles del dialogo. Por ejemplo, un
  boton esta desactivado cuando esta vacio un capo de entrada determinado.
  Seleccionar una entrada de una lista de opciones, llamada @b(lista
  desplegable) @%e(list box), puede cambiar el contenido de un campo de entrada. A
  la inversa, teclear texto en el campo de entrada puede seleccionar
  automaticamente una o mas entradas de la lista desplegable. En cuanto haya
  texto en el campo de entrada pueden activarse otros botones para permitir al
  usuario hacer algo con dicho texto, como cambiar o borrar aquello a lo que se
  refiere.

  Distintos cuadros de dialogo tendran distintas dependencias entre utiles. Asi,
  aunque los dialoges muestran los mismo tipos de utiles, no pueden reutilizar
  directamente las clases de utiles de las que se dispone; se ven obligados a
  personalizarlas para que reflejen las dependencias especificas de cada
  dialogo. Personalizarlas una a una mediante la herencia seria tedioso, ya que
  hay muchas clases involucradas.

  Estos problemas pueden ser evitados encapsulando el comportamiento colectivo
  en un objeto aparte llamado @b(mediador). Un mediador es responsable de
  controlar y coordinar las interaciones entre un grupo de objetos. El mediador
  hace las veces de un intermediario que evita que los objetos del grupo se
  refieran unos a otros explicitamente. Los objetos solo conocen al mediador,
  reduciendo asi el numero de interconexiones.

  Por ejemplo, @c(DirectorDialogoFuente) podria ser el mediador entre los utiles
  de un cuardro de dialogo. Un objeto @c(DirectorDialogoFuente) conoce a los
  utiles de un dialogo y coordina su interaccion. Funciona como un
  concentrador@n(48) de comunicaciones para utiles:

  ..img > img/101.png

  El siguiente diagrama de interaccion ilustra como cooperan los objetos para
  manejar un cambio en la seleccion de una lista:

  ..img > img/102.png

  Esta es la sucesion de eventos que tienen lugar cuando la seleccion de una
  lista pasa a un campo de entrada:

  1. La lista desplegable le dice a su director que ha cambiado.

  2. El director obtiene la seleccion de la lista.

  3. El director le pasa la seleccion al campo de entrada.

  4. Ahora que el campo de entrada contiene algo de texto, el director activa
     uno o varios botones que permitan inicializar una accion (por ejemplo,
     @"(negrita) o @"(cursiva)).

  Notese como el director media entre la lista y el campo de entrada. Los utiles
  se comunican unos con otros solo indirectamente, a travez del director. No
  tienen que saber nada de los otros; al unico al que conocen es al
  director. Ademos dado que el comportamiento se encuentra localizado en una
  clase, puede cambiarse o reemplazarse extendiendo o sustituyendo esa clase.

  Asi es como la abstraccion @c(DirectorDialogoFuente) puede integrarse en una
  biblioteca de clases:

  ..img > img/103.png

  @c(DirectorDialogo) es una clase abstracta que define el comportamiento general
  de un dialogo. Los clientes llaman a la operacion @c(MostrarDialogo) para
  mostrar el dialogo en la pantalla. @c(CrearUtiles) es una operacion abstracta
  que crea los utiles de un dialogo. @c(UtilModificado) es otra operacion
  abstracta a la que llaman los utiles para informar a su director de que han
  cambiado. Las subclases de @c(DirectorDialogo) redefinen @c(CrearUtiles) para
  crear los utiles apropiados, asi como @c(UtilModificado) para manejar los
  cambios.

*** Mediator Aplicabilidad <> Aplicabilidad

  Usese el patron Mediator cuando

  - un conjunto de objetos se comunican de forma bien definida, pero
    compleja. Las interdependencias resultantes no estan estructuradas y son
    dificiles de comprender.

  - es dificil reutilizar un objeto, ya que este se refiere a otros muchos
    objetos, con los que se comunica.

  - un comportamiento que esta distribuido entre varias clases deberia poder ser
    adaptado sin necesidad de una gran cantidad de subclases.

*** Mediator Estructura <> Estructura

  ..img > img/104.png

  Una estructura de objetos tipica podria parecerse a esta:

  ..img > img/105.png

*** Mediator Participantes <> Participantes

  - @c(Mediador) (@c(DirectorDialogo))

    - define una interfaz para comunicarse con sus objetos @c(Colega).

  - @c(MediadorConcreto) (@c(DirectorDialogoFuente))

    - implementa el comportamiento cooperativo coordinado objetos @c(Colega).

    - conoce a sus @c(Colega)s.

  - @b(clases) @c(Colega) (@c(ListaDesplegable), @c(CampoDeEntrada))

    - cada clase @c(Colega) conoce a su objeto @c(Mediador).

    - cada @c(Colega) se comunica con su mediador cada vez que, de no existir este,
      se hubiera comunicado con otro @c(Colega).

*** Mediator Colaboraciones <> Colaboraciones

  Los Colegas envian y reciber peticiones a traves de un Mediador. El mediador
  implementa el comportamiento cooperativo encaminando estas peticiones a los
  Colegas apropiados.

*** Mediator Consecuencias <> Consecuencias

  El patron Mediador tiene las siguientes ventajas e inconvenientes:

  1. @e(Reduce la herencia.) Un mediador localiza el comportamiento que de otra
     manera estaria distribuido en varios objetos. Para cambiar este
     comportamiento solo es necesario crear una subclase del Mediador; las
     clases @c(Colega) puden ser reutilizadas tal cual.

  2. @e(Desacopla a los Colegas.) Un mediador promueve un bajo acoplamiento
     entre Colegas. Las clases @c(Colega) pueden usarse y modificarse de forma
     independiente.

  3. @e(Simplifica los protocolos de los objetos.) Un mediador sustituye
     interacciones muchos-a-muchos por interacciones una-a-muchos entre el
     mediador y sus colegas. Las relaciones uno-a-muchos son mas faciles de
     compreder, mantener y extender.

  4. @e(Abstrae como cooperan los objetos.) Hacer de la mediacion un concepto
     independiente y encapsularla en un objeto permite centrarse en como
     interactuan los objetos en vez de en su comportamiento individual. Eso
     ayuda a clarificar como interactuarn los objetos de un sistema.

  5. @e(Centrar el control.) El patron Mediator cambia complejidad de
     interaccion por complejidad en el mediador. Dado que un mediador encapsula
     protocolos, puede hacerse mas complejo que cualquier @c(Colega)
     individual. Esto puede hacer del mediador un monolito dificil de mantener.

*** Mediator Implementacion <> Implementacion

  Son pertinentes los siguientes detalles de implementacion para el patron
  Mediator:

  1. @e(Omitir la clase abstracta @c(Mediador).) No es necesario definir una clase
     abstracta @c(Mediador) cuando los Colegas solo trabajan con un mediador. El
     acoplamiento abstracto proporcionado por la clase @c(Mediador) permite que los
     @c(Colega)s trabajen con diferentes subclases de @c(Mediador), y viceversa.

  2. @e(Comunicacion @c(Colega)-@c(Mediador).) Los Colegas tienen que
     comunicarse con su mediador cuando tiene lugar un evento de interes. Un
     enfoque es implementar el Mediador como un Observador, usando el patron
     @l(#Observer). Las clases @c(Colega) hacer de @c(Sujeto), enviando
     notificaciones al mediador cada vez que cambia su estado. El mediador
     responde propagando los efectos del cambio a otros Colegas.

     Otro enfoque define en el Mediador una interfaz de notificacion
     especializada que permite a los Colegas ser mas directos en su
     comunicacion. Smalltalk/V para Windows usa una forma de delegacion: cuando
     se comunica con el mediador, un Colega se pasa a si mismo como parametro,
     permitiendo al mediador identificar al emisor. El Codido de Ejemplo usa
     este enfoque y la implementacion de Smalltalk/V se examina mas adelante en
     los Usos Conocidos.

*** Mediator Codigo de Ejemplo <> Codigo de Ejemplo

  Usaremos un @c(DirectorDialogo) para implementar el cuadro de dialogo de
  seleccion del tipo fuente que se mostro en la Motivacion. La clase abstracta
  @c(Directordialogo) define la interfaz para los directores.

  ..src > c++
    class DirectorDialogo {
    public:
        virtual ~DirectorDialogo();

        virtual void MostrarDialogo();
        virtual void UtilModificado(Util*) = 0;

    protected:
        DirectorDialogo();
        virtual void CrearUtiles() = 0;
    };
  < src..

  @c(Util) es la clase base abstracta para los utiles. Un util conoce a su
  director.

  ..src > c++
    class Util {
    public:
        Util(DirectorDialogo*);
        virtual void Modificado();

        virtual void ManejarRaton(EventoRaton& evento);
        // ...
    private:
        DirectorDialogo* _director;
    };
  < src..

  @c(Modificado) llama a la operacion @c(UtilModificado) del director. Los utiles
  llaman a @c(UtilModificado) sobre su director para informarle de un evento
  significativo.

  ..src > c++
    void Util::Modificado () {
        _director->UtilModificado(this);
    }
  < src..

  Las subclases de @c(DirectorDialogo) redefinen @c(UtilModificado) para afectar
  a los utiles apropiados. El util pasa una referencia a si mismo como parametro
  a @c(UtilModificado), para que el director pueda identificar al util modificado.
  Las subclases de @c(DirectorDialogo) redefinen el metodo virtual pero
  @c(CrearUtiles) para construir los utiles del dialogo.

  @c(ListaDesplegable), @c(CampoDeEntrada) y @c(Boton) son subclases de @c(Util)
  para elementos especializados de la interfaz de usuario. @c(ListaDesplegable)
  proporciona una operacion @c(ObtenerSeleccion) para obtener la seleccion
  actual, y la operacion @c(EstablecerTexto) de @c(CampoDeEntrada) permite poner
  texto en el campo.

  ..src > c++
    class ListaDesplegable : public Util {
    public:
        ListaDesplegable(DirectorDialogo*);

        virtual const char* ObtenerSeleccion();
        virtual void EstablecerLista(Lista<char*>* elementos);
        virtual void ManejarRaton(EventoRaton& evento);
        // ...
    };

    class CampoDeEntrada : public Util {
    public:
        CampoDeEntrada(DirectorDialogo*);

        virtua void EstablecerTexto(const char* texto);
        virtual const char* ObtenerTexto();
        virtual void ManejarRaton(EventoRaton& evento);
        // ...
    };
  < src..

  @c(Boton) es un util sencillo que llama a @c(Modificado) cada vez que es
  pulsado. Esto se hace en la implementacion de @c(ManejarRaton):

  ..src > c++
    class Boton : public Util {
    public:
        Boton(DirectorDialogo*);

        virtual void EstablecerTexto(const char* texto);
        virtual void ManejarRaton(EventoRaton& evento);
        // ...
    };

    void Boton::ManejarRaton (EventoRaton& evento) {
        // ...
        Modificado();
    }
  < src..

  La clase @c(DirectorDialogoFuente) media entre los utiles del cuadro de
  dialogo. @c(DirectorDialogoFuente) es una subclase de @c(DirectorDialogo):

  ..src > c++
    class DirectorDialogoFuente : public DirectorDialogo {
    public:
        DirectorDialogoFuente();
        virtual ~DirectorDialogoFuente();
        virtual void UtilModificado(Util*);

    protected:
        virtual void CrearUtiles();

    private:
        Boton* _aceptar;
        Boton* _cancelar;
        ListaDesplegable* _fuenteLista;
        CompoDeEntrada* _nombreFuente;
    };
  < src..

  @c(DirectorDialogoFuente) se ocupa de los utiles que muestra. Redefine
  @c(CrearUtiles) para crear los utiles e inicializar sus referencias para que
  apunten a el:

  ..src > c++
    void DirectorDialogoFuente::CrearUtiles () {
        _aceptar = new Boton(this);
        _cancelar = new Boton(this);
        _fuenteLista = new ListaDesplegable(this);
        _nombreFuente = new CampoDeEntrada(this);

        // rellenar la lista con los nombres de fuentes disponibles

        // ensambla los utiles en el dialogo
    }
  < src..

  @c(UtilModificado) garantiza que los utiles trabajen juntos adecuadamente:

  ..src > c++
    void DirectorDialogoFuente::UtilModificado (
        Util* elUtilModificado
    ) {
        if (elUtilModificado == _fuenteLista) {
            _nombreFuente->EstablecerTexto(_fuenteLista->ObtenerSeleccion());

        } else if (elUtilModificado == _aceptar) {
            // aplicar el cambio de fuente y cerrar el dialogo
            // ...

        } else if (elUtilModificado == _cancelar) {
            // cerrar el dialogo
        }
    }
  < src..

  La complejidad de @c(UtilModificado) crece proporcionalmente a la complejidad
  del dialogo. Los dialogos grandes son indeseables por otras razones, por
  supuesto, pero la complejidad del mediador podria mitigar los beneficios del
  patron en otras aplicaciones.

*** Mediator Usos Conocidos <> Usos Conocidos

  Tanto ET++ [@l(#WGM88)] como la biblioteca de clases THINK C [@l(#Sym93b)] usan objetos
  parecidos a directores como mediadores entre los utiles de los dialogos.

  La arquitectura de Smalltalk/V para Windows esta basada en una estructura de
  mediadores [@l(#LaL94)]. En ese entorno, una aplicacion consiste en un objeto
  @c(Window) que contiene un conjunto de paneles. La biblioteca contiene varios
  objetos @c(Pane) predefinidos; ejemplos de estos son @c(TextPane),
  @c(Listbox), @c(Button), etcetera. Estos paneles pueden usarse sin necesidad
  de heredar de ellos. Un desarrollador de aplicaciones solo hereda de
  @c(ViewManager), una clase que es la responsable de realizar la coordinacion
  entre paneles. @c(ViewManager) es el Mediador, y cada panel solo conoce a su
  gestor de vistas, considerado como el @"(propietario) del panel. Los paneles
  no se refieren unos a otros directamente.

  El siguiente diagrama de objetos muestra una instancia de una aplicacion en
  tiempo de ejecucion:

  ..img > img/106.png

  Smalltalk/V usa un mecanismo de eventos para la comunicacion
  @c(Pane)-@c(ViewManager). Un panel genera un evento cuando quiere obtener
  informacion del mediador o cuando quiere informar a este de que ha ocurrido
  algo significativo. Un evento define un simbolo (por ejemplo, @c(#select)) que
  lo identifica. Para manejar el evento, el gestor de vistas registra el
  selector de metodo con el panel. Este selector es el manejador de evento;
  sera invocado cada vez que ocurra un evento.

  El codigo siguiente muestra un esbozo de como se crea un objeto @c(ListaPane)
  dentro de una subclase de @c(ViewManager) y como @c(ViewManager) resgitra un
  manejador de eventos para el evento @c(#select:)

  ..src > smalltalk
    self addSubpane: (ListPane new
              paneName: 'miListPane';
              owner: self;
              when: #select perform: #listSelect:).
  < src..

  Otra aplicacion del patron Mediator es coordinar actualizaciones complejas. Un
  ejemplo de esto es la clase @c(GestorDeCambios) mencionada en el patron
  @l(#Observer). @c(GestorDeCambios) hace de mediador entre sujetos y
  observaderes para evitar actualizaciones redundantes. Cuando un objeto cambia,
  se notifica al @c(GestorDeCambios), quien coordina la actualizacion
  notificando a su vez los objetos dependientes.

  Una aplicacion similar aparece en el framework de dibujo Unidraw [@l(#VL90)], que
  usa una clase llama CSolver para hacer cumplir las restricciones de
  conectividad entre @"(conectores). Los objetos de los editores graficos pueden
  unirse entre si de diferentes formas. Los conectores son utiles en
  aplicaciones que mantienen la conectividad automaticamente, como editores de
  diagramas y sistemas de diseño de circuitos. CSolver es un mediador entre
  conectores, que resuelve las restricciones de conectividad y actualiza las
  posiciones de los conectores para que las reflejon adecuadamente.

*** Mediator Patrones Relacionados <> Patrones Relacionados

  El patron @l(#Facade) difiere del Mediator en que abstrae un subsistema de
  objetos para proporcionar una interfaz mas conveniente. Su protocolo es
  unidireccional; es decir, los objetos Fachada hacen peticiones a las clases
  del subsistema pero no a la inversa. Por el contrario, el patron Mediador
  permite un comportamiento cooperativo que no es proporcionado por los objetos
  Colegas y el protocolo es multidireccional.

  Los Colegas pueden comunicarse con el mediador usando el patron @l(#Observer).

** Memento
*** Memento Proposito <> Proposito

  Representa y externaliza el estado interno de un objeto sin violar la
  encapsulacion, de forma que este puede volver a dicho estado mas tarde.

*** Memento Tambien Conocido Como <> Tambien Conocido Como

  Token@n(49)

*** Memento Motivacion <> Motivacion

  A veces es necesario guardar el estado interno de un objeto. Esto es necesario
  cuando se implementan casillas de verificacion o mecanismos de deshacer que
  permiten a los usuarios anular operaciones provisionales y recuperarse de los
  errores. Debe guardarse informacion del estado en algun sitio para que los
  objetos puedan volver a su estado anterior. Pero los objetos normalmente
  encapsulan parte de su estado, o todo, haciendolo inaccesible a otros objetos
  e imposible de guardar externamente. Exponer este estado violara la
  encapsulacion, lo que puede comprometer la fiabilidad y extensibilidad de la
  aplicacion.

  Pensemos, por ejemplo, en un editor que permite conectar objetos. Un usuario
  puede conectar dos rectangulos con una linea, y los rectangulos permanecen
  conectados cuando el usuario mueve cualquiera de ellos. El editor garantiza
  que la linea se estira para mantener la conexion.

  ..img > img/107.png

  Una forma habitual de mantener relaciones de conectividad entre objetos es
  mediante un sistema de resolucion de problemas. Podemos encapsular esta
  funcionalidad en un objeto @c(ResolventeDeRestricciones).
  @c(ResolventeDeRestricciones) almacena las conexiones a medida que se van
  creando estas y genera ecuaciones matematicas que las describen. Cada vez que
  el usuario hace una conexion o modifica el diagrama resuelve dichas
  ecuaciones. @c(ResolventeDeRestricciones) usa los resultados de sus calculos
  para volver a colocar los graficos de forma que mantengan las conexiones
  adecuadas.

  Permitir que se puedan deshacer ciertas operaciones en esta aplicacion no es
  tan sencillo como en un principio podria parecer. Una manera obvia de deshacer
  una operacion de movimiento es guardar la distancia que se ha movido el objeto
  desde su posicion original y mover este hacia atras una distancia
  equivalente. Sin embargo, esto no garantiza que todos los objetos aparezcan
  como estaban antes. Supongamos que hay algo de holgura en la conexion. En ese
  caso, mover el rectangulo hacia atras, a su posicion original, no producira
  necesariamente el efecto deseado.

  ..img > img/108.png

  En general, la interfaz publica de @c(ResolventeDeRestricciones) podria no ser
  suficente para permitir revertir con presicion sus efectos sobre otros
  objetos. El mecanismo de deshacer debe trabajar mas estrechamente con
  @c(ResolventeDeRestricciones) para reestablecer el estado previo, pero, por
  otro lado, tambien deberiamos evitar exponer al mecanismo de deshacer las
  interioridades de @c(ResolventeDeRestricciones).

  Este problema se puede solucionar con el patron Memento. Un memento es un
  objeto que almacena una instancia del estado interno de otro objeto @-(el
  creador del memento). El mecanismo de deshacer solicitara un memento al
  creador cuando necesite comprobar el estado de este. El creador inicializa el
  memento con informacion que representa su estado actual. Solo el creador puede
  almacenar y recuperar informacion del memento @-(el memento es @"(opaco) a
  otros objetos).

  En el ejemplo del editor grafico que se acaba de describir, el
  @c(ResolventeDeRestricciones) puede actuar como un creador. La siguiente
  secuencia de eventos representa el proceso de deshacer:

  1. El editor solicita un memento al @c(ResolventeDeRestricciones) como un
     efecto lateral de la operacion de mover.

  2. El @c(ResolventeDeRestricciones) crea y devuelve un memento, en este caso
     una instancia de una clase @c(EstadoDelResolvente). Un memento del
     @c(EstadoDelResolvente) contiene estructuras de datos que describen el
     estado actual de las ecuaciones y variables internas del
     @c(ResorventeDeRestricciones).

  3. Mas tarde, cuando el usuario deshace la operacion mover, el editor le
     devuelve al @c(ResolventeDeRestricciones) el @c(EstadoDelResolvente).

  4. Dependiendo de la informacion del @c(EstadoDelResolvente), el
     @c(ResolventeDeRestricciones) cambia sus estructuras de datos internas para
     devolver sus ecuaciones exactamente a su estado anterior.

  Este acuerdo permite al @c(ResolventeDeRestricciones) confiar a otros objetos
  la informacion que necesita para volver a un estado previo sin exponer sus
  estructuras y reprepresentaciones internas.

*** Memento Aplicabilidad <> Aplicabilidad

  Usese el patron Memento cuando

  - hay que guardar una instancia del estado de un objeto (o de parte de este)
    para que pueda volver posteriormente a ese estado, y

  - una interfaz directa para obtener el estado exponga detalles de
    implementacion y rompa la encapsulacion del objeto

*** Memento Estructura <> Estructura

  ..img > img/109.png

*** Memento Participantes <> Participantes

  - @c(Memento) (@c(EstadoDelResolvente))

    - guarda el estado interno del objeto @c(Creador). El memento puede guardar
      tanta informacion del estado interno del creador como sea necesario a
      discrecion del creador

    - protege frente a accesos de otros objetos que no sean el creador. Los
      mementos tienen realmente dos interfaces. El @c(Conserje) ve una interfaz
      @e(reducida) del Memento @-(solo puede pasar el memento a otros
      objetos). El Creador, por el contrario, ve una interfaz @e(amplia), que le
      permite acceder a todos los datos necesarios para volver a su estado
      anterior. Idealmente, solo el creador que produjo el memento estaria
      autorizado a acceder al estado interno de este.

  - @c(Creador) (@c(ResolventeDeRestricciones))

    - crea un memento que contiene una instancia de su estado interno actual.

    - usa el memento para volver a su estado anterior.

  - @c(Conserje) (mecanismo de deshacer)

    - es responsable de guardar en un lugar seguro el memento.

    - nunca examina los contenidos del memento, ni opera sobre ellos.

*** Memento Colaboraciones <> Colaboraciones

  - Un conserje solicita un memento a un creador, lo almacena durante un tiempo
    y se lo devuelve a su creador, tal y como ilustra el siguiente diagrama de
    interaccion:

    ..img > img/110.png

    A veces el conserje no devolvera el memento a su creador, ya que el creador
    podria no necesitar nunca volver a un estado anterior.

  - Los mementos son pasivos. Solo el creador que creo el memento asignara o
    recuperara su estado.

*** Memento Consecuencias <> Consecuencias

  El patron Memento tiene varias consecuencias:

  1. @e(Preservacion de los limites de la encapsulacion.) El memento evita
     exponer informacion que solo deberia ser gestionada por un creador, pero
     que sin embargo debe ser guardada fuera del creador. El patron oculta a
     otros objetos las interioridades, potencialmente complejas, del Creador,
     preservando asi los limites de la encapsulacion.

  2. @e(Simplifica al Creador.) En otros diseños que persiguen conservar la
     encapsulacion, el Creador mantiene las versiones de su estado interno que
     han sido soliciadas por los clientes. Eso asigna toda la responsabilidad de
     gestion del almacenamiento al Creador. Que sean los clientes quienes
     gestiones el estado que solucitan simplifica al Creador y evita que los
     clientes tengan que notificar a los creadores cuando han acabado.

  3. @e(El uso de mementos puede ser costoso.) Los mementos podrian producir un
     coste considerable si el Creador debe copiar grandes cantidades de
     informacion para guardarlas en el memento o si los clientes crean y
     devuelven mementos a su creador con mucha frucuencia. A menos que
     encapsular y reestablecer el estado del Creador sea poco costoso, el patron
     podria no ser apropiado. Vease la discucion acerca de los cambios
     incrementales en la seccino de Implementacion.

  4. @e(Definicion de interfaces reducidas y amplias.) En algunos lenguajes puede
     ser dificil garantizar que solo el creador acceda al estado del memento.

  5. @e(Costes ocultos en el cuidado de los mementos.) un conserje es
     responsable de borrar los mementos que custodia. Sin embargo, el conserje
     no sabe cuanto estado hay en el memento. De hay que el conserje que deberia
     ser ligero pueda provocar grandes costes de almacenamientos cuando debe
     guardar mementos.

*** Memento Implementacion <> Implementacion

  Estas son dos cuestiones a considerar a la hora de implementar el patron
  Memento:

  1. @e(Soperte del lenugaje.) Los mementos tienen dos interfaces: una amplia
     para los creadores y otra reducida para otros objetos. Lo ideal seria que
     el lenguaje de implementacion permitiese dos niveles de proteccion
     estatica. C++ permite hacer esto haciendo que @c(Creador) sea una clase
     amiga de memento y haciendo privada a la interfaz amplia del @c(Memento).
     Solo la interfaz reducido deberia ser declarada publica. Por ejemplo:

     ..src > c++
       class Estado;

       class Creador {
       public:
           Memento* CrearMemento();
           void EstablecerMemento(const Memento*);
           // ...
       private:
           Estado* _estado;      // estructuras  de datos internas
           // ...
       };

       class Memento {
       public:
           // interfaz publica reducida
           virtual ~Memento();
       private:
           // miembros privados accesibles solo para el Creador
           friend class Creador;
           Memento();

           void EstablecerEstado(Estado*);
           Estado* ObtenerEstado();
           // ...
       private:
           Estado* _estado;
           // ...
       };
     < src..

  2. @e(Guardar solo los cambios incrementales.) Cuando los mementos se crean y
     se devuelven a su creador en una secuencia predecible, el @c(Memento) puede
     guardar unicamente el @e(cambio) con respecto al estado interno del
     creador.

     Por ejemplo, las ordenes de deshacer de un historial pueden usar mementos
     para asegurar que las ordenes vuelven a su estado original exacto cuando se
     deshacen (vease el patron @l(#Command)). El historial define un orden
     concreto en el que las ordenes pueden deshacerse y repetirse. Eso significa
     que los mementos pueden guardar unicamente el cambio producido por una
     orden, en vez del estado completo de cada objeto al que afecta. En el
     ejemplo de la seccion de Motivacion, el resolvente de problemas podria
     guardor solo aquellas estructuras internas que cambian para que las lineas
     sigan uniendo a los rectangulos, en vez de guardar las posiciones
     absolutas de estos objetos.

*** Memento Codigo de Ejemplo <> Codigo de Ejemplo

  El codigo C++ que aqui se muestra ilustra el ejemplo del
  @c(ResolventeDeRestricciones) que se discutio anteriormente. hemos usado
  objetos @c(OrdenMover) (vease @l(#Command)) para (des)hacer la translacion de
  un objeto grafico de una posicion a otra. El editor grafico llama a la
  operacion @c(Ejecutar) de la orden para mover un objeto grafico, y a
  @c(Deshacer) para deshacer el movimiento. La orden guarda su destino, la
  distancia movida y una instancia de @c(MementoDelResolventeDeProblemas), un
  memento que contiene estado del resolvente de problemas.

  ..src > c++
    class Grafico:
        // clase base para los objetos graficos del editor grafico

        class OrdenMover {
    public:
        OrdenMover(Grafico* destino, const Punto& incremento);
        void Ejecutar();
        void Deshacer();

    private:
        MementoDelResolventeDeRestricciones* _estado;
        Punto _incremento;
        Grafico* _destino;
    };
  < src..

  Las restricciones de conexion son establecidas por la clase
  @c(ResolventeDeRestricciones). Su principal funcion miembro es @c(Resorver),
  que resuelve las restricciones registradas con la operacion @c(AnadirRestriccion).
  Para permitr deshacer, el estado de @c(ResorventeDeRestricciones) puede
  externalizarse con @c(CrearMemento) en una instancia de
  @c(MementoDelResolventeDeRestricciones). El resolvente de restricciones puede
  volver a un estado previo llamando a @c(EstablecerMemento).
  @c(ResolventeDeRestricciones) es un @l(#Singleton).

  ..src > c++
    class ResolventeDeRestricciones {
    public:
        static ResolventeDeRestricciones* Instancia();

        void Resolver();
        void AnadirRestriccion(
            Grafico* principioConexion, Grafico* finConexion
        );
        void EliminarRestriccion(
            Grafico* principioConexion, Grafico* finConexion
        );

        MementoDelResolventeDeRestricciones* CrearMemento();
        void EstablecerMemento(MementoDelResolventeDeRestricciones*);
    private:
        // estado no trivial y operaciones para hacer cumplir
        // la semantica de las conexiones
    };

    class MementoDelResolventeDeRestricciones {
    public:
        virtual ~MementoDelResolventeDeRestricciones();
    private:
        friend class ResolventeDeRestricciones;
        MementoDelResolventeDeRestricciones();

        // estado privado del resolvente de restricciones
    };
  < src..

  Dadas estas interfaces, podemos implementar los miembro @c(Ejecutar) y
  @c(Deshacer) de @c(OrdenMover) como sigue:

  ..src > c++
    void OrdenMover::Ejecutar () {
        ResolventeDeRestricciones* resolvente = ResolventeDeRestricciones::Instancia();
        _estado = resolvente->CrearMemento(); // crea un memento
        _destino->Mover(_incremento);
        resolvente->Resolver();
    }

    void OrdenMover::Deshacer () {
        ResolventeDeRestricciones* resolvente = ResolventeDeRestricciones::Instancia();
        _destino->Mover(-_incremento);
        resolvente->EstablecerMemento(_estado); // vuelve al estado anterior
        resolvente->Resolver();
    }
  < src..

  @c(Ejecutar) adquiere un memento del @c(MementoDelResolventeDeRestricciones)
  antes de mover al grafico. @c(Deshacer) mueve el grafico hacia atras, devuelve
  el resolvente de restricciones a su estado anterior y, por ultimo, le dice al
  resolvente de restricciones que resuelva sus restricciones.

*** Memento Usos Conocidos <> Usos Conocidos

  El ejemplo anterior esta tomado del soporte para conectividad de Unidraw a
  traves de su clase CSolver [@l(#VL90)].

  Las colecciones de Dylan [@l(#App92)] proporcionan una interfaz de interaccion
  que refleja el patron Memento. Estas colecciones tienen la nocion de un objeto
  @"(estado), el cual es un memento que representa el estado de la iteracion.
  Cada coleccion puede representar el estado actual de la iteracion en la forma
  que prefiera; dicha representacion permanece completamente oculta a los
  clientes. El enfoque de Dylan para la iteracion podria transladarse asi a C++:

  ..src > c++
    template <class Elemento>
    class Coleccion {
    public:
        Coleccion();

        EstadoIteracion* CrearEstadoInicial();
        void Siguiente(EstadoIteracion*);
        bool HaTerminado(const EstadoIteracion*) const;
        Elemento ElementoActual(const EstadoIteracion*) const;
        EstadoIteracion* Copiar(const EstadoIteracion*) const;

        void Insertar(const Elemento&);
        void Eleminar(const Elemento&);
        // ...
    };
  < src..

  @c(CrearEstadoInicial) devuelve un objeto @c(EstadoIteracion) inicializado
  para la coleccion. @c(Siguiente) hace avanzar el objeto estado a la siguiente
  posicion en la iteracion; en realidad lo que hace es incrementar el indice de
  la iteracion. @c(HaTeriminado) devuelve @c(true) si @c(Siguiente) ha avanzado
  mas alla del ultimo elemento de la coleccion. @c(ElementoActual) desreferencia
  el objeto estado y devuelve el elemento de la coleccion al cual se refiere.
  @c(Copiar) devuelve una copia del objeto estado. Esto es util para marcar un
  punto en una interaccion.

  Dada una clase @c(TipoDeElemento), podemos iterar sobre una coleccion de
  instancias suyas como sigue:@n(50)

  ..src > c++
    class TipoDeElemento {
    public:
        void Procesar();
        // ...
    };

    Coleccion<TipoDeElemento*> unaColeccion;
    EstadoIteracion* estado;

    estado = unaColeccion.CrearEstadoInicial();

    while (!unaColeccion.HaTerminado(estado)) {
        unaColeccion.ElementoActual(estado)->Procesar();
        unaColeccion.Siguiente(estado);
    }
    delete estado;
  < src..

  La interfaz de la iteracion basada en el memento tiene dos beneficios
  interesantes:

  1. Puede haber mas de un estado para la misma coleccion (y lo mismo es cierto
     para el patron @l(#Iterator)).

  2. No necesita romper la encapsulacion para permitir la iteracion. El memento
     solo es interpretado por la propia coleccion; nadie mas tiene acceso a el.
     Otros enfoques para iterar requieren romper la encapsulacion haciendo a las
     clase iterador amigas de las clases de sus colecciones (vease el patron
     @l(#Iterator)). La situacion es a la inversa en la implementacion basada
     en el memento. @c(Coleccion) es amiga de @c(IteratorState).

  El toolkit de resolucion de problemas QOCA guarda informacion incremental en
  mementos [@l(#HHMV92)]. Los cliente pueden obtener un memento que represente
  la solucion actual a un sistema de ecuaciones. El memento contiene solo
  aquellas variables de las ecuaciones que han camdiabo desde la ultima
  solucion. Normalmente, para cada nueva solucion solo cambia un pequeño
  subconjunto de las variables del resolvente. Este subconjunto es sufuciente
  para devolver el resolvente a su solucion precedente; volver a soluciones
  anteriores requiere almacenar mementos de las soluciones intermedias. Por
  tanto, no se pueden establecer mementos en cualquier orden; QOCA se basa en un
  mecanismo de historial para revertir a soluciones anteriores.

*** Memento Patrones Relacionados <> Patrones Relacionados

    @l(#Command): Las ordenes pueden usar mementos para guardar el estado de las
    operaciones que pueden deshacerse.

    Iterator: puede usar mementos para iteracion, tal como acabamos de
    describir.

** Observer
*** Observer Proposito <> Proposito

  Define una dependencia de uno-a-muchos entre objetos, de forma que cuando un
  objeto cambie de estado se notifique y se actualicen automaticamente todos los
  objetos que depnden de el.

*** Observer Tambien Conocido Como <> Tambien Conocido Como

  Dependents (Dependientes), Publish-Subcscribe (Publicar-Subscribir)

*** Observer Motivacion <> Motivacion

  Un efecto lateral habitual de dividir un sistema en una coleccion de clases
  cooperantes es la necesidad de mantener una consistencia entre objetos
  relacionados. No queremos alcanzar esa consistenca haciendo a las clases
  fuertemente acopladas, ya que eso reduciria su reutilizacion.

  Por ejemplo, muchos toolkits de interfaces graficas de usuario separan los
  aspectos de presentacion de la interfaz de usuario de los datos de aplicacion
  subyacentes [@l(#KP88), @l(#LVC89), @l(#P+88), @l(#WGM88)]. Las clases que
  definen los datos de las aplicaciones y las representaciones pueden
  reutilizarse de forma independiente. Tambien pueden trabajar juntas. Un objeto
  hoja de calculo y un grafico de barras pueden representar la informacion
  contenida en el mismo objeto de datos de aplicacion usando diferentes
  representaciones. La hoja de calculo y el grafico de barras no se conocen
  entre si, permitiendo asi reutilizar solo aquel que se necesite. Pero se
  @e(comportan) como si lo hicieran. Cuando el usuario cambia la informacion de
  la hoja de calculo, la barra de herramientas refleja los cambios
  inmediatamente, y viceversa.

  ..img > img/111.png

  Este comportamiento implica que la hoja de calculo y el grafico de barras son
  dependientes del objeto de datos y, por tanto, se les deberia notificar
  cualquer cambio en el estado de este. Y no hay razon para limitar a dos el
  numero de objetos dependientes; puede haber cualquier numero de interfaces de
  usuario diferentes para los mismos datos.

  El patron Observer describe como establecer estas relaciones. Los principales
  objetos de este patron son @b(el sujeto) y @b(el observador). Un sujeto puede
  tener cualquier numero de observadores dependientes de el. Cada vez que el
  sujeto cambia su estado se notifica a todos sus observadores. En respuesta,
  cada obeservador consultara al sujeto para sincronizar su estado con el estado
  de este.

  Este tipo de interaccion tambien se conoce como @b(publicar-suscribir). El
  sujeto es quien publica las notificaciones. Envia estas notificaciones sin
  tener que conocer quienes son sus observadores. Pueden suscribirse un numero
  indeterminado de observadores para recibir notificaciones.

*** Observer Aplicabilidad <> Aplicabilidad

  Usese el patron Observer en cualquiera de las situaciones siguientes:

  - Cuando una abstraccion tiene dos aspectos y uno depende del otro. Encapsular
    estos aspectos en objetos separados permite modificarlos y reutilizarlos de
    forma independiente.

  - Cuando un cambio en un objeto requiere cambiar otros, y no sabemos cuantos
    objetos necesitan cambiarse.

  - Cuando un objeto deberia ser capaz de notificar a otros sin hacer
    suposiciones sobre quienes son dichos objetos. En otras palabras, cuando no
    queremos que estos objetos esten fuertemente acoplados.

*** Observer Estructura <> Estructura

  ..img > img/112.png

*** Observer Participantes <> Participantes

  - @c(Sujeto)

    - conoce a sus observadores. Un sujeto puede ser observado por cualquier
      numero de objetos @c(Observador).

    - proporciona una interfaz para asignar y quitar objetos @c(Observador).

  - @c(Observador)

    - define una interfaz para actualizar los objetos que deben ser notificados
      ante cambios en un sujeto.

  - @c(SujetoConcreto)

    - almacena el estado de interes para los objetos @c(ObservadorConcreto).

    - envia una notificacion a sus observadores cuando cambia su estado.

  - @c(ObservadorConcreto)

    - mantiene una referencia a un objeto @c(SujetoConcreto).

    - guarda un estado que deberia ser consistente con el del sujeto.

    - implementa la interfaz de actualizacion del @c(Observador) para mantener
      su estado consistente con el del sujeto.

*** Observer Colaboraciones <> Colaboraciones

  - @c(SujetoConcreto) notifica a sus observadores cada vez que se produce un
    cambio que pudiera hacer que el estado de estos fuera inconsistente con el
    suyo.

  - Despues de ser informado de un cambio en el sujeto concreto, un objeto
    @c(ObservadorConcreto) puede pedirle al sujeto mas informacion.
    @c(ObservadorConcreto) usa esta informacion para sincronizar su estado con
    el del sujeto.

    El siguiente diagrama de interaccion muestra las colaboraciones entre un
    sujeto y dos observadores:

    ..img > img/113.png

    Notese como el objeto @c(Observador) que inicializa la peticion de cambio
    pospone su actualizacion hasta que obtiene una notificacion del sujeto.
    Notificar no simpre es llamado por el sujeto. Puede ser llamado por un
    observador o por un tipo de objeto completamente diferente. La seccion de
    Implementacion examina algunas variantes comunes.

*** Observer Consecuencias <> Consecuencias

  El patron @c(Observador) permite modificar los sujetos y observadores de forma
  independiente. Es posible reutilizar objetos sin reutilizar sus observadores,
  y viceversa. Esto permite añadir observadores sin modificar el sujeto u otros
  observadores.

  Otras ventajas e inconvenientes del patron Observer son los siguientes:

  1. @e(Acoplamiento abstracto entre @c(Sujeto) y @c(Observador).) Todo lo que
     un sujeto sabe es que tiene una lista de observadores, cada uno de los
     cuales se ajusta a la interfaz simple de la clase abstracta
     @c(Observador). El sujeto no conce la clase concreta de ningun
     observador. Por tanto el acoplamiento entre sujetos y observadores es
     minimo.

     Gracias a que @c(Sujeto) y @c(Observador) no estan fuertemente acoplados,
     pueden pertenecer a diferentes capas de abstraccion de un sistema. Un
     sujeto de bajo nivel puede comunicarse e informar a un observador de mas
     alto nivel, manteniendo de este modo intacta la estructura de capas del
     sistema. Si juntasemos al @c(Sujeto) y al @c(Observador) en un solo objeto,
     entonces el objeto resultante deberia dividirse en dos capas (violando asi
     la separacion en capas) o estaria obligado a residir en una capa u otra (lo
     que puede comprometer la abstraccion en capas).

  2. @e(Capacidad de comunicacion mediante difusion.) A diferencia de una
     peticion ordinaria, la notificacion enviada por un sujeto no necesita
     especificar su receptor. La notificacion se envia automaticamente a todos
     los objetos interesados que se hayan suscrito a ella. Al sujeto no le
     importa cuantos objetos interesados haya; su unica responsabilidad es
     notificar a sus observadores. Esto nos da la libertad de añadir y quitar
     observadores en cualquier momento. Se deja al observador manejar u obviar
     una notificacion.

  3. @e(Actualizaciones inesperadas.) Dudo que los observadores no saben de la
     presencia de los otros, pueden no saber el coste ultimo de cambiar el
     sujeto. Una operacion aparentemente inofensiva sobre un sujeto puede dar
     lugar a una serie de actualizaciones en cascada de observadores y sus
     objetos dependientes. Mas aun, los criterios de dependencia que no estan
     bien definidos o mantenidos suelen provocar falsas actualizaciones, que
     pueden ser muy dificiles de localizar.

     Este problema se ve agravado por el hecho de que el prototipo de
     actualizacion simple no proporciona detalles acerca de @e(que) ha cambiado
     en el sujeto. Sin protocolos adicionales para ayudar a los observadores a
     descubrir que ha cambiado, pueden verse obligados a trabajar duro para
     deducir los cambios.

*** Observer Implementacion <> Implementacion

  En esta seccion se examinan varias cuestiones relativas a la implementacion
  del mecanismo de dependencia.

  1. @e(Correspodencia entre los sujetos y sus observadores.) El modo mas simple
     de que un sujeto conozca a los observadores a los que deberia notificar es
     guardar referencias a ellos explicitamente en el sujeto. Sin embargo, dicho
     almacenamiento puede ser demaciado costoso cuando hay muchos sujetos y
     pocos observadores. Una solucion es intercambiar espacio por tiempo usando
     una busqueda asociativa (por ejemplo, mediante una tabla de dispersion
     @-(en ingles, tabla @e(hash))) para mantener la correspondencia
     sujeto-observador. Asi, un sujeto que no tenga observadores no incurrira en
     ningun coste de almacenamiento. Por otro lado, este enfoque incrementa el
     coste de acceder a los observadores.

  2. @e(Observar mas de un sujeto.) Puede tener sentido en algunas situaciones
     que un observador dependa de mas de un sujeto. Por ejemplo, una hoja de
     calculo puede depender de mas de un origen de datos. En tales casos es
     necesario extender la interfaz de @c(Actualizar) para que el observador
     sepa que sujeto esta enviando la notificacion. El sujeto puede simplemente
     pasarse a si mismo como parametro en la operacion @c(Actualizar),
     permitiendo asi al observador saber que sujeto examinar.

  3. @e(¿Quien dispara la actualizacion?) El sujeto y sus observadores se basan
     en el mecanismo de notificacion para permanecer consistentes. Pero, ¿que
     objeto llama realmente a @c(Notificar) para disparar la actualizacion? He
     aqui dos posibilidades:

     a. Hacer que las operaciones que establezcan el estado del @c(Sujeto)
        llamen a @c(Notificar) despues de cambiar el resto del mismo. La ventaja
        de este enfoque es que los clientes no tienen que acordarse de llamar a
        @c(Notificar) sobre el sujeto. El inconveniente es que varias operaciones
        consecutivas provocaran varias actualizaciones consecutivas, lo que
        puede ser ineficiente.

     b. Hacer que los clientes sean responsables de llamar a @c(Notificar) en el
        momento adecuado. La ventaja aqui es que el cliente puede esperar a
        disparar la actualizacion hasta que se produzcan una serie de cambios de
        estado, evitando asi las innecesarias actualizaciones intermedias. El
        inconveniente es que los clientes tienen la responsabilidad añadida de
        disparar la actualizacion. Eso hace que sea propenso a erorres, ya que los
        clientes pueden olvidares de llamar a @c(Notificar).

  4. @e(Referencias perdidas a los sujetos borrados.) Borrar un sujeto no
     deberia producir referencias perdidas en sus observadores. Una manera de
     evitar esto es hacer que el sujeto notifique a sus observadores cuando va a
     ser borrado, para que estos puedan inicializar la referencia al sujeto. En
     general, borrar los observadores no suele ser una opcion, ya que puede
     haber otros objetos que hagan referencia a ellos, y tambien pueden estar
     observando a otros sujetos.

  5. @e(Asegurarse de que el estado del @c(Sujeto) es consistente con sigo mismo
     antes de la notificacion.) Es importante garantizar que el estado del
     @c(Sujeto) es consistente consigo mismo antes de llamar a @c(Notificar),
     porque los observadores le piden al sujeto su estado actual mientras
     actualizan su propio estado.

     Es facil violar involuntariamente esta regla de auto-consistencia cuando
     las operaciones de las subclases de @c(Sujeto) llaman a operaciones
     heredadas. Por ejemplo, en la siguiente secuencia de codigo la
     actualizacion se dispara cuando el sujeto se encuentra en un estado
     inconsistente:

     ..src > c++
       void MiSujeto::Operacion (int nuevoValor) {
           ClaseBaseSujeto::Operacion(nuevoValor);
                // se dispara la notificacion

           _miVar += nuevoLavol;
                // se actualiza el estado de la subclase (¡demasiado tarde!)
       }
     < src..

     Se puede salvar este escollo enviando notificaciones en metodos plantilla
     (@l(#Template Method)) de la clase abstracta @c(Sujeto), definiendo una
     operacion primitiva para que sea redefinida por las subclases y haciendo
     que @c(Notificar) sea la ultima operacion del metodo plantilla, lo que
     garantizara que el objeto es consistente consigo mismo cuando las subclases
     redefinan las operaciones de @c(Sujeto).

     ..src > c++
       void Texto::Cortar (SeleccionDeTexto t) {
           SistituirSeloccion(t);   // redefinida en las subclases
           Notificar();
       }
     < src..

     Por cierto, siempre es una buena idea documentar que operaciones del
     @c(Sujeto) disparan notificaciones.

  6. @e(Evitar protocolos especificos del observador: los modelos push y pull.)
     Las implementaciones del patron Observer suelen hacer que el sujeto envie
     informacion adicional sobre el cambio. El sujeto pasa esta informacion como
     un parametro de @c(Actualizar). La cantidad de informaicon puede variar
     mucho.

     En un extremo, al que llamaremos @b(modelo push), el sujeto envia a los
     observadores informacion detallada acerca del cambio, ya quieran estos o
     no. El otro extremo es el @b(modelo pull); el sujeto no envia nada mas que
     la notificacion minima, y los observadores piden despues los detalles
     explicitamente.

     El modelo pull enfatiza la ignorancia del sujeto respecto a sus
     observadores, mientras que el modelo push asume que los sujetos saben algo
     sobre las necesidades de sus observadores. El modelo push puede hacer que
     los observadores sean menos reutilizables, ya que las clases @c(Sujeto)
     hacen suposiciones sobre las clases @c(Observador) que pudieran no ser
     siempre ciertas. Por otro lado, el modelo pull puede ser ineficiente, ya que
     las clases Observador deben determinar que ha cambiado sin ayuda por parte
     del @c(Sujeto).

  7. @e(Epecificar las modificaciones de interes explicitamente.) Se puede
     mejorar la eficiencia extendiendo la interfaz de registro del sujeto para
     permitir que los observadores registren solo a aquellos eventos concretos
     que les interesen. Cuando ocurre uno de tales eventos, el sujeto informa
     unicamente a aquellos observadores que se han registrado como interesados
     en ese evento. Una manera de permitir esto es usar la nocion de aspectos en
     los objetos @c(Sujeto). Para registrarse como interesado en eventos
     particulares, los observadores se adscriben a sus sujetos usando

     ..src > c++
       void Sujeto::Adscribir(Observador*, Aspecto& interes);
     < src..

     donde @c(interes) especifica el evento de interes. En el momento de la
     notificacion, el sujeto proporciona a sus observadores el aspecto que ha
     cambiado como un parametro de la operacion @c(Actualizar). Por ejemplo:

     ..src > c++
       void Observador::Actualizar(Sujeto*, Aspecto& interes);
     < src..

  8. @e(Encapsular la semantica de las actualizaciones complejas.) cuando la
     relacion de dependencia entre sujetos y observadores es particularmente
     compleja, puede ser necesario un objeto que mantenga estas relaciones.
     Llamaremos a este objeto un @c(GestorDeCambios). Su proposito es minimizar
     el trabajo necesario para lograr que los observadores reflejen un camibo en
     su sujeto. Por ejemplo, si una operacion necesita cambiar varios sujetos
     interdependientes, puede ser necesario asegurarse de que se notifica a sus
     observadores solo despues de que @e(todos) los sujetos han sido
     modificados, para evitar notificar a los observadores mas de una vez.

     @c(GestorDeCambios) tiene tres responsabilidades:

     a) Hace corresponder a un sujeto con sus observadores, proporcionando una
        interfaz para mantener dicha correspondencia. Esto elimina la necesidad
        de que los sujetos mantengan referencias a otros observadores y viceversa.

     b) Define una determinada estrategia de actualizacion.

     c) Actualiza todos los observadores dependientes a peticion de un sujeto.

     El diagrama siguiente representa una implementacion del patron Obserer
     basada en un @c(GestorDeCambios) simple. Hay dos tipos de
     @c(GestorDeCambios). @c(GestorDeCambiosSimple) es simplista en el sentido
     de que siempre actualiza todos los observadores de cada sujeto. Por el
     contrario, @c(GestorDeCambiosGDA) maneja grafos dirigidos-aciclicos de
     dependencias entre sujetos y sus observadores. Es preferible un
     @c(GestorDeCambiosGDA) frente a un @c(GestorDeCambiosSimple) cuando un
     observador observa a mas de un sujeto. En ese caso, un cambio en dos o mas
     sujetos podria causar actualizaciones redundantes. El
     @c(GestorDeCambiosGDA) garantiza que el observador solo recibe una unica
     actualizacion. @c(GestorDeCambiosSimple) esta bien cuando las
     actualizaciones multiples no constituyen un problema.

     ..img > img/114.png

     @c(GestorDeCambios) es una instancia del patron @l(#Mediator). En general,
     solo hay un unico @c(GestorDeCambios), y es conocido globalmente. El patron
     @l(#Sigleton) seria aqui de utilidad.

  9. @e(Unir las clases @c(Sujeto) y @c(Observador).) Las bibliotecas de clases
     escritas en lenguajes que carecen de herencia multiple (como Smalltalk)
     generalmente no definen clases separadas @c(Sujeto) y @c(Observador), sino
     que juntan sus interfaces en una clase. Eso permite definir un objeto que
     haga tanto de sujeto como de observador sin usar herencia multiple. En
     Smalltallk, por ejemplo, las interfaces de @c(Sujeto) y @c(Observador) se
     definen en la clase raiz @c(Object), haciendolas asi disponibles para todas
     las clases.

*** Observer Codigo de Ejemplo <> Codigo de Ejemplo

  Una clase abstracta define la interfaz @c(Observador):

  ..src > c++
    class Sujejo;

    class Observador {
    public:
        virtual ~Observador();
        virtual void Actualizar(Sujeto* elSujetoQueCambio) = 0;
    protected:
        Observador();
    };
  < src..

  Esta implementacion permite multiples sujetos por cada observador. El sujeto
  que se pasa a la operacion @c(Actualizar) permite que el observador determine
  que objeto ha cambiado cuando este observa mas de uno.

  De forma similar, una clase abstracta define la interfaz de @c(Sujeto):

  ..src > c++
    class Sujeto {
    public:
        virtual ~Sujeto();

        virtual void Adscribir(Observador*);
        virtual void Quitar(Observador*);
        virtual void Notificar();
    protected:
        Sujeto();
    private:
        Lista<Observador*> *_observadores;
    };

    void Sujeto::Adscribir (Observador* o) {
        _observadores->Insertar(o);
    }

    void Sujeto::Quitar (Observador* o) {
        _observadores->Eliminar(o);
    }

    void Sujeto::Notificar () {
        IteradorLista<Observador*> i(_observadores);

        for (i.Primero(); !i.HaTerminado(); i.Siguiente()) {
            i.ElementoActual()->Actualizar(this);
        }
    }
  < src..

  @c(Reloj) es un sujeto concreto que almacena y mantiene la hora del dia,
  notificando a sus observadores cada segundo. @c(Reloj) proporciona la interfaz
  para obtener unidades de tiempo por separado, como la hora, los minutos o los
  segundos.

  ..src > c++
    class Reloj : public Sujeto {
    public:
        Reloj();

        virtual int ObtenerHora();
        virtual int ObtenerMinuto();
        virtual int ObtenerSegundo();

        void Pulso();
    };
  < src..

  La operacion @c(Pulso) es llamada por un reloj interno a intervalos de tiempo
  regulares para proporcionar una base de tiempo fiable. @c(Pulso) actualiza el
  estado interno de @c(Reloj) y llama a @c(Notificar) para informar a los
  observadores del cambio:

  ..src > c++
    void Reloj::Pulso () {
        // actualiza el estado del tiempo interno
        // ...
        Notificar();
    }
  < src..

  Ahora podemos definir una clase @c(RelojDigital) que muestra el tiempo. Esta
  clase hereda su funcionalidad grafica de una clase @c(Util)@n(28) proporcionada por
  un toolkit de interfaces de usuario. La interfaz del observador se combina con
  la de @c(RelojDigital) heredando de @c(Observador).

  ..src > c++
    class RelojDigitar: public Util, public Observador {
    public:
        RelojDigital(Reloj*);
        virtual ~RelojDigital();

        virtual void Actualizar(Sujeto*);
            // redefine la operacion de Observador

        virtual void Dibujar();
            // redefine la operacion de Util;
            // define como dibujar el reloj digital

    private:
        Reloj* _sujeto;
    };

    RelojDigital::RelojDigital (Reloj* s) {
        _sujeto = s;
        _sujeto->Adscribir(this);
    }

    RelojDigital::RelojDigital () {
        _sujeto->Quitar(this);
    }
  < src..

  Antes de que la operacion @c(Actualizar) dibuje la apariencia del reloj, se
  comprueba que el sujeto de la notificacion sea el sujeto del reloj:

  ..src > c++
    void RelojDigital::Actualizar (Sujeto* elSujetoQueCambio) {
        if (elSujetoQueCambio == _sujeto) {
            dibujar();
        }
    }

    void RelojDigital::Dibujar () {
        // obtiene los nuevos valores del sujeto

        int hora = _sujeto->ObtenerHora();
        int minuto= _sujeto->ObtenerMinuto();
        // etc.
        // dibuja el reloj digital
    }
  < src..

  Se puede definir una clase @c(RelojAnalogico) de la misma manera.

  ..src > c++
    class RelojAnalogico : public Util, public Observador {
    public:
        RelojAnalogico(Reloj*);
        virtual void Actualizar(Sujeto*);
        virtual void Dibujar();
        // ...
    };
  < src..

  El siguiente codigo crea un @c(RelojAnalogico) y un @c(RelojDigital) que
  siempre muestra el mismo tiempo:

  ..src > c++
    Reloj* reloj = new Reloj;
    RelojAnalogico* relojAnalogico = new RelojAnalogico(reloj);
    RelojDigital* relojDigital = new RelojDigital(reloj);
  < src..

  Cada vez que @c(reloj) emite un pulso, los dos relojes se actualizaran y se
  volveran a dibujar de manera apropiada.

*** Observer Usos Conocidos <> Usos Conocidos

  El primer y tal vez mas importante ejemplo de patron Observer aparece en el
  Modelo/Vista/Contrelador de Smalltalk (MVC), el framework de interfaces de
  usuario en el entorno de Smalltalk [@l(#KP88)]. La clase @c(Modelo) de MCV
  desepeña el papel de @c(Sujeto), mientras que @c(Vista) es la clase base de
  los observadores. Smalltalk, ET++ [@l(#WGM88)] y la biblioteca de clases THINK
  [@l(#Sym93b)] proporcionan un mecanismo general de dependencia poniendo las
  interfaces de @c(Sujeto) y @c(Observador) en la clase base de todas las otras
  classe del sistema.

  Otros toolkits de interfaces de usuario que emplean este patron son InterViews
  [@l(#LVC89)]. Andrew Toolkit [@l(#P+88)] y Unidraw [@l(#VL90)]. InterViews define
  explicitamente las clases @c(Observer) y @c(Observable) (para los
  sujetos). Andrew las llama @"(vista) y @"(objeto de datos), respectiviamente.
  Unidraw divide los obejetos del editor grafico en partes @c(Vista) (para los
  observadores) y @c(Sujeto)

*** Observer Patrones Relacionados <> Patrones Relacionados

  @l(#Mediator): encapsulando semanticas de actualizaciones complejas, el
  @g(GestorDeCambios) actua como mediador entre sujetos y observadores.

  @l(#Singleton): el @c(GestorDeCambios) puede usar el patron Singleton para que
  sea unico y globalmente accesible.

** State
*** State Proposito <> Proposito

  Permite que un objeto modifique su comportamiento cada vez que cambie su
  estado interno. Parecera que cambia la clase del objeto.

*** State Tambien Conocido Como <> Tambien Conocido Como

  Objects for States (Estados como Objetos)

*** State Motivacion <> Motivacion

  Pensemos en una clase @c(ConexionTPC) que representa una conexion de red. Un
  objeto @c(ConexionTPC) puede encontrarse en uno de los siguientes estados:
  Establecida, Escuchando o Cerrada. Cuando un objeto @c(ConexionTPC) recibe
  peticiones de otros objetos, les reponde de distinta forma dependiendo de su
  estado actual. Por ejemplo, el efecto de una peticion @c(Abrir) depende de si
  la conexion se encuentra en su estado Cerrada o en su estado Establecida.
  El patron State describe como puede @c(ConexionTPC) exhibir un comportamiento
  diferente en cada estado.

  La idea clave de este patron es introducir una clase abstracta llama
  @c(EstadoTPC) que representa los estados de la conexion de red. La clase
  @c(EstadoTCP) declara una interfaz comun para todas las clases que representan
  diferentes estados operacionales. Las subclases de @c(EstadoTCP) implementan
  comportamiento especifico de cada estado. Por ejemplo, las clases
  @c(TCPEstablecida) y @c(TCPCerrada) implementan comportamiento concreto de los
  estados @c(Establecida) y @c(Cerrada) de una @c(ConexionTCP).

  La clase @c(ConexionTCP) mantiene un objeto de estado (una instancia de una
  subclase de @c(EstadoTCP)) que representa el estado actual de la conexion
  TCP. La clase @c(ConexionTCP) delega todas las peticiones dependientes del
  estado en este objeto de estado. @c(ConexionTPC) usa su instancia de la
  subclase de @c(EstadoTCP) para realizar operaciones que dependen del estado de
  la conexion.

  ..img > img/115.png

  Cada vez que cambia el estado de la conexion, el objeto @c(ConexionTPC) cambia
  el objeto de estado que usa. Cuando la conexion pasa de establecida a cerrada,
  por ejemplo, @c(ConexionTPC) sustituira su instancia de @c(TCPEstablecida) por
  una instancia de @c(TCPCerrada).

*** State Aplicabilidad <> Aplicabilidad

  Usese el patron State en cualquiera de los siguientes dos casos:

  - El comportamiento de un objeto depende de su estado, y debe cambiar en
    tiempo de ejecucion dependiendo de ese estado.

  - Las operaciones tienen largas sentencias condicionales con multimples ramas
    que dependen del estado del objeto. Este estado se suele representar por una
    o mas constantes enumeradas. Muchas veces son varias las operaciones que
    contienen esta misma estructura condicional. El patron State pone cada rama
    de la condicion en una clase aparte. Esto nos permite tratar al estado del
    objeto como un objeto de pleno derecho que puede variar independientemente
    de otros objetos.

*** State Estructura <> Estructura

  ..img > img/116.png

*** State Participantes <> Participantes

  - @c(Contexto) (@c(ConexionTCP))

    - define la interfaz de interes para los clientes.

    - mantiene una instancia de una subclase de @c(EstadoConcreto) que define el
      estado actual.

  - @c(Estado) (@c(EstadoTCP))

    - define una interfaz para encapsular el comportamiento asociado con un
      determinado estado del Contexto.

  - @b(subclases de) @c(EstadoConcreto) (@c(TCPEstablecida), @c(TCPEscuchando), @c(TCPCerrada))

    - cada subclase implementa un comportamiento asociado con un estado del Contexto.

*** State Colaboraciones <> Colaboraciones

  - Contexto delega las peticiones que dependen del estado en el objeto
    @c(EstadoConcreto) actual.

  - Un contexto puede pasarse a si mismo como parametro para que el objeto
    @c(Estado) maneje la peticion. Esto permite al objeto @c(Estado) acceder al
    contexto si fuera necesario.

  - Contexto es la interfaz principal para los clientes. Los clientes pueden
    configurar un contexto con objetos @c(Estado). Una vez que esta configurado el
    contexto, sus clientes ya no tienen que tratar con los objetos @c(Estado)
    directamente.

  - Cualquiera de las subclases de @c(Contexto) o de @c(EstadoConcreto) pueden
    decidir que estado sigue a otro y bajo que circunstancias.

*** State Consecuencias <> Consecuencias

  El patron State tiene las siguientes consecuencias:

  1. @e(Localiza el comportamiento dependiente del estado y divide dicho
     comportamiento en diferentes estados.) El patron State situa en un objeto
     todo el comportamiento asociado con un determinode estado. Como todo el
     codigo dependiente del estado reside en una subclase de @c(Estado), pueden
     añadirse facilmente nuevos estados y transiciones definiendo nuevas
     subclases. Una alternativa es usar valores de datos para definir los
     estados internos y hacer que las operaciones de @c(Contexto) comprueben
     dichos datos explicitamente. Pero en ese caso tendriamos sentencias
     condicionales repartidas por toda la implementacion de @c(Contexto). Añadir
     un nuevo estado podria requerir cambiar varias operaciones, complicando el
     mantenimiento.

     El patron State evita este problema, pero puede introducir otro, al
     distribuir el comportamiento para los diferentes estados en varias
     subclases de Estado. Esto incrementa el numero de clases y es menos
     compacto que una unica clase. Pero dicha distribucion es realmente buena si
     hay muchos estados, que de otro modo necesitarian grandes sentencias
     condicionales.

     Al igual que ocurre con los procedimientos largos, hay que tratar de evitar
     las grandes sentencias condicionales. Son monoliticas y tienden a hacer el
     codigo menos explicito, lo que a su vez las hace dificiles de modificar y
     extender. El patron State ofrece un modo mejor de estructurar el codigo
     dependiente del estado. La logica que determina las transiciones entre
     estados no reside en sentencias @c(if) o @c(switch) monoliticas, sino que
     se reparte entre las subclases de @c(Estado). Al encapsular cada transicion
     y accion en una clase estamos elevando la idea de un estado de ejecucion a
     objetos de estado en toda regla. Esto impone una estructura al codigo y
     hace que su intencion sea mas clara.

  2. @e(Hace explicitas las transiciones entre estados.) Cuando un objeto define
     su estado actual unicamente en terminos de valores de datos internos, sus
     transiciones entre estados carecen de una representacion explicita; solo
     aparecen como asignaciones a determinadas variables. Introducir objetos
     separados para los diferentes estados hace que las transiciones sean mas
     explicitas. Ademas, los objetos @c(Estado) pueden proteger al @c(Contexto)
     frente a uestados internos inconsistentes, ya que las transiciones entre
     estados son atomicas desde una perspectiva del @c(Contexto) @-(tiene lugar
     cambiando una variable (el objeto varible del @c(Contexto), @c(Estado)), no
     varias [@l(#dCLF93)]).

  3. @e(Los objetos @c(Estado) pueden compartirse.) En caso de que los objetos
     @c(Estado) no tengan variables @-(es decir, si el estado que representan
     esta totalmente representado por su tipo) entonces varios contextos pueden
     compartir un mismo objeto @c(Estado). Cuando se comparten los estados de
     este modo, son en esencia pesos ligeros (vease el patron @l(#Flyweight))
     que no tiene estado intrinseco, sino solo comportamiento.

*** State Implementacion <> Implementacion

  El patron Estado da lugar a una serie de cuestiones de implementacion:

  1. @e(Quien difene las transiciones entre estados?) El patron State no
     especifica que participante define los criterios para las transiciones entre
     estados. Si estos criterios son fijos, entonces pueden implementarse
     enteramente en el @c(Contexto). No obstante, es generalmente mas flexible y
     conveniente que sean las propias subclases de @c(Estado) quienes especifiquen
     su estado sucesor y cuando llevar a cabo la transicion. Esto requiere añadir
     una interfaz al @c(Contexto) que permita a los objetos @c(Estado) asignar
     explicitamente el estado actual del @c(Contexto).

     Descentralizar de esta forma la logica de transicion facilita modificar o
     extender dicha logica definiendo nuevas subclases de @c(Estado). Una
     desventaja de la descentralizacion es que una subclase de @c(Estado)
     conocera al menos a otra, lo que introduce dependencias de implementacion
     entre subclases.

  2. @e(Una alternativa basada en tablas.) Cargill, en su libro @e(C++
     Programming Style) [@l(#Car92)], describe otra forma de estructurar el codigo
     dirigido por estados: mediante tablas que hagan corresponder entradas con
     transiciones de estado. Para cada estado, una tabla hace corresponder cada
     posibre entrada con un estado sucesor. Este enfoque convierte codigo
     condicional (y funciones virtuales, en el caso del patron State) en una
     tabla de busqueda.

     La principal ventaja de las tablas es la seguridad; se pueden cambiar los
     criterios de transicion modificando datos en vez de codigo de programa. Hay
     no obstante, algunos inconvenientes:

     - Una tabla de busqueda es normalmente menos eficiente que una llamada a
       una funcion (virtual).

     - Situar la logica de transicion en un formato tabular uniforme hace que los
       criterios de transicion sean menos explicitos y, por tanto, mas dificiles
       de comprender.

     - Suele dificultar añadir acciones que acompañen a las transiciones de
       estado. El enfoque dirigido por una tabla representa los estados y sus
       transiciones, pero debe ser aumentado para realizar algun tipo de
       procesamiento arbitrario con cada transicion.

     Las principales diferencias entre las maquinas de estados basadas en tablas
     y el patron State se pueden resumir en esta: el patron State modela
     comportamiento especifico del estado, mientras que el enfoque basado en una
     tabla se centra en definir las transiciones de estado.

  3. @e(Crear y destruir objetos Estado.) Una cuestion de implementacion que hay
     que ponderar es si (1) crear los objetos @c(Estado) solo cuando se
     necesitan y destruirlos despues, o si (2) crearlos al principio y no
     destruirlos nunca.

     La primera eleccion es preferible cuando no se conocen los estados en
     tiempo de ejecucion y los contextos cambian de estado con poca
     frucuencia. Este enfoque envita crear objetos que no se usaran nunca, lo
     que puede ser importante si los objetos @c(Estado) guardan una gran
     cantidad de informacion. El segundo enfoque es mejor cuando los cambios
     tienen lugar rapidamente, en cuyo caso querremos evitar destruir los
     estados, ya que pueden volver a necesitarse de nuevo en breve. Los costes
     de creacion se pagan una vez al principio, y no existen costes de
     destruccion. No obstante, este enfoque puede no ser apropiado, ya que el
     @c(Contexto) debe guardar referencias a todos los estados en los que
     pudiera entrar.

  4. @e(Usar herencia dinamica.) Cambiar el comportamiento de una determinada
     peticion podria lograrse cambiando la clase del objeto en tiempo de
     ejecucion, pero esto no es posible en la mayor parte de los lenguajes de
     programacion orientados a objetos. Las excepciones incluyen Self [@l(#US87)] y
     otros lenguajes basados en delegacion que proporcionan dicho mecanismo y
     por tanto admiten el patron State directamente. Los objetos en Self pueden
     delegar operaciones en otros objetos para obtener una especie de herencia
     dinamica. Cambiar el destino de la delegacion en tiempo de ejecucion
     cambia por tanto la estructura de herencia. Este mecanismo permite que los
     objetos cambien su comportamiento, y viene a ser lo mismo que cambiar su
     clase.

*** State Codigo de Ejemplo <> Codigo de Ejemplo

  El ejemplo siguiente muestra el codigo C++ para el ejemplo de la conexion TCP
  que se describio en la seccion de Motivacion. Este ejemplo es una version
  simplificada del protocolo TCP; no se describe el protocolo completo ni todos
  los estados de las conexiones TCP.@n(51)

  En primer lugar, definimos la clase @c(ConexionTCP), que proporciona una
  interfaz para transmitir datos y que procesa las peticiones para cambiar el
  estado.

  ..src > c++
    class FlujoOctetosTCP;
    class EstadoTCP;

    class ConexionTCP {
    public:
        ConexionTCP();

        void AbrirActiva();
        void AbrirPasiva();
        void Cerrar();

        void Enviar();
        void AcuseDeRecibo();
        void Sincronizar();

        void ProcesarOcteto(FlujoOctetosTCP*);
    private:
        friendo class EstadoTCP;
        void CambiarEstado(EstadoTCP*);
    private:
        EstadoTCP* _estado;
    };
  < src..

  @c(ConexionTCP) guarda una instancia de la clase @c(EstadoTCP) en la variable
  miembro @c(_estado). La clase @c(EstadoTCP) duplica la interfaz para cambiar
  el estado de @c(ConexionTCP). Cada operacion @c(ConexionTCP) recibe como
  parametro una instancia de @c(ConexionTCP), lo que permite a @c(EstadoTCP)
  acceder a los datos de @c(ConexionTCP) y cambiar el estado de la conexion.

  ..src > c++
    class EstadoTCP {
    public:
        virtual void Transmitir(ConexionTCP*, FlujoOctetosTCP*);
        virtual void AbrirActiva(ConexionTCP*);
        virtual void AbrirPasiva(ConexionTCP*);
        virtual void Cerrar(ConexionTCP*);
        virtual void Sincronizar(ConexionTCP*);
        virtual void AcuseDeResibo(ConexionTCP*);
        virtual void Enviar(ConexionTCP*);
    protected:
        void CambiarEstado(ConexionTCP*, EstadoTCP*);
    };
  < src..

  @c(ConexionTCP) delega todas las peticiones dependiendo del estado en su
  instancia de @c(EstadoTCP), @c(_estado.ConexionTCP) tambien proporciona una
  operacion para cambiar esta varable por un nuevo @c(EstadoTCP). El constructor
  de @c(ConexionTCP) inicializa este objeto al estado @c(TCPCerrada) (definida
  mas adelante).

  ..src > c++
    ConexionTCP::ConexionTCP () {
        _estado = TCPCerrada::Instancia();
    }

    void ConexionTCP::CambiarEstado (EstadoTCP* e) {
        _estado = e;
    }

    void ConexionTCP::AbrirActiva () {
        _estado->AbrirActiva(this);
    }

    void ConexionTCP::AbrirPasiva () {
        _estado->AbrirPasiva(this);
    }

    void ConexionTCP::Cerrar () {
        _estado->Cerrar(this);
    }

    void ConexionTCP::AcuseDeRecibo () {
        _estado->AcuseDeRecibo(this);
    }

    void ConexionTCP::Sincronizar () {
        _estado->Sincronizar(this);
    }
  < src..

  @c(EstadoTCP) implementa el comportamiento predeterminado de todas las
  peticiones delegadas en el. Tambien puede cambiar el estado de una
  @c(ConexionTCP) mediante la operacion @c(CambiarEstado). @c(EstadoTCP) se
  declara como amiga de @c(ConexionTCP) para dar a esta operacion un acceso
  restringido.

  ..src > c++
    void EstadoTCP::Transmitir (ConexionTCP*, FlujoOctetosTCP*) {}
    void EstadoTCP::AbrirActiva (ConexionTCP*) {}
    void EstadoTCP::AbrirPasiva (ConexionTCP*) {}
    void EstadoTCP::Cerrar (ConexionTCP*) {}
    void EstadoTCP::Sincronizar (ConexionTCP*) {}

    void EstadoTCP::CambiarEstado (ConexionTCP* c, EstadoTCP* e) {
      c->CambiarEstado(e);
    }
  < src..

  Las subclases de @c(EstadoTCP) implementan comportamiento especifico de ese
  estado. Una conexion TCP puede encontrarse en muchos estados: Establecida,
  Escuchando, Cerrada, etc., y hay una subclase de @c(EstadoTCP) para cada uno
  de ellos. Examinaremos estas tres subclases en detalle: @c(TCPEstablecida),
  @c(TCPEscuchando) y @c(TCPCerrada).

  ..src > c++
    class TCPEstablecida : public EstadoTCP {
    public:
        static EstadoTCP* Instancia();

        virtual void Transmitir(ConexionTCP*, FlujoOctetosTCP*);
        virtual void Cerrar(ConexionTCP*);
    };

    class TCPEscuchando : public EstadoTCP {
    public:
      static EstadoTCP* Instancia();

      virtual void Enviar(ConexionTCP*);
      // ...
    };

    class TCPCerrada : public EstadoTCP {
    public:
      static EstadoTCP* Instancia();

      virtual void AbrirActiva(ConexionTCP*);
      virtual void AbrirPasiva(ConexionTCP*);
      // ...
    }
  < src..

  Las subclases de @c(EstadoTCP) no mantienen un estado local, de modo que
  pueden compartirse, siendo solo necesaria una instancia de cada una. Esta
  unica instancia de cada subclase de @c(EstadoTCP) se obtiene a traves de la
  operacion estatica @c(Instancia).@n(52)

  Cada subclase de @c(EstadoTCP) implementa comportamiento especifico de ese
  estado para aquellas peticiones validas en ese estado:

  ..src > c++
    void TCPCerrada::AbribActiva (ConexionTCP* c) {
        // envia SYN, recibe SYN, ACK, etc.

        CambiarEstado(c, TCPEstablecida::Instancia());
    }

    void TCPCerrada::AbrirPasiva (ConexionTCP* c) {
        CambiarEstado(c, TCPEscuchando::Instancia());
    }

    void TCPEstablecida::Cerrar (ConexionTCP* c) {
        // envia FIN, recibe ACK de FIN

        CambiarEstado(c, TCPEscuchando::Instancia());
    }

    void TCPEstablecida::Transmitir (ConexionTCP* c, FlujoOctetosTCP* o) {
        c->ProcesarOcteto(o);
    }

    void TCPEscuchando::Enviar (ConexionTCP* c) {
        // envia SYN, recibe SYN, ACK, etc.

        CambiarEstado(c, TCPEstablecida::Instancia());
    }
  < src..

  Despues de realizar el trabajo concreto de este estado, estas operaciones
  llaman a la operacion @c(CambiarEstado) para cambiar el estado de @c(ConexionTCP).
  @c(ConexionTCP) no sabe nada sobre el protocolo de @c(ConexionTCP); son las
  subclases de @c(EstadoTCP) quienes definen cada transicion de estado y accion
  de TCP.

*** State Usos Conocidos <> Usos Conocidos

  Johson y Zweig [@l(#JZ91)] describen el patron State y su aplicacion a los
  protocolos de conexion TCP.

  La mayoria de programas de dibujo interactivos proporcionan @"(herramientas)
  para llevar a cabo operaciones mediante manipulacion directa. Por ejemplo, una
  herramienta de dibujado de lineas permite al usuario selecciononar formas. Suele
  haber una paleta de herramientas para elegir. El usuario concibe esta
  actividad como tomar una herramienta y manejarla, pero en realidad el
  comportamiento del editor cambia con la herramienta actual: cuando esta activa
  una herramienta de dibujado creamos formas; cuando esta activa la herramienta
  de seleccion seleccionamos formas; y asi sucesivamente. Podemos usar el patron
  State para cambiar el comportamiento del editor que depende de la herramienta
  actual.

  Podemos definir una clase abstracta @c(Herramienta) a partir de la cual definir
  subclases que implementen comportamiento especifico de la herramienta. El
  editor de dibujo mantiene un objeto @c(Herramienta) actual al cual delega las
  peticiones. Cuando el usuario selecciona una nueva herramienta, cambia este
  objeto, haciendo que el comportamiento del editor cambie en consecuencia.

  Esta tecnica se emplea en los frameworks de editores de dibujo HotDraw [@l(#Joh92)]
  y UniDraw [@l(#VL90)]. Esto permite que los clientes definan nuevos tipos de
  herramientas facilmente. En HotDraw, la clase @c(DrawingController) redirige
  las peticiones al objeto @c(Tool) @%e(herramienta) actual. En Unidraw, las clases
  correspondientes son @c(Viewer) y @c(Tool). El siguiente diagrama de clases
  muestra un esbozo de las interfaces @c(Tool) y @c(DrawingController):

  ..img > img/117.png

  El modismo de Coplien Sobre-Carta @%e(Envelope-Letter) [@l(#Cop92)] esta
  relacionado con el patron State. Sobre-Carta es una tecnica para cambiar la
  clase de un objeto en tiempo de ejecucion. El patron State es mas especifico,
  centrandose en como tratar con un objeto cuyo comportamiento depende de su estado.

*** State Patrones Relacionados <> Patrones Relacionados

  El patron @l(#Flyweight) explica cuando y como compartir objetos Estado.

  Los objetos Estado muchas veces son @l(#Singletons).

** Strategy
*** Strategy Proposito <> Proposito

  Define una familia de algoritmos, encapsula cada uno de ellos y los hace
  intercambiables. Permite que un algoritmo varie independientemente de los
  clientes que lo usan.

*** Strategy Tambien Conocido Como <> Tambien Conocido Como

  Policy (Politica)

*** Strategy Motivacion <> Motivacion

  Existen muchos algoritmos para dividir un flujo de texto. Codificar dichos
  algoritmos en las clases que los usan no resulta una buena practica por varias
  razones:

  - Los clientes que necesitan dividir el texto en lineas se vuelven mas
    complejos si tienen que incluir dicho codigo, lo que los hace mas grandes y
    mas dificiles de matener, sobre todo si permiten varios algoritmos
    diferentes de division en lineas.

  - Los distintos algoritmos seran apropiados en distintos momentos. No tenemos
    por que permitir multiples algoritmos si no los vamos a usar todos.

  - Es dificil añadir nuevos algoritmos o modificar los existentes cuando la
    division en lineas es parte integral de un cliente.

  Estos problemos pueden evitarse definiendo clases que encapsulen los
  diferentes algoritmos de division de lineas. Un algoritmo asi encapsulado se
  denomina una estrategia.

  ..img > img/118.png

  Supongamos que una clase @c(Composicion) debe mantener y actualizar los saltos
  de linea del texto mostrado en un visor. Las estrategias de division en lineas
  no estan implementadas en la clase @c(Composicion). En vez de eso, se
  implementan separadamente por las subclases de la clase abstracta
  @c(Componedor). Las subclases de @c(Componedor) implementan diferentes
  estrategias:

  - @c(ComponedorSimple) implementa una estrategia simple que calcula un salto
    de linea cada vez.

  - @c(ComponedorTeX) implementa el algoritmo @b(TeX) para buscar los saltos de
    linea. Esta estrategia trata de optimizar los saltos de line globalmente, es
    decir, un parrafo cada vez.

  - @c(ComponedorMatriz) implementa una estrategia que selecciona los saltos de
    liene de modo que cada fila tenga un numero determinado de elementos. Es
    util para dividir una serie de iconos en filas, por ejemplo.

  Una @c(Composicion) mantiene una referencia a un objeto @c(Componedor). Cada
  vez que una @c(Composicion) vuelve a formatear su texto, reenvia esta
  responsabilidad a su objeto @c(Componedor). El cliente de @c(Composicion)
  especifica que @c(Componedor) deberia usarse, y dicho @c(Componedor) sera
  instalado en la @c(Composicion).

*** Strategy Aplicabilidad <> Aplicabilidad

  Usese el patron Strategy cuando

  - muchas clases relacionadas difieren solo en su comportamiento. Las
    estrategias permiten configurar una clase con un determinado comportamiento
    de entre muchos posibles.

  - se necesitan distintas variantes de un algoritmo. Por ejemplo, podriamos
    definir algoritmos que reflejasen distintas soluciones de compromiso entre
    tiempo y espacio. Pueden usarse estrategias cuando estas variantes se
    implementan como una jerarquia de clases de algoritmos [@l(#HO87)].

  - un algoritmo usa datos que los clientes no deberian conocer. Usese el patron
    Strategy para evitar exponer estructuras de datos complejas y dependientes
    del algoritmo.

  - una clase define muchos comportamientos, y estos se representan como
    multiples sentecias condicionales en sus operaciones. En vez de tener muchos
    condicionales, podemos mover las ramas de estos a su propia clase
    @c(Estrategia).

*** Strategy Estructura <> Estructura

  ..img > img/119.png

*** Strategy Participantes <> Participantes

  - @c(Estrategia) (@c(Componedor))

    - declara una interfaz comun a todos los algoritmos permitidos. El @c(Contexto)
      usa esta interfaz para llamar al algoritmo definido por una @c(EstrategiaConcreta).

  - @c(EstrategiaConcreta) (@c(ComponedorSimple), @c(ComponedorTeX), @c(ComponedorMatriz))

    - implementa el algoritmo utilizando la interfaz de @c(Estrategia).

  - @c(Contexto) (@c(Composicion))

    - se configura con un objeto @c(EstrategiaConcreta)
    - mantiene una referencia a un objeto @c(Estrategia).
    - puede definir una interfaz que permita a la @c(Estrategia) acceder a sus
      datos.

*** Strategy Colaboraciones <> Colaboraciones

  - @c(Estrategia) y @c(Contexto) interactuan para implementar el algoritmo
    elegido. Un contexto puede pasar a la estratiga todos los datos requeridos
    por el algoritmo cada vez que se llama a este. Otra alternativa es que el
    contexto se pase a si mismo como argumento de las operaciones de
    @c(Estrategia). Eso permite a la estrategia hacer llamadas al contexto
    cuando es necesario.

  - Un contexto redirige peticiones de los clientes a su estrategia. Los
    clientes normalmente crean un objeto @c(EstrategiaConcreta), el cual pasan
    al contexto; por tanto, los clientes interactuan exclusivamente con el
    contexto. Suele haber una familia de clases @c(EstrategiaConcreta) a elegir
    por el cliente.

*** Strategy Consecuencias <> Consecuencias

  El patron Strategy presenta las siguientes ventajas e inconvenietes:

  1. @e(Familias de algoritmos relacionados.) Las jerarquies de clases
     @c(Estrategia) definen una familia de algoritmos o comportamientos para ser
     reutilizados por los contextos. La herencia puede ayudar a sacar factor
     comun de la funcionalidad de estos algoritmos.

  2. @e(Una alternativa a la herencia.) La herencia ofrece otra forma de
     permitir una variedad de algoritmos o comportamientos. Se puede heredar
     directamente de una clase @c(Contexto) para proporcionar diferentes
     comportamientos. Pero esto liga el comportamiento al @c(Contexto),
     mezclando la implementacion del algoritmo con la del @c(Contexto), lo que
     hace que este sea mas dificil de comprender, mantener y extender. Y no se
     puede modificar el algoritmo dinamicamente. Acabaremos teniendo muchas
     clases relacionadas cuya unica diferencia es el algoritmo o comportamiento
     que utilizan. Encapsular el algoritmo en clases @c(Estrategia) separadas
     nos permite variar el algoritmo independientemente de su contexto,
     haciendolo mas facil de cambiar, compreder y extender.

  3. @e(Las estrategias eliminan las sentencias condicionales.) El patron
     Strategy ofrece una alternativa a las sentencias condicionales para
     seleccionar el comportamieto deseado. Cuando se juntan muchos
     comportamientos en una clase es dificil no usar sentecias condicionales
     para seleccionar el comportamiento correcto. Encapsular el comportamiento
     en clases @c(Estrategia) separadas elimina estas sentencias condicionales.

     Por ejemplo, sin estrategias, el codigo para dividir un texto en lineas
     podria parecerse a

     ..src > c++
       void Composicion::Reparar () {
           switch (_estrategiaDeDivision) {
           case EstrategiaSimple:
               ComponerConComponedorteSimple();
               break;
           case EstrategiaTeX:
               ComponerConComponedorTeX();
               break;
           // ...
           }
           // si es necesario, combina los resultados
           // con la composicion existente
       }
     < src..

     El patron Estrategia elimina esta sentencia condicional delegando la tarea
     de division en lineas en el objeto @c(Estrategia):

     ..src > c++
       void Composicion::Reparar () {
           _componer->Componer();
           // si es necesario, combina los resultados
           // con la composicion existente
       }
     < src..

     Un codigo que contiene muchas sentecias condicionales suele indicar la
     necesidad de aplicar el patron Estrategia.

  4. @e(Una eleccion de implementaciones.) Las estrategias pueden proporcionar
     distintas implementaciones del mismo comportamiento. El cliente puede
     elegir entre estrategias con diferentes soluciones de compromiso entre
     tiempo y espacio.

  5. @e(Los clientes deben conocer las diferentes Estrategias.) El patron tiene
     el inconveniente potencial de que un cliente debe conprender como difieren
     las Estrategias antes de seleccionar la adecuada. los clientes pueden estar
     expuestos a cuestiones de implementacion. Por tanto, el patron Strategy
     deberia usarse solo cuando la variacion de comportamiento sea relevante a
     los clientes.

  6. @e(Costes de comunicacion entre Estrategia y Contexto.) La interfaz de
     @c(Estrategia) es compartida por todas las clases @c(EstrategiaConcreta), ya
     sea el algoritmo que implementa trivial o complejo. Por tanto, es probable
     que algunos objetos @c(EstrategiaConcreta) no usen toda la informacion que
     reciben a traves de dicha interfaz, las estrategias concretas simples
     pueden incluso no utilizar nada de dicha informacion. Eso significa que
     habra veces en las que el contexto crea e inicializa parametros que nunca
     se usan. Si esto puede ser un problema, necesitaremos un acoplamiento mas
     fuerte entre @c(Estrategia) y @c(Contexto).

  7. @e(Mayor numero de objetos.) Las estrategias aumentan el numero de objetos
     de una aplicacion. A veces se puede reducir este coste implementando las
     estrategias como objetos sin estado que puedan ser compartidos por el
     contexto. El contexto mantiene cualquier estado residual, pasandolo en cada
     peticion al objeto @c(Estrategia). Las estrategias compartidas no deberian
     mantener el estado entre invocaciones. El patron @l(#Flyweight) describe
     este enfoque en mas detalle.

*** Strategy Implementacion <> Implementacion

  Examinemos las siguientes cuestiones de implementacion:

  1. @e(Definir las interfaces @c(Estrategia) y @c(Contexto).) Las interfaces
     @c(Estrategia) y @c(Contexto) deben permitir a una @c(EstrategiaConcreta)
     acceder de manera eficiente a cualquier dato que esta necesite del
     contexto, y viceversa.

     Un enfoque es hacer que @c(Contexto) pase los datos como parametros a las
     operaciones de @c(Estrategia) @-(en otras palabras, lleva los datos a la
     estrategia). Esto mantiene a @c(Estrategia) y @c(Contexto) desacoplados.
     Por otro lado, @c(Contexto) podria pasar datos a la @c(Estrategia) que esta
     no necesita.

     Otra tecnica consiste en que un contexto se pase a @e(si mismo) como
     argumento, y que la estrategia pida los datos explicitamente al
     contexto. Como alternativa, la estrategia puede guardar una referencia a su
     contexto, eliminando asi la necesidad de pasar nada. De cualquiera de las
     dos formas, la estrategia puede pedir exactamente lo que necesita. Pero
     ahora @c(Contexto) debe definir una interfaz mas elaborada para sus datos,
     lo que acopla mas estrechamente a @c(Estrategia) y @c(Contexto).

     Las necesidades del algoritmo concreto y sus requisitos de datos
     determinaran cual es la mejor tecnica.

  2. @e(Estrategias como parametros de plantillas.) En C++, pueden usarse las
     plantillas para configurar una clase como una estrategia. Esta tecnica solo
     se puede aplicar si (1) se puede seleccionar la @c(Estrategia) en tiempo de
     compilacion, y (2) no hay que cambiarla en tiempo de ejecucion. En este
     caso, la clase a configurar (por ejemplo, @c(Contexto)) se define en una
     clase plantilla que tiene como parametro una clase @c(Estrategia):

     ..src > c++
       template <class UnaEstrategia>
       class Contexto {
           void Operacion() { laEstrategia.HacerAlgoritmo(); }
           // ...
       private:
           UnaEstrategia laEstrategia;
       };
     < src..

     La clase se configura con una clase @c(Estrategia) en el momento en que se
     crea una instancia:

     ..src > c++
       class MiEstrategia {
       public:
           void HacerAlgoritmo();
       };

       Contexto<MiEstrategia> unContexto;
     < src..

     Con plantillas, no hay necesidad de definir una clase abstracta que defina
     la interfaz de la @c(Estrategia). Usar @c(Estrategia) como un parametro de
     plantilla tambien nos permite enlazar estaticamente una @c(Estrategia) a su
     @c(Contexto), lo que puede aumentar la eficiencia.

  3. @e(Hacer opcionales los objetos Estrategia.) La clase @c(Contexto) puede
     simplificarse en caso de que tenga sentido no tener un objeto
     @c(Estrategia). La clase @c(Contexto) comprueba si tiene un objeto
     @c(Estrategia) antes de acceder a el. En caso de que exista, lo usa
     normalmente. Si no hay una estrategia, @c(Contexto) realiza el
     comportamiento predeterminado. La ventaja de este enfoque es que los
     clientes no tienen que tratar con los objetos @c(Estrategia) @e(a menos)
     que no les sirva el comportamiento predeterminado.

*** Strategy Codigo de Ejemplo <> Codigo de Ejemplo

  A continuacion se muestra el codigo de alto nivel del ejemplo de la seccion de
  la Motivacion, que esta basado en la implementacion de las clases
  @c(Composicion) y @c(Componedor) de InterViews [@l(#LCI+92)].

  La clase @c(Composicion) tiene una coleccion de instancias de @c(Componente),
  que representan los elementos graficos y de texto de un documento. Una
  composicion distribuye los objetos componente en lineas usando una instancia
  de una subclase de @c(Componedor), la cual encapsula una estrategia de
  division en lineas. Cada componente tiene un tamaño natural asociado, una
  dimension maxima y otra minima. Estas definen cuanto puede crecer el
  componente por encima de su tamaño natural y cuanto puede encogerse,
  respectivamente. La composicion pasa estos valores a un componedor, que los
  usa para determinar la mejor posicion para los saltos de linea.

  ..src > c++
    class Composicion {
    public:
        Composicion(Componedor*);
        void Reparar();
    private:
        Componedor* _componedor;
        Componente* _componentes;   // la lista de componentes
        int _contadorComponentes;   // el numero de componentes
        int _anchoLinea;            // el ancho de linea de la composicion
        int* _saltosLinea;          // la posicion de los saltos de
                                    // linea en los componentes
        int _contadorLineas;        // el numero de lineas
    };
  < src..

  Cuando se necesita una neuva distribucion, la composicion le pide a su
  componedor que determine donde situar los saltos de linea. La composicion pasa
  al componedor tres arrays que definen el tamaño natural y las dimenciones
  maximas y minimas de los componentes. Tambien pasa el numero de componentes,
  el ancho de la linea y un array que rellena el componedor con la posicion de
  cada salto de liena. El componoder devuelve el numero de saltos calculados.

  La interfaz del @c(Componedor) permite que la composicion pase a este toda la
  informacion que necesita. Esto es un ejemplo de @"(llevar los datos a la
  estrategia):

  ..src > c++
    class Componedor {
    public:
        virtual int Componer(
            Coord natural[], Coord estirado[], Coord encogido[],
            int contadorComponentes, int anchoLinea, int saltos[]
        ) = 0;
    protected:
        Componedor();
    };
  < src..

  Notese que @c(Componedor) es una clase abstracta. Las subclases concretas
  definen estrategias concretas de division en lineas.

  La composicion llama a su componedor en su operacion @c(Reparar). En primer
  lugar, @c(Reparar) inicializa los arrays con el tamaño natural y las
  dimensiones maxima y minima de cada componente (omitiremos los detalles de
  como se hace esto en aras de la brevedad). A continuacion, llama al
  componedor para obtener los saltos de linea. Finalmente, distribuye los
  componentes en funcion de los saltos de linea (tambien omitido):

  ..src > c++
    void Composicion::Reparar () {
        Coord* natural;
        Coord* maxima;
        Coord* minima;
        int contadorComponentes;
        int* saltos;

        // preparar los arreglos con el tamaño deseado de los componentes
        // ...

        // determina donde van los saltos:
        int contadorSaltos;
        contadorSaltos = _componedor->Componer(
            natural, maxima, minima,
            contadorComponentes, _anchoLinea, saltos
        );

        // coloca los componentes en funcion de los saltos
        // ...
    }
  < src..

  Veamos ahora las subclases de @c(Componedor). @c(ComponedorSimple) examina los
  componentes de una linea cada vez, para determinar donde deberian ir los
  saltos:

  ..src > c++
    class ComponedorSimple : public Componedor {
    public:
        ConponedorSimple();

        virtual int Componer(
            Coord natural[], Coord maxima[], Coord minima[],
            int contadorComponentes, int anchoLinea, int saltos[]
        );
        // ...
    };
  < src..

  @c(ComponedorTeX) usa una estrategia mas global. Examina un @e(parrado) cada
  vez, teniendo en cuenta el tamaño y la dimension maxima de los
  componentes. Tambien trata de asignar un "color" uniforme al parrafo
  minimizando el espacio entre componentes.

  ..src > c++
    class ComponederTeX : public Componedor {
    public:
        ComponedorTeX();

        virtual int Componer(
            Coord natural[], Coord maxima[], Coord minima[],
            int contadorComponentes, int anchoLinea, int saltos[]
        );
        // ...
    };
  < src..

  @c(ComponedorMatriz) separa los componentes en lineas a intervalos regulares.

  ..src > c++
    class ComponedorMatriz : public Componedor {
    public:
      ComponedorMatriz(int intervalo);

      virtual int Componer(
          Coord natural[], Coord maxima[], Coord minima[],
          int contadorComponentes, int anchoLinea, int saltos[]
      );
      // ...
    };
  < src..

  Estas clases no usan toda la informacion que se le pasa a @c(Componer).
  @c(ComponedorSimple) no hace uso de la dimencion maxima de los componentes, y
  solo tiene en cuenta el ancho natural de estos. @c(ComponedorTeX) usa toda la
  informacion que recibe, mientras que @c(ComponedorMatriz) no usa nada.

  Para crear una instancia de @c(Composicion) es necesario pasarle el componedor
  que queremos que use:

  ..src > c++
    Composicion* rapida = new Composicion(new ComponedorSimple);
    Composicion* elegante = new Composicion(new ComponedorTeX);
    Composicion* iconos = new Composicion(new ComponedorMatriz(100));
  < src..

  La @c(intrefaz) de @c(Componedor) esta cuidadosamente diseñada para permitir
  toda clase de algoritmos de composicion que pudieran implementar las
  subclases. No queremos tener que cambiar esta interfaz con cada nueva
  subclase, ya que eso requeriria cambiar las subclases existentes. En general,
  las interfaces @c(Estrategia) y @c(Contexto) determinan en que medida consigue
  el patron su proposito.

*** Strategy Usos Conocidos <> Usos Conocidos

  Tanto ET++ [@l(#WGM88)] como InterViews usan estrategias para encapsular diferentes
  algoritmos de division en lineas tal y como se ha descrito aqui.

  En el Sistema RTL System para optimizacion de codigo en los compiladores
  [@l(#JML92)], las estrategias definen diferentes esquemas de asignacion de
  registros (RegisterAllocator) y de politicas de planificacion de juegos de
  instrucciones (RISCscheduler, CISCscheduler). Esto proporciona flexibilidad a
  la hora de usar el optimizador para diferentes arquitecturas de maquinas.

  El framework de moteres de calculo ET++ SwapsManager, calcula los precios de
  diversos intrumentos financieros [@l(#EG92)]. Sus abstracciones clave son
  @c(Instrument) y @c(YieldCurve). Los diferentes instrumentos se implementan
  como subclases de @c(Intrument). @c(YieldCurve) calcula los tipos de
  descuento, que determinan el valor actual de los flujos de caja futuros. Ambas
  clases delegan parte de su comportamiento en objetos Estrategia. El framework
  proporciona una familia de clase @c(EstrategiaConcreta) para generar flujos de
  caja, valorar permutas financieras y calcular tipos de descuento. Se pueden
  crear nuevos motores de calculo configurando @c(Istrument) y @c(YieoldCurve)
  con los distintos objetos @c(EstrategiaConcreta). Este enfoque permite
  combinar y usar las implementaciones existentes de @c(Estrategia) asi como
  definir otras nuevas.

  Los componentes de Booch [@l(#BV90)] usan estrategias como argumentos de
  plantillas. Las clases de colecciones de Booch permiten tres tipos de
  estrategias de asignacion de memoria: gestionada (asignacion mediante un
  @e(pool)), controlada (las asignaciones y liberaciones estan protegidas por
  bloqueos) y sin gestionar (el asignador de memoria predeterminado). Estas
  estrategias se pasan como argumentos de plantilla a una clase de coleccion
  cada vez que se crea una instancia de esta. Por ejemplo, una coleccion de
  tamaño variable que usa la estrategia de no gestionar se crea como una
  @c(UnboundedCollection).

  RApp es un sistema para el diseño de circuitos integrados [@l(#GA89), @l(#AG90)]. RApp
  debe dibujar cables que conectan los distintos subsistemas de un circuito. Los
  algoritmos que determinan por donde deben ir dichos cables se definen en RApp
  como subclases de una clase abstracta @c(Router). @c(Router) es una clase
  Estrategia.

  ObjectWindows de Borland [@l(#Bor94)] usa estrategias en los cuadros de dialogo
  para asegurar que el usuario introduzca datos validos. Por ejemplo, los numeros
  podrian tener que estar dentro de un intervalo determinado, y un campo
  numerico solo deberia aceptar digitos. Validar que una cadena es correcta
  puede necesitar una tabla de busqueda.

  ObjectWindows usa objetos @c(Validator) para encapsular estrategias de
  validacion. Los validadores son ejemplos de objetos Estrategia. Los campos de
  entrada de datos delegan la validacion a un objeto @c(Validator) opcional. El
  cliente asigna un validador a un campo que necesita ser validado (esto
  constituye un ejemplo de una estrategia opcional). Cuando se cierra el
  dialogo, los campos de entrada le piden a sus validadores que validen los
  datos. La biblioteca de clases proporciona validadores para los casos mas
  comunes, como un @c(RangeValidator) (validador de intervalo) para numeros. Se
  pueden definir facilmente nuevas estrategias especificas del cliente heredando
  de la clase @c(Validator).

*** Strategy Patrones Relacionados <> Patrones Relacionados

  @l(#Flyweight): los objetos Estrategia suelen ser buenos pesos ligeros.

** Template Method
*** Template Method Proposito <> Proposito

  Define en una operacion el esqueleto de un algoritmo, delegando en las
  subclases algunos de sus pasos. Permite que las subclases redefinan ciertos
  pasos de un algoritmo sin cambiar su estructura.

*** Template Method Motivacion <> Motivacion

  Pensemos en un framework que proporciona las clases @c(Aplicacion) y
  @c(Documento). La clase @c(Aplicacion) es la responsable de abrir el documento
  guardado en un formato externo, como por ejemplo un fichero. Un objeto
  @c(Documento) representa la informacion de un documento una vez que este ha
  sido leido del fichero.

  Las aplicaciones construidas con el framework pueden heredar de @c(Aplicacion)
  o @c(Documento) para adaptarse a necesidades esecificas. Por ejemplo, una
  aplicacion de dibujo define las subclase @c(AplicacionDeDibujo) y
  @c(DocumentoDeDibujo); una aplicacion de hoja de calculo define las subclases
  @c(AplicacionDeHojaDeCalculo) y @c(DocumentoDeHojaDeCalculo).

  ..img > img/120.png

  La clase @c(Aplicacion) define el algoritmo para abrir y leer un documento en
  su operacion @c(AbrirDocumento):

  ..src > c++
    void Aplicacion::AbrirDocumento (const char* nombre) {
        if (!SePuedeAbrirDocumento(nombre)) {
            // no se puede abrir este documento
            return;
        }

        Documento* doc = HacerCrearDocumento();
        if (doc) {
            _docs->AnadirDocumento(doc);
            APuntoDeAbrirDocumento(doc);
            doc->Abrir();
            doc->HacerLeer();
        }
    }
  < src..

  @c(AbrirDocumento) define cada paso para abrir el documento. Comprueba si el
  documento puede abrise, crea el objeto @c(Documento) especifico de la
  aplicacion, lo añade a su cojunto de documentos y lee el @c(Documento) de un
  fichero.

  Llamaremos a @c(AbrirDocumento) un @b(metodo plantilla). Un metodo plantilla
  define un algoritmo en terminos de operaciones abstractas que las subclases
  deben definir para proporcionar un determinado comportamiento. Las subclases
  de @c(Aplicacion) definen los pasos del algoritmo que comprueban si el
  decumento puede abrise @%c(SePuedeAbrirDocumento) y que crean el @c(Documento)
  @%c(HacerCrearDocumento). Las clases @c(Documento) definen el paso que lee el
  documento @%c(HacerLeer). El metodo plantilla tambien define una operacion que
  permite que las subclases de @c(Aplicacion) sepan cuando se va abrir el
  documento @%c(APuntoDeAbrirDocumento).

  Al definir algunos de los pasos de un algoritmo usando operaciones abstractas,
  el metodo plantilla fija su ordenacion, pero permite que las subclases de
  @c(Aplicacion) y @c(Documento) modifiquen dichos pasos para adecuarse a sus necesidades.

*** Template Method Aplicabilidad <> Aplicabilidad

  El patron Template Method deberia usarse

  - para implementar las partes de un algoritmo que no cambian y dejar que sean
    las subclase quienes implementen el comportamiento que puede variar.

  - cuando el comportamiento repetido de varias subclases deberia factorizarse y
    ser localizado en una clase comun para evitar el codigo duplicado. Esta es
    una buena idea de @"(refactorizar para generalizar), tal como la describen
    Opdyke y Johnson [@l(#OJ93)]. En primer lugar identificamos las diferencias en el
    codigo existente y a continuaicon separamos dichas diferencias en nuevas
    operaciones. Por ultimo, sustituimos el codigo que cambia por un metodo que
    llama a una de estas nuevas operaciones.

  - para controlar las extensiones de las subclases. Podemos definir un metodo
    plantilla que llame a operaciones @"(de enganche) (vease las Consecuencias)
    en determinados puntos, permitiendo asi las extensiones solo en esos puntos.

*** Template Method Estructura <> Estructura

  ..img > img/121.png

*** Template Method Participantes <> Participantes

  - @c(ClaseAbstacta) (@c(Aplicacion))

    - define operaciones primitivas abstractas que son definidas por las
      subclases para implementar los pasos de un algoritmo.

    - implementa un metodo plantilla que define el esqueleto de un algoritmo. El
      metodo plantilla llama a las operaciones primitivas asi como a operaciones
      definidas en @c(ClaseAbstracta) o a las de otros objetos.

  - @c(ClaseConcreta) (@c(MiAplicacion))

    - Implementa las operaciones primitivas para realizar los pasos del algoritmo
      especificos de las subclases.

*** Template Method Colaboraciones <> Colaboraciones

  @c(ClaseConcreta) se basa en la @c(ClaseAbstracta) para implementar los pasos
  de un algoritmo que no cambian.

*** Template Method Consecuencias <> Consecuencias

  Los metodos plantillas son una tecnica fundamental de reutilizacion de
  codigo. Son particularmente importantes en las bibliotecas de clases, ya que
  son el modo de factorizar y extraer el comportamiento comun de las clases de
  la biblioteca.

  Los metodos plantilla llevan a una estructura de control invertido que a veces
  se denomina @"(el principio de Hollywood), es decir, @"(No nos llame,
  nosotros le llamaremos) [@l(#Swe85)]. Esto se refiere a como una clase padre llama
  a las operaciones de una subclase y no al reves.

  Los metodos plantilla llaman a los siguientes tipos de operaciones:

  - operaciones concretas (ya sea de la @c(ClaseConcreta) o de las clases
    cliente);

  - operaciones de @c(ClaseAbstracta) (es decir, operaciones que suelen ser
    utiles para las subclases);

  - operaciones primitvas (es decir, operaciones abstractas);

  - metodos de fabricacion (vease el patron @l(#Factory Method)); y

  - operaciones de enganche, que proporcionan el comportamiento predeterminado
    que puede ser modificado por las subclases si es necesario. Una operacion de
    enganche normalmente no hace nada por omision.

  Es importante que los metodos plantilla especifiquen que operacines son
  enganches (que @e(pueden) ser redefinidas) y cuales son operaciones abstractas
  (que @e(deben) ser redefinidas). Para reutilizar una clase abstracta
  apropiadamente, los escritores de las subclases deben saber que operaciones
  estan diseñadas para ser redefinidas.

  Una subclase puede @e(extender) el comportamiento de una operacion de una
  clase padre redefiniendo la operacion y llamando explicitamente a la operacion
  del padre:

  ..src > c++
    void ClaseDerivada::Operacion () {
        // ClaseDerivada extiende el comportamiento
        ClasePadre::Operacion();
    }
  < src..

  Desgraciadamente, es facil olvidarse de llamar a la operacion heredada.
  Podemos trasformar esta operacion en un metodo plantilla que le de control al
  padre sobre como este puede ser extendido por las subclases. La idea es llamar
  a una operacion de enganche desde un metodo plantilla en la clase padre. Las
  subclases pueden entoces redefinir esta operacion de enganche:

  ..src > c++
    void ClasePadre::Operacion () {
        // comportamiento de ClasePadre
        OperacionDeEnganche();
    }
  < src..

  @c(OperacionDeEnganche) no hace nada en la @c(ClasePadre):

  ..src > c++
    void ClasePadre::OperacionDeEnganche () { }
  < src..

  Las subclases redefinen @c(OperacionDeEnganche) para extender su
  comportamiento:

  ..src > c++
    void ClaseDerivada::OperacionDeEnganche () {
        // extension de la clase derivada
    }
  < src..

*** Template Method Implementacion <> Implementacion

  Merece la pena tener en cuenta tres detalles de implementacion:

  1. @e(Usar el control de acceso de C++.) En C++, las operaciones primitivas a
     las que llama un metodo plantilla pueden ser declaradas como miembros
     protegidos. Esto garantiza que solo pueden ser llamadas por el metodo
     plantilla. Las operaciones primitivas que @e(deben) ser redefinidas se
     declaran como virtuales puras. El metodo plantilla en si no deberia ser
     redefinido; por tanto podemos hacer que sea una funcion miembro no virtual.

  2. @e(Minimzar las operaciones primitivas.) Un objeto importante para diseñar
     metodos plantilla es minimizar el numero de operaciones primitivas que una
     subclase debe redefinir para dar cuerpo al algoritmo. Cuantas mas
     operaciones necesiten ser redefinidas, mas tediosas se vuelven las cosas
     para los clientes.

  3. @e(Convenios de nominacion.) Se pueden identificar las operaciones que
     deberian ser redefinidas añadiendo un prefijo a sus nombres. Asi, por
     ejemplo, el framework MaccApp para aplicaciones de Machintosh [@l(#App89)] añade
     a los nombres de los metodos plantilla el prefijo @"c(Do-):
     @"c(DoCreateDocument), @"c(DoRead), etcetera.

*** Template Method Codigo de Ejemplo <> Codigo de Ejemplo

  El siguiente codigo en C++ muestra como puede una clase padre obligar a sus
  subclases a respetar un ivariente. El ejemplo procede del AppKit de NeXT
  AppKit [@l(#Add94)]. Pensemos en una clase @c(Vista) que permite dibujar en la
  pantalla. @c(Vista) hace cumplir el invariante de que sus subclases pueden
  dibujar en una vista solo despues de que esta ha recibido el @"(foco), lo que
  requiere establecer de forma apropiada parte del estado del dibujo (como, por
  ejemplo, las fuentes y los colores).

  Podemos usar un metodo plantilla, @c(Mostrar), para establecer dicho
  estado. @c(Vista) define dos operaciones concretas, @c(AsignarFoco) y
  @c(QuitarFoco), que establecen y limpian el estado del dibujo,
  respectivamente. La operacion @c(HacerMostrar) de @c(Vista) es quien realiza
  el dibujado real. @c(Mostrar) llama a @c(AsignarFoco) antes de
  @c(HacerMostrar) para configurar el estado del dibujo; @c(Mostrar) llama a
  @c(QuitarFoco) para liberar dicho estado.

  ..src > c++
    void Vista::Mostrar () {
        AsignarFoco();
        HacerMostrar();
        QuitarFoco();
    }
  < src..

  Para conservar el invariente, los clientes de @c(Vista) siempre llaman a
  @c(Mostrar), y las subclases de @c(Vista) siempre redefinen @c(HacerMostrar).

  @c(HacerMostrar) no hace nada en @c(Vista):

  ..src > c++
    void Vista::HacerMostrar() { }
  < src..

  Las subclases lo redefinen para añadir su comportamiento de dibujado
  especifico:

  ..src > c++
    void MiVista::HacerMostrar () {
        // muestra los contenidos de la vista
    }
  < src..

*** Template Method Usos Conocidos <> Usos Conocidos

  Los metodos plantilla son tan fundamentales que pueden encontrarse en casi
  cualquier clase abstracta. Wirfs-Brock et al. [@l(#WBWW90), @l(#WBJ90)]
  proporcionan una buena discusion de los metodos plantilla.

*** Template Method Patrones Relacionados <> Patrones Relacionados

  Los @l(#Factory Method<>Metodos de Fabricacion) se llaman muchas veces desde
  metodos plantilla. En el ejemplo de la seccion de Motivacion, el metodo de
  fabricacion @c(HacerCrearDocumento) es llamado por el metodo plantilla
  @c(AbrirDocumento).

  @l(#Strategy): Los metodos plantilla usan la herencia para modificar una parte
  de un algoritmo. Las estrategias usan delegacion para variar el algoritmo completo.

** Visitor
*** Visitor Proposito <> Proposito

  Representa una operacion sobre los elementos de una estructura de
  objetos. Permite definir una nueva operacion sin cambiar las clases de los
  elementos sobre los que opera.

*** Visitor Motivacion <> Motivacion

  Pensemos en un compilador que representa programas con arboles sintacticos
  abstractos. Necesitaremos realizar operaciones sobre dichos arboles
  sintacticos abstractos para llevar a cabo el analisis @"(semantico estatico),
  como comprobar que todas las variebles estan definidas. Tambien necesitaremos
  generar codigo. Por tanto, podriamos definir operaciones para la comprobacion
  de tipos, la optimizacion de codigo, el analisis de flujo, comprobar que se
  asignan valores a las variebles antes de su uso, etcetera. Mas aun, podriamos
  usar los arboles sintacticos abstractos para imprimir con formato,
  reestructurar el programa, instrumentacion de codigo o calcular diferentes
  metricas de un programa.

  La mayoria de estas operaciones necesitaran tratar a los nodos que representan
  sentencias de asignacion de forma distinta que a los que representa variables o
  expresiones aritmeticas. Por tanto, habra una clase para sentencias de
  asignacion, otra para los accesos a variables, otra para expresiones
  aritmeticas y asi sucesivamente. El conjunto de clases de nodos depende del
  lenguaje que esta siendo compilado, por supuesto, pero no cambia mucho para un
  lenguaje dado.

  ..img > img/122.png

  Este diagrama muestra parte de la jerarquia de clase de @c(Nodo). El problema
  aqui es que distribuir todas estas operaciones a traves de las distintas
  clases de nodos conduce a un sistema que es dificil de compreder, mantener y
  cambiar. Sera confuso tener la comprobacion de tipos mezclada con el codigo de
  impresion o con el de analisis de flujo. Ademas, añadir una nueva operacion
  normalmente obliga a recompilar todas estas clases. Seria mejor si cada nueva
  operacion pudiera ser añadida por separado y las clases de nodos fuesen
  independientes de las operaciones que se aplican sobre ellas.

  Podemos lograr ambas cosas empaquetando las operaciones relacionadas de las
  distintas clases en un objeto aparte, llamado @b(visitante), al que se le pasen
  los elementos del arbol sintactico abstracto a medida que va siendo
  recorrido. Cuando un elemento @"(acepta) al visitante, le envia una peticion
  que codifica la clase del elemento. Tambien incluye al elemento como
  argumento. El visitante ejecutara entonces la operacion para ese elemento @-(la
  operacion que solia estar en la clase elemento).

  Por ejemplo, un compilador que no usara visitantes podria comprobar los tipos
  de un procedimiento llamando a la operacion @c(ComporbarTipos) sobre su arbol
  sintactico abstracto. Cada uno de los nodos implementaria @c(ComprobarTipos)
  llamando a @c(ComprobarTipos) sobre sus componentes (vease el diagrama de
  clases precedente). Si la comprobacion de tipos de un procedimiento usara
  visitantes, entonces crearia un objeto @c(VisitanteComprobacionDeTipos) y
  llamaria a la operacion @c(Aceptar) sobre el arbol sintactico abstracto con
  ese objeto como argumento. Cada uno de los nodos implementaria @c(Aceptar)
  llamando a su vez al visitante: un nodo de asignacion llama a la operacion
  @c(VisitarAsignacion) del visitante, mientras que una referencia a una
  variable llama a @c(VisitarReferenciaAVariable). Lo que antes era la operacion
  @c(ComprobarTipos) de la clase @c(NodoAsignacion) ahora es la operacion
  @c(VisitarAsignacion) de @c(VisitanteComprobacionDeTipos).

  Para hacer que los visitantes sirvan para algo mas que simplemente la
  comprobacion de tipos necesitamos una clase padre abstracta,
  @c(VisitanteNodo), para todos los visitantes de un arbol sintactico
  abstracto. @c(VisitanteNodo) debe declarar una operacion para clase de
  nodo. Una aplicacion que necesite calcular metricas de programas definira
  nuevas subclases de @c(VisitanteNodo) y ya no necesitara añadir codigo
  especifico de una aplicacion a las clases de los nodos. El patron @c(Visitor)
  encapsula las operaciones de cada fase de compilacion en un visiante asociado
  a esa fase.

  ..img > img/123.png

  Con el patron @c(Visitor), definimos dos jerarquias de clases: una para los
  elementos sobre los que se opera (la jerarquia de @c(Nodo)) y otra para los
  visitantes que definen operaciones sobre los elementos (la jerarquia de
  @c(VisitanteNodo)). La forma de crear una nueva operacion es añadiendo una
  nueva subclase a la jerarquia de clases de los visitantes. Siempre y cuando no
  cambie la gramatica aceptada por el compilador (es decir, siempre que no
  tengamos que añadir nuevas subclases de @c(Nodo)), podemos añadir nueva
  funcionalidad simplemente definiendo nuevas subclases de @c(VisitanteNodo).

*** Visitor Aplicabilidad <> Aplicabilidad

  Usese el patron Visitor cuando

  - una estructura de objetos contiene muchas clases de objetos con diferentes
    interfaces, y queremos realizar operaciones sobre esos elementos que
    dependen de su clase concreta.

  - se necesitan realizar muchas operaciones distintas y no relacionadas sobre
    objetos de una estructura de objetos, y queremos evitar @"(contaminar) sus
    clases con dichas operaciones. El patron Visitor permite mantener juntas
    operaciones relacionadas definiendolas en una clase. Cuando la estructura de
    objetos es compartida por varias aplicaciones, el patron Visitor permite
    poner operaciones solo en aquellas aplicaciones que las necesitan.

  - las clases que definen la estructura de objetos rara vez cambian, pero
    muchas veces queremos definir nuevas operaciones sobre la
    estructura. Cambiar las clases de la estructura de objetos requiere
    redefinir la interfaz para todos los visitantes, lo que es potencialmente
    costoso. Si las clases de la estructura cambian con frecuencia,
    probablemente sea mejor definir las operaciones en las propias clases.

*** Visitor Estructura <> Estructura

  ..img > img/124.png

*** Visitor Participantes <> Participantes

  - @c(Visitante) (@c(VisitanteNodo))

    - declara una operacion @c(Visitar) para cada clase de operacion
      @c(ElementoConcreto) de la estructura de objetos. El nombre y signatura de
      la operacion identifican a la clase que envia la peticion @c(Visitar) al
      visitante. Eso permite al visitante determinar la clase concreta de
      elemento que esta siendo visitada. A continuacion el visitante puede
      acceder al elemento directamente a traves de su interfaz particular.

  - @c(VisitanteConcreto) (@c(VisitanteComprobacionDeTipos))

    - implementa cada operacion declarada por @c(Visitante). Cada operacion
      implementa un fragmento del algoritmo definido para la clase
      correspondiente de la estructura. @c(VisitanteConcreto) proporciona el
      contexto para el algoritmo y guarda su estado local. Muchas veces este
      estado acumula resultados durante el recorrido de la estructura.

  - @c(Elemento) (@c(Nodo))

    - define una operacion @c(Aceptar) que toma un visitante como argumento.

  - @c(ElementoConcreto) (@c(NodoAsignacion), @c(NodoRefVariable))

    - implementa una operacion @c(Aceptar) que toma un visitante como argumento.

  - @c(EstructuraDeObjetos) (@c(Programa))

    - puede enumerar sus elementos.

    - puede proporcionar una interfaz de alto nivel para permitir al visitante
      visitar a sus elementos.

    - puede ser un compuesto (vease el patron @l(#Composite)) o una coleccion,
      como una lista o un cojunto.

*** Visitor Colaboraciones <> Colaboraciones

  - Un cliente que usa el patron Visitor debe crear un objeto
    @c(VisitanteConcreto) y a continuacion recorrer la estructura, visitando
    cada objeto con el visitante.

  - Cada vez que se visita a un elemento, este llama a la operacion del
    Visitante que se correponde con su clase. El elemento se pasa a si mismo
    como argumento de la operacion para permitir al visitante acceder a su
    estado, en caso de que sea necesario.

    El siguiente diagrama de interaccion ilustra las colaboraciones entre una
    estructura de objetos, un visitante y dos elementos:

    ..img > img/125.png

*** Visitor Consecuencias <> Consecuencias

  Algunas de las ventajas e inconvenientes del patron Visitor son las siguientes:

  1. @e(El visitante facilita añadir nuevas operaciones.) Los visitantes
     facilitan añadir nuevas operaciones que dependen de los componentes de
     objetos complejos. Podemos definir una nueva operacion sobre una estructura
     simplemente añadiendo un nuevo visitante. Si, por el contrario,
     extendiesemos la funcionalidad sobre muchas clases, habria que cambiar
     cada clase para definir una nueva operacion.

  2. @e(Un visitante agrupa operaciones relacionadas y separa las que no lo estan.)
     El comportamiento similar no esta desperdigado por las clases que definen
     la estructura de objetos; esta localizado en un visitante. Las partes de
     comportamiento no relacionadas se dividen en sus propias subclases del
     visitante. Esto simplifica tanto las clases que definen los elementos como
     los algoritmos definidos por los visitantes. Cualquier estructura de datos
     especifica de un algoritmo puede estar oculta en el visitante.

  3. @e(Es dificil añadir nuevas clases de @c(ElementoConcreto).) El patron
     Visitor hace que sea complicado añadir nuevas subclases de @c(Elemento).
     Cada @c(ElementoConcreto) nuevo da lugar a una nueva operacion abstracta
     del Visitante y su correspondiente implementacion en cada clase
     @c(VisitanteConcreto). A veces se puede proporcionar en @c(Visitante) una
     implementacion predeterminada que puede ser heredada por la mayoria de los
     visitantes concretos, pero esto representa una excepcion mas que una regla.

     Por tanto la cuestion fundamental a considerar a la hora de aplicar el
     patron Visitor es si es mas probable que cambie el algoritmo aplicado sobre
     una estructura de objetos o las clases de los objetos que componen la
     estrucutra. La jerarquia de clases de Visitante puede ser dificil de
     mantener, cuando se añaden nuevas clases de @c(ElementoConcreto) con
     frecuencia. En tales casos, es probablemente mas facil definir las
     operaciones en las clases que componen la estructura. Si la jeraquia de
     clase de @c(Elemento) es estable pero estamos continuamente añadiendo
     operacione o cambiando algoritmos, el patron Visitor nos ayudara a
     controlar dichos cambios.

  4. @e(Visitar varias jerarquias de clases.) Un iterador (vease el patron
     @l(#Iterator)) puede visitar a los objetos de una estructura llamando a sus
     operaciones a medida que los recorre. Pero un iterador no puede trabajar en
     varias estructuras de objetos con distintos tipos de elementos. Por
     ejemplo, la interfaz @c(Iterador) definida el la seccion @l(#Iterator
     Codigo de Ejemplo<>Codigo de Ejemplo) de su respectivo patron, puede
     acceder unicamente a objetos del tipo @c(Elemento):

     ..src > c++
       template <class Elemento>
       class Iterador {
           // ...
           Elemento ElementoActual() const;
       };
     < src..

     Esto implica que todos los elementos que el iterador puede visitar tienen
     una clase padre comun @c(Elemento).

     El patron Visitor no tiene esta restriccion. Puede visitar objetos que no
     tienen una clase padre comun. Se puede añadir cualquier tipo de objeto a la
     intefaz de un Visitante. Por ejemplo, en

     ..src > c++
       class Visitante {
       public:
           // ...
           void VisitarMiTipo(MiTipo*);
           void VisitarTuTipo(TuTipo*);
       };
     < src..

     @c(MiTipo) y @c(TiTipo) no tienen por que estar relacionados en modo alguno
     atravez de la herencia.

  5. @e(Acumular el estado.) Los visitantes pueden acumular estado a medida que
     van visitanto cada elemento de la estructura de objetos. Sin un visitante,
     este estado se pasaria como argumentos extra a las operaciones que realizan
     el recorrido, o quiza como variables globales.

  6. @e(Romper la encapsulacion.) El enfoque del patron Visitor asume que la
     interfaz de @c(ElementoConcreto) es lo bastate pontente como para que los
     visitantes hagan su trabajo. Como resultado, el patron suele obligarnos a
     proporcionar operaciones publicas que accedan al estado interno de un
     elemento, lo que puede comprometer su encapsulacion.

*** Visitor Implementacion <> Implementacion

  Cada estructura de objetos tendra una clase @c(Visitante) asociada. Esta clase
  visitante abstracta declara una operacion @c(VisitarElementoConcreto) para
  cada clase de @c(ElementoConcreto) que define la estructura de objetos. Cada
  operacion @c(Visitar) de @c(Visitante) declara como argumento un
  @c(ElementoConcreto) en particular, permitiendo al @c(Visitante) acceder
  directamente a la interfaz del @c(ElementoConcreto). Las clases
  @c(VisitanteConcreto) redefinen cada operacion @c(Visitar) para implementar el
  comportamiento especifico del visitante para la correspondiente clase
  @c(ElementoConcreto).

  La clase @c(Visitante) se declararia asi en C++:

  ..src > c++
    class Visitante {
    public:
        virtual void VisitarElementoA(ElementoA*);
        virtual void VisitarElementoB(ElementoB*);

        // y asi para otros elementos concretos
    protected:
        Visitante();
    };
  < src..

  Cada clase de @c(ElementoConcreto) implementa una operacion @c(Aceptar) que
  llama a la operacion @c(Visitantar...) del visitante correspondiente a ese
  @c(ElementoConcreto). De modo que la operacion que es llamada al final depende
  tanto de la clase del elemento como de la clase del visitante.@n(53)

  Los elementos concretos se declaran como

  ..src > c++
    class Elemento {
    public:
        virtual ~Elemento();
        virtual void Aceptar(Visitante&) = 0;
    protected:
        Elemento();
    };

    class ElementoA : public Elemento {
    public:
        ElementoA();
        virtual void Aceptar(Visitante& v) { v.VisitarElementoA(this); }
    };

    class ElementoB : public Elemento {
    public:
        ElementoB();
        virtual void Aceptar(Visitante& v) { v.VisitarElementoB(this); }
    };
  < src..

  Una clase @c(ElementoCompuesto) podria implementar @c(Aceptar) como sigue:

  ..src > c++
    class ElementoCompuesto : public Elemento {
    public:
        virtual void Aceptar(Visitante&);
    private:
        Lista<Elemento*>* _hijos;
    };

    void ElementoCompuesto::Aceptar (Visitante& v) {
        IteradorLista<Elemento*> i(_hijos);

        for (i.Primero(); !i.HaTerminado(); i.Siguiente()) {
            i.ElementoActual()->Aceptar(v);
        }
        v.VisitarElementoCompuesto(this);
    }
  < src..

  Estas son otras dos cuestiones de implementacion que surgen al aplicar el
  patron Visitor:

  1. @e(Doble despacho.) El Patron Visitor nos permite añadir operaciones a
     clases sin modificar estas. Esto se logra mediante una tecnica llamada
     @b(doble-despacho), la cual es muy conocida. De hecho, algunos lenguajes de
     programacion la permiten directamente (por ejemplo, CLOS). Otros lenguajes,
     como C++ y Smalltalk, permiten el @b(despacho-unico).

     En lenguajes de despacho-unico, dos son los criterios que determinan que
     operacion satisfara una peticion: el nombre de la peticion y el tipo del
     receptor. Por ejemplo, la operacion a la que llamara una peticion a
     @c(GenerarCodigo) dependera del tipo de objeto nodo al que se le pida. En
     C++, llamar a @c(GeneraCodigo) sobre una instancia de @c(NodoRefVariable)
     llamara a @c(NodoRefvariable::GenerarCodigo) (que genera codigo para una
     referencia a una variable). Llamar a @c(GenerarCodigo) sobre un
     @c(NodoAsignacion) llamara a @c(NodoAsignacion::GenerarCodigo) que generara
     codigo para una asignacion). La operacion que se ejecuta depende tanto del
     tipo del solicitante como del tipo del receptor.

     @"(Doble-despacho) simplemente significa que la operacion que se ejecuta
     depende del tipo del solicitante y de los tipos de @e(dos) receptores.
     @c(Aceptar) es una operacion de doble-despacho. Su significado depende de
     dos tipos: el del @c(Visitante) y el del @c(Elemento). El doble-despacho
     permite a los visitantes solicitar diferentes operaciones en cada clase de
     elemento.@n(54)

     Esta es la clave del patron Visitor: la operacion que se ejecuta depende
     tanto del tipo del @c(Visitante) como del tipo del @c(Elemento)
     visitado. En vez de enlazar las operaciones estaticamente en la interfaz de
     @c(Elemento), podemos fusionar las operaciones en un @c(Visitante) y usar
     @c(Aceptar) para hacer el enlace en tiempo de ejecucion. Extender la
     interfaz de @c(Elemento) consiste en definir una nueva subclase de
     @c(Visitante) en vez de muchas nuevas subclases de @c(Elemento).

  2. @e(¿Quien es el responsable de recorrer la estructura de objetos?) Un
     visitante debe visitar cada elemento de la estructura de objetos. La
     cuestion es, ¿como lo logra? Podemos poner la responsabilidad del recorrido
     en cualquiera de estos tres sitios: en la estructura de objetos, en el
     visitante o en un objeto iterador aparte (vease el patron @l(#Iterator)).

     Muchas veces es la estructura de objetos la responsable de la iteracion.
     Una coleccion simplemente iterara sobre sus elementos, llamando a la
     operacion @c(Aceptar) de cada uno. Un compuesto generalmente se recorrera a
     si mismo haciendo que cada operacion @c(Aceptar) recorra los hijos del
     elemento y llame a @c(Aceptar) sobre cada uno de ellos, recursivamente.

     Otra solucion es usar un iterador para visitar los elementos. En C++,
     podriamos usar un iterador interno o externo, dependiendo de que esta
     disponible y que es mas eficiente. En Smalltalk, normalmente usamos un
     iterador interno mediante @c(do:) y un bloque. Puesto que los iteradores
     internos son implementados por la estructura de objetos, usar un iterador
     interno se parece mucho a hacer que sea la estructura de objetos la
     responsable de la iteracion. La principal diferencia estriba en que un
     iterador interno no provocara un doble-despacho @-(llamara a una operacion
     del @e(visitante) con un @e(elemento) como argumento, frente a llamar a una
     operacion del @e(elemento) con el @e(visitante) como argumento). Pero
     resulta sencillo usar el patron Visitor con un iterador interno si la
     operacion del visitante simplemente llama a la operacion del elemento sin
     recursividad.

     Incluso se podria poner el algoritmo del recorrido en el visitante, si bien
     en ese caso acabariamos duplicando el codigo del recorrido en cada
     @c(VisitanteConcreto) de cada agregado @c(ElementoConcreto). La principal
     razon para poner la estrategia de recorrido en el visitante es implementar
     un recorrido especialmente complejo, que dependa de los resultados de las
     operaciones de la estructura de objetos. En el Codigo de Ejemplo se vera un
     ejemplo para este caso.

*** Visitor Codigo de Ejemplo <> Codigo de Ejemplo

  Como los visitantes suelen asociarse a compuestos, usaremos la clase
  @c(Equipo) que se definio en el Codigo de Ejemplo del patron @l(#Composite)
  para ilustrar el patron Visitor. Usaremos el patron Visitor para definir
  operaciones para realizar el inventario de materiales y calcular el coste
  total de un equipo. Las clases @c(Equipo) son tan sencillas que realmente no
  seria necesario usar el patron Visitor, pero lo haremos asi para mostrar que
  implicaciones conllevan la implementacion de este patron.

  A continuacion se muestra de nuevo la clase @c(Equipo) del @l(#Composite). La
  hemos aumentado con la operacion @c(Aceptar) para que pueda funcionar con un
  visitante.

  ..src > c++
    class Equipo {
    public:
        virtual ~Equipo();

        const char* Nombre() { return _nombre; }

        virtual Vatio Potencia();
        virtual Moneda PrecioNeto();
        virtual Moneda PrecioConDescuento();

        virtual void Aceptar(VisitanteEquipo&);
    protected:
        Equipo(const char*);
    private:
        const char* _nombre;
    };
  < src..

  Las operaciones de @c(Equipo) devuelven los atributos de un equipo, tales como
  su consumo de potencia y su coste. Las subclases redefinen estas operaciones
  de forma apropiada a cada tipo de equipo (por ejemplo, chasis, unidades y
  placas base).

  La clase abstracta para todos los visitantes de equipos tiene una funcion
  virtual para cada subclase de equipo, como se muestra a continuacion. Todas
  las funciones virtuales no hacen nada por omision.

  ..src > c++
    class VisitanteEquipo {
    public:
        virtual ~VisitanteEquipo();

        virtual void VisitarDisquetera(Disquetera*);
        virtual void VisitarTarjeta(Tarjeta*);
        virtual void VisitarChasis(Chasis*);
        virtual void VisitarBus(Bus*);

        // y asi para el resto de subclases concretas de Equipo
    protected:
        VisitanteEquipo();
    };
  < src..

  Las subclases de @c(Equipo) definen @c(Aceptar) basicamente de la misma forma:
  llamando a la operacion de @c(VisitanteEquipo) que se corresponda con la clase
  que recibe la peticion @c(Aceptar), como en:

  ..src > c++
    void Disquetera::Aceptar (VisitanteEquipo& visitante) {
        visitor.VisitarDisquetera(this);
    }
  < src..

  Los equipos que contienen otros equipos (en concreto, las subclases de
  @c(EquipoCompuesto) en el patron @c(Composite)) implementan @c(Aceptar)
  iterando sobre sus hijos y llamando a @c(Aceptar) sobre cada uno de ellos.
  A continuacion llama a la operacion @c(Visitar) como siempre. Por ejemplo,
  @c(Chasis::Aceptar) podria recorrer todas las partes del @c(Chasis) como sigue:

  ..src > c++
    void Chasis::Aceptar (VisitanteEquipo& visitante) {
        for (
            IteradorLista <Equipo*> i(_partes);
            !i.HaTerminado();
            i.Siguiente()
        ) {
            i.ElementoActual()->Aceptar(visitar);
        }
        visitante.VisitarChasis(this);
    }
  < src..

  Las subclases de @c(VisitanteEquipo) definen algoritmos concretos sobre la
  estructura de equipos. El @c(VisitantePrecio) calcula el coste de la
  estructura de equipos, calculando el precio neto de todos los equipos simples
  (por ejemplo, las disqueteras) y el precio con descuento de todos los equipos
  compuestos (como los chasis y buses).

  ..src > c++
    class VisitantePrecio : public VisitanteEquipo {
    public:
        VisitantePrecio();

        Moneda& ObtenerPrecioTotal();

        virtual void VisitarDisquetera(Disquetera*);
        virtual void VisitarTarjeta(Tarjeta*);
        virtual void VisitarChasis(Chasis*);
        virtual void VisitarBus(Bus*);
        // ...
    private:
        Moneda _total;
    };

    void VisitantePrecio::VisitarDisquetera (Disquetera* e) {
        _total += e->PrecioNeto();
    }

    void VisitantePrecio::VisitarChasis (Chasis* e) {
        _total += e->PrecioConDescuento();
    }
  < src..

  @c(VisitantePrecio) calculara el coste total de todos los nodos de la
  estructura de equipos. Notese que @c(VisitantePrecio) elige la politica de
  precios apropiada para una clase de equipo despachando a la correspondiente
  funcion miembro. Y lo que es mas, podemos cambiar la politica de precios de
  una estructura de equipo simplemente cambiando la clase @c(VisitantePrecio).

  Podemos definir un visitante para realizar un inventario como sigue:

  ..src > c++
    class VisitanteInventario : public VisitanteEquipo {
    public:
        VisitanteInventario();

        Inventario& ObtenerInventario();

        virtual void VisitarDisquetera(Disquetera*);
        virtual void VisitarTarjeta(Tarjeta*);
        virtual void VisitarChasis(Chasis*);
        virtual void VisitarBus(Bus*);
        // ...

    private:
        Inventario _inventario;
    };
  < src..

  El @c(VisitanteInvertario) acumula los totales de cada tipo de equipo de la
  estructura de objetos. @c(VisitanteInventario) usa una clase @c(Inventario)
  que define una interfaz para añadir equipamiento (que no nos molestaremos en
  definir aqui).

  ..src > c++
    void VisitanteInventario::VisitarDisquetera (Disquetera* e) {
        _inventario.Acumular(e);
    }

    void VisitanteInventario::VisitarChasis (Chasis* e) {
        _inventario.Acumular(e);
    }
  < src..

  Asi es como podemos usar un @c(VisitanteInventario) en una estructura de
  equipos:

  ..src > c++
    Equipo* componente;
    VisitanteInventario visitante;

    componente->Aceptar(visitor);
    cout << "Inventario "
         << componente->Nombre()
         << visitante.ObtenerInventario();
  < src..

  Ahora veremos como implementar el ejemplo de Smalltalk del patron Interpreter
  (vease su respectiva seccion @l(#Interpreter Codigo de Ejemplo<>Codigo de
  Ejemplo)) con el patron Visitor. Como en el ejemplo anterior, este es tan
  pequeo que el Visitante probablemente no nos aporte gran cosa, pero
  proporciona un buen ejemplo de como usar el patron. Ademas, muestra una
  situacion en la que la interacion es responsabilidad del visisitante.

  La estructura de objetos (expresiones regulares) se compone de cuatro clases,
  y todas ellas tienen un metodo @c(aceptar:) que toma un visitante como
  argumento. En la clase @c(ExpresionSecuencia), el metodo @c(aceptar:) se
  define como

  ..src > smalltalk
    aceptar: unVisitante
         ^ unVisitante visitarSecuencia: self
  < src..

  En la clase @c(ExpresionRepetir), el metodo @c(aceptar:) envia el mensaje
  @c(visitarRepetir:). En la clase @c(ExpresionAlternativa), envia el mensaje
  @c(visitarAlternativa:). En la clase @c(ExpresionLiteral), envia el mensaje
  @c(visitarLiteral:)

  Las cuatro clases tambien deben tener funciones de acceso que pueda usar el
  visitante. Para @c(ExpresionSecuencia) estas son @c(expresion1) y
  @c(expresion2); para @c(ExpresionAlternativa) son @c(altertaniva1) y
  @c(alternativa2); para @c(ExpresionRepetir) es su @c(repeticion); y para
  @c(ExpresionLiteral) sus @c(compontentes).

  La clase @c(VisitanteConcreto) es @c(VisitanteReconocedorER). Es la
  responsable del recorrido porque su algoritmo de recorrido es irregular. La
  mayor irregularidad es que una @c(ExpresionRepetir) recorrera repetidamente su
  componente. La clase @c(VisitanteReconocedorER) tiene una variable de instancia
  @c(estadoEntrada). Sus metodos son, en esencia, los mismos que los metodos
  @c(reconocer:) de las clases de expresiones del patron Interpreter, salvo que
  estas sustituyen el argumento llamado @c(estadoEntrada) por el nodo con la
  expresion que esta siendo reconocida. En cualquier caso, siguen devolviendo el
  conjunto de flujos que puede reconocer la expresion para indentificar el
  estado actual.

  ..src > smalltalk
    vistiarSecuencia: expSecuencia
         estadoEntrada := expSecuencia expresion1 aceptar: self.
         ^ expSecuencia expresion2 aceptar: self.

    visitarRepetir: expRepetir
         | estadoFinal |
         estadoFinal := estadoEntrada copy.
         [estadoEntrada isEmpty]
             whileFalse:
                 [estadoEntrada := expRepetir repeticion aceptar: self.
                  estadoFinal addAll: estadoEntrada].
         ^ estadoFinal

    visitarAlternativa: expAlternativa
         | estadoFinal estadoOriginal |
         estadoOriginal := estadoEntrada.
         estadoFinal := expAlternativa alternativa1 aceptar: self.
         estadoEntrada := estadoOriginal.
         estadoFinal addAll: (expAlternativa alternativa2 aceptar: self).
         ^ estadoFinal

    visitarLiteral1: expLiteral1
         | estadoFinal tStream |
         estadoFinal := Set new.
         estadoEntrada
             do:
                 [:stream | tStream := stream copy.
                      (tStream nextAvailable:
                          expLiteral componentes size
                      ) = expLiteral componentes
                          ifTrue: [estadoFinal add: tStream]
                 ].
         ^ estadoFinal
  < src..

*** Visitor Usos Conocidos <> Usos Conocidos

  El compilador Smalltalk-80 tiene una clase Visitante llamada
  @c(ProgramNodeEnumerator). Se usa sobre todo para los algoritmos que analizan
  el codigo fuente. No se usa para generacion de codigo o impresion con formato,
  aunque se podria.

  IRIS Inventor [@l(#Str93)] es un toolkit para desarrollar aplicaciones graficas en
  3-D. Inventor representa una escena tridimensional como una jerarquia de
  nodos, cada uno de los cuales representa o bien un objeto geometrico o bien
  uno de sus atributos. Operaciones como mostrar una escena o establecer una
  accion para un evento de entrada necesitan recorrer esta estructura de varias
  formas. Inventor lleva a cabo esto usando visitantes llamados
  @"(acciones). Hay diferentes visitantes para la visualizacion, el manejo de
  eventos, la busqueda, guardar en ficheros o determinar las cajas limitrofes.

  Para facilitar la adicion de nuevos nodos, @c(Inventor) implementa un esquema
  de doble-despacho en C++. Este esquema se basa en la informacion de tipos en
  tiempo de ejecucion y en una tabla bidimencional en la que las filas
  representan visitantes y las columnas clases de nodos. Las casillas guardan un
  puntero a la funcion asignada a esas clases de visitante y nodo.

  Mark Linton acuño el termino @"(Visitor) en la especificacion de Fresco
  Application Toolkit, de X Consortium [@l(#LP93)].

*** Visitor Patrones Relacionados <> Patrones Relacionados

  @l(#Composite): los visitantes pueden usarse para aplicar una operacion sobre
  una estructura de objetos definida por el patron Composite.

  @l(#Interpreter): se puede aplicar el patron Visitor para llevar a cabo la
  interpretacion.

** Discusion sobre los patrones de comportamiento
*** Encapsular lo que varia

  Encapsular aquello que puede variar es el tema de muchos patrones de
  comportamiento. Cuando un determinado aspecto de un programa cambia con
  frecuenca, estos patrones definen un objeto que encapsula dicho aspecto. De
  esa manera, otras partes del programa pueden colaborar con el objeto siempre
  que dependan de ese aspecto. Los patrones normalmente definen una clase
  abstracta que describe el objeto encapsulado, y el patron toma su nombre de
  ese objeto.@n(55) Por ejemplo,

  - un objeto @l(#Strategy<>Estrategia) encapsula un algoritmo,
  - un objeto @l(#State<>Estado) encapsula un comportamiento dependiente del estado,
  - un objeto @l(#Mediator<>Mediador) encapsula el protocolo entre objetos, y
  - un objeto @l(#Iterator<>Iterador) encpasula el modo en que se accede y se
    recorren los componentes de un objeto agregado.

  Estos patrones describen aspectos de un programa que es probable que cambien.
  La mayoria de los patrones tienen dos tiepos de objetos: el nuevo objeto que
  encapsula el aspecto y el objeto existente que usa el nuevo objeto
  creado. Normalmente, si no fuera por el patron, la funcionalidad de los nuevos
  objetos seria una parte integral de los existentes. Por ejemplo, el codigo de
  una Estrategia probablemente estaria ligado al Contexto de la estrategia, y el
  codigo de un Estado se encontraria implementado directamente en el Contexto
  del estado.

  Pero no todos los patrones de comportamiento de objetos dividen asi la
  funcionalidad. Por ejemplo, el patron @l(#Chain of Responsibility) trata con
  un numero indeterminado de objetos (una cadena), cada uno de los cuales puede
  que ya exista en el sistema.

  El patron Chain of Responsibility muestra otra diferencia entre los patrones
  de comportamiento: no todos definen relaciones de comunicacion estaticas entre
  las clases. El patron Chain of Responsibility describe el modo de comunicacion
  entre un numero indefinido de objetos. Otros patrones usan objetos que pasan
  como argumentos.

*** Objetos como argumentos

  Varios patrones introducen un objeto que siempre se usa como argumento. Uno de
  ellos es el @l(#Visitor). Un objeto Visitante es el argumento de una operacion
  polimorfica @c(Aceptar) del objeto que visita. El visitante nunca se considera
  parte de estos objetos, incluso aunque la alternativa convencional al patron
  consiste en distribuir el codigo del Visitante entre las clases de la
  estructura de objetos.

  Otros patrones definen objetos que actuan como elementos magicos que se pasan
  de una lado a otro y que mas tarde pueden ser invocados. Tanto el patron
  @l(#Command) como el @l(#Memento) entran en esta categoria. En el Command, el
  elemento representa una peticion; en el Memento, representa el estado interno
  de un objeto en un momento concreto. En ambos casos, el elemento puede tener
  una representacion interna compleja, pero los clientes nunca llegan a
  percibirla. No obstante, incluso aqui hay diferencias. El polimorfismo es
  importante en el patron Command, ya que ejecutar el objeto @c(Orden) es una
  operacion palimorfica. Por el contrario, la interfaz del Memento es tan
  limitada que este solo puede pasarse como un valor. Por tanto, es plobable que
  no presente ninguna operacion polimorfica a sus clientes.

*** La comunicacion, ¿Deberia estar encapsulada o distribuida?

  El @l(#Mediator) y el @l(#Observer) son patrones rivales. La diferencia entre
  ellos es que el patron Observer distribuye la comunicacion introduciendo
  objetos Observador y Sujeto, mientras que un objeto Mediador encapsula la
  comunicacion entre objetos.

  En el patron Observer, no hay ningun objeto individual que encapsule una
  restriccion. En ves de eso, el Observador y el Sujeto deben cooperar para
  mantener  la restriccion. Los patrones de comunicacion se determinan por el
  modo en que se interconectan los observadores y los sujetos: un sujeto
  individual normalmente tiene muchos observadores, y a veces el observador de
  un sujeto es un sujeto de otro observador. El patron Mediator centraliza mas
  que distribuye, ubicando en el mediador la responsabilidad de mantener la
  restriccion.

  Hemos descubierto que es mas facil hacer Observaciones y Sujetos reutilizables
  que hacer Mediadores reutilizables. El patron Observer promueve la separacion y
  bajo acoplamiento entre el Observador y el Sujeto, lo que conduce a clases de
  grano mas fino que son mas aptas para ser reutilizadas.

  Por otro lado, es mas facil entender el flujo de comunicacion en el Mediator
  que en el Observer. Los observadores y sujetos suelen conectarse nada mas
  crearse, y es dificil ver mas tarde en el programa como estan conectados. Si
  conocemos el patron Observer, debemos entender que el modo en que se conectan
  los observadores y los sujetos es importante, y tambien sabremos que
  conexiones buscar. Sin embargo, la indireccion introducida por este patron
  sigue haciendo que el sistema sea dificil de entender.

  Los observadores pueden parametrizarse en Smalltalk con mensajes para acceder
  al estado del sujeto, lo que los hace mas reutilizables de lo que son en
  C++. Esto hace que en Smalltalk sea mas atractivo el Observer que el
  mediator. De hay que un programador de Smalltalk generalmente use el Observer
  donde un programador de C++ usaria un Mediator.

*** Desacoplar emisores y receptores

  Cuando los objetos que colaboran se refieren unos a otros explicitamente, se
  vuelven dependientes unos de otros, y eso puede tener un impacto adverso sobre
  la division en capas y la reutilizacion de un sistema. Los patrones Command,
  Observer, Mediator y Chain of Responsibility tratan el problema de como
  desacoplar emisores y receptores, cada uno con sus ventajas e inconvenientes.

  El patron Command permite el desacoplamiento usando un objeto Orden que define
  un enlace entre un emisor y un repceptor:

  ..img > img/unknow1.png

  El objeto @c(Orden) proporciona una interfaz simple para emitir la peticion
  (es decir, la operacion @c(Ejecutar)). Definir la conexion emisor-receptor en
  un objeto aparte permite que el emisor funcione con diferentes receptores.
  Gracias a mantener al emisor desacoplado de los receptores es mas facil
  reutilizar los emisores. Mas aun, es posible reutilizar el objeto Orden para
  parametrizar un receptor con diferentes emisores. El patron Command necesita
  que haya una subclase por cada conexion emisor-receptor, si bien el patron
  describe tecnicas de implementacion que evitan la herencia.

  El patron Observer desacopla los emisores (sujetos) de los receptores
  (observadores) definiendo una interfaz para indicar cambios en los sujetos.
  Observer define un enlace mas debil que Command entre el emisor y el receptor,
  ya que un sujeto puede tener multiples observadores, cuyo numero puede variar
  en tiempo de ejecucion.

  ..img > img/unknow2.png

  Las interfaces Sujeto y Observador del patron Observer estan diseñadas para
  posibles cambios en la comunicacion. Por tanto, el patron Observer es mejor
  para desacoplar objetos cuando hay dependencias de datos entre ellos.

  El patron mediator desacopla los objetos haciendo que se refieran unos a otros
  indirectamente, a traves del objeto Mediador.

  ..img > img/unknow3.png

  Un objeto @c(Mediador) encamina peticiones entre objetos @c(Colega), y
  centraliza su comunicacion. En consecuencia, los colegas solo pueden hablar
  entre si a traves de la interfaz del @c(Mediador). Dado que dicha interfaz es
  fija, el @c(Mediador) podria tener que implementar su propio mecanismo de despacho
  para una flexibilidad añadida. Las peticiones pueden ser codificadas junto con
  sus argumentos de tal forma que los compañeros pueden solicitar un conjunto de
  peticiones ilimitado.

  El patron Mediator puede reducir la herencia en un sistema, al centralizar el
  comportamiento de comunicacion en una clase en vez de distribuirlo entre las
  subclases. Sin embargo, los esquemas de despacho @e(ad hoc) suelen disminuir
  la seguridad de tipos.

  Por ultimo, el patron Chain Of Responsibility desacobla al emisor del
  receptor pasando la peticion a lo largo de una cadena de receptores
  potenciales:

  ..img > img/unknow4.png

  Puesto que la interfaz entre emisores y receptores es fija, la Cadena de
  Responsabilidad tambien puede requerir un esquema de despacho personalizado.
  Por tanto, tiene los mismo inconvenientes de seguridad de tipos que el
  mediator. La Cadena de Responsabilidad es un buen modo de desacoplar el emisor
  y el receptor en caso de que la cadena ya forme parte de la estructura del
  sistema y haya uno o varios objetos capaces de manejar la peticion. Y es mas,
  el patron ofrece una flexibilidad añadida en el sentido de que la cadena puede
  cambiarse o ampliarse facilmente.

*** Resumen

  Con unas pocas excepciones, los patrones de diseño de comportamiento se
  complementan y se refuerzan entre si. Una clase de una cadena de
  responsabilidad, por ejemplo, probablemente incluya almenos una aplicacion del
  patron @l(#Template Method). El metodo de plantilla puede usar operaciones
  primitivas para determinar si el objeto deberia manejar la peticion y para
  elegir el objeto al cual reenviarla. La cadena puede usar el patron Command
  para representar peticiones como objetos. El @l(#Interpreter) puede usar el
  patron State para definir contexto para el analisis. Un iterador puede
  recorrer un agregado, y un visitante puede aplicar una operacion a cada
  elemento del agregado.

  Los patrones de comportamiento funcionan bien con otros patrones tambien. Por
  ejemplo, un sistema que usa el patron @l(#Composite) podria usar un visitante
  para realizar operaciones sobre los componentes de la composicion. Podria usar
  una cadena de responsabilidad para que los componentes puedan acceder a las
  propiedades globales a traves de su padre. Tambien podrian usar el
  @l(#Decorator) para redefinir estas propiodades sobre partes de la
  composicion. O el patron Observer para ligar una estructura a la otra, y el
  patron State para que un componente pueda cambiar su comportamiento cuando
  cambia su estado. La propia composicion podria ser creada usando el enfoque del
  patron @l(#Builder) y se podria tratar como un @l(#Prototype) por otras partes
  del sistema.

  Los sistemas orientados a objetos bien diseñados no son mas que eso @-(tienen
  multiples patrones incrustados en ellos), pero no necesariamente porque sus
  diseñadores los hayan pensado en esos terminos. La composicion de @e(patrones)
  en vez de la de clases nos permite lograr la misma sinergia mas facilmente.

* Capitulo 6 <> Conclusion

  Es posible argüir que este libro no ha logrado gran cosa. Despues de todo, no
  presenta ningun algoritmo o tecnica de programacion que no se haya usado
  anteriormente. Tampoco proporciona un metodo riguroso para el diseño de
  sistemas, ni desarrolla una nueva teoria de diseño @-(simplemente, documenta
  diseños existentes). Podria concluirse, tal vez, que es una razonable guia de
  aprendizaje, pero que ciertamente no ofrece gran cosa a un diseñador orientado
  a objetos experimentado.

  Esperamos que no piense asi. Catalogar los patrones de diseño es importante.
  Nos da nombres y definiciones estadar de las tecnicas que usamos. Si no
  estudiaramos los patrones de diseño de software no podriamos mejorarlos, y
  seria dificil presentar otros nuevos.

  Este libro es solo un comienzo. Contiene algunos de los patrones de diseño mas
  comunes que utilizan los diseñadores orientados a objetos, y que sin embargo
  la gente conoce y aprende solo de oidas o estudiando los sistemas existentes.
  Las versiones preliminares del libro indujeron a otra gente a anotar los
  patrones de diseño que usaban, y todavia deberia inducir mas a ello en su
  nueva forma. Esperamos que esto marque el principio de un movimento de
  documentacion de la experiencia de los profecionales del software.

  Este capitulo discute el impacto que creemos que tendran los patrones de
  diseño, como se relacionan con otros trabajos de diseño y como puede uno
  involucrarse en la tarea de encontrar y catalogar patrones.

** 6.1 <> Que esperar de los patrones de diseño

  los patrones de diseño de este libro pueden afectar de varias formas el modo
  en que diseñamos software orientado a objetos, basandonos en nuestra
  experiencia diaria con ellos.

*** Un vocabulario de diseño comun

  Los estudios de programadores expertos de lenguajes convencionales muestran
  que el conocimiento y la experiencia no se organizan simplemente en torno a la
  sintaxis, sino en estructuras conceptuales mayores, tales como algoritmos,
  estructuras de datos y modismos [@l(#AS85), @l(#Cop92), @l(#SS86)], asi como
  en maneras de lograr un determinado objetivo [@l(#SE84)]. Los diseñadores
  probablemente no piensan en la notacion que estan usando para documentar su
  diseño, sino que intentan comparar la situacion actual de diseño con planos,
  algoritmos, estructuras de datos y modismos que han aprendido en el pasado.

  Los informaticos nominan y catalogan las estructuras de datos y algoritmos,
  pero no suelen dar nombre a otros tipos de patrones. Los patrones de diseño
  proporcionan un vocabulario comun que los diseñadores usan para comunicar,
  documentar y explorar alternativas de diseño. Los patrones de diseño hacen que
  un sistema parezca menos complejo, permitiendonos hablar de el con un mayor
  nivel de abstraccion del que permite una notacion de diseño o un lenguaje de
  programacion. Los patrones de diseño elevan el nivel en el que diseñamos y
  discutimos diseños con nuestros colegas.

  Una vez que haya absorbido los patrones de diseño de este libro, su
  vocabulario de diseño cambiara casi con toda seguridad. Hablara directamente
  en terminos de los nombres de los patronesde diseño. Se oira asi mismo decir
  cosas como @"(aqui deberiamos usar el patron Observer), o @"(extraigamos una
  estrategia de estas clases).

*** Una ayuda para la documentacion y el aprendizaje

  Conocer los patrones de diseño de este libro facilita la comprension de los
  sistemas existentes. La mayoria de los grandes sistemas orientados a objetos
  usan estos patrones de diseño. Las personas que aprenden programacion
  orientada a objetos a menudo se quejan de que los sistemas con los que estan
  trabajando utilizan la herencia de formas enrevesadas, y que es dificil seguir
  el flujo de control. En gran parte esto se debe a que no comprenden los
  patrones de diseño del sistema. Aprender estos patrones de diseño le ayudara a
  compreder los sistemas software existentes.

  Estos patrones de diseño tambien pueden convertirle en un diseñador mejor. Si
  trabaja con sistemas orientados a objetos lo suficientemente grandes,
  probablemente aprenda estos patrones por si mismo. Pero leer el libro le
  ayudara a aprender mucho mas deprisa. Aprender estos patrones ayudara a un
  novato a comportarse mas como un experto.

  Mas aun, describir un sistema en terminos de los patrones que usa hara que
  este sea mucho mas facil de entender. De otro modo, la gente tendra que hacer
  ingerieria inversa sobre el diseño para descubrir los patrones que usa. Tener
  un vocabulario comun significa que no tenemos que describir el patron de
  diseño entero; podemos simplemente nombrarlo y confiar en que quien lo lea lo
  conozca. Un lector que no conoce los patrones tendra que buscarlos en primer
  lugar, pero eso sigue siendo mas facil que hacer ingenieria inversa.

  Nosotros usamos estos patrones en nuestros propios diseños y pensamos que
  tienen un valor incalculable. No obstante, usamos los patrones de forma
  simplista y discutible. Los usamos para elegir nombres para las clases, para
  pensar en un buen diseño y enseñarlo, y para describir diseños en terminos de
  la secuencia de patrones que hemos aplicado [@l(#BJ94)]. Es facil imaginarse
  formas mas sofisticadas de usar los patrones, como herramientas CASE o
  documentos hipertexto basados en patrones. Pero los patrones son una gran
  ayuda incluso sin herramientas sofisticadas.

*** Un complemento de los metodos existentes

  Los metodos de diseño orientado a objetos estan pensados para promover el buen
  diseño, para enseñar a los nuevos diseñadores como diseñar bien y para
  estandarizar el modo en que se desarrollan los diseños. Un metedo de diseño
  generalmente define un conjunto de notaciones (normalemente graficas) para
  modelar varios aspectos de un diseño, junto con un conjunto de reglas que
  gobiernan como y cuando usar cada notacion. Los metodos de diseño normalmente
  describen los problemas que tienen lugar en un diseño, como resolverlos y como
  evaluar el diseño. Pero se han mostrado incapaces de representar la experienca
  de los diseñadores expertos.

  Creemos que nuestros patrones de diseño son una muestra importante de lo que
  hemos estado echando de menos en los metodos de diseño. Los patrones de diseño
  muestran como usar tecnicas primitivas como objetos, herencia y polimorfismo.
  Muestran como parametrizar un sistema con un algoritmo, un comportamiento, un
  estado o con la base de objetos que debe crear. Los patrones de diseño
  proporcionan una forma de describir mejor @"(el porque) de un diseño, en vez
  de limitarse a registrar los resultados de nuestras decisiones. Las secciones
  de Aplicabilidad, Consecuencias e Implementacion de los patrones de diseño le
  ayudaran en las decisiones que tenga que tomar.

  Los patrones de diseño son especialmente utiles a la hora de pasar de un
  modelo de analisis a un modelo de implementacion. A pesar de que muchas
  afirmaciones prometen una suave transicion del analisis orientado a objetos al
  diseño, en la practica la transicion es cualquier cosa menos suave. Un diseño
  flexible y reutilizable contendra objetos que no estan en el modelo de
  analisis. El lenguaje de programacion y las bibliotecas de clases utilizados
  afectan al diseño. Los modelos de analisis muchas veces deben ser rediseñados
  para hacerlos mas reutilizables. Muchos de los patrones de diseño del catalogo
  se enfrentan a estos problemas, mootivo por el que los denominamos patrones
  @e(de diseño).

  Un metodo de diseño complejo necesita patrones de mas tipos que los de
  diseño. Tambien puede haber patrones de analisis, patrones de diseño de
  interfaces de usuario o patrones de ajuste del rendimiento. Pero los patrones
  de diseño son una parte esencial, que ha sido obviada hasta ahora.

*** Un objetivo para la refactorizacion

  Uno de los problemas del desarrollo de software reutilizable es que a menudo
  tiene que ser reorganizado o refactorizado [@l(#OJ90)]. Los patrones de diseño
  ayudan a determinar como reorganizar un diseño, y pueden reducir la cantidad
  de refactorizacion que es necesario hacer luego.

  El ciclo de vida del software orientado a objetos tiene varias fases. Brian
  Foote identifica estas como las fases de protipado, expansion y consolidacion
  [@l(#Foo92)].

  La fase de prototipado es una oleada de actividad en la que el software ve la
  luz a traves del prototipado rapido y de los cambios incrementales, hasta que
  se descubren un conjunto de requisitos iniciales y alcanza la adolescencia. En
  este punto, el software normalmente consiste en jerarquias de clases que
  reflejan fielmente las entidades del dominio del problema inicial. El
  principal tipo de reutilizacion es de caja blanca mediante la herencia.

  Una vez que el software ha alcanzado su adolescencia y se pone en servicio, su
  evolucion esta gobernada por dos necesidades contradictorias: (1) el software
  debe satisfacer mas requisitos, y (2) el software debe ser mas reutilizable.
  Nuevos requisitos añaden nuevas clases y operaciones, y tal vez jerarquias de
  clases completas. El software cambia hacia una fase de expansion para
  descubrir nuevos requisitos. Esto, no obstante, no puede continuar durante
  largo tiempo. Al final el software se volvera demasiado inflexible para
  permitir mas cambios. Las jerarquias de clases ya no se corresponderan con
  ningun dominio de problema. En vez de eso, reflejaran muchos dominios de
  problemas, y las clases definiran muchas operaciones y variables de instancia sin
  relacion entre si.

  Para seguir evolucionando, el software debe ser reorganizado en un proceso
  conocido como @b(refactorizacion). Esta es la fase en la que suelen aparecer
  los frameworks. Refactorizar implica desbrozar las clases en componetes de
  proposito general y especial, moviendo operaciones hacia arriba y hacia abajo
  en la jeraquia de clases, y racionalizando las interfaces de las clases. Esta
  fase de consolidacion produce muchos nuevo tipos de objetos, a menudo mediante
  descomposicion de los objetos existentes, y usando composicion de objetos en
  vez de la herencia. Por tanto, la reutilizacion de caja negra sustituye a la
  de caja blanca. La necesidad constante de satisfacer mas requisitos, junto con
  la necesidad de mas reutilizacion lleva al software orientado a objetos a
  travez de repetidas faces de expansion y consolidacion @-(expansion a medida
  que se satisfacen nuevos requsitios, y consolidacion a medida que el software
  se vuelve mas general).

  ..img > img/sciclo.png

  Este ciclo es inevitable. Pero los buenos diseñadores estan pendientes de los
  cambios que pueden dar lugar a refactorizaciones. Los buenos diseñadores
  tambien conocen estructuras de clases y objetos que pueden ayudarles a eviar
  refactorizaciones @-(sus diseños son mas robustos frente a los cambios de
  requsitos). Un analisas de requisitos concienzudo pondra de manifiesto
  aquellos requisitos que es probable que cambien durante la vida del software,
  y un buen diseño sera robusto frente a dichos cambios.

  Nuestros patrones de diseño reflejan muchas de las estructuras que resultan de
  la refactorizacion. Usando estos patrones en las faces tempranas del diseño se
  previenen posteriores refactorizaciones. Pero incluso aunque no veamos como
  aplicar un patron hasta que hayamos construido nuestrro sistema, el patron
  todavia puede mostrarnos como cambiarlo. Los patrones de diseño nos
  proporcionan asi objetivos para nuestras refactorizaciones.

** 6.2 <> Una breve historia

  El catalogo comenzo como parte de la tesis doctoral de Erich [@l(#Gam91),
  @l(#Gam92)]. Cerca de la mitad de los patrones actuales estaban en su
  tesis. Para el OOPSLA '91 habia oficialmente un catalogo independiente, y
  Richard se unio a Erich para trabajar en el. John comenzo a trabajar en el
  enseguida. Para el OOPSLA '92, Ralph se habia unido al grupo. Trabajo duro
  para ajustar el catalogo para su publicacion en ECOOP '93, pero pronto nos
  dimos cuenta de que un articulo de 90 paginas no iba a ser aceptado. De modo
  que resumimos el catalogo y enviamos el resumen, que fue aceptado. Al poco,
  decidimos convertir el catalogo en un libro.

  Nuestron nombres de los patrones han cambiado algo desde entonces. @"(Wrapper)
  (envoltorio) se convirtio en @"(Decorator) (decorador), @"(Glue) (pegamento)
  se convirtio en @"(Facade) (fachada), @"(Solitaire) (solitario) en
  @"(Singleton) (unico), y @"(Walker) (caminante) en @"(Visitor) (visitante). Se
  quitaron un par de patrones porque no parecian lo suficientemente
  importantes. Pero, aparte de eso, el conjunto de patrones del catalogo ha
  cambiado poco desde finales de 1992. Los patrones en si, no obstante, han
  evolucionado tremendamente.

  De hecho, darse cuenta de que algo es un patron es la parte facil. Todos
  nosotros trabajamos de forma activa en la construccion de sistemas orientados
  a objetos, y hemos descubierto que es facil reconocer a los patrones cuando se
  miran bastastes sistemas. Pero @e(encontrar) patrones es mucho mas facil que
  @e(describirlos).

  Si construye sistemas y a continuacion reflexiona sobre lo que ha construido,
  vera patrones en lo que hace. Pero es dificil describir los patrones para que
  otra gente que no los conoce los compreda y se de cuenta de por que son
  importantes. Los expertos reconocieron inmediatamente el valor del catalogo en
  sus etapas iniciales. Pero los unicos que podrian entneder los patrones eran
  aquellos que ya los habian usado.

  Puesto que uno de los principales propositos del libro era enseñar diseño
  orientado a objetos a los nuevos diseñadores, sabiamos que teniamos que
  mejorar el catalogo. Ampliamos el tamaño medio de un patron de menos de 2 a
  mas de 10 paginas, incluyendo un detallado ejemplo de motivacion y codigo de
  ejemplo. Tambien comenzamos a examinar las ventajas e inconvenientes y las
  distintas formas de implementar el patron. Esto hizo que los patrones fuesen
  mas faciles de entender.

  Otro cambio importante del ultimo año ha sido dar mas importancia al problema
  que es resuelto por un patron. Lo mas facil es ver un patron como una solucion,
  como una tecnica que puede adaptarse y reutilizarse. Es mas dificil ver cuando
  resulta @e(apropiado) @-(caracterizar los problemas que resuelve y el contexto
  en el que constituye la mejor solucion). En general, es mas facil ver @e(que)
  hace algo que saber @e(por que), y el @"(porque) de un patron es el problema
  que resuelve. Conocer el proposito de un patron tambien es importante, porque
  nos ayuda a elegir los patrones a aplicar. El autor de un patron debe
  establecer y caracterizar el problema que resuelve el patron, incluso aunque
  tenga que hacelo despues de haber descubierto la solucion.

** 6.3 <> La comunidad de patrones

  Nosotros no somos los unicos interesados en escribir libros que cataloguen los
  patrones que utilizan los expertos. Formamos parte de una comunidad mayor
  interesada en los patrones en general, y en los patrones de software en
  particular. Christopher Alexander es el arquitecto que primero estudio los
  patrones en los edificios y comunidades y que desarrollo un @"(lenguaje de
  patrones) para generarlos. Su trabajo nos ha inspirado una y otra vez. Por
  tanto, es adecuado y merece la pena comparar su trabajo con el nuestro. A
  continuacion veremos el trabajo de otros en patrones de software.

*** Los lenguajes de patrones de Alexander

  Nuestro trabajo se parece al de Alexander en muchos aspectos. Ambos estan
  basados en observar los sistemas existentes y buscar patrones en ellos. Ambos
  tienen plantillas para describir patrones (si bien nuestras plantillas son
  bastante diferentes). Ambos se basan en el lenguaje natural y en montones de
  ejemplos para describir los patrones, en vez de en lenguajes formales, y ambos
  dan las razones de cada patron.

  Pero hay otros muchos aspectos en los que nuestros trabajos difieren:

  1. La gente ha estado haciendo casas durante miles de años, y hay muchos
     ejemplos clasicos a los que acudir. Hemos estado haciendo software durante
     un periodo de tiempo relativamente corto, y hay pocos que puedan
     considerarse clasicos.

  2. Alexander da un orden en el que deberian utilizarse sus patrones; nosotros no.

  3. Los patrones de Alexander hacen hincapie en el problema que solucionan,
     mientras que los patrones de diseño describen con mas detalle la solucion.

  4. Alexander afirma que sus patrones generan edificios completos. nosotros no
     afirmamos que nuestros programas generaran programas completos.

  Cuando Alexander afirma que se puede diseñar una casa simplemente aplicando
  sus patrones uno detras de otro, tiene metas similares a las de esos
  metodologos del diseño orientado a objeto que dan recetas de diseño. Alexander
  no niega la necesidad de la creatividad; algunos de sus patrones requieren
  compreder los habitos de vida de la gente que usara las casas, y su creencia
  en la @"(poesia) del diseño implica un nivel de experienca mas alla del
  lenguaje de patrones en si.@n(56) Pero su descripcion de como los patrones
  generan diseño implica que un lenguaje de patrones puede hacer que el proceso
  de diseño sea determinista y repetible.

  El punto de vista de Alexander nos ha ayudado a centrarnos en las ventajas e
  inconvenientes de los diseños @-(las diferentes @"(fuerzas) que ayudan a dar
  forma a un diseño). Su influencia nos hizo trabajar mas duro para compreder la
  aplicabilidad y consecuencias de nuestros patrones. Tambien evito que nos
  preocuparamos de definir una representacion formal para los patrones. Aunque
  dicha representacion podria hacer posible automatizar los patrones, en este
  punto es mas importante explorar el espacio de los patrones de diseño que
  formalizarlo.

  Desde el punto de vista de Alexander, los patrones de este libro no
  constituyen un lenguaje. Dada la gran cantidad de sitemas software que se
  construyen, es dificil imaginarse como podriamos proporcionar un conjunto
  @"(completo) de patrones, que ofreciese instrucciones paso a paso para diseñar
  una plicacion. Podemos hacerlo para ciertas clases de aplicaciones, tales com
  escribir informes o hacer un sistema de entrada de formularios. Pero nuestro
  catalogo tan solo es una coleccion de patrones relacionados; no podemos
  pretender que sea un lenguaje de patrones.

  De hecho, pensamos que es poco probable que haya @e(nunca) un lenguaje de
  patrones completo para el software. No obstante, es ciertamente posible hacer
  uno que sea @e(mas) completo. Se podrian haber añadido los frameworks y como
  usarlos [@l(#Joh92)], patrones para el diseño de interfaces de usuario [@l(#BJ94)],
  patrones de analisis [@l(#Coa92)] y todos los otros aspectos del desarrollo de
  software. Los patrones de diseño no son solo una parte de un lenguaje mayor de
  patrones de software.

*** Patrones De Software

  Nuestra primer experiencia colectiva en el estudio de la arquitectura del
  software fue en un taller de OOPSLA '91 conducido por Bruce Anderson. El
  taller estaba dedicado a desarrollar un manual para arquitectos de software (a
  juzgar por este libro, sospechamos que @"(enciclopedia de arqutectura) seria
  un nombre mas apropiado que @"(manual de arquitectura)). Ese primer taller
  llevo a una serie de encuentros, el mas reciente de los cuales fue la primera
  conferencia en Lenguajes de Patrones de Programas @%e(Pattern Languages of
  Programs) celebrada en agosto de 1994. Esto ha creado una comunidad de
  personas interesadas en documentar la experienca en el software

  Por supuesto, otros ya habian tenido este objetivo. El @e(The Art of Computer
  Programming) de Donald Knuth [@l(#Knu73)] fue uno de los primeros intentos de
  catalogar el conocimiento en el software, aunque el se centro en describir
  algoritmos. Incluso asi, la tarea se evidencio demasiado grande como para ser
  terminada. Las series de @e(Graphics Gems) [@l(#Gla90), @l(#Arv91),
  @l(#Kir92)] son otro catalogo de conocimiento de diseño, anuque tamben tiende
  a centrarse en algoritmos. El programa de Arqutectura de Software Especifica
  del Dominio, patrocinado por el Departamente de Defensa de los Estados Unidos
  [@l(#GM92)], se centra en recoger informacion arquitectonica. La comunidad de
  ingenieria de software basada en el conocimiento trata de represetar el
  conocimiento relativo al sorftware en general. Hay muchos otros grupos con
  objetivos al menos similares al nuestro.

  @e(Advanced C++: Programming Styles and Idioms), de James Coplien [@l(#Cop92)]
  tambien nos ha influido. Los patrones de este libro tienden a ser mas
  especificos de C++ que los nuestros, y su libro tambien contiene muchos
  patrones de mas bajo nivel. Pero hay cosas en comun, como señalamos en nuetros
  patrones. Jim ha sido un miembro activo de la comunidad de patrones.
  Actualmente esta trabajando en patrones que describen los roles de las
  personas en las organizaciones de desarrollo de software.

  Hay otros muchos sitios en los que se pueden encontrar descripciones de
  patrones. Kent Beck fue una de las primeras personas de la comunidad del
  software que defendio el trabajo de Christopher Alexander. En 1993 comenzo a
  escribir una columna en @e(The Smalltalk Report) sobre patrones de
  Smalltalk. Peter Coad tambien habia pasado cierto tiempo seleccionando
  patrones. Su articulo sobre patrones nos parece que contiene sobre todo
  patrones de analisis [@l(#Coa92)]; no hemos visto sus ultimos patrones, aunque
  sabemos que sigue trabajando en ellos. Hemos oido hablar de varios libros
  sobre patrones que estan escribiondese, pero tampoco hemos visto ninguno. Todo
  lo que podemos hacer es decir que estan en camino. Uno de estos libros sera de
  la conferencia de Lenguajes de Patrones de Programas.

** 6.4 <> Una invitacion

  ¿Que puede hacer si esta interesado en los patrones? En primer lugar, uselos y
  busque otros patrones que se ajusten a su diseño. En los proximos años
  apareceran un monton de libros y articulos acerca de patrones, de modo que
  habra muchas fuentes de nuevos patrones. desarrolle su vocabulario de patrones
  y uselo. Uselo cuando hable con otras personas sobre diseños. Uselo cuando
  piense y escriba sobre ellos.

  En segundo lugar, sea un consumidor critico. El catalogo de patrones de diseño
  es resultado de un duro trabajo, no solo nuestro, sino de docenas que nos
  dieron su opinion. Si encuentra un ploblema o cree que es necesaria mas
  explicacion, pongase en contacto con nosotros. Lo mismo vale para cualquier
  otro catalogo de patrones: ¡deles su opinion a los autores! Una de las
  mejores cosas de los patrnose es que apartan las decisiones de diseño del
  reino de la mera intuicion. Permiten que los autores sean explicitos sobre las
  ventajas e inconvenientes que proporcionan, lo que facilita ver los fallos de
  sus patrones y discutir con ellos. Aprovechese de ello.

  En tercer lugar, observe que patrones usa y anotelos. Haga de ellos parte de su
  documentacion. Muestrelos a otras personas. No necesita estar en un
  laboratoria de investigacion para descubrir patrones. De hecho, encontrar
  patrones relevantes es practicamente imposible si carece de experiencia
  practica. Animese a escribir su propio catalogo de patrones... ¡pero
  asegurese de que alguien mas le ayuda a darles forma!

** 6.5 <> Una reflexion a modo de despedida

  Los mejores diseño usaran muchos patrones de diseño que se imbrican entre si
  para producir un mejor todo. Como afirma Christopher Alexander:

  ..quote >
    Es posible hacer edificios enlazando patrones, de un modo poco preciso. Un
    edificio asi construido es una mezcolanza de patrones. No es denso. No es
    profundo. Pero tambien es posible juntar patrones de modo que muchos
    patrones se solapen en un mismo espacio fisico: el edificio en muy denso;
    tiene muchos significados representados en un espacio reducido; y atraves de
    esa densidad, se hace profundo.

    --A Patter Language [ALX+77, pagina xli]
  < quote..

* Apendice A <> Glosario

  - acoplamiento ::

    El grado en que los componentes software dependen unos de otros.

  - acoplamiento abstracto ::

    Dada una clase @e(A) que tiene una referencia a una clase abstracta @e(B),
    la clase @e(A) se dice que tiene un @e(acoplamiento abstracto a B). Lo
    llamamos acoplamiento abstracto porque @e(A) se refiene al @e(tipo) de un
    objeto, no a un objeto concreto.

  - clase ::

    Una clase define la interfaz de un objeto y su implementacion. Especifica la
    representacion interan de un objeto y define las operaciones que este puede
    llevar a cabo.

  - clase abstracta ::

    Una clase cuyo principal proposito es definir una interfaz. Una clase
    abstracta delega parte de su implementacion, o toda, en sus subclases. No se
    pueden crear instancias de una clase abstracta.

  - clase mezclable ::

    Una clase diseñada para ser combinada con otras por medio de la
    herencia. Las clases mezclables suelen ser abstractas.

  - clase amiga ::

    En C++, una clase que tiene los mismos permisos de acceso a las operaciones
    y datos de una clase que la propia clase.

  - clase concreta ::

    Una clase que no tiene operaciones abstractas. Se puden crean instancias de ella.

  - clase padre ::

    La clase de la que hereda otra clase. Tiene como sinonimos superclase
    (Smalltalk), clase base (C++) y clase antecesora.

  - composicion de objetos ::

    Ensablar o @e(componer) objetos para obtener un comportamiento mas complejo.

  - constructor ::

    En C++, una operacion que se invoca automaticamente para inicializar las
    nuevas instancias.

  - delegacion ::

    Un mecanismo de implementacion mediante el cual un objeto redirige o
    @e(delega) una peticion, a otro objeto. El delegado lleva a cabo la peticion
    en nombre del objeto original.

  - destructor ::

    En C++, una operacion a la que se invoca automaticamente para terminar un
    objeto que esta a punto de ser borrado.

  - diagrama de clases ::

    Un diagrama que representa clases, su estructura y operaciones internas, y
    las relaciones estaticas entre ellas.

  - diagrama de interaccion ::

    Un diagrama que muestra el flujo de peticiones entre objetos.

  - diagrama de objetos ::

    Un diagrama que representa una determinada estrucutra de objteos en tiempo de ejecucion.

  - encapsulacion ::

    El resultado de ocultar la representacion e implemenacion en un objeto. La
    representacion no es visible y no se puede acceder a ella directamente desde
    el exterior del objeto. El unico modo de acceder a la representacion de un
    objeto y de modificarla es atraves de sus operaciones.

  - enlace dinamico ::

    La asociacion en tiempo de ejecucion entre una peticion a un objeto y una de
    sus operaciones. En C++, solo las funciones virtuales puras estan enlazadas
    dinamicamente.

  - framework ::

    Un conjunto de clases cooperantes que forman un diseño reutilizable para
    determinada clase de software. Un framework proporciona una guia
    arquitectonica para dividir el diseño en clases abstractas y definir sus
    responsabilidades y colaboraciones. Un desarrollador adapta el framework a
    una aplicacion concreta heredando y componiendo instancias de las clases del
    framework.

  - herencia ::

    Una relacion que define una cantidad en terminos de otra. La herencia de
    clases define una nueva clase en terminos de una o mas clases padre. La nueva
    clase hereda su interfaz y sus implementaciones de sus padres. La nueva
    clase se dice que es una subclase o (en C++) una clase derivada. La herencia
    de clases combina @b(herencia de Interfaces) y @b(herencia de implementacion).
    La herencia de interfaces define una nueva interfaz en terminos de una o
    varias interfaces existentes. La herencia de implementacion define una nueva
    implemenacion en terminos de una o varias implementaciones existentes.

  - herencia privada ::

    En C++, una clase de la que se hereda solo por su implementacion.

  - interfaz ::

    El conjunto de todas las signaturas definidas por las operaciones de un
    objeto. La interfaz describe el conjunto de peticiones a las que puede
    responder un objeto.

  - metaclase ::

    Las clases son objetos en Smalltalk. Una metaclase es la clase de un objeto clase.

  - objeto ::

    Una entidad de tiempo de ejecucion que empaqueta datos y los procedimientos
    que operan sobre esos datos.

  - objeto agregado ::

    Un objeto que se compone de subobjetos. Los subobjetos se denominan las
    partes, y el agregadao es reponsable de ellos.

  - operacion ::

    Los datos de un objeto solo pueden ser manipulados por sus operaciones. Un
    objeto realiza una operacion cuando recibe una peticion. En C++, a las
    operacines se las denomina @b(funciones miembro). Smalltalk usa el termino
    @b(metodo).

  - operacion abstracta ::

    Una operacion que declara una signatura pero no la implementa. En C++, una
    operacion abstracta se corresponde con una funcion miembro virtual pura.

  - operacion de clase ::

    Una operacion que pertenece a una clase y no a un objeto individual. En C++,
    las operaciones de clase se denominan @b(funciones miembro estaticas).

  - patron de diseño ::

    Un patron de diseño nomina, da los motivos y explica sistematicamente un
    diseño general que resuelve un problema de diseño recurrente en los sistemas
    orientados a objetos. Describe el problema, la solucion, cuando aplicar este
    y sus consecuencias. Tambien ofrece trucos de implementacion y ejemplos. La
    solucion es una disposicion general de clases y objetos que resuelven el
    problema. Esta adaptada e implementada para resolver el problema en un
    determinado contexto.

  - peticion ::

    un objeto lleva a cabo una operacion cuando recibe la peticion
    correspondiente de otro objeto. Un sinonimo frecuente de peticion es @b(mensaje).

  - polimorfismo ::

    La capacidad de sustituir los objetos que se ajustan a una interfaz por
    otros en tiempo de ejecucion

  - protocolo ::

    Extiende el concepto de interfaz para incluir todas las secuencias de
    peticiones permitidas.

  - receptor :: El objeto destino de una pecition.

  - redefinicion ::

    Volver a definir una operacion (heredada de una clase padre) en una subclase

  - referencia de objetos :: Un valor que indentifica a otro objeto.

  - relacion de agregacion ::

    La relacion entre un objeto agregado y sus padres. Una clase define esta
    relacion con sus instancias (objetos agregados).

  - relacion de asociacion ::

    Una clase que se refiere a otra clase tiene una @e(asociacion) con esa clase.

  - reutilizacion de caja blanca ::

    Un estilo de reutilizacion basado en la herencia de clases. Una subclase
    reutiliza la interfaz e implementacion de su clase padre, pero puede acceder
    a los aspectos privades de su padre.

  - reutilizacion de caja negra ::

    un estilo de reutilizacion basado en la composicion de objetos. Los objetos
    compuestos no se revelan entre si sus detalles internos, lo que los hace ser
    como @"(cajas negras).

  - signatura ::

    La signatura de una operacion define su nombre, parametros y tipo de retorno.

  - subclase ::

    Una clase que hereda de otra. En C++, una subclase se denomina una clase derivada.

  - subsistema ::

    Un grupo independiente de clases que colaboran para llevar a cabo una serie
    de responsabilidades.

  - subtipo ::

    Un tipo es un subtipo de otro si su interfaz contiene a la interfaz de aquel.

  - supertipo :: El tipo padre del que hereda otro tipo.

  - tipo :: El nombre de una determinada interfaz

  - tipo parametrizado ::

    Un tipo que deja sin especificar alguno de sus tipos constituyentes. Los
    tipos sin especificar se porporcionan como parametros en el momento de su
    uso. En C++, los tipos parametrizados se llaman plantillas.

  - toolkit ::

    Una coleccion de clases que proporcionan una funcionalidad util pero que no
    definen el diseño de una aplicacion.

  - variable de instancia ::

    Un elemento de datos que define parte de la representacion de un objeto. C++
    usa el termino @b(miembro de datos).

* Apendice B <> Guia de la notacion

  A lo largo del libro se usan diagramas para ilustrar las ideas importantes.
  Algunos diagramas son formales, como una captura de pantalla de un cuadro de
  dialogo o un esquema que representa un arbol de objetos. Pero lo que son los
  patrones de diseño usan notaciones mas formales para denotar relaciones e
  interacciones entre clases y objetos. En este apendice se describen dichas
  notaciones en detalle.

  Usamos tres notaciones graficas distintas:

  1. Un @b(diagrama de clase) representa clases, su estructura y las relaciones
     estaticas entre ellas.

  2. Un @b(diagrama de objetos) muestra una determinada estructura de objetos en
     tiempo de ejecucion.

  3. Un @b(diagrama de interaccion) muestra el flujo de peticiones entre objetos.

  Cada patron de diseño incluye al menos un diagrama de clases. Las otras
  notaciones se usan cuando son necesarias para completar la descripcion. Los
  diagramas de clases y objetos estan basados en OMT (@e(Object Modeling
  Technique), Tecnica de Modelado de Objetos) [@l(#RBP+91), @l(#Rum94)].@n(57) Los
  diagramas de interaccion estan tomados de Objectory [@l(#JCJO92)] y del metodo
  Booch [@l(#Boo94)].

** B.1 <> Diagrama de clases

  La figura B.1a muestra la notacion OMT para las clases abstractas y
  concretas. Una clase se denota por un rectangulo con el nombre de la clase en
  negrita en la parte superior. Las principales operaciones de la clase aparecen
  bajo el nombre de la clase. Las variables de instancia se muestran debajo de
  las operaciones. La informacion de tipos es opcional; nosotros usamos el
  convenio de C++, que situa el nombre de tipo antes del nombre de la operacion
  (para singnificar el tipo de retorno), variable de instancia o parametro
  real. Si el tipo aparece en cursiva quiere decir que la operacion es
  abstracta.

  ..figure > (a) Clases abstractas y concretas

    ..img  > img/figure-b.1a.png

  En algunos diseños resulta util ver donde hacen referencia las clases cliente
  a las clases Participante. Cuando un patron incluye una clase Cliente como una
  de sus participantes (lo que quiere decir que el cliente tiene alguna
  responsabilidad en el patron, el Cliente aparece como una clase ordinaria. Un
  ejemplo de esto lo tenemos en el patron @l(#Flyweight). Cuando el patron no
  incluye el Cliente como participante (es decir, los clientes no tienen
  responsabilidades en el patron), pero a pesar de eso incluirlo en el diagrama
  ayuda a clarificar el modo en que el patron interactua con sus clientes,
  entonces la clase Cliente se muestra en gris, como en la figura B.1b. Un
  ejemplo de esto es el patron @l(#Proxy). Un Cliente en gris tambien deja claro
  que no ha sido omitido accidentalmente de la seccion de Participantes.

  ..figure > (b) Relaciones entre clases

    ..img  > img/figure-b.1b.png

  La figura B.1c muestra varias relaciones entre clases. La notacion OMT para la
  herencia de clases es un triangulo que conecta a una subclase (@c(FormaLinea)
  en la figura) a su clase padre @%c(Forma). Una referencia a un objeto que
  representa una relacion de agregacion o parte-todo se indica mediante una
  flecha con un rombo en su base. La flecha apunta a la clase del agregado (por
  ejemplo, @c(Forma)). Una flecha sin rombo denota asociacion (por ejemplo, una
  @c(FormaLinea) tiene una referencia a un objeto @c(Color) que puede ser compartido
  con otras formas). La referencia puede tener un nombre cerca de la base para
  distinguirla de otras referencias.@n(58)

  ..figure > (c) relacion entre clases

    ..img  > img/figure-b.1c.png

  Tambien es util mostrar que clases crean instancias de que otras. Para ello
  usamos una flecha con la linea punteada, ya que OMT no lo permite. Llamamos a
  esto la relacion @"(crea). la flecha apunta a la clase de la que se crea la
  instancia. En la figura B.1.c, @c(HerramientasDeCreacion) crea objetos
  @c(FormaLinea)

  OMT tambien define un circulo relleno que representa @"(mas de uno). Cuando el
  circulo aparece en el extremo de una referencia quiere decir que hay muchos
  objetos referenciados o agregados. La figura B.1c representa un agregado
  @c(Dibujo) que contiene multiples objetos de tipo @c(Forma).

  ..figure > (d) Notacion en pseudocodigo

    ..img  > img/figure-b.1d.png

  Por ultimo, hemos aumentado OMT con anotaciones en pseudocodigo que nos
  permiten esbozar las implementaciones de las operaciones. La figura B.1d
  muestra la anotacion en pseudocodigo para la operacion @c(Dibujar) de la clase
  @c(Dibujo).

** B.2 <> Diagrama de objetos

  Un Diagrama de objetos muestra exclusivamente instancias. Representa una
  instancia de los objetos de un patron de diseño. Los objetos tienen por nombre
  @"(unAlgo), donde @e(Algo) es la clase del objeto. Nuestro simbolo de un
  objeto (modificado ligeramente del estandar OMT) es un rectangulo con los
  bordes redondeados y una linea que separa el nombre del objeto de las
  referencias a otros objetos. Las flechas indican el objeto referenciado. La
  figura B.2 muestra un ejemplo.

  ..figure > @t(Figura B.2): Notacion de los diagramas de objetos

    ..img  > img/B.2.png

** B.3 <> Diagrama de iteracion

  Un diagrama de interacion muestra el orden en que se ejecutan las peticiones
  entre objetos. La figura B.3 es un diagrama de interaccion que muestra como se
  añade una forma a un dibujo.

  ..figure > @t(Figura B.3): Notacion de los diagramas de interaccion

    ..img > img/B.3.png

  En un diagrama de interaccion, el tiempo fluye de arriba a abajo. Una linea
  vertical indica el tiempo de vida de un determinado objeto. La convencion de
  nominacion de objetos es la misma que la de los diagramas de objetos @-(el
  nombre de la clase con los articulos indenterminados @"(un) o @"(una) como
  prefijo (por ejemplo, @c(unaForma))). Si no se crea ninguna instancia del
  objeto hasta un tiempo despues del instante inicial representado en el
  diagrama, entonces su linea vertical aparece punteada hasta el momento de la
  creacion.

  Un rectangulo vertical indica que un objeto esta activo; es decir, que esta
  procesando una peticion. La operacion puede enviar peticiones a otros objetos;
  esto se indica con una flecha horizontal que apunta al objeto receptor. El
  nombre de la peticion se muestra encima de la flecha. Una peticion se
  representa con una flecha hacia si mismo.

  La figura B.3 muestra que la primera repeticion procede de
  @c(unaHerramientaDeCreacion) para crear @c(unaFormaLinea). A continuacion, se
  añade @c(unaFormaLinea) a @c(unDibujo), lo que hace que @c(unDibujo) se envie
  a si mismo una peticion @c(Actualizar). Notese que @c(unDibujo) envia una
  peticion @c(Dibujar) a @c(unaFormaLinea) como parte de la operacion
  @c(Actualizar).

* Apendice C <> Clases fundamentales

  Este apendice documenta las clases fundamentales que usamos en el codigo
  de ejemplo C++ de varios patrones de diseño. Las hemos mantenido
  intencionadamente simples y minimas. Describiremos las clases siguientes:

  - @c(Lista), una lista ordenada de objetos.
  - @c(Iterador), la interfaz para acceder en secuencia a los objetos de un agregado.
  - @c(IteradorLista), un iterador para recorrer una @c(Lista).
  - @c(Punto), un punto de dos dimenciones.
  - @c(Rect), un rectangulo

  Algunos de los tipos estandar mas recientes de C++ puede que no esten
  disponibles en todos los compiladores. En concreto, si nuestro compilador no
  define @c(bool), podemos definirlo manualmente como sigue:

  ..src > c++
    typedef int bool;
    const int true  = 1;
    const int false = 0;
  < src..

** C.1 <> Lista

  La clase de plantilla @c(Lista) proporciona un contenedor basico para guardar
  una lista ordenada de objetos. @c(Lista) guarda los elementos por valor, lo
  que significa que sirve tanto para tipos predefinidos como para instancias de
  clases. Por ejemplo, @c(Lista<int>) declara una lista de @c(int)s. Pero la
  mayoria de los patrones usan @c(Lista) para guardar punteros a objetos, como
  en @c(Lista<Glifo*>). De ese modo se puede usar @c(Lista) para listas
  heterogeneas.

  Por conveniencia, @c(Lista) tambien proporciona sinonimos para operaciones de
  pilas, lo que hace mas explicito al codigo que usa @c(Lista) para pilas, sin
  necesidad de definir otra clase.

  ..src > c++
    template <class Elemento>
    class Lista {
    public:
        Lista(long tamano = CAPACIDAD_LISTA_PREDETERMINADA);
        Lista(Lista&);
        ~Lista();
        Lista& operator=(const Lista&);

        long Contar() const;
        Elemento& Obtener(long indice) const;
        Elemento& Primero() const;
        Elemento& Ultimo() const;
        bool Incluye(const Elemento&) const;

        void Insertar(const Elemento&);
        void InsertarAlPrincipio(const Elemento&);

        void Eliminar(const Elemento&);
        void EliminarUltimo();
        void EliminarPrimero();
        void EliminarTodos();

        Elemento& Cima() const;
        void Meter(const Elemento&);
        Elemento& Sacar();
    };
  < src..

  Las secciones siguientes describen estas operaciones en mas detalle.

*** Costruccion, Destruccion, Inicializacion y Asignacion

  - @c[Lista(long tamano)] ::

    inicializa la lista. El parametro @c(tamano) es una indicacion del numero
    inicial de elementos.

  - @c[Lista(Lista&)] ::

    redefine el constructor de copia predeterminado para que los datos miembros
    se inicialicen adecuadamente.

  - @c[~Lista()] ::

    libera las estructuras de datos internas, pero @e(no) los elementos de la
    lista. La clase no esta diseñada para ser heredada; por tanto, el destructor
    no es virtual.

  - @c[Lista& operator=(const Lista&)] ::

    Implementa la operacion de asignacion para asignar correctamente los datos miembros.

*** Acceso

  Estas operaciones proporcionan el acceso basico a los elementos de la lista.

  - @c[long Contar() const] :: devuelve el numero de objetos de la lista.

  - @c[Elemento& Obtener(long indice) const] :: devuelve el objeto del indice actual.

  - @c[Elemento& Primero() const] :: devuelve el primer objeto de la lista.

  - @c[Elemento& Ultimo() const] :: devuelve el ultimo objeto de la lista.

*** Adicion

  - @c[void Insertar(const Elemento&)] ::

    añade el argumento a la lista, pasando a ser el ultimo elemento.

  - @c[void InsertarAlPrincipio(const Elemento&)] ::

    añade el argumento a la lista, pasando a ser el primer elemento.

*** Borrado

  - @c[void Eliminar(const Elemento&)] ::

    elimina el elemento dado de la lista. Esta operacion requiere que el tipo de
    los elementos de la lista admita el operador @c(==) para la comparacion.

  - @c[void EliminarPrimero()] :: elimina el primer elemento de la lista.

  - @c[void EliminarUltimo()] :: elimina el ultimo elemento de la lista.

  - @c[void EliminarTodos()] :: elimina todos los elementos de la lista.

*** Interfaz de la pila

  - @c[Elemento& Cima() const] ::

    devuelve el elemento de la cima (cuando la @c(Lista) es vista como una pila).

  - @c[void Meter(const Elemento&)] :: mete el elemento en la pila.

  - @c[Elemento& Sacar()] :: extrae el elemento de la cima de la pila.

** C.2 <> Iterador

  @c(Iterador) es una clase abstracta que define una interfaz de recorrido para
  agregados.

  ..src > c++
    template <class Elemento>
    class Iterador {
    public:
        virtual void Primero() = 0;
        virtual void Siguiente() = 0;
        virtual bool HaTerminado() const = 0;
        virtual Elemento ElementoActual() const = 0;
    protected:
        Iterador();
    };
  < src..

  Las operaciones hacen lo siguiente:

  - @c[virtual void Primero()] ::

    posiciona el iterador sobre el primer objeto del agregado.

  - @c[virtual void Siguiente()] ::

    posiciona el iterador en el siguiente objeto de la secuencia.

  - @c[virtual bool HaTerminado() const] ::

    devuelve @c(true) cuando no hay mas objetos en la secuencia.

  - @c[virtual Elemento ElementoActual() const] ::

    devuelve el objeto situado en la posicion actual de la secuencia.

** C.3 <> IteradorLista

  @c(IteradorLista) implementa la interfaz @c(Iterador) para recorrer objetos
  @c(Lista). Su constructor recibe la lista a recorrer como argumento.

  ..src > c++
    template <class Elemento>
    class IteradorLista : public Iterador<Elemento> {
    public:
        IteradorLista(const Lista<Elemento>* unaLista);

        virtual void Primero();
        virtual void Siguiente();
        virtual bool HaTerminado() const;
        virtual Elemento ElementoActual() const;
    };
  < src..

** C.4 <> Punto

  @c(Punto) representa un punto en un espacio bidimencional de coordenadas
  cartecianas. @c(Punto) permite cierta aritmetica de vectores minima. Las
  coordenadas de un @c(Punto) se definen como:

  ..src > c++
    tipedef float Coord;
  < src..

  Las operaciones de @c(Punto) se explican por si mismas.

  ..src > c++
    class Punto {
    public:
        static const Punto Cero;

        Punto(Coord x = 0.0, Coord y = 0.0);

        Coord X() const; void X(Coord x);
        Coord Y() const; void Y(Coord y);

        friend Punto operator+(const Punto&, const Punto&);
        friend Punto operator-(const Punto&, const Punto&);
        friend Punto operator*(const Punto&, const Punto&);
        friend Punto operator/(const Punto&, const Punto&);

        Punto& operator+=(const Punto&);
        Punto& operator-=(const Punto&);
        Punto& operator*=(const Punto&);
        Punto& operator/=(const Punto&);

        Punto opeartor-();

        friend bool operator==(const Punto&, const Punto&);
        friend bool operator!=(const Punto&, const Punto&);

        friend ostream& operator<<(ostream&, const Punto&);
        friend istream& operator>>(istream&, Punto&);
    };
  < src..

  El miembro estatico @c(Cero) representa el @c[Punto(0, 0)].

** C.5 <> Rect

  @c(Rect) representa un rectangulo alineado con el eje. Un @c(Rect) se define
  por un punto de origen y una dimension (esto es, su ancho y su alto). Las
  operaciones de @c(Rect) son muy faciles de entender.

  ..src > c++
    class Rect {
    public:
        static const Rect Cero;

        Rect(Coord x, Coord y, Coord ancho, Coord alto);
        Rect(const Punto& origen, cont Punto& dimension);

        Coord Ancho    () const;  void Ancho    (Coord);
        Coord Alto     () const;  void Alto     (Coord);
        Coord Izquierda() const;  void Isquierda(Coord);
        Coord Inferior () const;  void Inferior (Coord);

        Punto& Origen   () const; void Origen(const Punto&);
        Punto& Dimension() const; void Dimension(const Punto&);

        void MoverA(const Punto&);
        void Mover(const Punto&);

        bool EstaVacio() const;
        bool Contiene(const Punto&) const;
    };
  < src..

  El miembro estatico @c(Cero) es equivalente al rectangulo

  ..src > c++
    Rect(Punto(0,0), Punto(0, 0));
  < src..

* Bibliografia

  [@t(Add94)] Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3,
  Volumeness 1 y 2, 1994.

  [@t(AG90)] D.B. Anderson y S. Gossain. Hierarchy evolution y the software
  lifecycle. In TOOLS '90 Conference Proceedings, pp. 41–50, Paris, Junio
  de 1990. Prentice Hall.

  [@t(AIS+77)] Christopher Alexander, Sara Ishikawa, Murray Silverstein, Max
  Jacobson, Ingrid Fiksdahl-King, y Shlomo Angel. A Pattern Language. Oxford
  University Press, Nueva York, 1977.

  [@t(App89)] Apple Computer, Inc., Cupertino, CA. Macintosh Programmers Workshop
  Pascal 3.0 Reference, 1989.

  [@t(App92)] Apple Computer, Inc., Cupertino, CA. Dylan. An object-oriented
  dynamic language, 1992.

  [@t(Arv91)] James Arvo. Graphics Gems II.Academic Press, Boston, MA, 1991.

  [@t(AS85)] B. Adelson y E. Soloway. The role of domain experience in software
  design. IEEE Transactions on Software Engineering, 11(11):1351-1360, 1985.

  [@t(BE93)] Andreas Birrer y Thomas Eggenschwiler. Frameworks in the financial
  engineering domain: An experience report. En European Conference on
  Object-Oriented Programming, pp. 21-35, Kaiserslautern, Alemania, julio de
  1993. Springer-Verlag.

  [@t(BJ94)] Kent Beck y Ralph Johnson. Patterns generate architectures. In
  European Conference on Object-Oriented Programming, pp. 139-149, Bologna,
  Italy, julio de 1994. Springer-Verlag.

  [@t(Boo94)] Grady Booch. Object-Oriented Analysis and Design with Applications.
  Benjamin/Cummings, Redwood City, CA, 1994. Segunda Edicion.

  [@t(Bor81)] A. Borning. The programming language aspects of ThingLab—a
  constraint-oriented simulation laboratory. ACM Transactions on Programming
  Languages and Systems, 3(4):343-387, octubre de 1981.

  [@t(Bor94)] Borland International, Inc., Scotts Valley, CA. A Technical
  Comparison of Borland ObjectWindows 2.0 and Microsoft MFC 2.5, 1994.

  [@t(BV90)] Grady Booch y Michael Vilot. The design of the C++ Booch
  components. In Object-Oriented Programming Systems, Languages, and Applications
  Conference Proceedings, pp. 1-11, Ottawa, Canada, Octubre de 1990. ACM Press.

  [@t(Cal93)] Paul R. Calder. Building User Interfaces with Lightweight
  Objects. PhD thesis, Stanford University, 1993.

  [@t(Car89)] J. Carolan. Constructing bullet-proof classes. In Proceedings C++
  at Work '89. SIGS Publications, 1989.

  [@t(Car92)] Tom Cargill. C++ Programming Style. Addison-Wesley, Reading,
  MA, 1992.

  [@t(CIRM93)] Roy H. Campbell, Nayeem Islam, David Raila, and Peter
  Madeany. Designing and implementing Choices: An object-oriented system in
  C++. Communications of the ACM, 36(9):117-126, septiembre de 1993.

  [@t(CL90)] Paul R. Calder y Mark A. Linton. Glyphs: Flyweight objects for user
  interfaces. In ACM User Interface Software Technologies Conference, pp.
  92-101, Snowbird, UT, octubre de 1990.

  [@t(CL92)] Paul R. Calder y Mark A. Linton. The object-oriented implementation
  of a document editor. In Object-Oriented Programming Systems, Languages, and
  Applications Conference Proceedings, pp. 154-165, Vancouver, British
  Columbia, Canada, octubre de 1992. ACM Press.

  [@t(Coa92)] Peter Coad. Object-oriented patterns. Communications of the ACM,
  35(9):152-159, septiembre de 1992.

  [@t(Coo92)] William R. Cook. Interfaces and specifications for the Smalltalk-80
  collection classes. In Object-Oriented Programming Systems, Languages, and
  Applications Conference Proceedings, pp. 1-15, Vancouver, British Columbia,
  Canada, octuebre de 1992. ACM Press.

  [@t(Cop92)] James O. Coplien. Advanced C++ Programming Styles and
  Idioms. Addison-Wesley, Reading, MA, 1992.

  [@t(Cur89)] Bill Curtis. Cognitive issues in reusing softwareartifacts. In Ted
  J. Biggerstaff y Alan J. Perlis,editors, Software Reusability, Volume II:
  Applications and Experience, pp. 269-287. Addison-Wesley, Reading, MA,
  1989.

  [@t(dCLF93)] Dennis de Champeaux, Doug Lea, y Penelope Faure. Object-Oriented
  System Development. Addison-Wesley, Reading, MA, 1993.

  [@t(Deu89)] L. Peter Deutsch. Design reuse y frameworks in the Smalltalk-80
  system.  In Ted J. Biggerstaff and Alan J. Perlis, editors, Software
  Reusability, Volume II: Applications and Experience, pp. 57-71. Addison-Wesley,
  Reading, MA, 1989.

  [@t(Ede92)] D. R. Edelson. Smart pointers: They're smart, but they're not
  pointers.  In Proceedings of the 1992 USENIX C++ Conference, pp. 1-19,
  Portland, OR, agosto de 1992. USENIX Association.

  [@t(EG92)] Thomas Eggenschwiler y Erich Gamma. The ET++SwapsManager: Using
  object technology in the financial engineering domain. In Object-Oriented
  Programming Systems, Languages, and Applications Conference Proceedings, pp.
  166-178, Vancouver, British Columbia, Canada, octubre de 1992. ACM Press.

  [@t(ES90)] Margaret A. Ellis y Bjarne Stroustrup. The Annotated C++ Reference
  Manual. Addison-Wesley,Reading, MA, 1990.

  [@t(Foo92)] Brian Foote. A fractal model of the life cycles of reusable
  objects. OOPSLA '92 Workshop on Reuse, octubre de 1992. Vancouver, British
  Columbia, Canada.

  [@t(GA89)] S. Gossain y D.B. Anderson. Designing aclass hierarchy for domain
  representation y reusability. In TOOLS '89 Conference Proceedings, pp.
  201-210, CNIT Paris—La Defense, France, noviembre de 1989. Prentice Hall.

  [@t(Gam91)] Erich Gamma. Object-Oriented Software Development based on ET++:
  Design Patterns, Class Library, Tools (en aleman). Tesis Doctoral, Universidad
  de Zurich Institut für Informatik, 1991.

  [@t(Gam92)] Erich Gamma. Object-Oriented Software Development based on ET++:
  Design Patterns, Class Library, Tools (en aleman). Springer-Verlag,
  Berlin, 1992.

  [@t(Gla90)] Andrew Glassner. Graphics Gems.Academic Press, Boston, MA, 1990.

  [@t(GM92)] M. Graham y E. Mettala. The Domain-Specific Software Architecture
  Program. En Proceedings of DARPA Software Technology Conference, 1992, pp.
  204-210, April de 1992. Publicado tambien en CrossTalk, The Journal of Defense
  Software Engineering, pp. 19-21, 32, octubre de 1992.

  [@t(GR83)] Adele J. Goldberg y David Robson. Smalltalk-80: The Language and Its
  Implementation. Addison-Wesley, Reading, MA, 1983.

  [@t(HHMV92)] Richard Helm, Tien Huynh, Kim Marriott, and John Vlissides. An
  object-oriented architecture for constraint-based graphical editing. En
  Proceedings of the Third Eurographics Workshopon Object-Oriented Graphics,
  pp. 1-22, Champéry, Switzerland, octubre de 1992. Tambien se encuentra
  disponible como el infrome tecnico RC 18524 (79392) de la Division de
  Investigacion de IBM.

  [@t(HO87)] Daniel C. Halbert y Patrick D. O'Brien.Object-oriented development.
  IEEE Software,4(5):71-79, septiembre de 1987.

  [@t(ION94)] IONA Technologies, Ltd., Dublin, Ireland.Programmer's Guide for
  Orbix, Version 1.2, 1994.

  [@t(JCJO92)] Ivar Jacobson, Magnus Christerson, Patrik Jonsson, y Gunnar
  Overgaard.  Object-Oriented Software Engineering—A Use Case Driven
  Approach. Addison-Wesley, Wokingham, Inglaterra, 1992.

  [@t(JF88)] Ralph E. Johnson y Brian Foote. Designing reusable classes. Journal
  of Object-Oriented Programming, 1(2):22-35, junio/julio de 1988.

  [@t(JML92)] Ralph E. Johnson, Carl McConnell y J. Michael Lake. The RTL
  system: A framework for code optimization. En Robert Giegerich y Susan
  L. Graham, editores, Code Generation—Concepts, Tools, Techniques. Proceedings of
  the International Workshop on Code Generation, pp. 255-274, Dagstuhl,
  Alemania, 1992. Springer-Verlag.

  [@t(Joh92)] Ralph Johnson. Documenting frameworks using patterns. In
  Object-Oriented Programming Systems, Languages,and Applications Conference
  Proceedings, pp. 63-76, Vancouver, British Columbia, Canada, octubre de 1992. ACM
  Press.

  [@t(JZ91)] Ralph E. Johnson y Jonathan Zweig. Delegation in C++. Journal of
  Object-Oriented Programming, 4(11):22-35, noviembre de 1991.

  [@t(Kir92)] David Kirk. Graphics Gems III.H arcourt, Brace, Jovanovich, Boston,
  MA, 1992.

  [@t(Knu73)] Donald E. Knuth. The Art of Computer Programming, Volumes 1, 2,
  and 3. Addison-Wesley, Reading, MA, 1973.

  [@t(Knu84)] Donald E. Knuth. The TeX book. Addison-Wesley, Reading, MA, 1984.

  [@t(Kof93)] Thomas Kofler. Robust iterators in ET++. Structured Programming,
  14:62-85, marzo de 1993.

  [@t(KP88)] Glenn E. Krasner y Stephen T. Pope. A cookbook for using the
  model-view controller user interface paradigm in Smalltalk-80. Journal of
  Object-Oriented Programming, 1(3):26-49, agosto/septiembre 1988.

  [@t(LaL94)] Wilf LaLonde. Discovering Smalltalk.Benjamin/Cummings, Redwood
  City, CA, 1994.

  [@t(LCI+92)] Mark Linton, Paul Calder, John Interrante, StevenTang, y John
  Vlissides.  InterViews Reference Manual.CSL, Stanford University, edicion
  3.1, 1992.

  [@t(Lea88)] Doug Lea. libg++, the GNU C++ library. In Proceedings of the 1988
  USENIX C++ Conference, pp. 243-256, Denver, CO, octubre de 1988. USENIX
  Association.

  [@t(LG86)] Barbara Liskov y John Guttag. Abstraction and Specification in
  Program Development. McGraw-Hill, Nueva York, 1986.

  [@t(Lie85)] Henry Lieberman. There's more to menu systems than meets the
  screen. In SIGGRAPH Computer Graphics, pp. 181-189, San Francisco, CA,
  julio de 1985.

  [@t(Lie86)] Henry Lieberman. Using prototypical objects to implement shared
  behavior in object-oriented systems. En Object-Oriented Programming Systems,
  Languages, and Applications Conference Proceedings, pp. 214-223, Portland, OR,
  noviembre de 1986.

  [@t(Lin92)] Mark A. Linton. Encapsulating a C++ library. En Proceedings of the
  1992 USENIX C++ Conference, pp. 57-66, Portland, OR, agosto de 1992. ACM Press.

  [@t(LP93)] Mark Linton y Chuck Price. Building distributed user interfaces with
  Fresco. En Proceedings of the 7th XTechnical Conference, pp. 77-87, Boston,
  MA, enero de 1993.

  [@t(LR93)] Daniel C. Lynch and Marshall T. Rose.Internet System Handbook.
  Addison-Wesley, Reading, MA, 1993.

  [@t(LVC89)] Mark A. Linton, John M. Vlissides y Paul R. Calder. Composing
  user interfaces with InterViews. Computer, 22(2):8-22, febrero de 1989.

  [@t(Mar91)] Bruce Martin. The separation of interface and implementation in
  C++. En Proceedings of the 1991 USENIXC++ Conference, pp. 51-63, Washington,
  D.C., abril de 1991. USENIX Association.

  [@t(McC87)] Paul McCullough. Transparent forwarding: Firststeps. En
  Object-Oriented Programming Systems, Languages, and Applications Conference
  Proceedings, pp. 331-341, Orlando, FL, octubre de 1987. ACM Press.

  [@t(Mey88)] Bertrand Meyer. Object-Oriented Software Construction. Series in
  Computer Science. Prentice Hall,Englewood Cliffs, NJ, 1988.

  [@t(Mur93)] Robert B. Murray. C++ Strategies andTactics. Addison-Wesley,
  Reading, MA, 1993.

  [@t(OJ90)] William F. Opdyke y Ralph E. Johnson. Refactoring: An aid in
  designing application frameworks y evolving object-oriented systems. En SOOPPA
  Conference Proceedings, pp. 145-161, Marist College, Poughkeepsie, NY,
  septiembre de 1990. ACM Press.

  [@t(OJ93)] William F. Opdyke y Ralph E. Johnson. Creating abstract superclasses
  by refactoring. En Proceedings of the 21st Annual Computer Science Conference
  (ACM CSC '93), pp. 66-73, Indianapolis, IN, febrero de 1993.

  [@t(P+88)] Andrew J. Palay et al. The Andrew Toolkit: An overview. En
  Proceedings of the 1988 Winter USENIX Technical Conference, pp. 9-21, Dallas,
  TX, febrero de 1988. USENIX Association.

  [@t(Par90)] ParcPlace Systems, Mountain View, CA.ObjectWorks\Smalltalk Release
  4 Users Guide, 1990.

  [@t(Pas86)] Geoffrey Smalltalk-80. A. En Pascoe. Encapsulators: A new software
  Object-Oriented Programming Systems, Languages, and Applications Conference
  Proceedings, pp. 341-346, Portland, OR, octubre de 1986. ACM Press.

  [@t(Pug90)] William Pugh. Skiplists: A probabilistic alternative to balanced
  trees. Communications of the ACM,33(6):668-676, junio de 1990.

  [@t(RBP+91)] James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy,
  y William Lorenson. Object-Oriented Modeling and Design. Prentice Hall,
  Englewood Cliffs, NJ, 1991.

  [@t(Rum94)] James Rumbaugh. The life of an object model: Howthe object model
  changes during development. Journal ofObject-Oriented Programming, 7(1):24-32,
  marzo/abril de 1994.

  [@t(SE84)] Elliot knowledge. Soloway IEEE y  Kate Transactions Ehrlich. En
  Empirical studies of Software Engineering, programming 10(5):595-609,
  septiembre de 1984.

  [@t(Sha90)] Yen-Ping Shan. MoDE: A UIMS for Smalltalk. En ACM OOPSLA/ECOOP '90
  Conference Proceedings, pp. 258-268, Ottawa, Ontario, Canada, octubre de 1990.
  ACM Press.

  [@t(Sny86)] Alan Snyder. Encapsulation and inheritance in object-oriented
  languages. En Object-Oriented Programming Systems, Languages, and Applications
  Conference Proceedings, pp. 38-45, Portland, OR, noviembre de 1986. ACM Press.

  [@t(SS86)] James C. Spohrer y Elliot Soloway. Novice mistakes: Are the folk
  wisdoms correct? Communications of the ACM, 29(7):624-632, julio de 1986.

  [@t(SS94)] Douglas C. Schmidt y Tatsuya Suda. The Service Configurator
  Framework: An extensible architecture for dynamically configuring concurrent,
  multi-service network daemons. En Proceeding of the Second International
  Workshop on Configurable Distributed Systems, pp. 190-201, Pittsburgh, PA,
  marzo de 1994. IEEE Computer Society.

  [@t(Str91)] Bjarne Stroustrup. The C++ Programming Language. Addison-Wesley,
  Reading, MA, 1991. Segunda edicion.

  [@t(Str93)] Paul S. Strauss. IRIS Inventor, a 3D graphics toolkit. En
  Object-Oriented Programming Systems, Languages, and Applications Conference
  Proceedings, pp. 192-200, Washington, D.C., septiembre de 1993. ACM Press.

  [@t(Str94)] Bjarne Stroustrup. The Design and Evolution of C++. Addison-Wesley,
  Reading, MA, 1994.

  [@t(Sut63)] I.E. Sutherland. Sketchpad: A Man-MachineGraphical Communication
  System. Tesis Doctoral, MIT, 1963.

  [@t(Swe85)] Richard E. Sweet. The Mesa programming environment. SIGPLAN
  Notices, 20(7):216-229, julio de 1985.

  [@t(Sym93a)] Symantec Corporation, Cupertino, CA. Bedrock Developer's
  Architecture Kit, 1993.

  [@t(Sym93b)] Symantec Corporation, Cupertino, CA. THINK Class Library
  Guide, 1993.

  [@t(Sza92)] Duane Szafron. SPECTalk: An object-oriented data specification
  language.  En Technology of Object-Oriented Languages and Systems (TOOLS 8),
  pp. 123-138, Santa Barbara, CA, agosto de 1992. Prentice Hall.

  [@t(US87)] David Ungar y Randall B. Smith. Self: The power of simplicity. En
  Object-Oriented Programming Systems, Languages, and Applications Conference
  Proceedings, pp. 227-242, Orlando, FL, octubre de 1987. ACM Press.

  [@t(VL88)] John M. Vlissides y Mark A. Linton. Applying object-oriented design
  to structured graphics. En Proceedings of the 1988 USENIX C++ Conference,
  pp. 81-94, Denver, CO, octubre de 1988. USENIX Association.

  [@t(VL90)] John M. Vlissides y Mark A. Linton. Unidraw: A framework for
  building domain-specific graphical editors. ACM Transactions on Information
  Systems, 8(3):237-268, julio de 1990.

  [@t(WBJ90)] Rebecca Wirfs-Brock y Ralph E. Johnson. A survey of current
  research in object-oriented design. Communications of the ACM,
  33(9):104-124, 1990.

  [@t(WBWW90)] Rebecca Wirfs-Brock, Brian Wilkerson, y Lauren Wiener. Designing
  Object-Oriented Software. Prentice Hall, Englewood Cliffs, NJ, 1990.

  [@t(WGM88)] André Weinand, Erich Gamma, y Rudolf Marty. ET++—An object-oriented
  application framework in C++. En Object-Oriented Programming Systems,
  Languages, and Applications Conference Proceedings, pp. 46–57, San Diego,
  CA, septiembre de 1988. ACM Press.

* Notas

  :: @N(1) :: Literalmente, @"(peso mosca). (N. del T.)

  :: @N(2) :: El termino original ingles es @"(mixin). (N. del T.)

  :: @N(3) :: @e(Templates) en el original en ingles. (N. del T.)

  :: @N(4) :: @e(Acquaintance) en el original en ingles. (N. del T.)

  :: @N(5) :: Literalmente, @"(juego de herramientas). (N. del T.)

  :: @N(6) :: Literamente, @"(marco). (N. del T.)

  :: @N(7) ::

     Literalmente, @"(Lo que ve es lo que obtiene). Hace referencia a
     los editores de documentos (sean de texto, de HTML, etcetera) donde lo que
     se ve en pantalla coincide con la que sera la apariencia real del documento
     final (una vez impreso, mostrado en el navegador, etcetera). (N. del T.)

  :: @N(8) ::

     El diseño de Lexi esta basado en Doc, una aplicacion de edicion de texto
     desarrollada por Calder [@l(#CL92)]

  :: @N(9) ::

     Hemos traducido el termino original, @e(look and feel), como @"(interfaz de
     usuario). (N. del T.)

  :: @N(10) ::

     Los autores tambien suelen ver el documento en terminos de su estructura
     logica, es decir, en termnos de oraciones, parrafos, secciones,
     subsecciones y capitulos. Para no complicar en exceso este ejemplo, nuestra
     representacion interna no almacenara informacion acerca de la estructura
     logica explicitamente. No abstante, la solucion de diseño que describimos
     funciona igualmente bien para representar dicha informacion.

  :: @N(11) ::

     @e(Glyph), en el original en ingles. Palabra derivada del griogo que podria
     traducirse como @"(grabado). En castellano existe la palabra
     @"(petroglifo), para indicar grabados en piedra (DRAE). Hemos tomado la
     decision de traducirla como @"(glifo), pese a que esta palabra no exista en
     español, por similitud con el termino ingles y porque aqui no hace alusion
     a grabado en piedra. Ademas, es esta la forma en que aparece traducida
     normalmente la palabra en informatica, arquitectura, etcetera. (N. del T.)

  :: @N(12) ::

     Calder fue el primero en usar el termino @"(glifo) (glyph) en este contexto
     [@l(#CL90)]. La mayoria de los editores de documentos actuales no utilizan
     un objeto para cada caracter, presumiblemente por razones de eficiencia.
     Calder demostro en su tesis que este enfoque es viable [@l(#Cal93)].
     Nuestros glifos son menos sofisticados que los suyos, en el sentido de que
     los hemos restringido a jerarquias estrictas por simplicidad. Los glifos de
     Calder pueden compartirse para reducir costes de almacenamiento, formando
     asi estructuras de grafos dirigidos aciclicos. Podria aplicarse el patron
     @l(#Flyweight) para tograr el mismo efecto, pero dejaremos esto como
     ejercicio para el lector.

  :: @N(13) ::

     La interfaz aqui descrita es intencionalmente minima para mantener la
     discusion simple. Una interfaz completa incluiria operaciones para manejar
     los atributos graficos tales como el color, la fuente y transformaciones de
     coordenadas, ademas de operaciones para una gestion de los hijos mas sofisticada.

  :: @N(14) ::

     Un indice entero no es probablemente la mejor manera de especificar los
     hijos de un glifo, dependiendo de la estructura de datos que este usa. Si
     el glifo almacena sus hijos en una lista enlazada, seria mas eficiente un
     puntero a la lista. Veremos una solucion mejor al problema de indexacion en
     la @l(#2.8<>Seccion 2.8), cuando estudiemos el analisis de documentos.

  :: @N(15) ::

     El usuario tendra mas que decir sobre la estructura logica del documento
     @-(las oraciones, parrafos, secciones, capitulos, etcetera). En comparacion,
     la estructura fisica resulta menos interesante. A la mayoria de la gente no
     le preocupa donde se insertan los saltos de linea en un parrafo siempre y
     cuando este correcamente formateado. Lo mismo ocurre con el formateado de
     columnas y paginas. Por tanto, al final los usuarios solo especifican
     restriccione de alto nivel de la estructura fisica, dejando que sea Lexi
     quien haga el trabajo duro de satisfacerlas

  :: @N(16) ::

     El componedor debe obtener los codigos de los caracteres de los glifos
     @c(Caracter) para poder calcular los saltos de linea. En la
     @l(#2.8<>Seccion 2.8) veremos como obtener esta informacion
     polimorficamente sin añadir una operacion especifica de caracteres en la
     interfaz de @c(Glifo).

  :: @N(17) :: @e(Transparent enclosure) en el original en ingles. (N. del T.)

  :: @N(18) :: @e(Scroller) en el original en ingles. (N. del T.)

  :: @N(19) :: En ingles, @e(widgets). (N. del T.)

  :: @N(20) ::

     Es decir, volver a realizar una operacion a la que se dio marcha atras (se
     anularon sus efectos).

  :: @N(21) ::

     Conceptualmente, el cliente es el usuario de Lexi, pero en realidad es otro
     objeto (como un despachador de eventos) que gestiona las entradas del usuario.

  :: @N(22) :: @e(Command) en el original en ingles. (N. del T.)

  :: @N(23) ::

     El termino original en ingles es @e(undoability). Tanto este como el verbo
     correspondiente, @e(undo) hacen alusion, en este contexto, a la accion de
     dar marcha atras a las operaciones, esto es a la posibilidad de revertir
     los efectos de una operacion anterior. Si bien @"(deshacer) es una
     traduccion demasiado literal (el DRAE no sanciona esta acepcion) se ha
     optado por ella al estar comunmente aceptada en la mayoria de las
     aplicaciones existentes. (N. del T.)


  :: @N(24) ::

     El original en ingles es @e(hyphenation). Segun el Webster, es la accion y
     efecto de conectar (dos palabras) o dividir (una palabra al final de la
     linea) con un guion. En este contexto significa lo segundo. En Español se
     suele usar el termino @"(guionado), que no aparece en el DRAE. nosotros lo
     hemos traducido generalmente como @"(insercion de guiones). (N. del T.)

  :: @N(25) ::

     Podriamos usar sobrecarga de funciones para dar a cada una de estas
     funciones miembro el mismo nombre, puesto que ya estan diferenciadas por
     sus parametros. Les hemos dado distintos nombres para resaltar sus
     diferencias, sobre todo cuando son llamadas.

  :: @N(26) ::

     @c(EstaMalEscrita) implementa el algoritmo de revision ortografica, que no
     detallaremos aqui ya que lo hemos hecho independiente del diseño de
     Lexi. Podemos permitir algoritmos diferentes heredando de
     @c(RevisiorOrtografico); otra alternativa es aplicar el patron
     @l(#Strategy) (igual que hicimos para el formateado en la @l(#2.3<>Seccion
     2.3) para permitir diferentes algoritmos de revision ortografica.

  :: @N(27) ::

     @"(Visitar) es un termino ligeramente mas general que @"(analizar). Anticipa
     la terminologia que usamos en el patron de diseño al que estamos llegando.

  :: @N(28) :: Widgets, en el original en ingles (N. del T.)

  :: @N(29) ::

     Hemos traducido el termino original en ingles, @e(widget), referido a los
     distintos elementos de la interfaz de usuario, como @"(util). (N. del T.)

  :: @N(30) :: @e(Lazy inicialization) en el original en ingles. (N. del T.)

  :: @N(31) :: Hemos traducido el termino original ingles, @e(widget), como @"(util). (N. del T.)

  :: @N(32) :: @c(CrearManipulador) es un ejemplo de @l(#Factory Method).

  :: @N(33) ::

     @"c(Imp) viene de @"(implementacion). A pesar de que, siguiendo la
     convencion de nominacion que hemos venido empleando a lo largo del libro,
     tal vez habria sido mas correcto @"c(ImpVentana) como nombre de la clase,
     hemos preferido mantener @"c(Imp) como sufijo, al igual que en el original
     en ingles, por ser este practicamente un convenio de programacion. (N. del T.)

  :: @N(34) ::

     Es facil olvidarse de borrar el iterador una vez que se ha usado. El patron
     @l(#Iterator) en su Seccion @l(#Iterator Codigo de Ejemplo<>Codigo de
     Ejemplo) muestra como protegerse contra tales errores.

  :: @N(35) :: @e(Pool), en el original en ingles. (N. del T.)

  :: @N(36) ::

     El tiempo de busqueda con este esquema es proporcional a la frecuencia de
     cambios de fuente. El caso peor en cuanto a rendimiento tiene lugar cuando
     se produce un cambio de fuente para cada caracter, pero eso es poco
     frecuente en la practica.

  :: @N(37) ::

     En el Codigo de Ejemplo mostrado anteriormente, la informacion de estilo se
     hizo extrinseca, dejando al codigo de caracter como el unico estado intrinseco.

  :: @N(38) ::

     Vease el patron @l(#Abstract Factory) para otra aproximacion a la
     independencia de la interfaz de usuario.

  :: @N(39) ::

     La implementacion de objteso distribuidos en NEXSTEP [@l(#Add94)] (en concreto,
     la clase NXProxy) usa esta tecnica. La implementacion redefine
     @c(forward), el enganche equivalente en NEXTSTEP.

  :: @N(40) ::

     El patron @l(#Iterator) describe otro tipo de proxy.

  :: @N(41) ::

     Casi todas las clases tienen, en ultima instancia, a Object como
     superclase. Por tanto, esto es lo mismo que decir @"(definir una clase que
     no tenga Object como su superclase).

  :: @N(42) ::

     Para simplificar, omitiremos la precedencia de operadores y asumiremos que
     es responsabilidad de cualquier otro objeto construir el arbol sintactico.

  :: @N(43) ::

     Booch se refiere a los iteradores externos como iteradores @b(activos) y
     @b(pasivos), respectivamente [@l(#Boo94)]. Los terminos @"(activo) y @"(pasivo)
     describen el rol del cliente, no el nivel de actividad del iterador.

  :: @N(44) ::

     Los cursores son un ejemplo sencillo del patron @l(#Memento), y comparten
     con el muchos de sus detalles de implementacion.

  :: @N(45) ::

     Podemos hacer esta interfaz todavia @e(mas pequeña) juntando @c(Siguiente),
     @c(HaTerminado) y @c(ElementoActual) en una unica operacion que avance al
     siguiente objeto y lo devuelva. Si se llega al final del recorrido esta
     operacion devulve un valor especial (0, por ejemplo) que marca el final de
     la ineracion.

  :: @N(46) ::

     Esto puede garantizarse en tiempo de compilacion simplemente declarando
     privados los operadores @c(new) y @c(delete). No se necesita ninguna
     implementacion adicional.

  :: @N(47) ::

     La operacion @c(Recorrer) de los ejemplos anteriores es un @l(#Factory
     Method) con @c(ComprobarElemento) y @c(ProcesarElemento) como operaciones
     primitivas.

  :: @N(48) :: @e(Hub), en el original en ingles. (N. del T.)

  :: @N(49) :: En este contexto, @"(recuerdo). (N. del T.)

  :: @N(50) ::

     Notese que nuestro ejemplo borra el objeto estado al final de la
     iteracion. Pero no se llamara a @c(delete) en caso de que
     @c(ProcesarElemento) lance una excepcion, lo que produciria basura. Esto es
     un problema en C++, poro no en Dylan, que tiene recoleccion de basura.
     Discutimos una solucion a este problema en la seccion @l(#Iterator Codigo
     de Ejemplo<>Codigo De Ejemplo) del patron Iterator.

  :: @N(51) ::

     Este ejemplo esta basado en el protocolo de conexion TCP descrito por Lynch
     y Rose [@l(#LR93)].

  :: @N(52) ::

     Esto hace de cada subclase de @c(EstadoTCP) un Singleton (vease el patron @l(#Singleton)).

  :: @N(53) ::

     Podriamos usar la sobrecarga de funciones para dar a estas operaciones el
     mismo nombre, como por ejemplo @c(Visitar), ya que las operaciones se
     diferencian por el parametro que se les pasa. Esta sobrecarga tiene sus
     pros y sus contras. Por un lado, refuerza el hecho de que cada operacion
     implica el mismo analisis, solo que sobre un argumento distinto. Por otro
     lado, podria hacer menos obvio que esta ocurriendo en el sitio de la
     llamada para alguien que este leyendo el codigo. Realmente se reduce a si
     creemos que la sobrecarga de funciones es buena o no.

  :: @N(54) ::

     Si podemos tener @e(doble)-despacho, ¿por que no tener @e(trible),
     @e(cuadruple) o cualquier otro numero? En realidad, el doble despacho no es
     mas que un caso especial de despacho multiple, en el cual la operacion se
     elige en funcion de un numero cualquiera de tipos (CLOS permite el despacho
     multiple). Los lenguajes que permiten el despacho doble o multiple ven
     reducida la necesidad del patron Visitor.

  :: @N(55) ::

     Este tema tambien afceta a otros tipos de patrones. Tanto el patron
     @l(#Abstract Factory) como el @l(#Builder) y el @l(#Protype), encapsulan el
     conocimiento sobre como se crean los objetos. El patron @l(#Decorator)
     encapsula la reponsabilidad que puede añadirse a un objeto. El patron
     @l(#Bridge) separa una abstraccion de su implementacion, permitiendolas
     varias de forma independiente.

  :: @N(56) :: Vease @"(La poesia del lenguaje) [@l(#AIS+77)].

  :: @N(57) ::

     OMT usa el termino @"(diagrama de objetos) para referirse a los diagramas
     de clases. Nosotros usamos @"(diagrama de objetos) para referirnos
     exclusivamene a diagramas de estructuras de objetos.

  :: @N(58) ::

     OMT tambien define asociaciones entre clases, que  pueden aparecer como
     lineas rectas entre rectangulos de clases. Las asociaciones son
     bidireccionales. Aunque las asociaciones son adecuadas durante el analisis,
     creemos que son de demasiado alto nivel para expresar las relaciones de los
     patrones de diseño, debido simplemente a que las asociaciones deben
     convertirse en referencias a objetos o en punteros durante el diseño. Las
     referencias a objetos son intrinsecamente dirigidas y se adecuan por tanto
     mejor a las relaciones que nos ocupan. Por ejemplo, el Dibujo conoce a las
     Formas, pero estas no saben nada del Dibujo en el que se encuentran. Esta
     relacion no puede expresarse solo con asociaciones.
